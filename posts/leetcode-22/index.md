# Leetcode算法 Part-22



动态规划<br>
滑动窗口<br>
单调栈
<!--more-->

## 动态规划
动态规划的核心思想是把原问题分解成子问题进行求解，也就是分治的思想。
去网上搜资料,竟然搜到[曾学长的文章](https://baijiahao.baidu.com/s?id=1635388976060265522&wfr=spider&for=pc)哈哈哈哈,并且讲的很棒!
一种可以用动态规划解决的情况就是会有**反复出现的子问题**，然后这些**子问题还会包含更小的子问题**。相比于不断尝试去解决这些反复出现的子问题，动态规划会尝试一次解决更小的子问题。之后可以将结果输出记录在表格中，在之后的计算中可以把这些记录作为问题的原始解。
对于经典的斐波那契数列就可以适用
0,1,1,2,3,5,8,13…它的每个数字都与前两个紧邻的数字相关。如果 F(n) 是第 n 个数字，那么我们会有 F(n) = F(n-1) + F(n-2)。这个在数学上称作*递归方程*或者*递推关系*。为了计算后面的项，它需要前面项的计算结果作为输入
大多数动态规划问题都能被归类成两种类型：
 - 优化问题
 - 组合问题

以下是两种不同的动态规划解决方案：
1. 自上而下：你从最顶端开始不断地分解问题，直到你看到问题已经分解到最小并已得到解决，之后只用返回保存的答案即可。这叫做记忆存储。
2. 自下而上：你可以直接开始解决较小的子问题，从而获得最好的解决方案。在此过程中，你需要保证在解决问题之前先解决子问题。
经典例题 [198-打家劫舍](https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/)

## 滑动窗口
滑动窗口法，可以用来解决一些查找满足一定条件的**连续区间**的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。
核心思想是维护左右指针
**滑动窗口的思想:先产生可行解,再优化**
```
先寻求一个可行的解
在可行解的基础上，优化这个可行解
优化到不能优化，产生出一个可能的最优解
继续寻求新的可行解
继续优化这个可行解
……循环
```
在可能的最优解中产生出最优解
典型例题 [76-最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

## 单调栈
单调栈也是经常会用到的,这里记录一下
### 概念
单调栈中存放的数据应该是有序的，所以单调栈也分为单调递增栈和单调递减栈
- 单调递增栈：数据出栈的序列为单调递增序列
- 单调递减栈：数据出栈的序列为单调递减序列

### 例子
现在有一组数10，3，7，4，12。从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。
- 10入栈时，栈为空，直接入栈，栈内元素为10。
- 3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。
- 7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。
- 4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。
- 12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。
下面用一道例题来说明

### 单调栈例题-视野总和
题目:
有n个人站队，所有的人全部向右看，个子高的可以看到个子低的发型，给出每个人的身高，问所有人能看到其他人发现总和是多少。
```
输入：4 3 7 1
输出：2
```
解释：个子为4的可以看到个子为3的发型，个子为7可以看到个子为1的身高，所以1+1=2
解体思路：
观察题之后，我们发现实际上题目转化为找当前数字向右查找的第一个大于他的数字之间有多少个数字，然后将每个 结果累计就是答案，但是这里时间复杂度为O(N^2)，所以我们使用单调栈来解决这个问题。
```c++
int FieldSum(vector<int>& v)
{
	v.push_back(INT_MAX);/这里可以理解为需要一个无限高的人挡住栈中的人，不然栈中元素最后无法完全出栈
	stack<int> st;
	int sum = 0;
	for (int i = 0; i < (int)v.size(); i++)
	{
        if (st.empty() || v[st.top()] > v[i])//小于栈顶元素入栈
		{
			st.push(i);
		}
		else
		{
			while (!st.empty() && v[st.top()] <= v[i])
			{
				int top = st.top();//取出栈顶元素
				st.pop();
				sum += (i - top - 1);//这里需要多减一个1
			}
			st.push(i);
		}
	}
	return sum;
}
```

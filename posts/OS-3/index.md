# OS总结 Part-3



存储管理
<!--more-->

# 存储管理
多道程序并行带来的问题：
 - 共享：代码和数据共享，节省内存
 - 保护：不允许内存中的程序相互间非法访问

## 地址映射
### 固定地址映射
**编程或编译时**确定逻辑地址和物理地址映射关系
特点：
 - 程序加载时必须放在指定的区域
 - 容易发生地址冲突，运行失败
 - 程序占用连续空间
 - 程序装入后不能移动

### 静态地址映射
程序装入时**由操作系统**完成逻辑地址到物理地址的映射
 - 逻辑地址：VA(Virtual Addr)
 - 装入基址：BA(Base Addr)
 - 物理地址：MA(Memory Addr)
 - MA = BA+VA
特点：
 - 程序运行前确定映射关系
 - 程序装入后不能移动（如果移动必须放回原来的位置）
 - 程序占用连续的内存空间

### 动态地址映射
 - 程序占用的内存空间可动态变化,要求及时更新基质BA
 - 程序不要求占用连续的内存空间
 - 便于多个进程共享代码,共享代码作为独立的一段存放
缺点:
 - 硬件支持(MMU:内存管理单元)
 - 软件复杂
如果程序有移动，BA可能会发生改变，自动计算新的MA
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/OS-3/11.png)

### 存储管理的功能-虚拟内存
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/OS-3/1.png)
虚拟内存的目标
 - 使得大的程序能在较小的内存中运行
 - 是的多个程序能在较小的内存中运行
 - 使得多个程序迸发运行时地址不冲突
 - 使得内存利用效率高，无碎片，共享方便

### 存储管理的功能-内存分配功能
为程序分配足够的内存空间
需要解决的问题：
 - 放置策略：程序调入内存是将其放置在哪个分区
 - 调入策略：何时把运行的代码和要访问的数据调入内存
 - 淘汰策略:内存不够时，迁出哪些代码或数据以腾出内存空间

### 存储管理的功能-存储保护功能
保证在内存中的多道程序只能在给定的存储区域内活动互不干扰
 - 防止访问越界
 - 防止访问越权
方法：界址寄存器
 - 在CPU中设置一对下限寄存器和上限寄存器存放程序在内存中的下限地址和上限地址
 - 基址寄存器和限长寄存器

# 分区内存管理
 - 单一区存储管理
 - 分区存储管理
    - 固定分区
    - 动态分区

## 单一存储管理（不分区存储管理）
### 定义
用户区不分区，完全被一个程序占用
例如 DOS

### 优点
简单，不需要复杂的硬件支持，适用于单用户单任务OS

### 缺点
程序运行占用整个内存，即使小程序也是如此，内存浪费，利用率低

## 分区存储管理
### 定义
 - 把用户区内存划分若干大小不等的分区，供不同程序使用
 - 分类
    - 固定分区
    - 动态分区

## 空闲分区使用策略
分配过程(假定用户要求空间大小为s)
 - 从空闲区表的第一个区开始,寻找>=s的空闲区
 - 找到后从分区中分割出大小为s的部分给用户使用
 - 分割后的剩余部分作为空闲区仍然登记在空闲区表中
注意:分割空闲区时一般从底部分割

### 空闲分区算法
1. 按空闲区位置(首址)递增排序
**首次适应算法**
尽可能先使用低地址空间
当需要较大分区时在高地址空间有较大的满足可能性
1. 按空闲区大小的递增排序
**最佳适应算法**
尽可能地使用较小的空闲区,保留大的空闲区
当需要较大分区时又较大的满足可能性
3. 按空闲区大小的递减排序
**最坏适应算法**
大空闲区分割后剩下部分还是很大,还能装下较大的程序
仅作一次检查就能找到所要分区

## 分区的回收
回收程序释放分区,登记到空闲区表
回收算法:
 - 要考虑释放区与现有空闲区是否相邻
 - 若释放区与现有空闲区不相邻,则直接插入空闲区表
 - 若释放区与现有空闲区相邻,则与空闲区合并后更新空闲区表

## 覆盖
在较小的内存空间中运行较大的程序
常驻区:被某段单独且独立的占用,可划分多个
覆盖区:能被多段共用(覆盖),可划分多个
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/OS-3/2.png)
覆盖的缺点:
 - 编程复杂,需要程序员划分程序模块并确定覆盖关系
 - 程序执行时间长,从外村装入内存耗时

## 交换技术
内存不够时将进程写入磁盘(swap out)
当进程要运行时重新写回内存(swap in)
优点:
 - 增加进程并发数
 - 不考虑程序结构
缺点:
 - 换入换出增加cpu开销
 - 交换单位太大(整个进程)
需要考虑的问题:
减少交换传送的信息量(模块/段)
外存交换空间的管理方法
程序换入时的地址重定位

## 内存碎片
过小的空闲区,难实际使用
内存碎片会降低内存有效利用率
### 动态分区的缺点
容易产生**内存碎片**:内存反复分配和分割
首次适应法,最佳适应法,最坏适应法
解决碎片的方法
1. 规定门限值,分割空闲区时若剩余部分小于门限值,则此空闲区不进行分割,而是全分配给用户
2. 内存拼接技术:将所有空闲区集中构成一个大的空闲区
拼接技术的缺点:消耗系统的资源,离线拼接,重新定义作业
3. 解除程序占用连续内存才能运行的限制

![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/OS-3/4.png)

# 虚拟内存管理
目标:使得大的程序能在较小的内存中运行
使得多个程序并发运行时地址不冲突
使得内存利用率提高,无碎片,共享方便
程序运行的局部性:
 - 程序在有限的时间段内访问的代码和数据往往在有限的范围内
典型的虚拟内存管理方式:
 - 页式虚拟存储管理
 - 段式虚拟存储管理
 - 段页式虚拟存储管理
将进程空间(虚拟)和内存空间划分成等大小的片
片的典型大小:1k,2k,4k
进程的片-页(虚拟页)
内存的片-页框(物理页)
内存以页框的单位分配使用
进程以页为单位装入内存
 - 只把程序部分页装入内存便可运行
 - 页在内存中占用的页框不必相邻
 - 需要新页时,按需从硬盘中调入内存
 - 不再运行的页及时删除,腾出空间

## 页式系统中的地址
虚拟地址(VA)可以分解为页号p和页内偏移w
页号p = va/页的大小
页内偏移w = va%页的大小
p和w的另一种算法,已知页的大小2<sup>n</sup>
p = VA>>n
w = VA && (2<sup>n-1</sup>)
记录页和页框之间的对应关系->页表

# 快表机制
快表的特点:
 - 容量小,访问快
 - 快表是慢表部分内容的复制
 - 若在快表中找到所需内容,则称为"命中",若没有命中则访问慢表,更新快表

![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/OS-3/4.png)

# 页面的共享
 - 在不同进程的页表上填上相同的页框号,多个进程能访问相同的内存空间,从而实现页面共享
 - 共享页面在内存上只有一份真实存储,节省内存

![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/OS-3/5.png)

# 缺页中断
## 页表的扩充
即页表中有中断位和辅存地址
中断位i-标识该页是否在内存
 - i =1 不在内存
 - i =0 在内存
辅存地址:该页在辅存上的地址
修改位->标识该页的数据是否已被修改
 - 0->该页未被修改
 - 1->该页已被修改

![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/OS-3/6.png)

## 缺页中断定义
在地址映射过程中,当所要访问的目的页不在内存时,则系统产生异常中断->缺页中断
却也中断处理程序:中断处理程序将所缺的页从页表指出的辅存地址调入内存的某个页框中,并更新页表中该页对应的页框号以及修改中断位为0 
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/OS-3/7.png)

## 缺页(中断)率
缺页率f = 缺页次数/访问页面次数
命中率= 1-f

# 页面淘汰
1. 淘汰策略
选择淘汰哪一页的规则称为淘汰策略
2. 页面抖动
    - 页面在内存和辅存间频繁交换的现象
    - "抖动"会导致系统效率下降
3. 好的淘汰策略
    - 具有较低的缺页率(高命中率)
    - 页面抖动较少

## 常用的淘汰算法
1. 最佳算法(OPT-optimal)
 - 淘汰以后不再需要或最远的未来才会使用到的页面
 - 理论上最佳,但实践中算法无法实现
2. 先进先出算法(FIFO)
 - 淘汰在内存中停留时间最长的页面
 - 实现简单,但只有进程按顺序访问时命中率才是最理想的,对于指定的访问序列,随着分配页框的增多,缺页率反而增加
3. 最久未使用淘汰算法(LRU)
 - 淘汰最长时间未被使用的页面
 - **实现方法:**
    - 页面设置一个移位寄存器R,每当页面访问时将其重置为1
    - 周期性的将所有页面的R左移一位(右边补0),当需要淘汰时选择R值最大的页
    - R的位数越多(移位周期越小)就越精确,但是硬件成本实现较高
 - **近似算法**
   - 利用页表访问位,页被访问时将其值由硬件置为1
   - 软件周期性(T)将所有访问位置0
   - 当淘汰页面时根据该页访问位来判断是否淘汰
      - 访问位为1时:在T时间内,该页被访问过
      - 访问位为0时:在T时间内,该页未被访问过
 - 缺点
    - 周期T难定
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/OS-3/8.png)
4. 最不经常使用算法(LFU)
 - 选择到当前时间位置被访问次数最少的页面
 - 每页设置访问计数器,每当页面被访问时,该页的访问器上计数器+1
 - 发生缺页中断时,淘汰计数器最小的页面,并将所有计数器清零

# 段式存储器
进程分段:把进程按逻辑意义划分为多个段,每段有段名,长度不定,进程由多段组成
## 段式存储的内存分配
程序以段为单位装入,每段分配连续的内存
但是段和段不要求相邻

## 段式内存的虚拟地址
段式虚拟地址VA包含段号s和段内偏移w 
段表:
 - 段号:段的编号
 - 段长:段的长度
 - 基地址:该段在内存中的首地址

## 段的共享
 - 共享段在内存中只有一份存储
 - 共享段被多个进程映射到各自的段
 - 需要共享的模块可以设置为单独的段

## 段的缺点
段需要连续的存储空间
段的最大尺寸收到内存大小的限制
在辅存中管理可变尺寸的段比较困难

# 段式系统和页式系统的比较
页式系统:一维空间
段式系统:二维空间
段长可变-页面大小固定
段的划分有意义-页面无意义
段方便共享-页面不方便共享
段用户可见-页面用户不可见
段偏移有溢出-页面偏移无溢出

# 段页式存储
系统为每个进程建立一个段表
每个段有一个页表
段表给出每段的页表基址及页表长度(段长)
页表给出每页对应的页框
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/OS-3/9.png)


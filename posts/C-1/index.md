# C语言-指针


这几天发现自己的指针学的有些糊涂,经常写懵,所以决定补习一下指针的概念和用法
在这里记录一下知识点和心得
<!--more--> 

# 通俗理解
## 指针的概念
指针变量是一种变量类型,所有的指针变量都是无符号整型变量(unsigned int),其字节数为4个字节
所以可以得出
```c
sizeof(char*) = 4
sizeof(int*) = 4...
```
指针的声明 int* a 即声明a为(int*)类型的指针变量,存储一个指向int类型变量的内存地址
*a 即地址a所指向的变量
```c
int b = 4;
int* a = NULL; //申请指针变量的好习惯
a = &b;
printf("%d",*a);

/*结果输出 4*/
```
## 结构体指针
结构体指针变量有特殊用法，即 **结构体->成员** 即可访问结构体中的变量
```c
typedef struct
{
    char name[31];
    int age;
    float score;
}Student;

int main(void)
{
    Student stu = {"Bob" , 19, 98.0};
    Student*ps = &stu;

    ps->age = 20;
    ps->score = 99.0;
    printf("name:%s age:%d\n",ps->name,ps->age);
    /*等价于 printf("name:%s age:%d\n",(*ps).name,(*ps).age)*/
    /*等价于 printf("name:%s age:%d\n",stu.name,stu.age)*/
    return 0;
}
```
## 野指针
指针在使用的过程中，要注意野指针
野指针的概念：
1. 指向已销毁的变量
2. 指向无权访问的内存空间
如何避免野指针：
1. 指针初始化的好习惯： int*p = NULL；
2. free（p）销毁p的内存后，要 p = NULL; 令其指针变量为NULL

# 参考其他Blog
## 指针的用处?
指针解决了一些编程中基本的问题。
1. 指针的使用使得不同区域的代码可以轻易的共享内存数据。当然你也可以通过数据的复制达到相同的效果，但是这样往往效率不太好，因为诸如结构体等大型数据，占用的字节数多，复制很消耗性能。但使用指针就可以很好的避免这个问题，因为任何类型的指针占用的字节数都是一样的（根据平台不同，有4字节或者8字节或者其他可能）。
2. 指针使得一些复杂的链接性的数据结构的构建成为可能，比如链表，链式二叉树等等。
3. 有些操作必须使用指针。如操作申请的堆内存。
还有一点：**C语言中的一切函数调用中，实参传递给形参的机理都是“按值传递(pass by value)”的，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成**。

## 指针是什么
我们指知道：C语言中的数组是指 一类 类型，数组具体区分为  int 类型数组，double类型数组,char数组 等等。同样指针 这个概念也泛指 一类 数据类型，int指针类型，double指针类型，char指针类型等等。
通常，我们用int类型保存一些整型的数据，如 int num = 97 ， 我们也会用char来存储字符： char ch = 'a'。
我们也必须知道：任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。
因此：指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。

## 程序的地址
而作为一个程序员，我们不需要了解内存的物理结构，操作系统将DRAM等硬件和软件结合起来，给程序员提供的一种对物理内存使用的抽象。这种抽象机制使得程序使用的是虚拟存储器,而不是直接操作物理存储器。所有的虚拟地址形成的集合就是虚拟地址空间。 
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/C-1/5.png)
也就是说，虚拟存储器是一个很大的，线性的字节数组（平坦寻址）。每一个字节都是固定的大小，由8个二进制位组成。最关键的是，每一个字节都有一个唯一的编号,编号从0开始，一直到最后一个字节。如上图中，这是一个4GB的虚拟存储器的模型，它一共有4x1024x1024x1024 个字节，那么它的虚拟地址范围就是 0 ~ 4x1024x1024x1024-1 。

由于内存中的每一个字节都有一个唯一的编号，因此，在程序中使用的变量，常量，甚至数函数等数据，当他们被载入到内存中后，都有自己唯一的一个编号，这个编号就是这个数据的地址。指针就是这样形成的。
```c
#include <stdio.h>
int main(void)
{
    char ch = 'a';
    int  num = 97;
    printf("ch 的地址:%p\n",&ch);   //ch 的地址:0028FF47
    printf("num的地址:%p\n",&num);  //num的地址:0028FF40
    return 0;
}
```
指针的值实质是内存单元（即字节）的编号，所以指针 单独从数值上看，也是整数，他们一般用16进制表示。指针的值（虚拟地址值）使用一个机器字的大小来存储,也就是说,对于一个机器字为w位的电脑而言,它的虚拟地址空间是0~2w － 1 ,程序最多能访问2w个字节。这就是为什么xp这种32位系统最大支持4GB内存的原因了。
我们可以大致画出变量ch和num在内存模型中的存储。（假设 char占1个字节，int占4字节）
## 操作系统为什么提供虚拟地址空间而不是让直接使用物理地址空间？
1. 提高物理内存的利用效率。
你可能会困惑，这怎么就提高物理内存使用效率了呢？我这里举个共享单车的例子：假如一个国家有10个人，而只生产了2辆自行车(国家小，资源有限嘛~)，这2辆车被2个人买了。把你自己想象为那8个没有自行车的人之一，你的思维是什么——"我没有自行车，我只能步行外出"。倘若是那2个有车的人呢——"我每次外出都可以骑车去，但是大部分时间，我的车是空闲的，没其他人用"。后来，这个国家回收了这仅有的2辆车，把车刷成了统一的颜色，贴上二维码，引入了共享单车系统，然后发出公告：只要车停在路边没人用，任何人都可以刷开骑走。那现在这10个人怎么想呢——“只要我看到有空闲的单车，我就可以使用它”。
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/C-1/6.png)
2. 抽象的东西更加简单稳定。

从古至今，我们对于“去饭馆吃饭”这个抽象社会行为没有太大的变化——进入饭馆，点菜，付钱，享用，走人。但是人们烹饪的方法却发生了具大的改变，烹饪的器材、食材、食谱一直都在更新改进，如果你经常烹饪，你就需要不断的学习，因为你需要掌握做一道菜的每个细节。

回到内存相关的话题来：无论机器的内存用的是ddr3还是ddr4，是4G物理内存还是8G物理内存，程序员都似乎无需太过关心，因为他们在编程时面向的是虚拟内存，而虚拟内存的模型到目前为止都是固定的。这给程序员带来非常大的便利，他们无需为快速更新的计算机设备而改变自己的编程思维。

这并不意味着抽象的东西就一定不会改变。例如从“到饭馆吃饭”到“点外卖”；从32位操作系统到64位操作系统。都属于抽象的更新换代。
总结：
 - 资产有限的情况下，使用合理的资产使用管理机制，可以使有限的资产服务于更多的人。
 - 抽象的事物更加简单稳定，特定的事物更加复杂易变。
 - 底层通过给上层提供抽象服务来获得利益，上层通过使用底层的抽象来获得便利。

## 指针变量 和 指向关系
用来保存 指针(地址) 的变量，就是指针变量。如果指针变量p1保存了变量 num的地址，则就说：p1指向了变量num，也可以说p1指向了num所在的内存块 ，这种指向关系，在图中一般用 箭头表示。
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/C-1/1.png)
上图中，指针变量p1指向了num所在的内存块 ，即从地址0028FF40开始的4个byte 的内存块。
### 定义指针变量
C语言中，定义变量时，在变量名 前 写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题。
 
引申：C语言中，定义变量时，在定义的最前面写上typedef ，那么这个变量名就成了一种类型，即这个类型的同义词。
```c
int a ; //int类型变量 a
int* p ; //int* 变量p
int arr[3]; //arr是包含3个int元素的数组
int (* parr )[3]; //parr是一个指向【包含3个int元素的数组】的指针变量

//-----------------各种类型的指针------------------------------
int* p_int; //指向int类型变量的指针 
double* p_double; //指向double类型变量的指针 
struct Student *p_struct; //结构体类型的指针
int(*p_func)(int,int); //指向返回类型为int，有2个int形参的函数的指针 
int(*p_arr)[3]; //指向含有3个int元素的数组的指针 
int** p_pointer; //指向 一个整形变量指针的指针
```

### 取地址
既然有了指针变量，那就得让他保存其它变量的地址，使用& 运算符取得一个变量的地址。
```c
int add(int a , int b)
{
    return a + b;
}
int main(void)
{
    int num = 97;
    float score = 10.00F;
    int arr[3] = {1,2,3};
    //-----------------------
    int* p_num = &num;
    float* p_score = &score;
    int (*p_arr)[3] = &arr;           
    int (*fp_add)(int ,int )  = &add;  //p_add是指向函数add的函数指针
/* 等同于 int (*fp_add)(int ,int )  = add; */
    return 0;
}
```
特殊的情况，他们并不一定需要使用&取地址：
 - 数组名的值就是这个数组的第一个元素的地址。
 - 函数名的值就是这个函数的地址。
 - 字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名称,也就是这个字符串在内存中的地址。

### 解地址
我们需要一个数据的指针变量干什么？当然使用通过它来操作（读/写）它指向的数据啦。对一个指针解地址，就可以取到这个内存数据，解地址 的写法，就是在指针的前面加一个*号。
解指针的实质是：从指针指向的内存块中取出这个内存数据。
```c
int main(void)
{
    int age = 19;
    int*p_age = &age;
    *p_age  = 20;  //通过指针修改指向的内存数据

    printf("age = %d\n",*p_age);   //通过指针读取指向的内存数据
    printf("age = %d\n",age);

    return 0;
}
```

### 指针之间的赋值
指针赋值和int变量赋值一样，就是将地址的值拷贝给另外一个。指针之间的赋值是一种浅拷贝，是在多个编程单元之间共享内存数据的高效的方法。
```c
int* p1  = & num;
int* p3 = p1;
/*通过指针 p1 、 p3 都可以对内存数据 num 进行读写，如果2个函数分别使用了p1 和p3，那么这2个函数就共享了数据num。*/
```
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/C-1/2.png)

### 空指针
指向空，或者说不指向任何东西。在C语言中，我们让指针变量赋值为NULL表示一个空指针，而C语言中，NULL实质是 ((void*)0) ，  在C++中，NULL实质是0。
换种说法：任何程序数据都不会存储在地址为0的内存块中，它是被操作系统预留的内存块。
stddef.h 源程序代码
```c
#ifdef __cplusplus
     #define NULL    0
#else    
     #define NULL    ((void *)0)
#endif
```

### 坏指针
指针变量的值是NULL，或者未知的地址值，或者是当前应用程序不可访问的地址值，这样的指针就是坏指针，不能对他们做解指针操作，否则程序会出现运行时错误，导致程序意外终止。
任何一个指针变量在做 解地址操作前，都必须保证它指向的是有效的，可用的内存块，否则就会出错。坏指针是造成C语言Bug的最频繁的原因之一。
```c
void opp()
{
     int*p = NULL;
     *p = 10;      //Oops! 不能对NULL解地址
}
void foo()
{
     int*p;
     *p = 10;      //Oops! 不能对一个未知的地址解地址
}
void bar()
{
     int*p = (int*)1000; 
     *p =10;      //Oops!   不能对一个可能不属于本程序的内存的地址的指针解地址
}
```

## 指针的2个重要属性
指针也是一种数据，指针变量也是一种变量，因此指针 这种数据也符合前面 变量和内存 主题中的特性。 这里我只想强调2个属性： 
 - 指针的类型
 - 指针的值。
```c
int main(void)
{
    int num = 97;
    int *p1  = &num;
    char* p2 = (char*)(&num);

    printf("%d\n",*p1);    //输出  97
    putchar(*p2);          //输出  a
    return 0;
}
```
由于num的地址是0028FF40，因此p1和p2的值都是0028FF40
 - *p1 :  将从地址0028FF40 开始解析，因为p1是int类型指针，int占4字节，因此向后连续取4个字节，并将这4个字节的二进制数据解析为一个整数 97。
 - *p2 :  将从地址0028FF40 开始解析，因为p2是char类型指针，char占1字节，因此向后连续取1个字节，并将这1个字节的二进制数据解析为一个字符，即'a'。
**同样的地址，因为指针的类型不同，对它指向的内存的解释就不同，得到的就是不同的数据。**

## 结构体和指针
结构体指针有特殊的语法：  -> 符号 
如果p是一个结构体指针，则可以使用 p ->【成员】 的方法访问结构体的成员。p->member 等价于 (*p).member。
```c
typedef struct
{
    char name[31];
    int age;
    float score;
}Student;

int main(void)
{
    Student stu = {"Bob" , 19, 98.0};
    Student*ps = &stu;

    ps->age = 20;
    ps->score = 99.0;
    printf("name:%s age:%d\n",ps->name,ps->age);
    return 0;
}
```

## 数组和指针
1. 数组名作为右值的时候，就是第一个元素的地址。
```c
int main(void)
{
    int arr[3] = {1,2,3};
 
    int*p_first = arr;
    printf("%d\n",*p_first);  //1
    return 0;
}
```
2.指向数组元素的指针 支持 递增 递减 运算。（实质上所有指针都支持递增递减 运算 ，但只有在数组中使用才是有意义的）
```c
int main(void)
{
    int arr[3] = {1,2,3};
 
    int*p = arr;
    for(;p!=arr+3;p++){
        printf("%d\n",*p); 
    }
    return 0;
}
```
3. p= p+1 意思是：
让p指向原来指向的内存块的下一个相邻的相同类型的内存块。
同一个数组中，元素的指针之间可以做减法运算，此时，指针之差等于下标之差。
4. 用指针指向数组中的元素
```c
p[n]    == *(p+n)
p[n][m]  == *(  *(p+n)+ m )
```
5. 当对数组名使用sizeof时，返回的是整个数组占用的内存字节数。当把数组名赋值给一个指针后，再对指针使用sizeof运算符，返回的是指针的大小。
这就是为什么我么将一个数组传递给一个函数时，需要另外用一个参数传递数组元素个数的原因了。
```c
int main(void)
{
    int arr[3] = {1,2,3};
 
    int*p = arr;
    printf("sizeof(arr)=%d\n",sizeof(arr));  //sizeof(arr)=12
    printf("sizeof(p)=%d\n",sizeof(p));   //sizeof(p)=4
 
    return 0;
}
```

## 函数和指针
### 函数的参数和指针
C语言中，实参传递给形参，是按值传递的，也就是说，函数中的形参是实参的拷贝份，形参和实参只是在值上面一样，而不是同一个内存数据对象。这就意味着：这种数据传递是单向的，即从调用者传递给被调函数，而被调函数无法修改传递的参数达到回传的效果。
```c
void change(int a)
{
    a++;      //在函数中改变的只是这个函数的局部变量a，而随着函数执行结束，a被销毁。age还是原来的age，纹丝不动。
}
int main(void)
{
    int age = 19;
    change(age);
    printf("age = %d\n",age);   // age = 19
    return 0;
}
```
有时候我们可以使用函数的返回值来回传数据，在简单的情况下是可以的，但是如果返回值有其它用途（例如返回函数的执行状态量），或者要回传的数据不止一个，返回值就解决不了了。
 
传递变量的指针可以轻松解决上述问题。
复制代码
```c
void change(int* pa)
{
    (*pa)++;   //因为传递的是age的地址，因此pa指向内存数据age。当在函数中对指针pa解地址时，
               //会直接去内存中找到age这个数据，然后把它增1。
}
int main(void)
{
    int age = 19;
    change(&age);
    printf("age = %d\n",age);   // age = 20
    return 0;
}
```
再来一个老生常谈的，用函数交换2个变量的值的例子：
```c
#include<stdio.h>
void swap_bad(int a,int b);
void swap_ok(int*pa,int*pb);

int main()
{
    int a = 5;
    int b = 3;
    swap_bad(a,b);       //Can`t swap;
    swap_ok(&a,&b);      //OK
    return 0;
}

//错误的写法
void swap_bad(int a,int b)
{
    int t;
    t=a;
    a=b;
    b=t;
}

//正确的写法：通过指针
void swap_ok(int*pa,int*pb)
{
    int t;
    t=*pa;
    *pa=*pb;
    *pb=t;
}
```
有的时候，我们通过指针传递数据给函数不是为了在函数中改变他指向的对象，相反，我们**防止这个目标数据被改变**。
**传递指针只是为了避免拷贝大型数据**。
考虑一个结构体类型Student。我们通过show函数输出Student变量的数据。
```c
typedef struct
{
    char name[31];
    int age;
    float score;
}Student;

//打印Student变量信息
void show(const Student * ps)
{
    printf("name:%s , age:%d , score:%.2f\n",ps->name,ps->age,ps->score);   
}
```
我们只是在show函数中取读Student变量的信息，而不会去修改它，为了防止意外修改，我们使用了常量指针去约束。另外我们为什么要使用指针而不是直接传递Student变量呢？
从定义的结构看出，Student变量的大小至少是39个字节，那么通过函数直接传递变量，实参赋值数据给形参需要拷贝至少39个字节的数据，极不高效。而传递变量的指针却快很多，因为在同一个平台下，无论什么类型的指针大小都是固定的：X86指针4字节，X64指针8字节，远远比一个Student结构体变量小。

### 函数的指针
每一个函数本身也是一种程序数据，一个函数包含了多条执行语句，它被编译后，实质上是多条机器指令的合集。在程序载入到内存后，函数的机器指令存放在一个特定的逻辑区域：代码区。既然是存放在内存中，那么函数也是有自己的指针的。
C语言中，函数名作为右值时，就是这个函数的指针。
```c
void echo(const char *msg)
{
    printf("%s",msg);
}
int main(void)
{
    void(*p)(const char*) = echo;   //函数指针变量指向echo这个函数
    p("Hello ");      //通过函数的指针p调用函数，等价于echo("Hello ")
    echo("World\n");
    return 0;
}
```

## const 和 指针
如果const 后面是一个类型，则跳过最近的原子类型，修饰后面的数据。（原子类型是不可再分割的类型，如int, short , char，以及typedef包装后的类型）
如果const后面就是一个数据，则直接修饰这个数据。
```c
int main()
{
    int a = 1;
    int const *p1 = &a;        //const后面是*p1，实质是数据a，则修饰*p1，通过p1不能修改a的值
    const int*p2 =  &a;        //const后面是int类型，则跳过int ，修饰*p2， 效果同上
    int* const p3 = NULL;      //const后面是数据p3。也就是指针p3本身是const .
    const int* const p4 = &a;  // 通过p4不能改变a 的值，同时p4本身也是 const
    int const* const p5 = &a;  //效果同上
    return 0;

}
```

# 深拷贝和浅拷贝
如果2个程序单元（例如2个函数）是通过拷贝 他们所共享的数据的 指针来工作的，这就是浅拷贝，因为真正要访问的数据并没有被拷贝。如果被访问的数据被拷贝了，在每个单元中都有自己的一份，对目标数据的操作相互 不受影响，则叫做深拷贝。
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/C-1/3.png)

# 指针和引用这个2个名词的区别
指针和引用这个2个名词的区别。他们本质上来说是同样的东西。指针常用在C语言中，而引用，则用于诸如Java，C#等 在语言层面封装了对指针的直接操作的编程语言中。引用是编程语言提供给程序员的抽象机制，而指针是操作系统提供给软件开发模型的抽象机制。

# 大端模式和小端模式
1. Little-Endian就是数据的低字节排放在内存的低地址端，高字节排放在内存的高地址端。个人PC常用，Intel X86处理器是小端模式。
2. Big-Endian就是数据的高字节排放在内存的低地址端，低字节排放在内存的高地址端。
 
采用大端方式 进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。有些机器同时支持大端和小端模式。
 
假如 short类型占用2个字节，且存储的地址为0x30。
short a = 1; 
![img](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/C-1/4.png)




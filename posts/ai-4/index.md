# AI-Heuristic Algorithm


heuristic algorithm
<!--more-->

# 启发式算法的概念
启发式算法（heuristic algorithm)是**相对于最优化算法提出的**。一个问题的最优算法求得该问题每个实例的最优解。启发式算法可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。现阶段，**启发式算法以仿自然体算法为主**，主要有蚁群算法、模拟退火法、神经网络等。
[百度百科](https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/938987?fr=aladdin)
[启发式算法概念](https://blog.csdn.net/weixin_42937223/article/details/109046158)

# 启发式函数的使用
启发式函数h(n)告诉A*从任意结点n到目标点的最小代价评估值
因此，选择一个好的启发式函数是重要的
|情况|函数|结果|
|:-:|:-:|:-:|
|h(n) = 0|A*演变为Dijkstra算法|保证能找到最短路径(但是运算时间长)|
|h(n)<=实际代价|h(n)越小,A*扩展的结点越多,运算减慢|能找到一条最短路径,运算速度更快|
|h(n)=实际代价|仅仅寻找最佳路径而不扩展其他结点|保证能找到一条最短路径,运算时间最短|
|h(n)>实际代价|寻找最短路径且扩展别的结点|不能保证找到一条最短路径,但运算更快|
|h(n)>>g(n)|A*演变为BFS算法|不能保证找到一条最短路径,但运算非常快|

所以得到一个很有趣的情况，那就是可以决定想要从A* 中获得什么
理想情况下，想最快地得到最短路径
**如果目标太低，仍会得到最短路径，不过速度变慢了**
**如果目标太高，那就放弃了最短路径，但A* 运行得更快**

A*的这个特性非常有用，例如
在某些情况下，希望得到一条好的路径-“good”path,而不是一条完美的路径-“perfect” path
为了权衡g(n)和h(n)，可以修改任意一个的权重

在学术上，如果启发式函数值是对实际代价的低估，A*算法被称为简单的A算法（simply A）
然而，继续称之为A*，因为在实现上是一样的，并且在编程领域并不区别A和A*

# 权衡代价函数
A* 改变它自己行为的能力基于启发式代价函数
在**速度和精确度之间取得折衷**将会让搜索运行得更快
在搜索中，并不真正需要得到最好的路径，仅需要近似的就足够了
而需要什么则取决于路径搜索中发生着什么，或者运行路径搜索的机器有多快
假设路径搜索的地图中有两种地形：平原和山地
有可能有一条沿着平原到山地的路径
在平原中的移动代价是1，而在山地则是3
把两个邻接点之间的评估距离设为1.5可以加速A* 的搜索过程
然后A* 会将3和1.5比较，这并不比把3和1比较差
速度和精确度之间的选择前不是静态的
可以基于CPU的速度、用于路径搜索的时间片数、地图上物体的数量、物体的重要性、组（group）的大小、难度或者其他任何因素来进行动态的选择
取得动态的折衷的一个方法是：
建立一个启发式函数用于假定通过一个网格空间的最小代价是1
然后建立一个代价函数（cost function）用于测量（scales）： 
g′(n) = 1 + alpha∗(g (n)–1)
改变最短路径搜索算法的代价
 - 如果alpha是0，则改进后的代价函数的值总是1，地形代价被完全忽略，简单地判断一个网格可否通过
 - 如果alpha是1，则最初的最短路径搜索算法代价函数将起作用，然后得到了A*的所有优点

也可以考虑对启发式函数的返回值做选择：绝对最小代价或者期望最小代价.例如，如果地图大部分地形是代价为2的草地，其它一些地方是代价为1的道路.那么可以考虑让启发式函数不考虑道路，而只返回2*距离
当然，速度和精确度之间的选择并不是全局的

# 衡量单位
A* 计算f(n)=g(n)+h(n)
为了对这两个值进行相加，这两个值必须使用相同的衡量单位
如果g(n)用小时来衡量而h(n)用米来衡量，那么A* 将会认为g或者h太大或者太小
因而将不能得到正确的路径，同时A* 算法将运行得更慢

>因此优化启发式算法的过程就是找到一个合适的f(n)函数,而在寻找的过程也需要进行大量计算

# 精确的启发式函数
如果启发式函数精确地等于实际最佳路径（optimal path）
此时A*扩展的结点将非常少

A* 算法内部发生的事情是：
在每一结点它都计算f(n)=g(n)+h(n)

当h(n)精确地和g(n)匹配时，f(n)的值在沿着该路径时将不会改变
不在最短路径上，所有结点的f(n)值均大于最短路径上的f(n)值
如果已经有较低f(n)值的结点，A* 将不考虑f(n)值较高的结点
因此它肯定不会偏离最短路径

## 预计算的精确启发式函数
构造精确启发函数的一种方法：
预先计算任意一对结点之间最短路径的长度

然后添加一个启发函数 h ′ h' h′用于评估从任意位置n到达邻近导航点（waypoints）的代价
最终的启发式函数：h(n)=h′(n,w1)+distance(w1,w2)+h′(w2,goal)

或者如果希望一个更好但更昂贵的启发式函数
则分别用靠近结点和目标的 所有的w1，w2对 对上式进行求值

## 线性精确启发式算法
在特殊情况下，可以不通过预计算而让启发式函数很精确
如果有一个不存在障碍物和平缓地形
那么从初始点到目标的最短路径应该是一条直线
如果正使用简单的启发式函数（不知道地图上的障碍物）
则它应该和精确的启发式函数相符合
如果不是这样，则会遇到衡量单位的问题，或者所选择的启发函数类型的问题
[参考博客-1](https://blog.csdn.net/qq_32618327/article/details/100081677)

<img loading="lazy" src="https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/4/1.png">

<img loading="lazy" src="https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/4/2.png">

<img loading="lazy" src="https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/4/3.png">

<img loading="lazy" src="https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/4/4.png">

<img loading="lazy" src="https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/4/5.png">

[参考博客-2](https://joveh-h.blog.csdn.net/article/details/100071325)

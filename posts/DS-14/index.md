# 动态规划 背包问题-1



花了大半天时间,算是稍微理解了背包问题<br>
甲级题要把我虐穿了...这两天肝一肝8...(哭)
<!--more-->

首先了解一下什么叫背包问题
背包问题的一个典型例子就是小偷偷东西,有多个大小不同,价值不同的物品,但是小偷的背包能装下的物体的空间有限,这是就要去计算一个最优解,即"如何能在不超过背包容量的情况下,总体偷取的物品总价值最高"
对于这类问题,动态规划的解决方法就是,将这个问题划分为多个小问题组成,并计算每个小问题的优化解,在得到的小问题的优化解,逐步扩大求解范围,并在这个过程中继续优化解,因此最后可以得到一个最优解
"拆分小问题" -> "优化推进" 这个过程

# 基本概念
这里直接贴上简书大佬的文章了
内容搬运自算法图解这本书
[参考文章](https://www.jianshu.com/p/a66d5ce49df5)

>其实手头就有一本算法图解,之前也看过...虽然之前也看过,但由于当初没有算法功底,所以...看了也都没啥印象,不过现在再看,效果就好了很多,毕竟这本书我认为不是零基础入门的,而是更生动的理解算法的出发点和解决问题的方式

# 问题分类
背包问题目前我只是接触了最基础的一类问题,因此这算是第一篇吧,后面的其他类型问题还会慢慢学习
 - 0-1背包
 - 完全背包

## 0-1背包
0-1背包名字的由来就是,在待求解问题中,每一个可选元素,都只有一个,即只有 "选" 或 "不选" 两种选择
而对于问题的求解,如果从逻辑上直接过渡到代码实现的话,就需要构造一个二维数组,最后问题也可以优化为一维数组
但二维和一维的区别在于,一维数组遍历顺序有所改变,是从后向前进行遍历

### 二维求解
```c++
/*
状态转移方程：
定义f[i][j]:前i个物品，背包容量j下的最优解

1. 当前背包容量不够（j < w[i]），为前i-1个物品最优解：f[i][j] = f[i-1][j]
2. 当前背包容量够，判断选与不选第i个物品

选：f[i][j] = f[i-1][j-w[i]] + v[i]
不选：f[i][j] = f[i-1][j]
*/
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1005;
int w[MAXN];    // 重量 
int v[MAXN];    // 价值 
int f[MAXN][MAXN];  // f[i][j], j重量下前i个物品的最大价值 

int main() 
{
    int n, m;   
    cin >> n >> m;
    for(int i = 1; i <= n; ++i) 
        cin >> w[i] >> v[i];

    for(int i = 1; i <= n; ++i) 
        for(int j = 1; j <= m; ++j)
        {
            //  当前重量装不进，价值等于前i-1个物品
            if(j < w[i]) 
                f[i][j] = f[i-1][j];
            // 能装，需判断 
            else    
                f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + v[i]);
        }           

    cout << f[n][m];
    return 0;
}
```

### 一维优化
**从后向前遍历**
```c++
/*
状态转移方程为：f[j] = max(f[j], f[j-w[i]] + v[i]
*/
for(int i = 1; i <= n; ++i)
{
    for(int j = m; j >= 0; --j) 
        if(j >= w[i])
            f[j] = max(f[j], f[j-w[i]] + v[i]);
} 
```

## 完全背包
### 二维求解
```c++
#include<iostream>
using namespace std;
const int N = 1010;
int f[N][N];
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 1 ; i <= n ;i ++)
    {
        cin>>v[i]>>w[i];
    }

    for(int i = 1 ; i<=n ;i++)
    for(int j = 0 ; j<=m ;j++)
    {
        for(int k = 0 ; k*v[i]<=j ; k++)
            f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
    }

    cout<<f[n][m]<<endl;
}
```

### 一维优化
[参考文章](https://www.acwing.com/solution/content/5345/)
```c++
#include<iostream>
using namespace std;
const int N = 1010;
int f[N];
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 1 ; i <= n ;i ++)
    {
        cin>>v[i]>>w[i];
    }

    for(int i = 1 ; i<=n ;i++)
    for(int j = v[i] ; j<=m ;j++)
    {
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
    cout<<f[m]<<endl;
}
```

# 个人理解
这里着重记录一下目前的理解
1. 0-1背包 一维求解 从后向前遍历
2. 完全背包问题 一维求解 从前向后遍历


当从后向前遍历时,对于当前解的优化,只是涉及到了单独的前驱元素,而此时前驱元素不包含当前判定元素,因此可以保证,在向前遍历过程中的每个元素都可以保证,**当前判定元素只使用了一次**
但当从前向后遍历时,每个元素都是可以经过前面的累计,即**后驱元素在当前元素的选择上,可以继续选择当前判定元素**,因此元素使用次数不限制,限制条件只有总体容量限制


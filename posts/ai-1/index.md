# AI-Uninformed Search


Berkeley CS-188
<!--more-->

# AI发展历史
![](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/1/1.png)

# Definition of agent(智能体)
![](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/1/2.png)
人工智能只会在基于当前数据下做出合理的决策,而没有创造力,但是没有记忆的衰减性

# Ⅰ.Note官方笔记
[PDF笔记](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/1/n1.pdf)

# Ⅱ.Translation
## Agents
在人工智能中，目前的主要问题是创建一个理性（rational） agent，一个有特定目标或偏好并会针对这些目标试图执行一系列操作（actions）来得到最优解的实体。理性agent存在于为给定的agent示例而量身定制的特定环境中。举一个简单的例子，一个西洋棋agent的环境就是它用来与对手对弈的虚拟棋盘，而对应的操作就是棋子的移动。一个环境和其中的agents一起创造了一个世界。

反射（reflex）agent不会考虑它的操作的后果，而只是根据世界的当前状态而选择一个操作。而计划（planning）agent则有一个世界模型并用这个模型来模拟执行不同的操作，远远胜过了反射agent。于是，agent就能确定操作的假想结果并选择最佳操作。这样的模拟“智能”在这个意义上符合人类在任何情况下尝试决定最佳动作的行为——预测。 

## State Spaces and Search Problems 
**状态空间和搜索问题**
 为了创建一个理性计划agent，我们需要一种方法来对agent存在的环境进行数学表达。为此，我们必须正式表达一个搜索问题（search problem）——给定agent的当前状态（state）（它在环境中的配置），我们如何尽可能最好地达到一个满足目标的新状态？讲一个问题公式化需要四个前提：

 - 状态空间state space：在给定世界中所有可能的状态
 - 后继函数successor function：包含一个状态和一个操作，并计算执行该操作的代价（cost）和执行操作后世界的后继状态
 - 起始状态start state：agent最初存在时当前世界的状态
 - 目标测试函数goal test：一个函数，输入一个状态并决定它是否是一个目标状态

要解决一个搜索问题，首先要考虑它的起始状态，然后用后继函数探索它的状态空间，反复计算不同状态的后继直到得到一个目标状态，这时我们就能确定一条连接起始状态和目标状态的路径（一般称为计划路径（plan））。由一个既定的策略（strategy）来决定我们考虑不同状态的顺序。很快我们将介绍策略的种类及其性能。

在我们继续讨论如何解决搜索问题之前，有必要强调一下世界状态（world state）和搜索状态（search state）的区别。世界状态包含一个给定状态的所有信息，而**搜索状态仅包含对计划（主要是为了空间效率）必要的信息**。我们将介绍本课程的一大亮点——吃豆人Pacman来解释这些概念。这个游戏很简单：吃豆人必须探索一个迷宫，吃掉所有的的小豆子并且不被游荡的恶灵吃掉。如果它吃了大豆子，它将在一段时间内无敌并且能吃掉恶灵赚取分

我们来考虑这个游戏的一个变式，迷宫中只有吃豆人和豆子。在这种情况下我们能给出两种不同的搜索问题：路径规划和光盘行动（pathing and eat-all-dots）。路径规划需要找出从位置(x<sub>1</sub>,y<sub>1</sub>)到(x<sub>2</sub>,y<sub>2</sub>)的最佳方案，而光盘行动要求用尽可能短的时间吃掉迷宫中所有的豆子。下面分别列出了两个问题的状态、操作、后继函数和目标测试函数：

|问题|路径规划|光盘行动|
|:-:|:-:|:-:|
状态|(x,y)坐标|(x,y)坐标,豆子的bool量|
|操作|东南西北|东南西北|
|后继函数|仅更新位置信息|更新位置和bool|
|目标测试函数|(x,y) == end|所有的豆子bool是否都等于0|

路径规划的状态包含的信息比光盘行动要少，因为在光盘行动中我们必须保存一大批布尔值用来表示在给定状态中每个豆子有没有被吃掉。一个世界状态还有可能包含更多的信息，比如吃豆人走过的总距离，或者吃豆人在它的当前位置（x，y）和豆子布尔值上到达过的所有地方这些潜在的编码信息。

## State Space Size 状态空间大小
在估算搜索问题的计算运行时间时，状态空间的大小是一个很重要的问题。这个问题几乎只能用基础计数原理（fundamental counting principle）解决：如果在一个给定的世界里有n个变量分别有x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>...x<sub>n</sub>种不同的取值，那么状态的总数为n 。我们用吃豆人来举例说明这个概念：
![](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/1/3.png)

我们定义变量和它们分别的取值种数如下：

 - 吃豆人位置：吃豆人可以在120个不同的（x，y）坐标，而只有一个吃豆人
 - 吃豆人前进方向：共有东南西北四种可能
 - 恶灵位置：有两个恶灵，每一个都有可能在12个不同的（x，y）坐标
 - 豆子分布：共30个豆子，每个都要么被吃要么没有被吃

根据基础计数原理，吃豆人有120个位置，可以朝着4个方向，恶灵分布有12$\times$12种（每个恶灵12种），豆子分布有2<sup>30</sup>种。由此可得总状态空间大小为 $120\times4\times12^2\times2^{30}$

## State Space Graphs and Search Trees 
**状态空间图和搜索树**
 现在我们已经构建了状态空间的概念并用了四个部件来完整地定义了一个状态空间，我们马上就可以开始着手解决搜索问题了。现在我们缺少的最后一块拼图就是状态空间图和搜索树。

图是由一些结点和连接结点的边构成的。这些边也会有与之相关的权重。**状态空间图（state space graph）**是由代表状态的结点以及从一个状态指向其后继的有向边构成的。这些**边表示操作（action）**，而任何相关联的权重表示对应操作的代价。通常，状态空间图太大，无法存储在内存中（就算是吃豆人这样的简单例子也有大约$10^{13}$种不同状态）。不过在解决问题时从概念上记住它们就好。另一点需要注意的是，在一个状态空间图中，每一个状态仅表示一次——没必要多次表示一个状态，这一点在尝试推理搜索问题时非常有用。

与状态空间图不同，我们要讲的下一个结构，**搜索树（search trees）**对于一个状态出现的次数没有限制。这是因为虽然搜索树也是一类用结点表示状态、用边表示状态之间操作的图，每个结点/状态并不仅仅代表它本身，同时也代表了状态空间图中连通起始状态和给定状态的**整个路径（或计划）**。观察下面的状态空间图和与其对应的搜索树：
![](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/1/4.png)

状态空间图中标红的路径(S → d → e → r → f → G)在对应的搜索树中表示为从**起始状态S到标红状态G的路径**。同理，状态空间图中从起始节点到其他任意节点的每条路径在搜索树中都表示为从根节点S到另一节点对应的子孙节点的路径。由于从一个状态到另一个状态通常会有多种方案，搜索树中状态会出现多次。由此，搜索树的规模大于等于对应的状态空间图。

我们已经确定了即使是简单问题的状态空间图也有相当大的规模，于是问题来了——如果这些结构大到无法再内存中表示，我们如何对它们进行有效计算呢？答案就在后继函数中——我们只保存即刻处理的状态，并用相应的后继函数根据需求来计算新的状态。通常，搜索问题是用搜索树来解决的。在树中，我们每次观察那几个非常小心地存储选择的节点，反复地用其后继来替换节点，直到我们到达一个目标状态。**有许多种方法可以用来决定在搜索树中迭代替换节点的顺序**，现在我们将介绍这些方法。

## Uninformed Search 未知搜索
寻找从起始状态到目标状态的计划的标准协议（standard protocol）是保持来自于搜索树的部分计划的边缘（outer fringe）。通过移除一个与部分计划对应的节点（用给定的策略来选择）并用它所有的子节点代替它，我们**不断地扩展（expand）我们的边缘**。用子节点代替边缘上的元素,相当于丢弃一个长度为n的计划并考虑所有源于它的长度为（n+1）的计划。我们继续这一操作，直到最终将目标从边缘移除为止。此时我们得出结论，与移除的目标状态相对应的部分计划其实就是从起始状态到目标状态的一条路径。实际上，这类算法的大多数实现都对父节点、到节点的距离和节点内部的信息进行编码。我们刚刚介绍的这一过程就是**树搜索（tree search）**

 当我们不知道目标状态在搜索树中的的位置时，我们只能从属于未知搜索（uninformed search）的技术中选择用于树搜索的策略。我们将依次介绍三种策略：深度优先搜索DFS、广度优先搜索BFS和一致代价搜索UCS。同时，我们还会介绍它们的一些基本性质，内容如下：

 - 每种策略的完备性（completeness）：如果此搜索问题有解，在拥有无限计算资源的情况下，是否可以保证找到这个解？
 - 每种策略的最优性（optimality）：这个策略是否能保证找到通往目标状态代价最低的路径？
 - 分支因数b：每次将边缘节点移除并用其子节点替换时，边缘节点增加的数量为O(b)。在搜索树深度为k的一层存在$O(b^k)$个节点。
 - 最大深度m
 - 最浅解的深度s

### Depth-First Search
 - 描述：深度优先搜索DFS总是选择距离起始节点最深的边缘节点来进行扩展。
 - 边缘表示：在边缘移除最深的节点并用它的孩子节点替换，这当然意味着现在孩子节点就成为了最深的节点——它们的深度比之前的最深节点要多1。这意味着要实现DFS，我们需要一种结构来让最近添加的对象总是有最高优先级。后进先出（LIFO）堆栈正是这样，而且它在实现DFS时通常用来表示边缘。
  ![](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/1/5.png)
 - 完备性：深度优先搜索并不具有完备性。如果在状态空间图中存在回路，这必然意味着相应搜索树的深度将是无限的。因此，存在这样一种可能性，即DFS老实地在无限大的搜索树中搜索最深的节点而不幸地陷入僵局，注定无法找到解。
 - 最优性：深度优先搜索只是在搜索树中找到“最左边”的解，而没有考虑路径的代价，因此不是最优的。
 - 时间复杂度：在最坏情况下，深度优先搜索最终可能会搜遍整个搜索树。因此，给定一棵最大深度为m的树，DFS的时间复杂度$O(b^k)$。
 - 空间复杂度：在最坏情况下，DFS在边缘上m个深度级别上都有b个节点。这是一个简单的结果，因为一旦某个父节点的b个子节点进入队列，DFS的本性在任意时间点都只允许研究任意一个子节点的一棵子树。因此，DFS的空间复杂度是$O(bm)$。

### Breadth-First Search
 - 描述：宽度优先搜索总是选择距离起始节点最浅（近）的边缘节点来扩展。
 - 边缘表示：如果我们想在较深的节点之前访问较浅的节点，我们必须按照节点的插入顺序来访问它们。因此，我们希望有一种能输出最早进入队列的对象的结构来表示我们的边缘。为此，BFS使用了一种先进先出（FIFO）队列。
    ![](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/1/6.png)
 - 完备性：如果存在一个解，那么最浅节点s的深度一定是有限的，所以BFS最终一定会搜索这个深度。所以它是完备的。
 - 最优性：BFS一般不是最优的，因为它在选择边缘上被替换的节点时不会考虑代价问题。在所有边的代价都相等的特殊情况下BFS可以保证是最优的，因为这会让BFS退化为一致代价搜索，我们将会在下面讨论这个特殊情况。
 - 时间复杂度：在最坏情况下我们必须搜索 $1+b+b^2+ ... b^s$ 个节点，因为我们得在从1到s每一个深度下都遍历所有节点。因此，时间复杂度是$O(b^s)$。
 - 空间复杂度：在最坏情况下，边缘所有节点都在对应最浅解的那一层。由于最浅解位于深度s处，在这一深度有$O(b^s)$个节点。

### Uniform Cost Search(一致代价搜索)
 - 描述：一致代价搜索（UCS），我们的最后一种方案，总是**选择距离起始节点代价最小的边缘节点来扩展**。
 - 边缘表示：为了表示UCS的边缘，通常**选择基于堆的优先队列**，其中给定排队节点v的权重就是从起始节点到v的路径代价，或是**v的后退代价（backward cost）**。直观来讲，以这种方式构建的优先队列只需重新自我洗牌就能维持我们希望得到的按照路径代价排序的顺序，因为我们移除当前代价最小的路径并用它的子路径代替了它。
![](https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/AI/1/7.png)
 - 完备性：一致代价搜索是完备的。如果存在一个目标状态，它一定有一些有限长度最短路径；因此，UCS最终一定能找到这条长度最短路径。
 - 最优性：如果我们假设所有的边都是非负的，那么UCS也是最优的。通过构造，由于我们按照路径代价递增的顺序来搜索节点，我们肯定能找到到达一个目标状态的最低代价路径。**一致代价搜索的策略与Dijkstra算法相同，主要区别在于UCS在找到一个解状态时终止，而不是找到通往所有状态的最短路径**。要注意的是，如果在我们的图中有边的代价为负会导致路径上的节点长度减少，从而破坏了最优性的保证。（有关应对这种可能性的较慢的算法请参阅Bellman-Ford算法）
 - 时间复杂度：我们定义最优路径代价为$C*$，状态空间图内两节点之间最小代价为$\varepsilon$。那么，我们得简单粗暴地遍历深度为从1到$C*\over\varepsilon$范围内的所有节点，导致运行时间为$O(b^{C*/\varepsilon})$。
 - 空间复杂度：又是简单粗暴地，边缘会包括代价最低解所在层的所有节点，所以UCS空间复杂度大约为$O(b^{C*/\varepsilon})$。

作为对一致代价搜索的最后说明，必须注意上面列出的三种策略本质上是相同的——只是在扩展策略上有所区别，上面给出的树搜索伪代码捕捉到了它们的相似之处。

[{"categories":["Hugo"],"content":"搭建Hugo 下载go 设置环境变量 GOROOT : 安装的文件夹D:\\Go Path : D:\\Go\\bin ","date":"2022-03-04","objectID":"/posts/hugo/:0:0","tags":["Hugo-FixIt"],"title":"搭建Hugo","uri":"/posts/hugo/"},{"categories":["Centos"],"content":"curl常用命令 命令格式 curl [option] [url] ","date":"2022-03-03","objectID":"/posts/centos-2/:0:0","tags":["Centos-Tools"],"title":"curl常用命令","uri":"/posts/centos-2/"},{"categories":["Centos"],"content":"保存网页 curl -o baidu.html http://www.baidu.com ","date":"2022-03-03","objectID":"/posts/centos-2/:1:0","tags":["Centos-Tools"],"title":"curl常用命令","uri":"/posts/centos-2/"},{"categories":["Centos"],"content":"使用代理 curl -x 192.168.100.100:1080 http://www.baidu.com ","date":"2022-03-03","objectID":"/posts/centos-2/:2:0","tags":["Centos-Tools"],"title":"curl常用命令","uri":"/posts/centos-2/"},{"categories":["Centos"],"content":"发送POST请求 curl -X POST http://www.baidu.com ","date":"2022-03-03","objectID":"/posts/centos-2/:3:0","tags":["Centos-Tools"],"title":"curl常用命令","uri":"/posts/centos-2/"},{"categories":["Centos"],"content":"只显示 HTTP 头 curl -I http://www.codebelief.com ","date":"2022-03-03","objectID":"/posts/centos-2/:4:0","tags":["Centos-Tools"],"title":"curl常用命令","uri":"/posts/centos-2/"},{"categories":["Centos"],"content":"自定义User-Agent curl -A “Mozilla/5.0 (Android; Mobile; rv:35.0) Gecko/35.0 Firefox/35.0” http://www.baidu.com ","date":"2022-03-03","objectID":"/posts/centos-2/:5:0","tags":["Centos-Tools"],"title":"curl常用命令","uri":"/posts/centos-2/"},{"categories":["Centos"],"content":"自定义 header curl -H “Referer: www.example.com” -H “User-Agent: Custom-User-Agent” http://www.baidu.com ","date":"2022-03-03","objectID":"/posts/centos-2/:6:0","tags":["Centos-Tools"],"title":"curl常用命令","uri":"/posts/centos-2/"},{"categories":["Centos"],"content":"POST 请求 POST 请求，-d 用于指定发送的数据，-X 用于指定发送数据的方式： curl -d “userName=tom\u0026passwd=123456” -X POST http://www.example.com/login 在使用 -d 的情况下，如果省略 -X，则默认为 POST 方式： curl -d “userName=tom\u0026passwd=123456” http://www.example.com/login 常见参数 -A/--user-agent \u003cstring\u003e 设置用户代理发送给服务器 -b/--cookie \u003cname=string/file\u003e cookie字符串或文件读取位置 -c/--cookie-jar \u003cfile\u003e 操作结束后把cookie写入到这个文件中 -C/--continue-at \u003coffset\u003e 断点续转 -D/--dump-header \u003cfile\u003e 把header信息写入到该文件中 -e/--referer 来源网址 -f/--fail 连接失败时不显示http错误 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中，保留远程文件的文件名 -r/--range \u003crange\u003e 检索来自HTTP/1.1或FTP服务器字节范围 -s/--silent 静音模式。不输出任何东西 -T/--upload-file \u003cfile\u003e 上传文件 -u/--user \u003cuser[:password]\u003e 设置服务器的用户和密码 -w/--write-out [format] 什么输出完成后 -x/--proxy \u003chost[:port]\u003e 在给定的端口上使用HTTP代理 -#/--progress-bar 进度条显示当前的传送状态 -L, --location 自动跳转 ","date":"2022-03-03","objectID":"/posts/centos-2/:7:0","tags":["Centos-Tools"],"title":"curl常用命令","uri":"/posts/centos-2/"},{"categories":["Centos"],"content":"Linux下用来周期性的执行任务 crond是Linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，可以使用命令：systemctl status crond进行查看。 crond进程定期(每分钟)检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。用户在cron表（也被称为crontab文件）指定了定时任务，crontab也就是我们常见的定时任务设置命令。Linux下的任务调度分为两类，系统任务调度和用户任务调度。 因此只需要对crontab操作即可 系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。/etc/crontab文件就是系统任务调度的配置文件。 [root@ ~]# cat /etc/crontab SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # For details see man 4 crontabs # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed crond是执行任务计划的一个守护进程 contab才是需要进行配置的 [root@ ~]# crontab --help crontab：无效选项 -- - crontab: usage error: unrecognized option Usage: crontab [options] file crontab [options] crontab -n [hostname] Options: -u \u003cuser\u003e define user -e edit user's crontab -l list user's crontab -r delete user's crontab -i prompt before deleting -n \u003chost\u003e set host in cluster to run users' crontabs -c get host in cluster to run users' crontabs -s selinux context -x \u003cmask\u003e enable debugging [root@ ~]# man crontab NAME crontab - maintains crontab files for individual users SYNOPSIS crontab [-u user] file crontab [-u user] [-l | -r | -e] [-i] [-s] crontab -n [ hostname ] crontab -c DESCRIPTION Crontab is the program used to install a crontab table file, remove or list the existing tables used to serve the cron(8) daemon. Each user can have their own crontab, and though these are files in /var/spool/, they are not intended to be edited directly. For SELinux in MLS mode, you can define more crontabs for each range. For more information, see selinux(8). In this version of Cron it is possible to use a network-mounted shared /var/spool/cron across a cluster of hosts and specify that only one of the hosts should run the crontab jobs in the particular directory at any one time. You may also use crontab(1) from any of these hosts to edit the same shared set of crontab files, and to set and query which host should run the crontab jobs. ","date":"2022-03-03","objectID":"/posts/docker-9/:0:0","tags":["Centos-Tools"],"title":"crond","uri":"/posts/docker-9/"},{"categories":["Centos"],"content":"安装 yum install cronie ","date":"2022-03-03","objectID":"/posts/docker-9/:1:0","tags":["Centos-Tools"],"title":"crond","uri":"/posts/docker-9/"},{"categories":["Centos"],"content":"启动暂停crond # 启动守护进程 crond -i # 关闭守护进程 (没找到别的方法) ps ax -O uid,uname,gid,group,ppid kill -9 PID ","date":"2022-03-03","objectID":"/posts/docker-9/:2:0","tags":["Centos-Tools"],"title":"crond","uri":"/posts/docker-9/"},{"categories":["Centos"],"content":"crontab命令 ","date":"2022-03-03","objectID":"/posts/docker-9/:3:0","tags":["Centos-Tools"],"title":"crond","uri":"/posts/docker-9/"},{"categories":["Centos"],"content":"编辑定时任务配置文件 crontab -e #相当于 vi /var/spool/cron/ 定时任务配置文件保存目录 # vi /var/spool/cron/root root用户设置的定时任务配置文件 # vi /var/spool/cron/shuai shuai用户设置的定时任务配置文件 # 添加任务 */1 * * * * python /home/path/timer_test.py \u003e\u003e /home/path/testcrontab.log 2\u003e\u00261 ","date":"2022-03-03","objectID":"/posts/docker-9/:3:1","tags":["Centos-Tools"],"title":"crond","uri":"/posts/docker-9/"},{"categories":["Centos"],"content":"查看定时任务 crontab -l (list) ","date":"2022-03-03","objectID":"/posts/docker-9/:3:2","tags":["Centos-Tools"],"title":"crond","uri":"/posts/docker-9/"},{"categories":["Centos"],"content":"删除任务 crontab -r ","date":"2022-03-03","objectID":"/posts/docker-9/:3:3","tags":["Centos-Tools"],"title":"crond","uri":"/posts/docker-9/"},{"categories":["Centos"],"content":"报错解决 报错 cron: can’t lock /var/run/crond.pid, otherpid may be 2699: Resource temporarily unavailable rm -rf /var/run/crond.pid ","date":"2022-03-03","objectID":"/posts/docker-9/:4:0","tags":["Centos-Tools"],"title":"crond","uri":"/posts/docker-9/"},{"categories":["Docker"],"content":"构建前后端服务组 ","date":"2022-03-03","objectID":"/posts/docker-8/:0:0","tags":["Docker服务器"],"title":"构建前后端服务组","uri":"/posts/docker-8/"},{"categories":["Docker"],"content":"服务器 centos7.9 Nginx-1.20 ","date":"2022-03-03","objectID":"/posts/docker-8/:1:0","tags":["Docker服务器"],"title":"构建前后端服务组","uri":"/posts/docker-8/"},{"categories":["Docker"],"content":"安装 yum install nginx ","date":"2022-03-03","objectID":"/posts/docker-8/:2:0","tags":["Docker服务器"],"title":"构建前后端服务组","uri":"/posts/docker-8/"},{"categories":["Docker"],"content":"查看配置文件所在位置 /usr/sbin/nginx -t ","date":"2022-03-03","objectID":"/posts/docker-8/:3:0","tags":["Docker服务器"],"title":"构建前后端服务组","uri":"/posts/docker-8/"},{"categories":["Docker"],"content":"配置文件 vim /etc/nginx/nginx.conf # 访问过滤 allow IP; allow 127.0.0.1; deny all; # 应用映射 location /api { proxy_pass http://127.0.0.1:8001/; } location /jenkins { proxy_pass http://127.0.0.1:8080/jenkins; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } location /DatangQcc { proxy_pass http://127.0.0.1:8082/; } 安装依赖库 # -i https://pypi.tuna.tsinghua.edu.cn/simple pip install fastapi apschedule uvicorn pymysql error_log cat /var/log/nginx/error.log; docker进程管理 yum install procps #安装ps 查看进程 ps ax -O uid,uname,gid,group,ppid 杀死进程 kill -9 PID 重启docker systemctl restart docker docker安装 ","date":"2022-03-03","objectID":"/posts/docker-8/:4:0","tags":["Docker服务器"],"title":"构建前后端服务组","uri":"/posts/docker-8/"},{"categories":["Docker"],"content":"修改镜像源 # 编辑配置文件 vi /etc/docker/daemon.json { \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"] } # 重启docker服务 systemctl restart docker.service ","date":"2022-03-03","objectID":"/posts/docker-8/:5:0","tags":["Docker服务器"],"title":"构建前后端服务组","uri":"/posts/docker-8/"},{"categories":["Docker"],"content":"拉取镜像 docker pull mysql:8.0.26 docker pull nginx:1.20.1 docker pull rockylinux:8.5 ","date":"2022-03-03","objectID":"/posts/docker-8/:6:0","tags":["Docker服务器"],"title":"构建前后端服务组","uri":"/posts/docker-8/"},{"categories":["Docker"],"content":"数据库mysql docker_mysql docker run -itd --name docker_mysql -p 3309:3306 -e MYSQL_ROOT_PASSWORD=980215 mysql:8.0.26 ","date":"2022-03-03","objectID":"/posts/docker-8/:7:0","tags":["Docker服务器"],"title":"构建前后端服务组","uri":"/posts/docker-8/"},{"categories":["Docker"],"content":"后端 docker_fastapi docker run -itd --name docker_fastapi -p 8081:80 -v /home/DockerVolume/fastapi/data:/home python:3.9 因为没有系统层面的控制,但是想用到supervisor,因此还是装系统容器吧 发现centos8被官方抛弃了,以后也不会维护了,转向了rockylinux 安装 docker pull rockylinux:8.5 docker run -itd --name docker_rocky -p 8001:80 -p 8002:8080 -v /home/DockerVolume/rocky:/home rockylinux:8.5 docker_rockylinux # 首先安装EPEL源 yum install epel-release # 安装supervisor yum install supervisor # 安装python yum install python39 # 链接python3.9到python # 链接pip3.9到pip ln -s /usr/bin/python3.9 /usr/bin/python ln -s /usr/bin/pip3.9 /usr/bin/pip # (不需要) # 更换yum源 # 设置镜像变量 MIRROR=mirrors.aliyun.com/rockylinux # 执行替换 sudo sed -i.bak \\ -e \"s|^mirrorlist=|#mirrorlist=|\" \\ -e \"s|^#baseurl=|baseurl=|\" \\ -e \"s|dl.rockylinux.org/\\$contentdir|$MIRROR|\" \\ /etc/yum.repos.d/Rocky-*.repo sudo dnf makecache # (不需要) # 设置全局变量 vim /etc/profile # 在最后添加 export PATH=/usr/local/bin:$PATH # 刷新配置文件 source /etc/profile 项目代码修改 # fastapi 0.0.0.0:port ","date":"2022-03-03","objectID":"/posts/docker-8/:8:0","tags":["Docker服务器"],"title":"构建前后端服务组","uri":"/posts/docker-8/"},{"categories":["Docker"],"content":"前端 docker_nginx docker run -itd --name docker_nginx -p 8082:80 -v /home/DockerVolume/nginx/data:/home nginx:1.20 ","date":"2022-03-03","objectID":"/posts/docker-8/:9:0","tags":["Docker服务器"],"title":"构建前后端服务组","uri":"/posts/docker-8/"},{"categories":["Centos"],"content":"整点没用的 下载 wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.11-Linux-x86_64.sh --no-check-certificate 安装 bash Anaconda3-2020.11-Linux-x86_64.sh ... Please, press ENTER to continue # 按enter 出现用户协议 一直按enter Please answer 'yes' or 'no':' # 输入 yes 按enter [/home/anaconda3] \u003e\u003e\u003e # 设置安装目录，直接enter就是默认的目录，显示在左边中括号那个 Unpacking payload ... #出现就是就是在安装了 by running conda init? [yes|no] # 是否初始化conda，这里一定要输入yes 不要直接按enter，因为默认是no 然后就安装完成了 如果最后一步你输入了yes，那么打开~/.bashrc会看到这段配置 # !! Contents within this block are managed by 'conda init' !! __conda_setup=\"$('/home/lucky/anaconda3/bin/conda' 'shell.bash' 'hook' 2\u003e /dev/null)\" if [ $? -eq 0 ]; then eval \"$__conda_setup\" else if [ -f \"/home/lucky/anaconda3/etc/profile.d/conda.sh\" ]; then . \"/home/lucky/anaconda3/etc/profile.d/conda.sh\" else export PATH=\"/home/lucky/anaconda3/bin:$PATH\" fi fi unset __conda_setup # \u003c\u003c\u003c conda initialize \u003c\u003c\u003c 虽然conda设置了配置，但是并没有激活，需要激活一下 source ~/.bashrc # 检查是否安装成功 conda -V conda 4.10.3 # 出来这个就说明安装成功了 退出conda环境 conda deactivate ","date":"2022-03-03","objectID":"/posts/centos-1/:0:0","tags":["Conda"],"title":"centos安装conda","uri":"/posts/centos-1/"},{"categories":["Jenkins"],"content":"初识Jenkins 包管理器Python包管理之poetry的使用 SQLAlchemy之alembic SQLAlchemy之alembic_why404-CSDN博客 部署Jenkins服务 Linux+Jenkins环境搭建以及自动部署django项目_冰棒的博客-CSDN博客_jenkins部署django Jenkins 远程部署Django（Flask）项目_gbfeng123的博客-CSDN博客 使用Jenkins进行Python项目的持续集成 - 简书 (jianshu.com) 使用Jenkins部署Python项目 - 姜小豆 - 博客园 (cnblogs.com) Jenkins部署git+python项目实现持续集成 - 六三零 - 博客园 (cnblogs.com) Jenkins安装与配置(Flask+Gunicorn及React) - 简书 (jianshu.com) 利用Jenkins + nginx 实现前端项目自动构建与持续集成 - SegmentFault 思否 ","date":"2022-03-03","objectID":"/posts/jenkins/:0:0","tags":["Jenkins"],"title":"Jenkins入门","uri":"/posts/jenkins/"},{"categories":["Jenkins"],"content":"反向代理jenkins 在nginx中设置jenkins的反向代理 - 简书 (jianshu.com) fastapi设置根目录映射 Behind a Proxy - FastAPI (tiangolo.com) yum 别执行 yum update 重装yum rpm -qa | grep yum # 查看已安装的yum rpm -aq|grep yum|xargs rpm -e –nodeps # 卸载 cat /etc/redhat-release # 查看当前centos版本 # 下载 wget http://vault.centos.org/7.4.1708/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-42.el7.noarch.rpm wget http://vault.centos.org/7.4.1708/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm wget http://vault.centos.org/7.4.1708/os/x86_64/Packages/yum-3.4.3-154.el7.centos.noarch.rpm # 安装 rpm -ivh yum-* # 修改源 cd /etc/yum.repos.d mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup wget http://mirrors.163.com/.help/CentOS7-Base-163.repo yum clean all yum makecache Jenkins ","date":"2022-03-03","objectID":"/posts/jenkins/:1:0","tags":["Jenkins"],"title":"Jenkins入门","uri":"/posts/jenkins/"},{"categories":["Jenkins"],"content":"安装 yum install java yum install git yum install nginx service nginx start wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key yum install jenkins --nogpgcheck service jenkins restart ","date":"2022-03-03","objectID":"/posts/jenkins/:2:0","tags":["Jenkins"],"title":"Jenkins入门","uri":"/posts/jenkins/"},{"categories":["Jenkins"],"content":"配置文件 ··· location /jenkins{ proxy_pass http://jenkins_ip:jenkins_port; proxy_redirect http:// https://; sendfile off; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_max_temp_file_size 0; } ··· vim /etc/sysconfig/jenkins 追加 ··· JENKINS_ARGS=\"--prefix=/jenkins\" ··· 修改配置文件生效 在修改过配置文件后,需要重新设定相应的权限Jenkins才可以正常运行,于是修改JENKINS_USER=\"jenkins\"为root JENKINS_USER=\"jenkins\" 重启服务 nginx -s reload service jenkins restart ","date":"2022-03-03","objectID":"/posts/jenkins/:3:0","tags":["Jenkins"],"title":"Jenkins入门","uri":"/posts/jenkins/"},{"categories":["Python"],"content":"selenium4.1新版更新 今天改点之前写的Selenium代码 但是发现都提示过期了,看了文档才知道selenium 4.1版本语法变了 记录一下新的语法 ","date":"2022-03-02","objectID":"/posts/selenium_update/:0:0","tags":["Selenium"],"title":"Selenium4.1新版","uri":"/posts/selenium_update/"},{"categories":["Python"],"content":"Service对象 首先在引入chromedriver部分发生了改变,需要声明Service对象 from selenium import webdriver import re import time from selenium.webdriver.common.by import By from selenium.webdriver.chrome.service import Service service = Service(executable_path=r\"E:\\Webdriver\\chromedriver\") option = webdriver.ChromeOptions() option.binary_location = r\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" option.add_argument(\"--lang=en-US\") option.add_experimental_option('w3c', True) browser = webdriver.Chrome(service=service, options=option) ","date":"2022-03-02","objectID":"/posts/selenium_update/:1:0","tags":["Selenium"],"title":"Selenium4.1新版","uri":"/posts/selenium_update/"},{"categories":["Python"],"content":"隐式等待 在看文档的过程发现了一个很棒的东西implicitly_wait(10),叫隐式等待,参数是时间,单位为秒 例如设定时间为10s,但并不是一直等待10s,当脚本执行到某个元素定位时,如果元素存在,则继续执行,如果定位不到元素,则将以轮询的方式不断的判断元素是否存在,假设在第6秒定位到了元素,则继续执行,若直到超过设定的时间10s还没有定位到元素,则抛出异常 ","date":"2022-03-02","objectID":"/posts/selenium_update/:2:0","tags":["Selenium"],"title":"Selenium4.1新版","uri":"/posts/selenium_update/"},{"categories":["Python"],"content":"定位元素 ","date":"2022-03-02","objectID":"/posts/selenium_update/:3:0","tags":["Selenium"],"title":"Selenium4.1新版","uri":"/posts/selenium_update/"},{"categories":["Python"],"content":"通过id browser.find_element(By.ID, 'username') ","date":"2022-03-02","objectID":"/posts/selenium_update/:3:1","tags":["Selenium"],"title":"Selenium4.1新版","uri":"/posts/selenium_update/"},{"categories":["Python"],"content":"通过class_name browser.find_element(By.CLASS_NAME, 'btn-submit') ","date":"2022-03-02","objectID":"/posts/selenium_update/:3:2","tags":["Selenium"],"title":"Selenium4.1新版","uri":"/posts/selenium_update/"},{"categories":["Python"],"content":"通过css browser.find_element(By.CSS_SELECTOR, '.pagination-info') ","date":"2022-03-02","objectID":"/posts/selenium_update/:3:3","tags":["Selenium"],"title":"Selenium4.1新版","uri":"/posts/selenium_update/"},{"categories":["Python"],"content":"通过LINK_TEXT browser.find_elements(By.LINK_TEXT, \"推送法务系统\") ","date":"2022-03-02","objectID":"/posts/selenium_update/:3:4","tags":["Selenium"],"title":"Selenium4.1新版","uri":"/posts/selenium_update/"},{"categories":["Python"],"content":"SQLAlchemy持续性断连 断连问题 发现了一个非常奇妙的事情 第一天接口数据都好好的,第二天就崩了 第二天重启接口又好好的,第三天就崩了 后来查了查,看了看文档才发现代码存在的几个问题 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:0:0","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"sqlalchemy的session回收机制 [官方文档](Connection Pooling — SQLAlchemy 1.4 Documentation) ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:1:0","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"悲观解决方式 在create_engine中添加参数pool_pre_ping=True 当连接数据库前,会进行一次预测试连接,如果先前的连接已失效,则申请连接池当前session ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:1:1","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"乐观解决方式 设置pool_recycle=3600当session超过3600秒后,自动被连接池收回 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:1:2","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"session的close机制 创建一个session，连接池会分配一个connection。 当session在使用后显示地调用 session.close()，也不能把这个连接关闭，而是由由QueuePool连接池管理并复用连接。 确保 session 在使用完成后用 session.close、session.commit 或 session.rollback 把连接还回 pool Session ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:2:0","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"关于 Session Session 其实 就是一个会话, 可以和数据库打交道的一个会话 在一般的意义上， 会话建立与数据库的所有对话，并为你在其生命周期中加载或关联的所有对象表示一个“等待区”。他提供了一个入口点获得查询对象， 向数据库发送查询，使用会话对象的当前数据库连接， 将结果行填充在对象中， 然后存储在会话中， 在这种结构中称为身份映射 – 这种数据结构维护了每一个副本的唯一， 这种唯一意味着一个对象只能有一个特殊的唯一主键。 会话以基本无状态的形式开始，一旦发出查询或其他对象被持久化，它就会从一个引擎申请连接资源，该引擎要么与会话本身相关联，要么与正在操作的映射对象相关联。此连接标识正在进行的事务， 在会话提交或回滚其挂起状态之前，该事务一直有效。 会话中维护的所有变化的对象都会被跟踪 - 在再次查询数据库或提交当前事务之前， 它将刷新对数据库的所有更改， 这被称为工作模式单元。 在使用会话时候，最重要的是要注意与它相关联的对象是会话所持有的事务的代理对象 - 为了保持同步，有各种各样的事件会导致对象重新访问数据库。可能从会话中分离对象并继续使用他们，尽管这种做法有其局限性。但是通常来说，当你希望再次使用分离的对象时候，你会将他们与另一个会话重新关联起来， 以便他们能够恢复表示数据库状态的正常任务。 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:3:0","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"Session是缓存吗？ 可能会将这里的session与http中的session搞混，需要注意的是，它有点用作缓存，因为它实现了 身份映射 模式，并存储了键入其主键的对象。但是，它不执行任何类型的查询缓存。 此外，默认情况下，Session使用弱引用存储对象实例。这也违背了将Session用作缓存的目的。关于session强应用下次再讨论。 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:3:1","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"Session作用： 1. session创建和管理数据库连接的会话 2. model object 通过session对象访问数据库，并把访问到的数据以 Identity Map的方式，映射到Model object中 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:3:2","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"Session生命周期： 1. session在刚被创建的时候，还没有和任何model object 绑定，可认为是无状态的 2. session 接受到query查询语句, 执行的结果或保持或者关联到session中 3. 任意数量的model object被创建，并绑定到session中，session会管理这些对象 4. 一旦session 里面的objects 有变化，那可是要commit/rollback提交或者放弃changs ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:3:3","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"Session什么时候创建，提交，关闭？ 一般来说，session在需要访问数据库的时候创建，在session访问数据库的时候，准确来说，应该是“add/update/delete”数据库的时候，会开启database transaction。 假设没有修改autocommit的默认值(False), 那么，database transaction 一直会保持，只有等到session发生rolled back、committed、或者closed的时候才结束，一般建议，当database transaction结束的时候，同时close session,以保证，每次发起请求，都会创建一个新的session 特别是对web应用来说，发起一个请求，若请求使用到Session访问数据库，则创建session，处理完这个请求后，关闭session ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:3:4","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"获取一个Session： Session 是一个直接实例化的常规的Python 类。然而， 为了标准会会话的配置和获取方式， sessionmaker 类通常用于创建顶级会话配置， 然后可以在整个应用程序中使用它， 就不需要重复配置参数。 下面是sessionmaker 的使用方式 from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker # 创建连接数据库的引擎，session连接数据库需要 my_engine = create_engine('mysql+pymysql://root:123456@localhost/my_db') # 创建一个配置过的Session类 Session = sessionmaker(bind=my_engine) # 实例化一个session db_session = Session() # 使用session myobject = MyObject('foo', 'bar') db_session.add(myobject) db_session.commit() 在上面，该**sessionmaker()创建了一个工厂类，在创建这个工厂类时我们配置了参数绑定了引擎。将其赋值给Session。每次实例化Session都会创建一个绑定了引擎的Session。**这样这个session在访问数据库时都会通过这个绑定好的引擎来获取连接资源 当你编写应用程序时， 请将sessionmaker 工厂放在全局级别，视作应用程序配置的一部分。例如：应用程序包中有三个.py文件，您可以将该sessionmaker行放在__init__.py文件中; 在其他模块“from mypackage import Session”。这样，所有的Session()的配置都由该配置中心控制。 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:3:5","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"关于SQLAlchemy 的 create_engine： 直接只用 create_engine 时，就会创建一个带连接池的引擎： my_engine = create_engine('mysql+pymysql://root:123456@localhost/my_db') 创建一个session，连接池会分配一个connection。当session在使用后显示地调用 session.close()，也不能把这个连接关闭，而是由由QueuePool连接池管理并复用连接。 确保 session 在使用完成后用 session.close、session.commit 或 session.rollback 把连接还回 pool，这是一个必须在意的习惯。 关于SQLAlchemy 数据库连接池： session 和 connection 不是相同的东西， session 使用连接来操作数据库，一旦任务完成 session 会将数据库 connection 交还给 pool。 在使用 create_engine 创建引擎时，如果默认不指定连接池设置的话，一般情况下，SQLAlchemy 会使用一个 QueuePool 绑定在新创建的引擎上。并附上合适的连接池参数 create_engine() 函数和连接池相关的参数有： pool_recycle, 默认为 -1, 推荐设置为 7200, 即如果 connection 空闲了 7200 秒，自动重新获取，以防止 connection 被 db server 关闭。 pool_size=5, 连接数大小，默认为 5，正式环境该数值太小，需根据实际情况调大 max_overflow=10, 超出 pool_size 后可允许的最大连接数，默认为 10, 这 10 个连接在使用过后，不放在 pool 中，而是被真正关闭的。 pool_timeout=30, 获取连接的超时阈值，默认为 30 秒 SQLAlchemy不使用连接池： 在创建引擎时指定参数 poolclass=NullPool 即禁用了SQLAlchemy提供的数据库连接池。SQLAlchemy 就会在执行 session.close() 后立刻断开数据库连接。当然，如果没有被调用 session.close()，则数据库连接不会被断开，直到程序终止。 my_engine = create_engine('mysql+pymysql://root:123456@localhost/my_db'，poolclass=NullPool) 关于 SQLAlchemy 的 engine ,这里有一篇文章写的很好：http://sunnyingit.github.io/book/section_python/SQLalchemy-engine.html ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:3:6","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"关于线程安全： session不是线程安全的，在多线程的环境中，默认情况下，多个线程将会共享同一个session。试想一下，假设A线程正在使用session处理数据库，B线程已经执行完成，把session给close了，那么此时A在使用session就会报错，怎么避免这个问题？ 1. 可以考虑在这些线程之间共享Session及其对象。但是应用程序需要确保实现正确的锁定方案，以便多个线程不会同时访问Session或其状态。SQLAlchemy 中的 scoped_session 就可以证线程安全，下面会有讨论。 2. 为每个并发线程维护一个会话，而不是将对象从一个Session复制到另一个Session，通常使用Session.merge()方法将对象的状态复制到一个不同Session的新的本地对象中。 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:3:7","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"单线程下 scoped_session 对创建 Session 的影响 上面简单介绍了sessionmaker的作用，下面开始探讨 scoped_session 对创建 Session 的影响。现在先探讨单线程情况。 先声明待会实验用的模型： from sqlalchemy.ext.declarative import declarative_base from sqlalchemy import Column, Integer, String from sqlalchemy import create_engine Base = declarative_base engine = create_engine(\"mysql+pymysql://root:123456@127.0.0.1:3306/my_db?charset=utf8mb4\") class Person(Base): __tablename__ = 'Person' id = Column(Integer, primary_key=True, autoincrement=True) name = Column(String(length=64), comment='姓名') mobile = Column(String(length=13), comment='手机号') id_card_number = Column(String(length=64), comment='身份证') def __str__(self): return '%s(name=%r,mobile=%r,id_card_number=%r)' % ( self.__class__.__name__, self.name, self.mobile, self.id_card_number ) # 在数据库中创建模型对象的表 Base.metadata.create_all(engine) ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:4:0","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"两个 Session 添加同一个对象 在 commit 之前添加： from sqlalchemy.orm import sessionmaker, scoped_session session_factory = sessionmaker(bind=engine) # engine 在上面已经创建好了 person = Person(name='frank-' + 'job3', mobile='111111', id_card_number='123456789') Session= session_factory() s1= session_factory() # s1 : \u003csqlalchemy.orm.session.Session object at 0x107ec8c18\u003e s2 = session_factory() # s2 : \u003csqlalchemy.orm.session.Session object at 0x107ee3ac8\u003e print(s1 is s2) # False id(s1),id(s2) # 4427910168, 4428020424 s1.add(person) s2.add(person) # 会报错！ # sqlalchemy.exc.InvalidRequestError: Object '\u003cPerson at 0x22beb14bf60\u003e' is already attached to session '2' (this is '3') 结论： 通过 sessionmaker 工厂创建了两个 Session ，而且可以看到 s1 s2 是两个不同的 Session 。 在 s1 添加 person 后，继续使用 s2 添加 person 报错. 说 person 这个对象 已经和 另一个 Session 关联一起来了, 所以再次关联另一个 Session 就会报错。 在 commit 之后添加： 即在上面代码的 s1.add(person) 之后， s1.commit() ,然后再 s2.add(persion) 这里就没帖代码了。 结论： 即使在 s1 提交之后，s2 再去添加 person 也会发生错误,但 s1 的提交是成功了的，数据 person 已经存放在数据库了。 当 s1 添加 person 并提交，然后关闭 s1 ,s2再去添加并提交 person 数据库,这不会报错，但是数据库也不会出现两条 person 数据。 再 close 之后添加： p = Person(name='frank', mobile='11111111', id_card_number='123456789') s1.add(p) s1.commit() s2.add(p) s2.commit() # 也会报错！！！ # sqlalchemy.exc.InvalidRequestError: Object '\u003cPerson at 0x21207e3e128\u003e' is already attached to session '2' (this is '3') p = Person(name='frankcc', mobile='1111111122', id_card_number='1234567890') s1.add(p) s1.commit() s1.close() s2.add(p) s2.commit() # 不会报错 结论： s1 关闭之后， s2再去添加提交同一个对象，不会报错，但是数据库值有一条 person 数据。 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:4:1","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"不同的 Session 添加不同的对象 person4 = Person(name='frank-' + 'job4', mobile='4444444444', id_card_number='123456789') person1 = Person(name='frank-' + 'job1', mobile='111111', id_card_number='123456789') s1.add(person1) s2.add(person4) s1.commit() # 提交数据 s2.commit() # 提交数据, 写入数据库 结论： 当然，s1 ,s2 添加提交不同的对象，不会出错。在数据库成功新增数据。 mysql\u003e select * from person; +----+------------+------------+----------------+ | id | name | mobile | id_card_number | +----+------------+------------+----------------+ | 1 | frank-job1 | 111111 | 123456789 | | 2 | frank-job4 | 4444444444 | 123456789 | +----+------------+------------+----------------+ 2 rows in set (0.00 sec) 以上说明： 一个对象一旦被一个 Session 添加，除非关闭这个 Session ，不然其他的 Session 无法添加这个对象。 一个 Session 添加并提交一个对象，然后关闭该 Session ，其他的 Session 可以添加并提交这个对象，但是数据库并不会有这条数据。 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:4:2","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"用 scoped_session 创建 Session session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) s1 = Session() # \u003csqlalchemy.orm.session.Session object at 0x0000020E58690240\u003e s2 = Session() # \u003csqlalchemy.orm.session.Session object at 0x0000020E58690240\u003e print(s1 is s2) # True p = Person(name='frankaaabb', mobile='1111111122233', id_card_number='12345678900099') s1.add(p) s2.add(p) s2.commit() 结论： 可以看到，通过scoped_session再去创建 Session ，返回的是同一个 Session 。 scoped_session类似单例模式，当我们调用使用的时候，会先在Registry里找找之前是否已经创建Session，未创建则创建 Session ，已创建则直接返回。 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:4:3","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"多线程下 scoped_session 对创建 Session 的影响 这里探讨在多线程下使用 scoped_session 与不使用 scoped_session 的情况 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:5:0","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"当不用 scoped_session 时： 当不使用 scoped_session 时，也分两种情况，是否创建全局性 Session 多线程下不设置 Session 为全局变量 session_factory = sessionmaker(bind=engine) Session = session_factory def job(name): session = Session() print(f\"id session:{id(session)}\") person = Person(name='frank-' + name, mobile='111111', id_card_number='123456789') print(f\"{name}person is add..\") session.add(person) time.sleep(1) if name == 'job3': # 线程3 提交, 其他线程不提交. session.commit() session.close() if __name__ == '__main__': thread_list = [] # 创建5个线程 for i in range(5): name = 'job' + str(i) t = threading.Thread(target=job, name=name, args=(name,)) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join() 结论： 每个线程下的 Session 都是不同的 Session 数据库成功新增了线程3提交的数据，其他的线程中的数据并没有提交到数据库中去。 id session:2557871997392 job0 person is add.. id session:2557871998064 job1 person is add.. id session:2557871998568 job2 person is add.. id session:2557871999072 job3 person is add.. id session:2557871999688 job4 person is add.. mysql\u003e select * from person; +----+------------+--------+----------------+ | id | name | mobile | id_card_number | +----+------------+--------+----------------+ | 14 | frank-job3 | 111111 | 123456789 | +----+------------+--------+----------------+ 1 row in set (0.00 sec) 在多线程下用全局 Session session_factory = sessionmaker(bind=engine) Session = session_factory session = Session() def job(name): global session print(f\"id session:{id(session)}\") person = Person(name='frank-' + name, mobile='111111', id_card_number='123456789') print(f\"{name}person is add..\") session.add(person) time.sleep(1) if name == 'job3': # 线程3 提交, 其他线程不提交. session.commit() session.close() if __name__ == '__main__': thread_list = [] # 创建5个线程 for i in range(5): name = 'job' + str(i) t = threading.Thread(target=job, name=name, args=(name,)) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join() 结论： 全部线程下的 Session 都时同一个 Session 每个线程下的数据都被提交到了数据库 id session:2737857674824 job0 person is add.. id session:2737857674824 job1 person is add.. id session:2737857674824 job2 person is add.. id session:2737857674824 job3 person is add.. id session:2737857674824 job4 person is add.. mysql\u003e select * from person; +----+------------+--------+----------------+ | id | name | mobile | id_card_number | +----+------------+--------+----------------+ | 15 | frank-job0 | 111111 | 123456789 | | 16 | frank-job2 | 111111 | 123456789 | | 17 | frank-job1 | 111111 | 123456789 | | 18 | frank-job3 | 111111 | 123456789 | | 19 | frank-job4 | 111111 | 123456789 | +----+------------+--------+----------------+ 5 rows in set (0.00 sec) ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:5:1","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"当使用 scoped_session 时： 多线程下不设置 Session 为全局变量 session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) def job(name): session = Session() print(f\"id session:{id(session)}\") person = Person(name='frank-' + name, mobile='111111', id_card_number='123456789') print(f\"{name}person is add..\") session.add(person) time.sleep(1) if name == 'job3': # 线程3 提交, 其他线程不提交. session.commit() session.close() if __name__ == '__main__': thread_list = [] # 创建5个线程 for i in range(5): name = 'job' + str(i) t = threading.Thread(target=job, name=name, args=(name,)) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join() 结论： 每个线程下的 Session 都不相同 只有线程3下的数据被提交到了数据库 id session:2173841850832 job0 person is add.. id session:2173841851504 job1 person is add.. id session:2173841851896 job2 person is add.. id session:2173841852008 job3 person is add.. id session:2173841853128 job4 person is add.. mysql\u003e select * from person; +----+------------+--------+----------------+ | id | name | mobile | id_card_number | +----+------------+--------+----------------+ | 32 | frank-job3 | 111111 | 123456789 | +----+------------+--------+----------------+ 1 row in set (0.00 sec) 多线程下设置 Session 为全局变量 session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() def job(name): global session print(f\"id session:{id(session)}\") person = Person(name='frank-' + name, mobile='111111', id_card_number='123456789') print(f\"{name}person is add..\") session.add(person) time.sleep(1) if name == 'job3': # 线程3 提交, 其他线程不提交. session.commit() session.close() if __name__ == '__main__': thread_list = [] # 创建5个线程 for i in range(5): name = 'job' + str(i) t = threading.Thread(target=job, name=name, args=(name,)) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join() 结论： 每个线程下的 Session 是同一个 Session 每个线程下的数据都没提交到了数据库 id session:2810724382032 job0 person is add.. id session:2810724382032 job1 person is add.. id session:2810724382032 job2 person is add.. id session:2810724382032 job3 person is add.. id session:2810724382032 job4 person is add.. mysql\u003e select * from person; +----+------------+--------+----------------+ | id | name | mobile | id_card_number | +----+------------+--------+----------------+ | 33 | frank-job0 | 111111 | 123456789 | | 34 | frank-job2 | 111111 | 123456789 | | 35 | frank-job1 | 111111 | 123456789 | | 36 | frank-job3 | 111111 | 123456789 | | 37 | frank-job4 | 111111 | 123456789 | +----+------------+--------+----------------+ 5 rows in set (0.00 sec) 以上说明： 在同一个线程中，有 scoped_session 的时候，返回的是同一个 Session 对象。 在多线程下，即使通过 scoped_session 创建Session，每个线程下的 Session 都是不一样的，每个线程都有一个属于自己的 Session 对象，这个对象只在本线程下共享。 scoped_session 只有在单线程下才能发挥其作用。在多线程下显得没有什么作用。 ","date":"2022-03-01","objectID":"/posts/python_SQL-3/:5:2","tags":["SQLAlchemy"],"title":"SQLAlchemy断连","uri":"/posts/python_SQL-3/"},{"categories":["Python"],"content":"定时任务框架的使用 安装 pip install apscheduler 基本概念介绍 触发器（triggers）：触发器包含调度逻辑，描述一个任务何时被触发，按日期或按时间间隔或按 cronjob 表达式三种方式触发。每个作业都有它自己的触发器，除了初始配置之外，触发器是完全无状态的。 作业存储器（job stores）：作业存储器指定了作业被存放的位置，默认情况下作业保存在内存，也可将作业保存在各种数据库中，当作业被存放在数据库中时，它会被序列化，当被重新加载时会反序列化。作业存储器充当保存、加载、更新和查找作业的中间商。在调度器之间不能共享作业存储。 执行器（executors）：执行器是将指定的作业（调用函数）提交到线程池或进程池中运行，当任务完成时，执行器通知调度器触发相应的事件。 调度器（schedulers）：任务调度器，属于控制角色，通过它配置作业存储器、执行器和触发器，添加、修改和删除任务。调度器协调触发器、作业存储器、执行器的运行，通常只有一个调度程序运行在应用程序中，开发人员通常不需要直接处理作业存储器、执行器或触发器，配置作业存储器和执行器是通过调度器来完成的。 任务实例 ","date":"2022-02-11","objectID":"/posts/apschedule/:0:0","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"间隔性任务 from apscheduler.schedulers.blocking import BlockingScheduler def tick(): print('Tick! The time is: %s' % datetime.now()) if __name__ == '__main__': scheduler = BlockingScheduler() scheduler.add_job(tick, 'interval', seconds=3) print('Press Ctrl+{0}to exit'.format('Break' if os.name == 'nt' else 'C ')) try: scheduler.start() except (KeyboardInterrupt, SystemExit): pass 导入调度器模块 BlockingScheduler，这是最简单的调度器，调用 start 方阻塞当前进程 如果程序只用于调度，除了调度进程外没有其他后台进程，那么请用 BlockingScheduler 非常有用，此时调度进程相当于守护进程。 ","date":"2022-02-11","objectID":"/posts/apschedule/:1:0","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"cron 任务 from apscheduler.schedulers.blocking import BlockingScheduler def tick(): print('Tick! The time is: %s' % datetime.now()) if __name__ == '__main__': scheduler = BlockingScheduler() scheduler.add_job(tick, 'cron', hour=19,minute=23) try: scheduler.start() except (KeyboardInterrupt, SystemExit): pass 定时 cron任务非常简单，直接给触发器 trigger 传入 cron 即可。hour =19 ,minute =23 这里表示每天的19：23 分执行任务。这里可以填写数字，也可以填写字符串 hour =19 , minute =23 hour ='19', minute ='23' minute = '*/3' 表示每 5 分钟执行一次 hour ='19-21', minute= '23' 表示 19:23、 20:23、 21:23 各执行一次任务 配置调度器 调度器的主循环其实就是反复检查是不是有到时需要执行的任务，分以下几步进行： 询问自己的每一个作业存储器，有没有到期需要执行的任务，如果有，计算这些作业中每个作业需要运行的时间点，如果时间点有多个，做 coalesce 检查。 提交给执行器按时间点运行。 各调度器的适用场景： BlockingScheduler：适用于调度程序是进程中唯一运行的进程，调用start函数会阻塞当前线程，不能立即返回。 BackgroundScheduler：适用于调度程序在应用程序的后台运行，调用start后主线程不会阻塞。 AsyncIOScheduler：适用于使用了asyncio模块的应用程序。 GeventScheduler：适用于使用gevent模块的应用程序。 TwistedScheduler：适用于构建Twisted的应用程序。 QtScheduler：适用于构建Qt的应用程序。 上述调度器可以满足我们绝大多数的应用环境，本文以两种调度器为例说明如何进行调度器配置。 作业存储器的选择有两种： 一是内存，也是默认的配置；二是数据库 具体选哪一种看我们的应用程序在崩溃时是否重启整个应用程序，如果重启整个应用程序，那么作业会被重新添加到调度器中，此时简单的选取内存作为作业存储器即简单又高效。但是，当调度器重启或应用程序崩溃时您需要您的作业从中断时恢复正常运行，那么通常我们选择将作业存储在数据库中 执行器的选择也取决于应用场景。通常默认的 ThreadPoolExecutor 已经足够好。如果作业负载涉及CPU 密集型操作，那么应该考虑使用 ProcessPoolExecutor，甚至可以同时使用这两种执行器，将ProcessPoolExecutor 行器添加为二级执行器。 apscheduler 提供了许多不同的方法来配置调度器。可以使用字典，也可以使用关键字参数传递。首先实例化调度程序，添加作业，然后配置调度器，获得最大的灵活性。 配置示例 配置名为“mongo”的MongoDBJobStore作业存储器 配置名为“default”的SQLAlchemyJobStore(使用SQLite) 配置名为“default”的ThreadPoolExecutor，最大线程数为20 配置名为“processpool”的ProcessPoolExecutor，最大进程数为5 UTC作为调度器的时区 coalesce默认情况下关闭 作业的默认最大运行实例限制为3 from pytz import utc from apscheduler.schedulers.background import BackgroundScheduler from apscheduler.jobstores.mongodb import MongoDBJobStore from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor jobstores = { 'default': SQLAlchemyJobStore(url='sqlite:///jobs.sqlite'), 'shit': MongoDBJobStore() } executors = { 'default': ThreadPoolExecutor(20), 'shit': ProcessPoolExecutor(5) } job_defaults = { 'coalesce': False, 'max_instances': 3 } scheduler = BackgroundScheduler(jobstores=jobstores,executors=executors,job_defaults=job_defaults,timezone=utc) ","date":"2022-02-11","objectID":"/posts/apschedule/:2:0","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"增加任务add_job 文档的参数描述 add_job(func, trigger=None, args=None, kwargs=None, id=None, name=None, misfire_grace_time=undefined, coalesce=undefined, max_instances=undefined, next_run_time=undefined, jobstore=‘default’, executor=‘default’, replace_existing=False, **trigger_args) scheduler.add_job(func_name, trigger, args=[...], id=\"this_is_id\", jobstore=\"shit\", # 使用先前声明中存在的配置 executor=\"shit\" # 使用先前声明中存在的配置 ) ","date":"2022-02-11","objectID":"/posts/apschedule/:3:0","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"触发器类型 trigger types: date: use when you want to run the job just once at a certain point of time interval: use when you want to run the job at fixed intervals of time cron: use when you want to run the job periodically at certain time(s) of day 时间设定 ","date":"2022-02-11","objectID":"/posts/apschedule/:4:0","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"corn定时调度 (int|str) 表示参数既可以是int类型，也可以是str类型 (datetime | str) 表示参数既可以是datetime类型，也可以是str类型 year (int|str) – 4-digit year -（表示四位数的年份，如2008年） month (int|str) – month (1-12) -（表示取值范围为1-12月） day (int|str) – day of the (1-31) -（表示取值范围为1-31日） week (int|str) – ISO week (1-53) -（格里历2006年12月31日可以写成2006年-W52-7（扩展形式）或2006W527（紧凑形式）） day_of_week (int|str) – number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) - （表示一周中的第几天，既可以用0-6表示也可以用其英语缩写表示） hour (int|str) – hour (0-23) - （表示取值范围为0-23时） minute (int|str) – minute (0-59) - （表示取值范围为0-59分） second (int|str) – second (0-59) - （表示取值范围为0-59秒） start_date (datetime|str) – earliest possible date/time to trigger on (inclusive) - （表示开始时间） end_date (datetime|str) – latest possible date/time to trigger on (inclusive) - （表示结束时间） timezone (datetime.tzinfo|str) – time zone to use for the date/time calculations (defaults to scheduler timezone) -（表示时区取值） ","date":"2022-02-11","objectID":"/posts/apschedule/:5:0","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"示例 #表示2017年3月22日17时19分07秒执行该程序 sched.add_job(my_job, 'cron', year=2017,month = 03,day = 22,hour = 17,minute = 19,second = 07) #表示任务在6,7,8,11,12月份的第三个星期五的00:00,01:00,02:00,03:00 执行该程序 sched.add_job(my_job, 'cron', month='6-8,11-12', day='3rd fri', hour='0-3') #表示从星期一到星期五5:30（AM）直到2014-05-30 00:00:00 sched.add_job(my_job(), 'cron', day_of_week='mon-fri', hour=5, minute=30,end_date='2014-05-30') #表示每5秒执行该程序一次，相当于interval 间隔调度中seconds = 5 sched.add_job(my_job, 'cron',second = '*/5') ","date":"2022-02-11","objectID":"/posts/apschedule/:5:1","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"interval间隔调度 weeks (int) – number of weeks to wait days (int) – number of days to wait hours (int) – number of hours to wait minutes (int) – number of minutes to wait seconds (int) – number of seconds to wait start_date (datetime|str) – starting point for the interval calculation end_date (datetime|str) – latest possible date/time to trigger on timezone (datetime.tzinfo|str) – time zone to use for the date/time calculations ","date":"2022-02-11","objectID":"/posts/apschedule/:6:0","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"示例 #表示每隔3天17时19分07秒执行一次任务 sched.add_job(my_job, 'interval',days = 03,hours = 17,minutes = 19,seconds = 07) ","date":"2022-02-11","objectID":"/posts/apschedule/:6:1","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"date 定时调度（作业只会执行一次) run_date (datetime|``str``) – the date``/``time to run the job at ``-``（任务开始的时间） timezone (datetime.tzinfo|``str``) – time zone ``for` `run_date ``if` `it doesn’t have one already ","date":"2022-02-11","objectID":"/posts/apschedule/:7:0","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"示例 # The job will be executed on November 6th, 2009 sched.add_job(my_job, 'date', run_date=date(2009, 11, 6), args=['text']) # The job will be executed on November 6th, 2009 at 16:30:05 sched.add_job(my_job, 'date', run_date=datetime(2009, 11, 6, 16, 30, 5), args=['text']) 常见问题 job_defaults = { 'coalesce': True, 'misfire_grace_time': None } scheduler = BackgroundScheduler(job_defaults=job_defaults) # 全局设置misfire_grace_time # 或者 scheduler.add_job(……, misfire_grace_time=None, coalesce=True) # 对单个任务设置 misfire_grace_time ​ 每个任务都有一个misfire_grace_time，单位：秒，默认是0秒。意思是 那些错过的任务在有条件执行时（有线程空闲出来/服务已恢复），如果还没有超过misfire_grace_time，就会被再次执行。如果misfire_grace_time=None，就是不论任务错过了多长时间，都会再次执行。 原文： misfire_grace_time: seconds after the designated runtime that the job is still allowed to be run (or None to allow the job to run no matter how late it is) ​ 如果有个任务C是每2分钟执行一次的周期性任务，且设置了较长misfire_grace_time ,结果服务停了10分钟，10分钟后服务恢复，那么错过的5个任务C都会执行。这种情况下，如果你只想执行1个任务C，可以设置coalesce = True。 立即执行 To add a job to be run immediately: # The 'date' trigger and datetime.now() as run_date are implicit sched.add_job(my_job, args=['text']) ","date":"2022-02-11","objectID":"/posts/apschedule/:7:1","tags":["APScheduler"],"title":"APScheduler的使用","uri":"/posts/apschedule/"},{"categories":["Python"],"content":"Python Generator ","date":"2022-02-11","objectID":"/posts/yield/:0:0","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"1.生成器 在 Python 中，一边循环一边计算的机制，称为生成器（Generator）； 生成器是一个返回迭代器的函数，只能用于迭代操作； ","date":"2022-02-11","objectID":"/posts/yield/:1:0","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"2.什么是生成器函数 生成器是Python中的一个对象，对这个对象进行操作，可以依次生产出按生成器内部运算产生的数据； 生成器函数指的是函数体中包含yield关键字的函数（yield就是专门给生成器用的return）； 生成器可以通过生成器表达式和生成器函数获取到； ","date":"2022-02-11","objectID":"/posts/yield/:2:0","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"生成器语法 ","date":"2022-02-11","objectID":"/posts/yield/:3:0","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"生成器表达式 通列表解析语法，只不过把列表解析的[]换成() 生成器表达式能做的事情列表解析基本都能处理，只不过在需要处理的序列比较大时，列表解析比较费内存。 \u003e\u003e\u003e gen = (x**2 for x in range(5)) \u003e\u003e\u003e gen \u003cgenerator object \u003cgenexpr\u003e at 0x0000000002FB7B40\u003e \u003e\u003e\u003e for g in gen: ... print(g, end='-') ... 0-1-4-9-16- \u003e\u003e\u003e for x in [0,1,2,3,4,5]: ... print(x, end='-') ... 0-1-2-3-4-5- ","date":"2022-02-11","objectID":"/posts/yield/:3:1","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"生成器函数 在函数中如果出现了yield关键字，那么该函数就不再是普通函数，而是生成器函数。 但是生成器函数可以生产一个无线的序列，这样列表根本没有办法进行处理。 yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator def odd(): n=1 while True: yield n n+=2 odd_num = odd() count = 0 for o in odd_num: if count \u003e=5: break print(o) count +=1 ","date":"2022-02-11","objectID":"/posts/yield/:3:2","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"send() 生成器函数最大的特点是可以接受外部传入的一个变量，并根据变量内容计算结果后返回。 def gen(): value=0 while True: receive = yield value if receive == 'e': break value = 'got: %s' % receive g=gen() print(g.send(None)) print(g.send('aaa')) print(g.send(3)) print(g.send('e')) 输出 \"\"\" 1. 通过g.send(None)或者next(g)可以启动生成器函数，并执行到第一个yield语句结束的位置。 此时，执行完了yield语句，但是没有给receive赋值。 yield value会输出初始值0 注意：在启动生成器函数时只能send(None),如果试图输入其它的值都会得到错误提示信息。 2. 通过g.send('aaa')，会传入aaa，并赋值给receive，然后计算出value的值，并回到while头部，执行yield value语句有停止。 此时yield value会输出\"got: aaa\"，然后挂起。 3. 通过g.send(3)，会重复第2步，最后输出结果为\"got: 3\" 4. 当我们g.send('e')时，程序会执行break然后推出循环，最后整个函数执行完毕，所以会得到StopIteration异常。 最后的执行结果如下： \"\"\" 0 got: aaa got: 3 Traceback (most recent call last): File \"h.py\", line 14, in \u003cmodule\u003e print(g.send('e')) StopIteration ","date":"2022-02-11","objectID":"/posts/yield/:3:3","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"throw() 用来向生成器函数送入一个异常，可以结束系统定义的异常，或者自定义的异常。 throw()后直接跑出异常并结束程序，或者消耗掉一个yield，或者在没有下一个yield的时候直接进行到程序的结尾。 def gen(): while True: try: yield 'normal value' yield 'normal value 2' print('here') except ValueError: print('we got ValueError here') except TypeError: break g=gen() print(next(g)) print(g.throw(ValueError)) print(next(g)) print(g.throw(TypeError)) 输出 \"\"\" 1. print(next(g))：会输出normal value，并停留在yield 'normal value 2'之前。 2. 由于执行了g.throw(ValueError)，所以会跳过所有后续的try语句，也就是说yield 'normal value 2'不会被执行，然后进入到except 语句，打印出we got ValueError here。 3. 然后再次进入到while语句部分，消耗一个yield，所以会输出normal value。 4. print(next(g))，会执行yield 'normal value 2'语句，并停留在执行完该语句后的位置。 5. g.throw(TypeError)：会跳出try语句，从而print('here')不会被执行，然后执行break语句，跳出while循环，然后到达程序结尾，所 以跑出StopIteration异常。 \"\"\" normal value we got ValueError here normal value normal value 2 Traceback (most recent call last): File \"h.py\", line 15, in \u003cmodule\u003e print(g.throw(TypeError)) StopIteration ","date":"2022-02-11","objectID":"/posts/yield/:3:4","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"yield from yield产生的函数就是一个迭代器，所以我们通常会把它放在循环语句中进行输出结果。 有时候我们需要把这个yield产生的迭代器放在另一个生成器函数中，也就是生成器嵌套。 比如下面的例子： def inner(): for i in range(10): yield i def outer(): g_inner=inner() #这是一个生成器 while True: res = g_inner.send(None) yield res g_outer=outer() while True: try: print(g_outer.send(None)) except StopIteration: break 此时，我们可以采用yield from语句来减少我么你的工作量。 def outer2(): yield from inner() ","date":"2022-02-11","objectID":"/posts/yield/:3:5","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"3.生成器函数的定义 def add(): for i in range(10): yield i g = add() print(g) # \u003cgenerator object add at 0x10f6110f8\u003e print(next(g)) # 0 print(next(g)) # 1 我们可以通过yield关键字来定义一个生成器函数，这个生成器函数返回值就是一个生成器对象； ","date":"2022-02-11","objectID":"/posts/yield/:4:0","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"4.生成器函数的调用 def gen(): print('111111') yield '111111' print('222222') yield '222222' print('333333') yield '333333' g = gen() print(g) # \u003cgenerator object gen at 0x0026BBF0\u003e next(g) # 111111 next(g) # 222222 next(g) # 333333 next(g, 'over') 生成器函数可以使用next()迭代，且每次next()只会返回一次yield的值，然后暂停，下次一次next()时会在当前位置继续，如果没有元素可以迭代了，还 执在行next()则需要给定一个默认值，不给默认值会报错； 如果在生成器函数中使用return，则会终止迭代，且不能得到返回值； def gen(): print('111111') yield '111111' print('222222') return '222222' print('333333') yield '333333' g = gen() print(g) # \u003cgenerator object gen at 0x0026BBF0\u003e next(g) # 111111 next(g) # 222222, 抛出异常 ","date":"2022-02-11","objectID":"/posts/yield/:5:0","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"5.生成器函数的使用场景 # 死循环 def way(): i = 0 while True: i += 1 yield i c = way() print(next(c)) # 1 print(next(c)) # 2 print(next(c)) # 3 print(next(c)) # 4 print(next(c)) # 5 在生成器中使用死循环，不会一直执行，仍旧是执行多少次next()，返回多少个值； ","date":"2022-02-11","objectID":"/posts/yield/:6:0","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"6.生成器函数中的语法糖 # 普通生成器函数way1 def way1(): for i in range(5): yield i # 带语法糖的生成器函数way2 def way2(): yield from range(5) #循环输出way1 for i in way1(): print(i) #0 1 2 3 4 #循环输出way2 for j in way2(): print(j) #0 1 2 3 4 ","date":"2022-02-11","objectID":"/posts/yield/:7:0","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Python"],"content":"生成器的实例 def eat(name): print('%sready to eat' % name) food_list = [] while True: food = yield food_list # food='骨头' food_list.append(food) # food_list=['泔水','骨头'] print('%sstart to eat %s' % (name, food)) dog1 = eat('alex') # 1、必须初始化一次，让函数停在yield的位置 res0 = dog1.__next__() print(res0) # 接下来的事，就是喂狗,send有两方面的功能 # 1、给yield传值 # 2、同__next__的功能 res1 = dog1.send('泔水') print(res1) res2 = dog1.send('骨头') print(res2) res3 = dog1.send('shit') print(res3) \"\"\"控制台打印 alex ready to eat [] alex start to eat 泔水 ['泔水'] alex start to eat 骨头 ['泔水', '骨头'] alex start to eat shit ['泔水', '骨头', 'shit'] \"\"\" ","date":"2022-02-11","objectID":"/posts/yield/:8:0","tags":["Python基础语法"],"title":"yield的用法","uri":"/posts/yield/"},{"categories":["Vue"],"content":"Vue + TS + element-plus + Vite 搭建管理项目 前言: 由于平台新存储了大量接口取来的数据,因此需要搭建一个数据管理平台 前端在技术上硬着头皮选了Vue3和TS 经过几天的emotional damage终于算入一点门了 开个专题在这里记录一下学习(踩坑)经历 本项目使用element-plus+vue3+typescript+vite搭建 使用element-plus ","date":"2022-02-10","objectID":"/posts/vue-2/:0:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"npm安装 npm install element-plus --save ","date":"2022-02-10","objectID":"/posts/vue-2/:1:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"main.ts import ElementPlus from \"element-plus\"; import \"element-plus/dist/index.css\"; import * as Icons from \"@element-plus/icons-vue\"; const app = createApp(App); app.use(ElementPlus); app.use(router).mount(\"#app\"); // 全局引入element-plus icon Object.keys(Icons).forEach((key) =\u003e { app.component(key, Icons[key as keyof typeof Icons]); }); ","date":"2022-02-10","objectID":"/posts/vue-2/:2:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"组件使用 ","date":"2022-02-10","objectID":"/posts/vue-2/:3:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"首页搭建 首页由header,navbar,router-viewer三部分构成 使用element-plus的el-menu和el-row创建navbar和header ","date":"2022-02-10","objectID":"/posts/vue-2/:3:1","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"index页面引入navbar和header 利用element-plus的容器el-container来布局 \u003ctemplate\u003e \u003cel-container style=\"height: 100%; border: 1px solid #eee\"\u003e \u003cel-header height=\"85px\" style=\"background-color:#F5F5F5;\"\u003e \u003ccom_header\u003e\u003c/com_header\u003e \u003c/el-header\u003e \u003cel-container\u003e \u003cel-aside width=\"230px\" style=\"background-color:#F5F5F5\"\u003e \u003ccom_navbar\u003e\u003c/com_navbar\u003e \u003c/el-aside\u003e \u003cel-main\u003e \u003crouter-view/\u003e \u003c/el-main\u003e \u003c/el-container\u003e \u003c/el-container\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import com_navbar from '../components/com_navbar.vue' import com_header from '../components/com_header.vue' \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:3:2","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"父子组件传值 在编写一个显示数据的表格页面时,将table写到了一个组件中,并且在页面中引入了该组件 数据在页面中请求得到,需要赋值给子组件,出现了父子组件传值的问题 不得不说…vue的文档写的让我真是头大…感觉是给前端大佬看的,初学前端不适合看 其实实现起来很简单,只需要声明一个props,在我看来就是子组件暴露给外部的一个变量 子组件 \u003ctemplate\u003e \u003cel-table :data=\"props.tableData\" style=\"width: 100%\"\u003e ... \u003c/el-table\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e interface inter { zh_name: string; name: string; url: string; args: string; comment: string; request: string; } // 定义Props const props = defineProps\u003c{ tableData: Array\u003cinter\u003e; }\u003e(); // 通过 props.tableData 获取该变量的值 \u003c/script\u003e 父组件 \u003ctemplate\u003e \u003ccom_table v-model:tableData=\"fatherData\"\u003e\u003c/com_table\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import com_table from \"../../components/com_table.vue\"; import axios from \"axios\"; import { ref, } from \"vue\"; // 创建变量 const fatherData = ref([]); // 请求数据 function getdata(): any { axios .post(\"interface/get_list\") .then((res) =\u003e { fatherData.value = res.data; }) .catch((err) =\u003e { console.log(err); }); } getdata(); \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:3:3","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"icon使用变量定义 \u003cel-icon\u003e \u003ccomponent :is=\"item.icon\"\u003e\u003c/component\u003e \u003c/el-icon\u003e \u003cscript lang=\"ts\" setup\u003e语法糖 在vue中，sfc(单文件组件)指的是文件后缀名为.vue的特殊文件格式，它允许将 Vue 组件中的模板、逻辑 与 样式封装在单个文件中 ","date":"2022-02-10","objectID":"/posts/vue-2/:4:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"标准的sfc写法 在使用TS的情况下，标准的sfc需要借助defineComponent来进行类型推断 \u003ctemplate\u003e \u003cdiv\u003e parent{{count}} \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import { defineComponent } from 'vue' export default defineComponent({ setup() { return { // 暴露给template的属性  } } }) \u003c/script\u003e script setup的推出，目的是为了让开发者更高效率的开发组件，减少样板内容，减轻开发负担。仅仅需要给script标签添加一个setup属性，就能将script变成setup函数，同时定义的变量，函数，导入的组件都会默认暴露给模板 ","date":"2022-02-10","objectID":"/posts/vue-2/:5:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"暴露变量 ","date":"2022-02-10","objectID":"/posts/vue-2/:6:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"未使用语法糖 \u003cscript\u003e import { defineComponent, ref} from 'vue' export default defineComponent({ setup() { const count = ref(0) return { count } } }) \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:6:1","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"使用语法糖 \u003ctemplate\u003e \u003cdiv\u003e parent{{count}} \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import {ref} from 'vue' const count = ref(0) \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:6:2","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"组件挂载 ","date":"2022-02-10","objectID":"/posts/vue-2/:7:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"未使用语法糖 \u003ctemplate\u003e \u003cdiv\u003e parent \u003cchild /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import { defineComponent } from 'vue' import child from './childComponent' export default defineComponent({ components: { child }, setup() { // ...  } }) \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:7:1","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"使用语法糖 \u003ctemplate\u003e \u003cdiv\u003e parent \u003cchild /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import child from './childComponent' \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:7:2","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"Props ","date":"2022-02-10","objectID":"/posts/vue-2/:8:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"未使用语法糖 父组件 // parent.vue \u003ctemplate\u003e \u003cchild :count={count} /\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e impor {defineComponent,ref} from 'vue' import child from './childComponent' export default defineComponent({ components: { child }, setup() { const count = ref(0) return { count } } }) \u003c/script\u003e 子组件 // child.vue \u003ctemplate\u003e child{{count}} \u003c/template\u003e \u003cscript lang=\"ts\"\u003e impor {defineComponent} from 'vue' export default defineComponent({ props: ['count'], setup(props) { return {} } }) \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:8:1","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"使用语法糖 父组件 // parent.vue \u003ctemplate\u003e \u003cchild :count={count} /\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e impor {ref} from 'vue' import child from './childComponent' const count = ref\u003cnumber\u003e(0) \u003c/script\u003e 子组件 // child.vue \u003ctemplate\u003e child{{count}} \u003c/template\u003e \u003cscript setup\u003e defineProps(['count']) \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:8:2","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"props赋予默认值 withDefaults会对默认值进行类型检查 \u003cscript lang=\"ts\" setup\u003e interface d { name: string } interface Props { count: number; // Number要换成ts的语法  ---title: string; data: d; } const props = withDefaults(defineProps\u003cProps\u003e(), { count: 0, ---title: 'header', data: () =\u003e ({name: '王小二'}) }) \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:8:3","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"defineProps \u003ctemplate\u003e \u003ch1\u003e{{ msg }}\u003c/h1\u003e \u003cdiv @click=\"clickThis\"\u003e1111\u003c/div\u003e \u003c/template\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:9:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"ts专有声明-无默认值 \u003cscript setup lang=\"ts\"\u003e defineProps\u003c{ msg: string, num?: number }\u003e() \u003c/script\u003e // 多值传值 \u003cscript setup lang=\"ts\"\u003e defineProps\u003c{ title?: string, hello?: (string | number) }\u003e() \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:9:1","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"ts专有声明-有默认值 \u003cscript setup lang=\"ts\"\u003e interface Props { msg?: string labels?: string[] } const props = withDefaults(defineProps\u003cProps\u003e(), { msg: 'hello', labels: () =\u003e ['one', 'two'] }) \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:9:2","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"非ts专有声明 \u003cscript setup lang=\"ts\"\u003e defineProps({ // 非ts专有声明 msg: String, num: { type:Number, default: '' } }) \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:9:3","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"defineExpose 在标准组件写法里，子组件的数据都是默认隐式暴露给父组件的，但在 script-setup 模式下，所有数据只是默认 return 给 template 使用，不会暴露到组件外，所以父组件是无法直接通过挂载 ref 变量获取子组件的数据 如果要调用子组件的数据，需要先在子组件显示的暴露出来，才能够正确的拿到，这个操作，就是由 expose 来完成 defineExpose API 来实现 expose 的功能 ","date":"2022-02-10","objectID":"/posts/vue-2/:10:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"子组件暴露属性 \u003ctemplate\u003e \u003cdiv\u003e子组件helloword.vue\u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import { ref } from 'vue' const count = ref(123456) defineExpose({ count //暴露 count 变量 }) \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:10:1","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"父组件获取属性 \u003ctemplate\u003e \u003cdiv @click=\"helloClick\"\u003e父组件\u003c/div\u003e \u003chelloword ref=\"hello\"\u003e\u003c/helloword\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import { ref } from 'vue' import helloword from './components/HelloWorld.vue' const hello = ref(null) const helloClick = () =\u003e { console.log(hello.value.count) // 123456 } \u003c/script\u003e 父组件可以通过 ref API 去拿到子组件暴露出来的数据 通过ref=\"hello\"获得子组件实例 从而通过hello.value.count获取暴露的变量 ","date":"2022-02-10","objectID":"/posts/vue-2/:10:2","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"defineEmits ","date":"2022-02-10","objectID":"/posts/vue-2/:11:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"父组件 \u003ctemplate\u003e \u003cdiv \u003e \u003cpage_child @nextStep=\"father_click\"\u003e\u003c/page_child\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import page_child from '@/view/view_test/page_child.vue' const father_click = ($event: any) =\u003e { console.log($event); } \u003c/script\u003e ","date":"2022-02-10","objectID":"/posts/vue-2/:11:1","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"子组件 \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003e\u003cbutton @click=\"nextDown\"\u003e子按钮\u003c/button\u003e\u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e const emit= defineEmits(['nextStep']) const nextDown = () =\u003e { emit('nextStep',10) } \u003c/script\u003e vite启用跨域访问 ","date":"2022-02-10","objectID":"/posts/vue-2/:11:2","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // 查看文档 // https://cn.vitejs.dev/config export default defineConfig({ plugins: [vue()], server: { proxy: { '/api': { target: 'http://127.0.0.1:8080', changeOrigin: true, //rewrite: (path) =\u003e path.replace(/^\\/api/, '') }, } } }) 其中/api指向接口网址 使用alias:@路径 使用@路径会大大节省脑子,否则全是相对路径…人直接傻了 修改 vite.config.ts 和 tsconfig.json ","date":"2022-02-10","objectID":"/posts/vue-2/:12:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"vite.config.ts export default defineConfig({ plugins: [vue()], alias:{ '@':'/src/', '@components':'/src/components/', '@assets':'/src/assets/', } }) ","date":"2022-02-10","objectID":"/posts/vue-2/:13:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"tsconfig.json 配完后可以直接使用，但是编辑器会标红，需要修改 tsconfig.json 加上 baseUrl 跟 paths { ... \"compilerOptions\": { ... \"baseUrl\": \"./\", \"paths\": { \"@/*\": [\"./src/*\"], \"@components/*\": [\"./src/components/*\"], \"@assets/*\": [\"./src/assets/*\"] } }, ... } ","date":"2022-02-10","objectID":"/posts/vue-2/:14:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"使用path 在 vite.config.ts 中，如果使用 __dirname + path 方式写地址的话，如果 TS 报错提示找不到，则需要安装 @types/node yarn add @types/node vite.config.ts import { resolve } from 'path' export default defineConfig({ plugins: [vue()], resolve: { alias: { '@': resolve(__dirname, 'src'), '@assets': resolve(__dirname, 'src/assets') } } }) tsconfig.json照常加上 baseUrl 跟 paths TS模块化 ","date":"2022-02-10","objectID":"/posts/vue-2/:15:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"使用JS自带库 当TS在使用JS中自带的window时,会发生报错,需要额外声明才能使用 // 使用 window.webkitRTCPeerConnection 以及 window.mozRTCPeerConnection declare global { interface Window { webkitRTCPeerConnection: any; mozRTCPeerConnection: any; } }; ","date":"2022-02-10","objectID":"/posts/vue-2/:16:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"引入外部库 例如引入外部js文件 需要更改index.html \u003cbody\u003e \u003cdiv id=\"app\"\u003e\u003c/div\u003e \u003cscript type=\"module\" src=\"/src/main.ts\"\u003e\u003c/script\u003e \u003cscript src=\"https://pv.sohu.com/cityjson?ie=utf-8\" \u003e\u003c/script\u003e \u003c/body\u003e 使用引入文件的参数,需要declare declare let returnCitySN:any; // returnCitySN为参数 export function getIP(){ return returnCitySN[\"cip\"]; } ","date":"2022-02-10","objectID":"/posts/vue-2/:17:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["Vue"],"content":"引入模块化函数 export function function_name(){ return something; } ","date":"2022-02-10","objectID":"/posts/vue-2/:18:0","tags":["Vue"],"title":"Vue-TS入门","uri":"/posts/vue-2/"},{"categories":["FastAPI"],"content":"FastAPI-文档 构建fastapi项目 ","date":"2022-02-10","objectID":"/posts/fastapi-3/:0:0","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"文件层级 . ├── app │ ├── __init__.py │ ├── main.py │ ├── dependencies.py │ └── routers │ │ ├── __init__.py │ │ ├── items.py │ │ └── users.py │ └── internal │ ├── __init__.py │ └── admin.py ","date":"2022-02-10","objectID":"/posts/fastapi-3/:1:0","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"_init_.py文件的作用 ","date":"2022-02-10","objectID":"/posts/fastapi-3/:2:0","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"package的标识 如果没有该文件，该目录就不会认为是package 包有两种导入方式: 精确导入： from Root.Pack1 import Pack1Class import Root.Pack1.Pack1Class 模糊导入： from Root.Pack1 import * ","date":"2022-02-10","objectID":"/posts/fastapi-3/:2:1","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"定义package中的__all__ 模糊导入中的*中的模块是由__all__来定义的 __all__ = [\"Pack1Class\",\"Pack1Class1\"] ","date":"2022-02-10","objectID":"/posts/fastapi-3/:2:2","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"APIRouter 假设专门用于处理用户逻辑的文件是位于 /app/routers/users.py 的子模块。 你希望将与用户相关的路径操作与其他代码分开，以使其井井有条。 但它仍然是同一 FastAPI 应用程序/web API 的一部分（它是同一「Python 包」的一部分）。 你可以使用 APIRouter 为该模块创建路径操作。 ","date":"2022-02-10","objectID":"/posts/fastapi-3/:3:0","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"导入 APIRouter 你可以导入它并通过与 FastAPI 类相同的方式创建一个「实例」： from fastapi import APIRouter router = APIRouter() @router.get(\"/users/\", tags=[\"users\"]) async def read_users(): return [{\"username\": \"Rick\"}, {\"username\": \"Morty\"}] @router.get(\"/users/me\", tags=[\"users\"]) async def read_user_me(): return {\"username\": \"fakecurrentuser\"} @router.get(\"/users/{username}\", tags=[\"users\"]) async def read_user(username: str): return {\"username\": username} ","date":"2022-02-10","objectID":"/posts/fastapi-3/:3:1","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"APIRouter的参数集成 假设你在位于 app/routers/items.py 的模块中还有专门用于处理应用程序中「项目」的端点。 你具有以下路径操作： /items/ /items/{item_id} 这和 app/routers/users.py 的结构完全相同。 但是我们想变得更聪明并简化一些代码。 我们知道此模块中的所有路径操作都有相同的： 路径 prefix：/items。 tags：（仅有一个 items 标签）。 额外的 responses。 dependencies：它们都需要我们创建的 X-Token 依赖项。 因此，我们可以将其添加到 APIRouter 中，而不是将其添加到每个路径操作中。 from fastapi import APIRouter, Depends, HTTPException from ..dependencies import get_token_header router = APIRouter( prefix=\"/items\", tags=[\"items\"], dependencies=[Depends(get_token_header)], responses={404: {\"description\": \"Not found\"}}, ) fake_items_db = {\"plumbus\": {\"name\": \"Plumbus\"}, \"gun\": {\"name\": \"Portal Gun\"}} @router.get(\"/\") async def read_items(): return fake_items_db @router.get(\"/{item_id}\") async def read_item(item_id: str): if item_id not in fake_items_db: raise HTTPException(status_code=404, detail=\"Item not found\") return {\"name\": fake_items_db[item_id][\"name\"], \"item_id\": item_id} @router.put( \"/{item_id}\", tags=[\"custom\"], responses={403: {\"description\": \"Operation forbidden\"}}, ) async def update_item(item_id: str): if item_id != \"plumbus\": raise HTTPException( status_code=403, detail=\"You can only update the item: plumbus\" ) return {\"item_id\": item_id, \"name\": \"The great Plumbus\"} ","date":"2022-02-10","objectID":"/posts/fastapi-3/:4:0","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"添加一些自定义的 tags、responses 和 dependencies 我们不打算在每个路径操作中添加前缀 /items 或 tags =[\"items\"]，因为我们将它们添加到了 APIRouter 中。 但是我们仍然可以添加更多将会应用于特定的路径操作的 tags，以及一些特定于该路径操作的额外 responses： from fastapi import APIRouter, Depends, HTTPException from ..dependencies import get_token_header router = APIRouter( prefix=\"/items\", tags=[\"items\"], dependencies=[Depends(get_token_header)], responses={404: {\"description\": \"Not found\"}}, ) fake_items_db = {\"plumbus\": {\"name\": \"Plumbus\"}, \"gun\": {\"name\": \"Portal Gun\"}} @router.get(\"/\") async def read_items(): return fake_items_db @router.get(\"/{item_id}\") async def read_item(item_id: str): if item_id not in fake_items_db: raise HTTPException(status_code=404, detail=\"Item not found\") return {\"name\": fake_items_db[item_id][\"name\"], \"item_id\": item_id} @router.put( \"/{item_id}\", tags=[\"custom\"], responses={403: {\"description\": \"Operation forbidden\"}}, ) async def update_item(item_id: str): if item_id != \"plumbus\": raise HTTPException( status_code=403, detail=\"You can only update the item: plumbus\" ) return {\"item_id\": item_id, \"name\": \"The great Plumbus\"} ","date":"2022-02-10","objectID":"/posts/fastapi-3/:5:0","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"FastAPI 主体 位于 app/main.py 的模块 这将是你的应用程序中将所有内容联结在一起的主文件。 并且由于你的大部分逻辑现在都存在于其自己的特定模块中，因此主文件的内容将非常简单。 ","date":"2022-02-10","objectID":"/posts/fastapi-3/:6:0","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"导入 FastAPI¶ 你可以像平常一样导入并创建一个 FastAPI 类。 我们甚至可以声明全局依赖项，它会和每个 APIRouter 的依赖项组合在一起： from fastapi import Depends, FastAPI from .dependencies import get_query_token, get_token_header from .internal import admin from .routers import items, users app = FastAPI(dependencies=[Depends(get_query_token)]) app.include_router(users.router) app.include_router(items.router) app.include_router( admin.router, prefix=\"/admin\", tags=[\"admin\"], dependencies=[Depends(get_token_header)], responses={418: {\"description\": \"I'm a teapot\"}}, ) @app.get(\"/\") async def root(): return {\"message\": \"Hello Bigger Applications!\"} 注入依赖 ","date":"2022-02-10","objectID":"/posts/fastapi-3/:6:1","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"示例 from typing import Optional from fastapi import Depends, FastAPI app = FastAPI() async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read_items(commons: dict = Depends(common_parameters)): return commons @app.get(\"/users/\") async def read_users(commons: dict = Depends(common_parameters)): return commons 依赖项函数的形式和结构与路径操作函数一样。 因此，可以把依赖项当作没有「装饰器」（即，没有 @app.get(\"/some-path\") ）的路径操作函数。 依赖项可以返回各种内容。 本例中的依赖项预期接收如下参数： 类型为 str 的可选查询参数 q 类型为 int 的可选查询参数 skip，默认值是 0 类型为 int 的可选查询参数 limit，默认值是 100 然后，依赖项函数返回包含这些值的 dict。 目的: 接收到新的请求时，FastAPI 执行如下操作： 用正确的参数调用依赖项函数（「可依赖项」） 获取函数返回的结果 把函数返回的结果赋值给路径操作函数的参数 无需创建专门的类，并将之传递给 FastAPI 以进行「注册」或执行类似的操作 这样，只编写一次代码，FastAPI 就可以为多个路径操作共享这段代码 。 ","date":"2022-02-10","objectID":"/posts/fastapi-3/:7:0","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["FastAPI"],"content":"在路径操作装饰器中添加 dependencies 参数 路径操作装饰器支持可选参数 ~ dependencies。 该参数的值是由 Depends() 组成的 list： from fastapi import Depends, FastAPI, Header, HTTPException app = FastAPI() async def verify_token(x_token: str = Header(...)): if x_token != \"fake-super-secret-token\": raise HTTPException(status_code=400, detail=\"X-Token header invalid\") async def verify_key(x_key: str = Header(...)): if x_key != \"fake-super-secret-key\": raise HTTPException(status_code=400, detail=\"X-Key header invalid\") return x_key @app.get(\"/items/\", dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items(): return [{\"item\": \"Foo\"}, {\"item\": \"Bar\"}] 相对导入import 一个单点 .表示从当前层级寻找包 from .dependencies import get_token_header 两个点 ..表示从上一级寻找包 from ..dependencies import get_token_header 三个点...表示上上一级 ","date":"2022-02-10","objectID":"/posts/fastapi-3/:8:0","tags":["FastAPI基础"],"title":"FastAPI-3","uri":"/posts/fastapi-3/"},{"categories":["Python"],"content":"requests-proxies 报错解决 ","date":"2022-02-09","objectID":"/posts/python-proxy/:0:0","tags":["Python-Spider"],"title":"爬虫代理池的使用","uri":"/posts/python-proxy/"},{"categories":["Python"],"content":"requests.exceptions.SSLError: HTTPSConnectionPool 因为爬取的网站存在多次重定向导致报错 关闭证书验证verify=False response = requests.get('http://xxx.com/', headers = header, verify=False) [参考文章](2020 python解决requests.exceptions.SSLError: HTTPSConnectionPool问题_ywj_486的博客-CSDN博客) ","date":"2022-02-09","objectID":"/posts/python-proxy/:1:0","tags":["Python-Spider"],"title":"爬虫代理池的使用","uri":"/posts/python-proxy/"},{"categories":["Python"],"content":"InsecureRequestWarning: Unverified HTTPS request is being made to host # 忽略requests证书警告 from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) requests使用代理 import requests # 从ip代理池中获取ip和port ip = proxydata['ip'] port = proxydata['port'] proxy = str(ip) + ':' + str(port) proxies = { 'http': 'http://' + proxy, 'https': 'http://' + proxy } data = requests.get(get_url, proxies=proxies, verify=False, timeout=20) data.close() # 注意关闭requests请求 resdata = data.text BeautifulSoup ","date":"2022-02-09","objectID":"/posts/python-proxy/:2:0","tags":["Python-Spider"],"title":"爬虫代理池的使用","uri":"/posts/python-proxy/"},{"categories":["Python"],"content":"初始化对象 from bs4 import BeautifulSoup soup = BeautifulSoup(data, \"html.parser\") # 解析器使用html.parse ","date":"2022-02-09","objectID":"/posts/python-proxy/:3:0","tags":["Python-Spider"],"title":"爬虫代理池的使用","uri":"/posts/python-proxy/"},{"categories":["Python"],"content":"find_all('tag')方法 # 返回第一个table标签中的内容 soup.find_all('table')[0] # 返回table标签中 属性name为'imgShow'的 td标签内容 table_list = table.find_all('td', {\"name\": 'imgShow'}) find('tag')方法找到第一个符合的标签 find_all('tag')方法找到所有符合的标签,返回数组 ","date":"2022-02-09","objectID":"/posts/python-proxy/:4:0","tags":["Python-Spider"],"title":"爬虫代理池的使用","uri":"/posts/python-proxy/"},{"categories":["Python"],"content":"获取标签的属性值 for item in table_list: # 获取a标签中的title属性 title = item.find('a').attrs['title'] notice_title = str(title) # 获取当前td标签的id属性 notice_time = str(item.attrs['id']) ","date":"2022-02-09","objectID":"/posts/python-proxy/:5:0","tags":["Python-Spider"],"title":"爬虫代理池的使用","uri":"/posts/python-proxy/"},{"categories":["FastAPI"],"content":"Centos + gunicorn + Supervisor 部署 Fastapi gunicorn # 查看进程树 pstree -ap|grep gunicorn #重启Gunicorn任务 kill -HUP 14226 #退出Gunicorn任务 kill -9 28097 centos7安装nginx(老版本) 一. gcc 安装 安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装： yum install gcc-c++ 二. PCRE pcre-devel 安装 PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令： yum install -y pcre pcre-devel 三. zlib 安装 zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。 yum install -y zlib zlib-devel 四. OpenSSL 安装 OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。 nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 yum install -y openssl openssl-devel 五. nginx安装 使用wget命令下载（推荐）。确保系统已经安装了wget，如果没有安装，执行 yum install wget 安装。 wget -c https://nginx.org/download/nginx-1.12.0.tar.gz 解压 依然是直接命令： tar -zxvf nginx-1.12.0.tar.gz cd nginx-1.12.0 配置 其实在 nginx-1.12.0 版本中你就不需要去配置相关东西，默认就可以了。当然，如果你要自己配置目录也是可以的。 1.使用默认配置 ./configure 2.自定义配置（不推荐） ./configure \\ --prefix=/usr/local/nginx \\ --conf-path=/usr/local/nginx/conf/nginx.conf \\ --pid-path=/usr/local/nginx/conf/nginx.pid \\ --lock-path=/var/lock/nginx.lock \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --with-http_gzip_static_module \\ --http-client-body-temp-path=/var/temp/nginx/client \\ --http-proxy-temp-path=/var/temp/nginx/proxy \\ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ --http-scgi-temp-path=/var/temp/nginx/scgi 注：将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录 编译安装 make make install 查找安装路径： whereis nginx ","date":"2022-02-08","objectID":"/posts/fastapi-4/:0:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"启动、停止nginx cd /usr/local/nginx/sbin/ ./nginx ./nginx -s stop ./nginx -s quit ./nginx -s reload ./nginx -s quit:此方式停止步骤是待nginx进程处理任务完毕进行停止。 ./nginx -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。 参考: CentOS7安装Nginx - boonya - 博客园 (cnblogs.com) 参考2: centOS7安装nginx及nginx配置_Snow、杨-CSDN博客_centos7安装nginx ","date":"2022-02-08","objectID":"/posts/fastapi-4/:1:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"添加Nginx访问过滤 vim /usr/local/nginx/conf/nginx.conf # 在 server内 location的上方添加 allow IP; allow 127.0.0.1; deny all; # 即可使得接口服务只有 IP 和 localhost能访问, 其他IP访问都是403, 保证了服务器的安全性 端口检查 ","date":"2022-02-08","objectID":"/posts/fastapi-4/:2:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"fuser 关闭占用80端口的进程 sudo fuser -k 80/tcp sudo fuser -k -n tcp 80 # 关闭占用8080端口的进程 sudo fuser -k 8080/tcp sudo fuser -k -n tcp 8080 sudo fuser -k --namespace tcp 8080 -k, –kill kill processes accessing the named file -n, –namespace 接 命名空间(tcp | udp | file) 接 (端口号 | 文件名)， 如果不会引起歧义的话, 可用：name/space (80/tcp)之类的表示 , 省略 -n。 参考: CentOS7 关闭占用指定端口的进程_kfepiza的博客-CSDN博客_centos关闭指定端口进程 ","date":"2022-02-08","objectID":"/posts/fastapi-4/:3:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"netstat 1、查看服务器所有被占用端口 netstat -ant 2、验证某个端口号是否被占用 netstat -tunlp | grep 端口号 3、查看所有监听端口号 netstat -lntp centos安装python3 ","date":"2022-02-08","objectID":"/posts/fastapi-4/:4:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"查看python版本 [root@localhost ~]# python -V Python 2.7.5 系统默认安装了Python 2.7.5 ","date":"2022-02-08","objectID":"/posts/fastapi-4/:5:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"安装依赖 yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make 如果有提示一路选择Y就可以。 安装libffi-devel依赖。 yum install libffi-devel -y 注意：如果不安装这个包，python3可以装成功，但是后面装flask、uwsgi等依赖python3中有个内置模块叫ctypes时会报错。报错ModuleNotFoundError: No module named ‘_ctypes‘。需要安装依赖包和重新编译安装python3。 参看：https://blog.csdn.net/qq_36416904/article/details/79316972 ","date":"2022-02-08","objectID":"/posts/fastapi-4/:6:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"下载稳定版本3.8版 wget https://www.python.org/ftp/python/3.8.12/Python-3.8.12.tgz ","date":"2022-02-08","objectID":"/posts/fastapi-4/:7:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"解压安装python源码包 1、解压 tar -zxvf Python-3.8.12.tgz 2、安装 进入解压后的目录进行编译和安装 cd Python-3.8.12/ [root@localhost Python-3.8.12]# [root@localhost Python-3.8.12]# ./configure [root@localhost Python-3.8.12]# make\u0026\u0026make install ","date":"2022-02-08","objectID":"/posts/fastapi-4/:8:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"建立命令软链接 虽然python3.8.12安装成功了，但默认输入python还是显示是2.7版本的。如果要用python3.8.12需要输入python3即可，有时候不太方便。可以通过修改软链接的方式将默认的python指向python3.8.12。 先看一下默认的python及新安装的python3都安装在哪里 [root@localhost Python-3.8.12]# which python /usr/bin/python [root@localhost Python-3.8.12]# which python3 /usr/local/bin/python3 可以看到默认的python路径为/usr/bin/python，python3的路径为/usr/local/bin/python3 将python3的软链接加到python上 [root@localhost Python-3.8.12]# mv /usr/bin/python /usr/bin/python.bak [root@localhost Python-3.8.12]# ln -s /usr/local/bin/python3 /usr/bin/python 通过python -V命令查看python版号，这时python的版本已经是3.8.12了。 [root@localhost Python-3.8.12]# python -V Python 3.8.12 pip命令也可以修改，python3.8.12默认的pip是pip3，CentOS7的python2.7默认没有安装pip. 输入pip命令的时候提示命令没有找到 [root@localhost Python-3.8.12]# pip bash: pip: command not found... 这时也可以通过建立软链接的方式将pip命令链接到pip3上。首先看pip3命令在哪? [root@localhost Python-3.8.12]# which pip3 /usr/local/bin/pip3 然后建立pip到pip3的软链接 [root@localhost Python-3.8.12]# ln -s /usr/local/bin/pip3 /usr/bin/pip [root@localhost Python-3.8.12]# pip -V pip 21.1.1 from /usr/local/lib/python3.8/site-packages/pip (python 3.8) ","date":"2022-02-08","objectID":"/posts/fastapi-4/:9:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"配置yum 安装python3改完软链接以后发现yum命令报错了，yum是依赖python2.7的，你把python改成了3.8了，所以报错了。 [root@localhost Python-3.8.12]# yum File \"/usr/bin/yum\", line 30 except KeyboardInterrupt, e: ^ SyntaxError: invalid syntax 可以修改yum里对python2的依赖即可。虽然安装了python3但是系统里python2依旧还在系统里，可以通过python2来指定用python2.7的命令，首先来看下python2的命令在哪里 [root@localhost ~]# which python2 /usr/bin/python2 可以cd到/usr/bin目录下 通过ls -alh|grep python查看python命令的详细情况。 [root@localhost bin]# ls -alh|grep python vi /usr/libexec/urlgrabber-ext-down 修改对python的依赖，修改成python2或python2.7都可以。 vi /usr/bin/yum 修改完这两个文件后，再敲yum命令就不会报错了。 vi /usr/bin/yum 把 #! /usr/bin/python 修改为 #! /usr/bin/python2 vi /usr/libexec/urlgrabber-ext-down 把 #! /usr/bin/python 修改为 #! /usr/bin/python2 vi /usr/bin/yum-config-manager #!/usr/bin/python 改为 #!/usr/bin/python2 至此CentOS7环境下python3.8.12已经成功安装！ 参考博客: CentOS7下安装python3.8 - xiejava - 博客园 (cnblogs.com) 测试数据库远程连接 from sqlalchemy import create_engine, inspect engine = create_engine('mysql+pymysql://username:password@ip/db_name', encoding='utf-8', echo=False, pool_size=100, pool_timeout=30) inspector = inspect(engine) # 获取全部的schema模式 schemas = inspector.get_schema_names() print(schemas) # for schema in schemas: # print(\"schema: %s\" % schema) # for table_name in inspector.get_table_names(schema=schema): # for column in inspector.get_columns(table_name, schema=schema): # print(\"Column: %s\" % column) nginx部署fastapi 在fastapi的main文件中(该步骤请跳过) if __name__ == '__main__': uvicorn.run(app='main:app', host=\"127.0.0.1\", port=8000, reload=True, debug=True) 切换到nginx目录配置文件 cd /usr/local/nginx/conf.d # 其中nginx.conf为配置文件 vim default.conf ","date":"2022-02-08","objectID":"/posts/fastapi-4/:10:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"conf编辑文件 # 配置转发 ... location / { proxy_pass http://127.0.0.1:8000/; } ... # 转发文档 接口文档使用默认时，还需添加如下配置 location /openapi.json { proxy_pass http://fastapi_host/openapi.json; } ","date":"2022-02-08","objectID":"/posts/fastapi-4/:11:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"安装gunicorn pip install gunicorn ","date":"2022-02-08","objectID":"/posts/fastapi-4/:12:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"运行gunicorn gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker # -D 守护启动 -c 配置文件 参考博客 Nginx配置转发FastAPI接口和文档_愤怒的小兵-CSDN博客_fastapi nginx ","date":"2022-02-08","objectID":"/posts/fastapi-4/:13:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"查看Nginx日志 cat /usr/local/nginx/logs/error.log ","date":"2022-02-08","objectID":"/posts/fastapi-4/:14:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"查看Nginx配置文件 cat /usr/local/nginx/conf/nginx.conf 新版nginx部署fastapi Nginx+Gunicorn+Supervisor 部署 FastApi 项目 - 年不迈的小清新 - 博客园 (cnblogs.com) ","date":"2022-02-08","objectID":"/posts/fastapi-4/:15:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"Supervisor管理 Gunicorn 进程 ","date":"2022-02-08","objectID":"/posts/fastapi-4/:16:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"安装 yum install supervisor sudo easy_install supervisor ","date":"2022-02-08","objectID":"/posts/fastapi-4/:16:1","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"配置 touch supervisor_app.conf vim supervisor_app.conf ##### 填写如下内容 [include] files=/etc/supervisord.conf [program:app_name] directory= /home/filename/ command= gunicorn main:app -k uvicorn.workers.UvicornWorker -c gunicorn.conf ##### ","date":"2022-02-08","objectID":"/posts/fastapi-4/:16:2","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"gunicorn参数解释 -c CONFIG : CONFIG,配置文件的路径，通过配置文件启动；生产环境使用； -b ADDRESS : ADDRESS，ip加端口，绑定运行的主机； -w INT, --workers INT：用于处理工作进程的数量，为正整数，默认为1； -k STRTING, --worker-class STRTING：要使用的工作模式，默认为sync异步，可以下载eventlet和gevent并指定 --threads INT：处理请求的工作线程数，使用指定数量的线程运行每个worker。为正整数，默认为1。 --worker-connections INT：最大客户端并发数量，默认情况下这个值为1000。 --backlog int：未决连接的最大数量，即等待服务的客户的数量。默认2048个，一般不修改； -p FILE, --pid FILE：设置pid文件的文件名，如果不设置将不会创建pid文件 --access-logfile FILE ： 要写入的访问日志目录 --access-logformat STRING：要写入的访问日志格式 --error-logfile FILE, --log-file FILE ： 要写入错误日志的文件目录。 --log-level LEVEL ： 错误日志输出等级。 --limit-request-line INT ： HTTP请求头的行数的最大大小，此参数用于限制HTTP请求行的允许大小，默认情况下，这个值为4094。值是0~8190的数字。 --limit-request-fields INT ： 限制HTTP请求中请求头字段的数量。此字段用于限制请求头字段的数量以防止DDOS攻击，默认情况下，这个值为100，这个值不能超过32768 --limit-request-field-size INT ： 限制HTTP请求中请求头的大小，默认情况下这个值为8190字节。值是一个整数或者0，当该值为0时，表示将对请求头大小不做限制 -t INT, --timeout INT：超过这么多秒后工作将被杀掉，并重新启动。一般设定为30秒； --daemon： 是否以守护进程启动，默认false； --chdir： 在加载应用程序之前切换目录； --graceful-timeout INT：默认情况下，这个值为30，在超时(从接收到重启信号开始)之后仍然活着的工作将被强行杀死；一般使用默认； --keep-alive INT：在keep-alive连接上等待请求的秒数，默认情况下值为2。一般设定在1~5秒之间。 --reload：默认为False。此设置用于开发，每当应用程序发生更改时，都会导致工作重新启动。 --spew：打印服务器执行过的每一条语句，默认False。此选择为原子性的，即要么全部打印，要么全部不打印； --check-config ：显示现在的配置，默认值为False，即显示。 -e ENV, --env ENV： 设置环境变量； ","date":"2022-02-08","objectID":"/posts/fastapi-4/:16:3","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"配置文件 # gunicorn.conf # 并行工作进程数 workers = 4 # 指定每个工作者的线程数 threads = 2 # 监听内网端口5000 bind = '127.0.0.1:5000' # 设置守护进程,将进程交给supervisor管理 daemon = 'false' # 工作模式协程 # worker_class = 'gevent' # 设置最大并发量 worker_connections = 2000 # 设置进程文件目录 pidfile = '/var/run/gunicorn.pid' # 设置访问日志和错误信息日志路径 accesslog = '/var/log/gunicorn_acess.log' errorlog = '/var/log/gunicorn_error.log' # 设置日志记录水平 loglevel = 'warning' ","date":"2022-02-08","objectID":"/posts/fastapi-4/:16:4","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"配置文件启动supervisor supervisord -c supervisor_app.conf ","date":"2022-02-08","objectID":"/posts/fastapi-4/:16:5","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"启动应用 sudo supervisorctl start app_name ","date":"2022-02-08","objectID":"/posts/fastapi-4/:16:6","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"常用命令 supervisorctl start [program_name] supervisorctl stop [program_name] supervisorctl restart [program_name] # 重启服务，注意这里不会重新加载配置文件 supervisorctl status # 查看当前程序运行状态 重新加载配置文件，重新启动正在运行的服务： sudo supervisorctl reload sudo supervisorctl update ","date":"2022-02-08","objectID":"/posts/fastapi-4/:16:7","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"查看日志 cat /var/log/supervisor/supervisord.log ","date":"2022-02-08","objectID":"/posts/fastapi-4/:16:8","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"查看程序启动的具体报错 supervisorctl tail program_name stdout ","date":"2022-02-08","objectID":"/posts/fastapi-4/:17:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"关闭supervisor进程 寻找进程 ps -ef | grep supervisord 杀掉进程 kill -s SIGTERM 29646 Python-requirement.txt 文件 ","date":"2022-02-08","objectID":"/posts/fastapi-4/:18:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"使用freeze 生成 requirements.txt 进入项目根目录，执行以下命令 pip freeze \u003e requirements.txt 使用 requirement.txt 安装第三方库 pip install -r requirement.txt ","date":"2022-02-08","objectID":"/posts/fastapi-4/:19:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"使用pipreqs # 安装 pip install pipreqs # 在当前目录生成 pipreqs . --encoding=utf8 --force # 安装 pip install -r requirements.txt 报错解决 ","date":"2022-02-08","objectID":"/posts/fastapi-4/:20:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["FastAPI"],"content":"OSError: [Errno 98] Address already in use 指端口被占用，未释放或者程序没有正常结束 查询端口占用进程 lsof -i:8080 # 查找8080端口进程 杀死进程 kill -9 pidnumber ","date":"2022-02-08","objectID":"/posts/fastapi-4/:21:0","tags":["FastAPI服务器部署"],"title":"Centos部署Fastapi","uri":"/posts/fastapi-4/"},{"categories":["Python"],"content":"进度条tqdm的使用 ","date":"2022-02-06","objectID":"/posts/python-tqdm/:0:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"安装 pip install tqdm ","date":"2022-02-06","objectID":"/posts/python-tqdm/:1:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"迭代对象处理 对于可以迭代的对象都可以使用下面这种方式，来实现可视化进度，非常方便 from tqdm import tqdm import time for i in tqdm(range(100)): time.sleep(0.1) pass 在使用tqdm的时候，可以将tqdm(range(100))替换为trange(100) from tqdm import tqdm,trange import time for i in trange(100): time.sleep(0.1) pass ","date":"2022-02-06","objectID":"/posts/python-tqdm/:2:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"观察处理的数据 通过tqdm提供的set_description方法可以实时查看每次处理的数据 from tqdm import tqdm import time pbar = tqdm([\"a\",\"b\",\"c\",\"d\"]) for c in pbar: time.sleep(1) pbar.set_description(\"Processing %s\"%c) ","date":"2022-02-06","objectID":"/posts/python-tqdm/:3:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"手动设置处理的进度 通过update方法可以控制每次进度条更新的进度 from tqdm import tqdm import time #total参数设置进度条的总长度 with tqdm(total=100) as pbar: for i in range(100): time.sleep(0.05) #每次更新进度条的长度 pbar.update(1) ","date":"2022-02-06","objectID":"/posts/python-tqdm/:4:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"推荐用法 除了使用with之外，还可以使用另外一种方法实现上面的效果 from tqdm import tqdm import time #total参数设置进度条的总长度 pbar = tqdm(total=100) for i in range(100): time.sleep(0.05) #每次更新进度条的长度 pbar.update(1) #关闭占用的资源 pbar.close() ","date":"2022-02-06","objectID":"/posts/python-tqdm/:5:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"自定义进度条显示信息 通过set_description和set_postfix方法设置进度条显示信息 from tqdm import trange from random import random,randint import time with trange(100) as t: for i in t: #设置进度条左边显示的信息 t.set_description(\"GEN %i\"%i) #设置进度条右边显示的信息 t.set_postfix(loss=random(),gen=randint(1,999),str=\"h\",lst=[1,2]) time.sleep(0.1) ","date":"2022-02-06","objectID":"/posts/python-tqdm/:6:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"多层循环进度条 通过tqdm也可以很简单的实现嵌套循环进度条的展示 from tqdm import tqdm import time for i in tqdm(range(20), ascii=True,desc=\"1st loop\"): for j in tqdm(range(10), ascii=True,desc=\"2nd loop\"): time.sleep(0.01) ","date":"2022-02-06","objectID":"/posts/python-tqdm/:7:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"多进程进度条 在使用多进程处理任务的时候，通过tqdm可以实时查看每一个进程任务的处理情况 from time import sleep from tqdm import trange, tqdm from multiprocessing import Pool, freeze_support, RLock L = list(range(9)) def progresser(n): interval = 0.001 / (n + 2) total = 5000 text = \"#{}, est. {:\u003c04.2}s\".format(n, interval * total) for i in trange(total, desc=text, position=n,ascii=True): sleep(interval) if __name__ == '__main__': freeze_support() # for Windows support p = Pool(len(L), # again, for Windows support initializer=tqdm.set_lock, initargs=(RLock(),)) p.map(progresser, L) print(\"\\n\" * (len(L) - 2)) ","date":"2022-02-06","objectID":"/posts/python-tqdm/:8:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"Pandas中使用tqdm import pandas as pd import numpy as np from tqdm import tqdm df = pd.DataFrame(np.random.randint(0, 100, (100000, 6))) tqdm.pandas(desc=\"my bar!\") df.progress_apply(lambda x: x**2) ","date":"2022-02-06","objectID":"/posts/python-tqdm/:9:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"注意 在使用tqdm显示进度条的时候，如果代码中存在print可能会导致输出多行进度条，此时可以将print语句改为tqdm.write，代码如下 for i in tqdm(range(10),ascii=True): tqdm.write(\"come on\") time.sleep(0.1) ","date":"2022-02-06","objectID":"/posts/python-tqdm/:10:0","tags":["Python进度条"],"title":"进度条显示tqdm","uri":"/posts/python-tqdm/"},{"categories":["Python"],"content":"在知乎上看到了一篇讲 依赖注入 非常好的文章,在这里分享一下 ","date":"2022-02-04","objectID":"/posts/python-DI/:0:0","tags":["依赖注入"],"title":"依赖注入","uri":"/posts/python-DI/"},{"categories":["Python"],"content":"原始代码 class iPhone6 extends Iphone { function read($user=\"某人\"){ echo $user.\"打开了知乎然后编了一个故事 \\n\"; } function play($user=\"某人\"){ echo $user.\"打开了王者农药并送起了人头 \\n\"; } function grab($user=\"某人\"){ echo $user.\"开始抢红包却只抢不发 \\n\"; } } class Ming extends Person { private $_name; private $_age; public function __construct(){ $this-\u003e_name = '小明'; $this-\u003e_age = 26; } function read(){ //…… 省略若干代码 (new iPhone6())-\u003eread($this-\u003e_name); //逛知乎 } function play(){ //…… 省略若干代码 (new iPhone6())-\u003eplay($this-\u003e_name);//玩农药 } function grab(){ //…… 省略若干代码 (new iPhone6())-\u003egrab($this-\u003e_name);//抢红包 } } 输出: $ming = new Ming(); //小明起床 $ming-\u003eread(); $ming-\u003eplay(); $ming-\u003egrab(); # 小明打开了知乎然后编了一个故事 # 小明打开了王者农药并送起了人头 # 小明开始抢红包却只抢不发 但是这里出现了一个问题，如果小明更换手机，那么需要将所有的iphone6更换为iphone13 此时为过度耦合 那么如何解耦呢，这个时候就需要转换控制权，将手机的控制权不放在小明的手里，控制反转 ","date":"2022-02-04","objectID":"/posts/python-DI/:1:0","tags":["依赖注入"],"title":"依赖注入","uri":"/posts/python-DI/"},{"categories":["Python"],"content":"new code class Ming extends Person { private $_name; private $_age; private $_phone; //将手机作为自己的成员变量 public function __construct($phone){ $this-\u003e_name = '小明'; $this-\u003e_age = 26; $this-\u003e_phone = $phone; echo \"小明起床了 \\n\"; } function read(){ //…… 省略若干代码 $this-\u003e_phone-\u003eread($this-\u003e_name); //逛知乎 } function play(){ //…… 省略若干代码 $this-\u003e_phone-\u003eplay($this-\u003e_name);//玩农药 } function grab(){ //…… 省略若干代码 $this-\u003e_phone-\u003egrab($this-\u003e_name);//抢红包 } } $phone = new IphoneX(); //创建一个iphoneX的实例 if($phone-\u003eisBroken()){//如果iphone不可用，则使用旧版手机 $phone = new Iphone6(); } $ming = new Ming($phone);//小明不用关心是什么手机，他只要玩就行了。 $ming-\u003eread(); $ming-\u003eplay(); $ming-\u003egrab(); ","date":"2022-02-04","objectID":"/posts/python-DI/:2:0","tags":["依赖注入"],"title":"依赖注入","uri":"/posts/python-DI/"},{"categories":["Python"],"content":"总结 如果一个类A 的功能实现需要借助于类B，那么就称类B是类A的依赖，如果在类A的内部去实例化类B，那么两者之间会出现较高的耦合，一旦类B出现了问题，类A也需要进行改造，如果这样的情况较多，每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，程序会极难维护，并且很容易出现问题。要解决这个问题，就要把A类对B类的控制权抽离出来，交给一个第三方去做，把控制权反转给第三方，就称作控制反转（IOC Inversion Of Control）。控制反转是一种思想，是能够解决问题的一种可能的结果，而依赖注入（Dependency Injection）就是其最典型的实现方法。由第三方（我们称作IOC容器）来控制依赖，把他通过构造函数、属性或者工厂模式等方法，注入到类A内，这样就极大程度的对类A和类B进行了解耦。 ","date":"2022-02-04","objectID":"/posts/python-DI/:3:0","tags":["依赖注入"],"title":"依赖注入","uri":"/posts/python-DI/"},{"categories":["Python"],"content":"Python的classmethod修饰符使用 classmethod 修饰符对应的函数不需要实例化 不需要 self 参数，但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。 class A(object): # 属性默认为类属性（可以给直接被类本身调用） num = \"类属性\" # 实例化方法（必须实例化类之后才能被调用） def func1(self): # self : 表示实例化类后的地址id print(\"func1\") print(self) # 类方法（不需要实例化类就可以被类本身调用） @classmethod def func2(cls): # cls : 表示没用被实例化的类本身 print(\"func2\") print(cls) print(cls.num) cls().func1() # 不传递传递默认self参数的方法（该方法也是可以直接被类调用的，但是这样做不标准） def func3(): print(\"func3\") print(A.num) # 属性是可以直接用类本身调用的 # A.func1() 这样调用是会报错：因为func1()调用时需要默认传递实例化类后的地址id参数，如果不实例化类是无法调用的 A.func2() A.func3() ","date":"2022-01-31","objectID":"/posts/python-classmethod/:0:0","tags":["Python基础语法"],"title":"classmethod修饰符","uri":"/posts/python-classmethod/"},{"categories":["FastAPI"],"content":"FastAPI-文档 请求模型 from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None @app.post(\"/items/\") async def create_item(item: Item): item_dict = item.dict() if item.tax: price_with_tax = item.price + item.tax item_dict.update({\"price_with_tax\": price_with_tax}) return item_dict 嵌套模型 ","date":"2022-01-30","objectID":"/posts/fastapi-2/:0:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"List class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None categories: list = [] @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item): results = {\"item_id\": item_id, \"item\": item} return results ","date":"2022-01-30","objectID":"/posts/fastapi-2/:1:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"带有类型的List class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None categories: List[str] = [] @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item): results = {\"item_id\": item_id, \"item\": item} return results ","date":"2022-01-30","objectID":"/posts/fastapi-2/:1:1","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"Set 元素不重复的集合 ","date":"2022-01-30","objectID":"/posts/fastapi-2/:2:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"嵌套 class Image(BaseModel): url: str name: str class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None categories: Set[str] = [] image: Optional[Image] = None @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item): results = {\"item_id\": item_id, \"item\": item} return results 特殊类型的校验 使用Pydantic校验 例如在Image模型中有一个url字段,可以将它声明为Pydantic的HttpUrl而不是str from typing import Optional, Set from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None categories: Set[str] = set() image: Optional[Image] = None @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item): results = {\"item_id\": item_id, \"item\": item} return results 该字符串将被检查是否为有效的 URL，并在 JSON Schema / OpenAPI 文档中进行记录。 纯列表请求体 如果期望的 JSON 请求体的最外层是一个 JSON array（即 Python list），则可以在路径操作函数的参数中声明此类型，就像声明 Pydantic 模型一样： images: List[Image] 例如： from typing import List from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str @app.post(\"/images/multiple/\") async def create_multiple_images(images: List[Image]): return images 模式增加示例 ","date":"2022-01-30","objectID":"/posts/fastapi-2/:3:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"Field 的附加参数 在 Field, Path, Query, Body 和其他你之后将会看到的工厂函数，你可以为JSON 模式声明额外信息，你也可以通过给工厂函数传递其他的任意参数来给JSON 模式声明额外信息，比如增加 example: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel, Field app = FastAPI() class Item(BaseModel): name: str = Field(..., example=\"Foo\") description: Optional[str] = Field(None, example=\"A very nice Item\") price: float = Field(..., example=35.4) tax: Optional[float] = Field(None, example=3.2) @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item): results = {\"item_id\": item_id, \"item\": item} return results 额外数据类型 使用Pydantic类型 例如UUID, datetime.datetime, frozenset, Decimal等 from datetime import datetime, time, timedelta from typing import Optional from uuid import UUID from fastapi import Body, FastAPI app = FastAPI() @app.put(\"/items/{item_id}\") async def read_items( item_id: UUID, start_datetime: Optional[datetime] = Body(None), end_datetime: Optional[datetime] = Body(None), repeat_at: Optional[time] = Body(None), process_after: Optional[timedelta] = Body(None), ): start_process = start_datetime + process_after duration = end_datetime - start_process return { \"item_id\": item_id, \"start_datetime\": start_datetime, \"end_datetime\": end_datetime, \"repeat_at\": repeat_at, \"process_after\": process_after, \"start_process\": start_process, \"duration\": duration, } Cookies 可以像定义 Query 参数和 Path 参数一样来定义 Cookie 参数 from typing import Optional from fastapi import Cookie, FastAPI app = FastAPI() @app.get(\"/items/\") # 第一个值是参数的默认值，同时也可以传递所有验证参数或注释参数，来校验参数： async def read_items(ads_id: Optional[str] = Cookie(None)): return {\"ads_id\": ads_id} Header 使用和Path, Query and Cookie 一样的结构定义 header 参数 from typing import Optional from fastapi import FastAPI, Header app = FastAPI() @app.get(\"/items/\") # 第一个值是参数的默认值，同时也可以传递所有验证参数或注释参数，来校验参数： async def read_items(user_agent: Optional[str] = Header(None)): return {\"User-Agent\": user_agent} ","date":"2022-01-30","objectID":"/posts/fastapi-2/:4:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"符号 ’ - ’ 的自动转换 大多数标准的headers用 “连字符” 分隔，也称为 “减号” (-)。 但是像 user-agent 这样的变量在Python中是无效的。 因此, 默认情况下, Header 将把参数名称的字符从下划线 (_) 转换为连字符 (-) 来提取并记录 headers. 同时，HTTP headers 是大小写不敏感的，因此，因此可以使用标准Python样式(也称为 “snake_case”)声明它们。 因此，您可以像通常在Python代码中那样使用 user_agent ，而不需要将首字母大写为 User_Agent 或类似的东西。 如果出于某些原因，你需要禁用下划线到连字符的自动转换，设置Header的参数 convert_underscores 为 False: from typing import Optional from fastapi import FastAPI, Header app = FastAPI() @app.get(\"/items/\") async def read_items( strange_header: Optional[str] = Header(None, convert_underscores=False) ): return {\"strange_header\": strange_header} 响应模型 from typing import List, Optional from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None categories: List[str] = [] @app.post(\"/items/\", response_model=Item) async def create_item(item: Item): return item ","date":"2022-01-30","objectID":"/posts/fastapi-2/:5:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"添加输出模型 相反，我们可以创建一个有明文密码的输入模型和一个没有明文密码的输出模型： from typing import Optional from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserIn(BaseModel): username: str password: str email: EmailStr full_name: Optional[str] = None class UserOut(BaseModel): username: str email: EmailStr full_name: Optional[str] = None @app.post(\"/user/\", response_model=UserOut) async def create_user(user: UserIn): return user ","date":"2022-01-30","objectID":"/posts/fastapi-2/:6:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"response_model_exclude_unset 设置路径操作装饰器的 response_model_exclude_unset=True 参数： 响应中将不会包含那些默认值，而是仅有实际设置的值 from typing import List, Optional from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Optional[str] = None price: float # 设置默认值 10.5 tax: float = 10.5 categories: List[str] = [] items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2}, \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": []}, } @app.get(\"/items/{item_id}\", response_model=Item, response_model_exclude_unset=True) async def read_item(item_id: str): return items[item_id] \"\"\" 因此，如果你向路径操作发送 ID 为 foo 的商品的请求，则响应（不包括默认值）将为： { \"name\": \"Foo\", \"price\": 50.2 } \"\"\" ","date":"2022-01-30","objectID":"/posts/fastapi-2/:7:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"response_model_include 和 response_model_exclude 你还可以使用路径操作装饰器的 response_model_include 和 response_model_exclude 参数。 它们接收一个由属性名称 str 组成的 set 来包含（忽略其他的）或者排除（包含其他的）这些属性。 如果你只有一个 Pydantic 模型，并且想要从输出中移除一些数据，则可以使用这种快捷方法。 from typing import Optional from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Optional[str] = None price: float tax: float = 10.5 items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The Bar fighters\", \"price\": 62, \"tax\": 20.2}, \"baz\": { \"name\": \"Baz\", \"description\": \"There goes my baz\", \"price\": 50.2, \"tax\": 10.5, }, } @app.get( \"/items/{item_id}/name\", response_model=Item, response_model_include={\"name\", \"description\"} ) async def read_item_name(item_id: str): return items[item_id] @app.get( \"/items/{item_id}/public\", response_model=Item, response_model_exclude={\"tax\"} ) async def read_item_public_data(item_id: str): return items[item_id] 额外的模型 对用户模型来说,拥有多个相关的模型是很常见的,因为： 输入模型需要拥有密码属性。 输出模型不应该包含密码。 数据库模型很可能需要保存密码的哈希值。 ","date":"2022-01-30","objectID":"/posts/fastapi-2/:8:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"多模型处理 from typing import Optional from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserIn(BaseModel): username: str password: str email: EmailStr full_name: Optional[str] = None class UserOut(BaseModel): username: str email: EmailStr full_name: Optional[str] = None class UserInDB(BaseModel): username: str hashed_password: str email: EmailStr full_name: Optional[str] = None def fake_password_hasher(raw_password: str): return \"supersecret\" + raw_password def fake_save_user(user_in: UserIn): hashed_password = fake_password_hasher(user_in.password) user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password) print(\"User saved! ..not really\") return user_in_db @app.post(\"/user/\", response_model=UserOut) async def create_user(user_in: UserIn): user_saved = fake_save_user(user_in) return user_saved ","date":"2022-01-30","objectID":"/posts/fastapi-2/:9:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"user_in.dict() user_in 是一个 UserIn 类的 Pydantic 模型. Pydantic 模型具有 .dict（） 方法，该方法返回一个拥有模型数据的 dict。 ","date":"2022-01-30","objectID":"/posts/fastapi-2/:10:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"解包 dict 如果我们将 user_dict 这样的 dict 以 **user_dict 形式传递给一个函数（或类），Python将对其进行「解包」。它会将 user_dict 的键和值作为关键字参数直接传递。 UserInDB(**user_dict) 会产生类似于以下的结果： UserInDB( username=\"john\", password=\"secret\", email=\"john.doe@example.com\", full_name=None, ) ","date":"2022-01-30","objectID":"/posts/fastapi-2/:11:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"解包 dict 和额外关键字 然后添加额外的关键字参数 hashed_password=hashed_password，例如： UserInDB(**user_in.dict(), hashed_password=hashed_password) …最终的结果如下： UserInDB( username = user_dict[\"username\"], password = user_dict[\"password\"], email = user_dict[\"email\"], full_name = user_dict[\"full_name\"], hashed_password = hashed_password, ) ","date":"2022-01-30","objectID":"/posts/fastapi-2/:12:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"模型的继承 from typing import Optional from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserBase(BaseModel): username: str email: EmailStr full_name: Optional[str] = None class UserIn(UserBase): password: str class UserOut(UserBase): pass class UserInDB(UserBase): hashed_password: str def fake_password_hasher(raw_password: str): return \"supersecret\" + raw_password def fake_save_user(user_in: UserIn): hashed_password = fake_password_hasher(user_in.password) user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password) print(\"User saved! ..not really\") return user_in_db @app.post(\"/user/\", response_model=UserOut) async def create_user(user_in: UserIn): user_saved = fake_save_user(user_in) return user_saved ","date":"2022-01-30","objectID":"/posts/fastapi-2/:13:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"模型列表 你可以用同样的方式声明由对象列表构成的响应。 为此，请使用标准的 Python typing.List： from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str items = [ {\"name\": \"Foo\", \"description\": \"There comes my hero\"}, {\"name\": \"Red\", \"description\": \"It's my aeroplane\"}, ] @app.get(\"/items/\", response_model=List[Item]) async def read_items(): return items ","date":"2022-01-30","objectID":"/posts/fastapi-2/:14:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"dict 构成的响应 你还可以使用一个任意的普通 dict 声明响应，仅声明键和值的类型，而不使用 Pydantic 模型。 如果你事先不知道有效的字段/属性名称（对于 Pydantic 模型是必需的），这将很有用。 在这种情况下，你可以使用 typing.Dict： from typing import Dict from fastapi import FastAPI app = FastAPI() @app.get(\"/keyword-weights/\", response_model=Dict[str, float]) async def read_keyword_weights(): return {\"foo\": 2.3, \"bar\": 3.4} 响应状态码 from fastapi import FastAPI app = FastAPI() @app.post(\"/items/\", status_code=201) async def create_item(name: str): return {\"name\": name} 接收表单数据 依赖安装 pip install python-multipart 对于接收的数据类型不是JSON而是表单Form from fastapi import FastAPI, Form app = FastAPI() @app.post(\"/login/\") async def login(username: str = Form(...), password: str = Form(...)): return {\"username\": username} ","date":"2022-01-30","objectID":"/posts/fastapi-2/:15:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"请求文件 from fastapi import FastAPI, File, UploadFile app = FastAPI() @app.post(\"/files/\") async def create_file(file: bytes = File(...)): return {\"file_size\": len(file)} @app.post(\"/uploadfile/\") async def create_upload_file(file: UploadFile = File(...)): return {\"filename\": file.filename} 建议使用UploadFile而不使用bytes UploadFile 与 bytes 相比有更多优势： 使用spooled文件： 存储在内存的文件超出最大上限时，FastAPI 会把文件存入磁盘； 这种方式更适于处理图像、视频、二进制文件等大型文件，好处是不会占用所有内存； 可获取上传文件的元数据； 自带 file-like``async 接口； 暴露的 Python SpooledTemporaryFile对象，可直接传递给其他预期「file-like」对象的库。 ","date":"2022-01-30","objectID":"/posts/fastapi-2/:16:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"UploadFile UploadFile 的属性如下： filename：上传文件名字符串（str），例如， myimage.jpg； content_type：内容类型（MIME 类型 / 媒体类型）字符串（str），例如，image/jpeg； file： SpooledTemporaryFile。其实就是 Python文件，可直接传递给其他预期 file-like 对象的函数或支持库。 UploadFile 支持以下 async 方法，（使用内部 SpooledTemporaryFile）可调用相应的文件方法。 write(data)：把 data （str 或 bytes）写入文件； read(size)：按指定数量的字节或字符（size (int)）读取文件内容； seek(offset)：移动至文件offset（int）字节处的位置； 例如，await myfile.seek(0) 移动到文件开头； 执行 await myfile.read() 后，需再次读取已读取内容时，这种方法特别好用； close()：关闭文件。 因为上述方法都是 async 方法，要搭配「await」使用。 例如，在 async 路径操作函数 内，要用以下方式读取文件内容： contents = await myfile.read() 在普通 def 路径操作函数 内，则可以直接访问 UploadFile.file，例如： contents = myfile.file.read() ","date":"2022-01-30","objectID":"/posts/fastapi-2/:16:1","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"多文件上传 可用同一个「表单字段」发送含多个文件的「表单数据」。 上传多个文件时，要声明含 bytes 或 UploadFile 的列表（List）： from typing import List from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse app = FastAPI() @app.post(\"/files/\") async def create_files(files: List[bytes] = File(...)): return {\"file_sizes\": [len(file) for file in files]} @app.post(\"/uploadfiles/\") async def create_upload_files(files: List[UploadFile] = File(...)): return {\"filenames\": [file.filename for file in files]} @app.get(\"/\") async def main(): content = \"\"\" \u003cbody\u003e \u003cform action=\"/files/\" enctype=\"multipart/form-data\" method=\"post\"\u003e \u003cinput name=\"files\" type=\"file\" multiple\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003cform action=\"/uploadfiles/\" enctype=\"multipart/form-data\" method=\"post\"\u003e \u003cinput name=\"files\" type=\"file\" multiple\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \"\"\" return HTMLResponse(content=content) ","date":"2022-01-30","objectID":"/posts/fastapi-2/:17:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"File和Form同时上传 from fastapi import FastAPI, File, Form, UploadFile app = FastAPI() @app.post(\"/files/\") async def create_file( file: bytes = File(...), fileb: UploadFile = File(...), token: str = Form(...) ): return { \"file_size\": len(file), \"token\": token, \"fileb_content_type\": fileb.content_type, } 错误处理 ","date":"2022-01-30","objectID":"/posts/fastapi-2/:18:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"使用 HTTPException 向客户端返回 HTTP 错误响应，可以使用 HTTPException。 from fastapi import FastAPI, HTTPException app = FastAPI() items = {\"foo\": \"The Foo Wrestlers\"} @app.get(\"/items/{item_id}\") async def read_item(item_id: str): if item_id not in items: raise HTTPException(status_code=404, detail=\"Item not found\") return {\"item\": items[item_id]} ","date":"2022-01-30","objectID":"/posts/fastapi-2/:19:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["FastAPI"],"content":"覆盖 HTTPException 错误处理器 同理，也可以覆盖 HTTPException 处理器。 例如，只为错误返回纯文本响应，而不是返回 JSON 格式的内容： from fastapi import FastAPI, HTTPException from fastapi.exceptions import RequestValidationError from fastapi.responses import PlainTextResponse from starlette.exceptions import HTTPException as StarletteHTTPException app = FastAPI() @app.exception_handler(StarletteHTTPException) async def http_exception_handler(request, exc): return PlainTextResponse(str(exc.detail), status_code=exc.status_code) @app.exception_handler(RequestValidationError) async def validation_exception_handler(request, exc): return PlainTextResponse(str(exc), status_code=400) @app.get(\"/items/{item_id}\") async def read_item(item_id: int): if item_id == 3: raise HTTPException(status_code=418, detail=\"Nope! I don't like 3.\") return {\"item_id\": item_id} ​ ","date":"2022-01-30","objectID":"/posts/fastapi-2/:20:0","tags":["FastAPI基础"],"title":"FastAPI-2","uri":"/posts/fastapi-2/"},{"categories":["Vue"],"content":"入门Vue! ","date":"2022-01-19","objectID":"/posts/vue-1/:0:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"脚手架创建项目 vue create vue-el-plus-demo npm run server ","date":"2022-01-19","objectID":"/posts/vue-1/:1:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"快速删除node_modules # 安装插件（已经安装，不用反复依赖） npm install rimraf -g # 切到到工程目录下 rimraf node_modules # 等到删除即可 ","date":"2022-01-19","objectID":"/posts/vue-1/:2:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"使用vite创建vue3-js项目 npm init vite@latest my-vue-app --template vue npm install ","date":"2022-01-19","objectID":"/posts/vue-1/:3:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"路由 ","date":"2022-01-19","objectID":"/posts/vue-1/:4:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"安装 npm i --save vue-router@next ","date":"2022-01-19","objectID":"/posts/vue-1/:4:1","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"router.index.js import { createRouter, createWebHistory } from 'vue-router' const routes = [ { path: '/', name: 'Home', component: () =\u003e import('../views/Home.vue') }, { path: '/login', name: 'Login', component: () =\u003e import('../views/LoginRegister.vue') }, { path: '/:catchAll(.*)', name: '/404', component: () =\u003e import('../views/404.vue') } ] const router = createRouter({ history: createWebHistory(process.env.BASE_URL), routes }) export default router ","date":"2022-01-19","objectID":"/posts/vue-1/:4:2","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"解决WebStorm识别不到“@”符号路径问题 { \"compilerOptions\": { \"target\": \"es6\", \"baseUrl\": \".\", \"paths\": { \"@/*\": [\"src/*\"] } }, \"exclude\": [\"node_modules\", \"dist\"], \"include\": [\"src/**/*\"] } ","date":"2022-01-19","objectID":"/posts/vue-1/:5:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"reset.css ","date":"2022-01-19","objectID":"/posts/vue-1/:6:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"安装scss npm install -g sass ","date":"2022-01-19","objectID":"/posts/vue-1/:7:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"弹窗 \u003cscript\u003e import {reactive} from \"vue/dist/vue\"; import {ElMessage} from \"element-plus\"; export default { name: 'App', setup() { let data = reactive({ name: '范坚强', obj: { age: 28 } }) function handleTab() { ElMessage('this is a message.') } return { data, handleTab } } } \u003c/script\u003e ","date":"2022-01-19","objectID":"/posts/vue-1/:7:1","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"vite导入组件 // 需要使用拓展名 import navbar from '@/views/navbar.vue' 构建项目流程 ","date":"2022-01-19","objectID":"/posts/vue-1/:7:2","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"安装yarn npm install -g yarn ","date":"2022-01-19","objectID":"/posts/vue-1/:8:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"安装依赖(deprecated) npm init vite-app project-name # 初始化项目 cd project-name yarn # 安装依赖 npm i -S typescript vue-router@next # 安装ts支持和router yarn add element-plus ","date":"2022-01-19","objectID":"/posts/vue-1/:9:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"安装依赖 # vite@latest 是正式版 npm init vite@latest project-name cd project-name yarn npm i -S typescript vue-router@next # 安装ts支持和router yarn add element-plus yarn add @element-plus/icons npm install @element-plus/icons-vue ","date":"2022-01-19","objectID":"/posts/vue-1/:10:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"配置ts npx tsc --init 创建tsconfig.json文件 把根目录下的main.js文件改名为main.ts 把根目录下的index.html中引入的main.js改名为main.ts 同时把.vue文件里的\u003cscript\u003e标签中加入lang=\"ts\" 在项目根目录创建shim.d.ts文件，同时在其中写入以下代码，用于配置ts支持识别.vue文件 declare module \"*.vue\" { import { Component } from \"vue\"; const component: Component; export default component; } ","date":"2022-01-19","objectID":"/posts/vue-1/:11:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"配置router： 在src下建立router目录并在其中创建index.ts文件，并在其中写入（此处的地址为自己在根目录创建views文件夹下创建index.vue文件，可根据自己需要创建） import { RouteRecordRaw, createRouter, createWebHistory } from \"vue-router\"; const routes: RouteRecordRaw[] = [ { path: \"/\", name: \"Home\", component: import(\"../views/index.vue\"), }, ]; const router = createRouter({ history: createWebHistory(process.env.BASE_URL), routes, }); export default router; 修改main.ts文件引入vue-router import { createApp } from \"vue\"; import App from \"./App.vue\"; import router from \"./router/index\"; createApp(App).use(router).mount(\"#app\"); ","date":"2022-01-19","objectID":"/posts/vue-1/:12:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"TS 导出组件 ","date":"2022-01-19","objectID":"/posts/vue-1/:13:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"安装依赖 yarn add vue-property-decorator ","date":"2022-01-19","objectID":"/posts/vue-1/:13:1","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"加载组件 import {Component, Vue} from 'vue-property-decorator' import MenuBar from ... @Component({ components: { MenuBar }, }) export default class App extends Vue {} ","date":"2022-01-19","objectID":"/posts/vue-1/:13:2","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Vue"],"content":"ts父子组件传值 Array 可以写成 Array as PropType\u003coneType[]\u003e Object 可以写成 Object as PropType\u003coneType\u003e 然后你可以定义你的type oneType = {} PropType 从vue 导入 Tips 路由使用提前加载,如果使用按需加载会出现闪屏 提前加载 import about from '../view/about.vue' { path: '/about', name: 'about', component: about, } 按需加载 { path: '/about', name: 'about', component: ()=\u003eimport(\"../view/about.vue\"), } ","date":"2022-01-19","objectID":"/posts/vue-1/:14:0","tags":["Vue"],"title":"Vue基础入门","uri":"/posts/vue-1/"},{"categories":["Git"],"content":"讲个笑话,都快2202年了,我还不会推新库… 推送到Github 现在github改成了main…好久没有推新库了,有点懵,今天整理了一下推送代码到github 首先在github上新建repository git remote add origin https://url ","date":"2021-12-30","objectID":"/posts/git-4/:0:0","tags":["Git基础"],"title":"推送到Github","uri":"/posts/git-4/"},{"categories":["Git"],"content":"查看分支情况 git branch -a ","date":"2021-12-30","objectID":"/posts/git-4/:1:0","tags":["Git基础"],"title":"推送到Github","uri":"/posts/git-4/"},{"categories":["Git"],"content":"创建main分支 创建并切换分支到main git checkout -b main ","date":"2021-12-30","objectID":"/posts/git-4/:2:0","tags":["Git基础"],"title":"推送到Github","uri":"/posts/git-4/"},{"categories":["Git"],"content":"删除本地master分支 git branch -D master ","date":"2021-12-30","objectID":"/posts/git-4/:3:0","tags":["Git基础"],"title":"推送到Github","uri":"/posts/git-4/"},{"categories":["Git"],"content":"将remote的pull下来 git pull origin main --allow-unrelated-histories ","date":"2021-12-30","objectID":"/posts/git-4/:4:0","tags":["Git基础"],"title":"推送到Github","uri":"/posts/git-4/"},{"categories":["Git"],"content":"推送remote git push -u origin main -f 设置.git文件自定义路径 path为.git文件的路径 git init --separate-git-dir = path 设置git推送通过代理端口 查看代理端口 例如 port: 7890 git config --global http.proxy http://127.0.0.1:7890 设置代理 git config --global http.proxy #查看git的http代理配置 git config --global https.proxy #查看git的https代理配置 git config --global -l #查看git的所有配置 取消全局代理： git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2021-12-30","objectID":"/posts/git-4/:5:0","tags":["Git基础"],"title":"推送到Github","uri":"/posts/git-4/"},{"categories":["win"],"content":"OneDrive小技巧 今天发现了一个小技巧…简直吹爆! 不过怎么依稀记得之前也学到过…但是一直没用起来 由于onedrive同步的文件都在一个文件夹下,因此如果想要同步单独的文件夹,只能通过mklink来实现 mklink命令 ","date":"2021-12-30","objectID":"/posts/win-23/:0:0","tags":["OneDrive"],"title":"OneDrive创建文件同步","uri":"/posts/win-23/"},{"categories":["win"],"content":"简介 NTFS 符号链接又称“符号链接”，是 NTFS 文件系统中指向文件系统中的另一个对象的一类对象，被指向的对象叫做“目标”。mklink 是 Windows 下用于创建符号链接的工具，存在于 Windows Vista 及以后版本的 Windows 操作系统中。 ","date":"2021-12-30","objectID":"/posts/win-23/:1:0","tags":["OneDrive"],"title":"OneDrive创建文件同步","uri":"/posts/win-23/"},{"categories":["win"],"content":"使用方式 MKLINK [[/D] | [/H] | [/J]] Link Target 说明： /D 创建目录符号链接而不是文件符号链接（默认为文件符号链接） /H 创建硬链接而不是符号链接 /J 创建目录连接点 Link 指定新的符号链接名称 Target 指定新链接引用的路径（绝对路径或者相对路径均可） ","date":"2021-12-30","objectID":"/posts/win-23/:2:0","tags":["OneDrive"],"title":"OneDrive创建文件同步","uri":"/posts/win-23/"},{"categories":["win"],"content":"注意 参数 Link 和 Target 要求不能使用 Windows 中不允许用作文件名的字符（\\ / : * ? \" \u003c \u003e |）。并且如果 Link 和 Target 这两个参数中需要包含空格，则必须使用英文双引号将内容引起来，以避免参数识别错误。 使用 mklink /d C:\\OneDrive\\File E:\\File # 将E盘下的File文件,同步到Onedrive中的File下 需要注意的是,在mklink时,onedrive文件下不能有File文件夹,该文件夹是通过mklink命令创建的 ","date":"2021-12-30","objectID":"/posts/win-23/:3:0","tags":["OneDrive"],"title":"OneDrive创建文件同步","uri":"/posts/win-23/"},{"categories":["Ubuntu"],"content":"Ubuntu20.04搭建FTP服务 搭建FTP服务 ","date":"2021-12-30","objectID":"/posts/ubuntu-33/:0:0","tags":["Linux-Ubuntu","FTP"],"title":"Ubuntu搭建FTP","uri":"/posts/ubuntu-33/"},{"categories":["Ubuntu"],"content":"安装VSFTPD apt-get install vsftpd -y ","date":"2021-12-30","objectID":"/posts/ubuntu-33/:1:0","tags":["Linux-Ubuntu","FTP"],"title":"Ubuntu搭建FTP","uri":"/posts/ubuntu-33/"},{"categories":["Ubuntu"],"content":"启动 netstat -nltp | grep 21 # systemctl start vsftpd.service 手动开启 ","date":"2021-12-30","objectID":"/posts/ubuntu-33/:2:0","tags":["Linux-Ubuntu","FTP"],"title":"Ubuntu搭建FTP","uri":"/posts/ubuntu-33/"},{"categories":["Ubuntu"],"content":"VSFTPD服务开机启动 systemctl enable vsftpd.service ","date":"2021-12-30","objectID":"/posts/ubuntu-33/:3:0","tags":["Linux-Ubuntu","FTP"],"title":"Ubuntu搭建FTP","uri":"/posts/ubuntu-33/"},{"categories":["Ubuntu"],"content":"设置访问目录 一般FTP服务都是访问部分目录（比如一个共享文件夹），不可能访问整个系统，所以最好单独建立单独的FTP用户及访问目录。 - 新建访问目录（/home/ftp）,当然也可以用其他名称，以下以ftp为例 mkdir /home/ftp ","date":"2021-12-30","objectID":"/posts/ubuntu-33/:4:0","tags":["Linux-Ubuntu","FTP"],"title":"Ubuntu搭建FTP","uri":"/posts/ubuntu-33/"},{"categories":["Ubuntu"],"content":"设置单独的用户访问 # 新建用户 useradd -d /home/ftp -s /bin/bash ftpuser # 设置密码 passwd ftpuser # 删除掉pam.d 中的 vsftpd , 因为该配置文件会导致登录失败： rm /etc/pam.d/vsftpd # 限制该用户只能通过FTP 访问 usermod -s /sbin/nologin ftpuser ","date":"2021-12-30","objectID":"/posts/ubuntu-33/:5:0","tags":["Linux-Ubuntu","FTP"],"title":"Ubuntu搭建FTP","uri":"/posts/ubuntu-33/"},{"categories":["Ubuntu"],"content":"配置vsftpd vsftpd 配置文件为 /etc/vsftpd.conf。首先增加可写权限：sudo chmod a+w /etc/vsftpd.conf 。配置包括限制用户对主目录外的访问、 指定允许访问用户的配置文件、使用utf8编码等。可直接将以下内容拷贝到配置文件最下方： # 限制用户对主目录以外目录访问 chroot_local_user=YES # 指定一个 userlist 存放允许访问 ftp 的用户列表 userlist_deny=NO userlist_enable=YES # 记录允许访问 ftp 用户列表 userlist_file=/etc/vsftpd.user_list # 不配置可能导致莫名的530问题 seccomp_sandbox=NO # 允许文件上传 write_enable=YES # 使用utf8编码 utf8_filesystem=YES ","date":"2021-12-30","objectID":"/posts/ubuntu-33/:6:0","tags":["Linux-Ubuntu","FTP"],"title":"Ubuntu搭建FTP","uri":"/posts/ubuntu-33/"},{"categories":["Ubuntu"],"content":"新增可访问用户列表 新建文件/etc/vsftpd.user_list存放允许访问ftp的用户。上面我们只建立了一个用户：ftpuser，所以文件内容应该仅有一行： ftpuser 若想有多个用户，可以按照以上步骤建立，并加到该文件中，每行一个用户 ","date":"2021-12-30","objectID":"/posts/ubuntu-33/:7:0","tags":["Linux-Ubuntu","FTP"],"title":"Ubuntu搭建FTP","uri":"/posts/ubuntu-33/"},{"categories":["Python"],"content":"多线程下载PDF文件 多线程下载PDF文件 from Exc_xl import readexcel import requests from concurrent.futures import ThreadPoolExecutor, as_completed data_num = 11681 data = readexcel('./res_data/GetReportInfo2.xlsx', data_num) supplier_name = data['Orgname'] executor = ThreadPoolExecutor(max_workers=500) # 线程池500 def download_pdf(tmp_url, tmp_name): r = requests.get(tmp_url) fo = open(r'./FTP_data/' + str(tmp_name) + '.pdf', 'wb') fo.write(r.content) fo.close() print(\"success \" + tmp_name) threads = [] for index, url in enumerate(data['ReportUrl']): suburl = url name = supplier_name[index] args = [url, name] thread_spider = executor.submit(lambda p: download_pdf(*p), args) threads.append(thread_spider) count = 1 for future in as_completed(threads): #data = future.result() print('当前进度: %s/ %s' % (count, str(data_num))) count = count + 1 ","date":"2021-12-30","objectID":"/posts/python-10/:0:0","tags":["多线程"],"title":"Pyhton实现下载PDF","uri":"/posts/python-10/"},{"categories":["win"],"content":"便捷小脚本 辣鸡网易云在歌单的曲目设置了1000首的限制,因此如果歌单超过了1k首,就会无法全量导入 只能通过编写magic完成 安装Nodejs接口 NeteaseCloudMusicApi] git clone git@github.com:Binaryify/NeteaseCloudMusicApi.git npm install # 安装依赖 node app.js # 运行 获取歌单全部歌曲 调用接口: /playlist/detail **官方解释: ** 说明 : 歌单能看到歌单名字, 但看不到具体歌单内容 , 调用此接口 , 传入歌单 id, 可 以获取对应歌单内的所有的音乐(未登录状态只能获取不完整的歌单,登录后是完整的)，但是返回的 trackIds 是完整的，tracks 则是不完整的，可拿全部 trackIds 请求一次 song/detail 接口获取所有歌曲的详情 因此将返回的的response数据保存到本地 解析歌曲详细内容 调用接口: /song/detail?ids= import urllib import requests import json headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36', } def readJson(filename): with open(filename, \"r\", encoding='utf-8') as f: loaded_dic = json.load(f) return loaded_dic json_data = readJson('response.json') id_list = [] for row in json_data['playlist']['trackIds']: tmp_id = row['id'] id_list.append(tmp_id) print(len(id_list)) unit = len(id_list)/70 pre_count = 0 count = unit json_shit = None writer = open('res.txt', \"w\", encoding='utf-8') for a in range(0, 69): url = 'http://localhost:3000/song/detail?ids=' test_list = id_list[int(pre_count):int(count)] for i, row in enumerate(test_list): if len(test_list) \u003e i \u003e 0: url = url + \",\"+str(row) else: url = url + str(row) get_response = requests.get(url, headers=headers, params=None) try: json_shit = get_response.json()['songs'] except Exception as e: print(get_response) print(str(e)) for row in json_shit: try: writer.writelines(row['name'] + \"-\" + row['ar'][0]['name']+'\\n') except Exception as e: print(str(e)) pre_count = count count += unit writer.close() 得到res.txt文件 My Imotion (Original Mix)-Sashoook Alone Again (Radio Edit)-Capcha One Legendary-Epic Soul Factory Bring Back the Summer (feat. OLY)-Rain Man Shine-Canvai One Shot (Typhoon) (Album Edit)-Julian Calor Invaders (Original Mix)-Hinkik ... 导入Apple Music 使用歌曲导入网站Tunemymusic tunemymusic ","date":"2021-12-29","objectID":"/posts/win-22/:0:0","tags":["网易云"],"title":"AppleMusic导入全量网易云","uri":"/posts/win-22/"},{"categories":["FastAPI"],"content":"FastAPI-文档 安装 pip install fastapi pip install uvicorn[standard] 调试 ","date":"2021-12-28","objectID":"/posts/fastapi-1/:0:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"运行测试服务 uvicorn main:app --reload uvicorn main:app 命令含义如下: main：main.py 文件（一个 Python「模块」）。 app：在 main.py 文件中通过 app = FastAPI() 创建的对象。 --reload：让服务器在更新代码后重新启动。仅在开发时使用该选项。 接口文档 ","date":"2021-12-28","objectID":"/posts/fastapi-1/:1:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"Docs http://127.0.0.1:8000/docs ","date":"2021-12-28","objectID":"/posts/fastapi-1/:2:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"Redoc http://127.0.0.1:8000/redoc 接口参数 ","date":"2021-12-28","objectID":"/posts/fastapi-1/:3:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"初始化 from fastapi import FastAPI from typing import Optional # 可选参数 from pydantic import BaseModel # 使用模型 app = FastAPI() ","date":"2021-12-28","objectID":"/posts/fastapi-1/:4:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"路径参数 ","date":"2021-12-28","objectID":"/posts/fastapi-1/:5:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"裸奔版 @app.get(\"/items/{item_id}\") async def read_item(item_id): return {\"item_id\": item_id} ","date":"2021-12-28","objectID":"/posts/fastapi-1/:6:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"参数类型验证 @app.get(\"/items/{item_id}\") async def read_item(item_id: int): return {\"item_id\": item_id} ","date":"2021-12-28","objectID":"/posts/fastapi-1/:7:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"接口调用顺序 由于路径操作是按顺序依次运行的，需要确保路径 /users/me 声明在路径 /users/{user_id}否则，/users/{user_id} 的路径还将与 /users/me 相匹配，“认为\"自己正在接收一个值为 \"me\" 的 user_id 参数。 @app.get(\"/users/me\") async def read_user_me(): return {\"user_id\": \"the current user\"} @app.get(\"/users/{user_id}\") async def read_user(user_id: str): return {\"user_id\": user_id} ","date":"2021-12-28","objectID":"/posts/fastapi-1/:8:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"参数预设值 from enum import Enum from fastapi import FastAPI # 继承于str,枚举元素只能为str类型 class ModelName(str, Enum): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI() @app.get(\"/models/{model_name}\") async def get_model(model_name: ModelName): if model_name == ModelName.alexnet: return {\"model_name\": model_name, \"message\": \"Deep Learning FTW!\"} # 通过value属性获得真实值 if model_name.value == \"lenet\": return {\"model_name\": model_name, \"message\": \"LeCNN all the images\"} ","date":"2021-12-28","objectID":"/posts/fastapi-1/:9:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"参数查询 fake_items_db = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}] @app.get(\"/items/\") async def read_item(skip: int = 0, limit: int = 10): return fake_items_db[skip : skip + limit] # http://127.0.0.1:8000/items/?skip=0\u0026limit=10 ","date":"2021-12-28","objectID":"/posts/fastapi-1/:10:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"可选参数 @app.get(\"/items/{item_id}\") async def read_item(item_id: str, q: Optional[str] = None): if q: return {\"item_id\": item_id, \"q\": q} return {\"item_id\": item_id} # Optional[str] 其中可选参数的类型为str ","date":"2021-12-28","objectID":"/posts/fastapi-1/:11:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"多路径参数 @app.get(\"/users/{user_id}/items/{item_id}\") async def read_user_item( user_id: int, item_id: str, q: Optional[str] = None, short: bool = False ): item = {\"item_id\": item_id, \"owner_id\": user_id} if q: item.update({\"q\": q}) if not short: item.update( {\"description\": \"This is an amazing item that has a long description\"} ) return item ","date":"2021-12-28","objectID":"/posts/fastapi-1/:12:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"请求体+路径参数 FastAPI 将识别出与路径参数匹配的函数参数应从路径中获取，而声明为 Pydantic 模型的函数参数应从请求体中获取 class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None app = FastAPI() @app.put(\"/items/{item_id}\") async def create_item(item_id: int, item: Item): return {\"item_id\": item_id, **item.dict()} ","date":"2021-12-28","objectID":"/posts/fastapi-1/:13:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"请求体 + 路径参数 + 查询参数 class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None app = FastAPI() @app.put(\"/items/{item_id}\") async def create_item(item_id: int, item: Item, q: Optional[str] = None): result = {\"item_id\": item_id, **item.dict()} if q: result.update({\"q\": q}) return result ","date":"2021-12-28","objectID":"/posts/fastapi-1/:14:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"使用Path接收参数 路径参数总是必需的，因为它必须是路径的一部分。 所以，你应该在声明时使用 ... 将其标记为必需参数。 然而，即使你使用 None 声明路径参数或设置一个其他默认值也不会有任何影响，它依然会是必需参数 from fastapi import FastAPI, Path app = FastAPI() @app.get(\"/items/{item_id}\") async def read_items( q: str, item_id: int = Path(..., title=\"The ID of the item to get\") ): results = {\"item_id\": item_id} if q: results.update({\"q\": q}) return results ","date":"2021-12-28","objectID":"/posts/fastapi-1/:15:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"参数列表 @app.get(\"/items/\") # async def read_items(q: Optional[List[str]] = Query(None)): async def read_items(q: List[str] = Query([\"foo\", \"bar\"])): # 默认值为[\"foo\", \"bar\"] query_items = {\"q\": q} return query_items # http://localhost:8000/items/?q=foo\u0026q=bar \"\"\" response { \"q\": [ \"foo\", \"bar\" ] } \"\"\" 参数校验 ","date":"2021-12-28","objectID":"/posts/fastapi-1/:16:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"字符长度校验 from typing import Optional from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") # 最小长度为3, 最大长度为50 默认值为 \"fixedquery\" async def read_items(q: Optional[str] = Query(\"fixedquery\", min_length=3, max_length=50)): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results ","date":"2021-12-28","objectID":"/posts/fastapi-1/:17:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"参数列表不检查类型 @app.get(\"/items/\") async def read_items(q: list = Query([])): query_items = {\"q\": q} return query_items ","date":"2021-12-28","objectID":"/posts/fastapi-1/:18:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"增加接口描述 title和description 这些信息将包含在生成的 OpenAPI 模式中，并由文档用户界面和外部工具所使用 @app.get(\"/items/\") async def read_items( q: Optional[str] = Query( None, title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, ) ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results ","date":"2021-12-28","objectID":"/posts/fastapi-1/:19:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"别名参数 假设你想要查询参数为 item-query。 http://127.0.0.1:8000/items/?item-query=foobaritems 但是 item-query 不是一个有效的 Python 变量名称。最接近的有效名称是 item_query。 但是你仍然要求它在 URL 中必须是 item-query… 这时你可以用 alias 参数声明一个别名，该别名将用于在 URL 中查找查询参数值： @app.get(\"/items/\") async def read_items(q: Optional[str] = Query(None, alias=\"item-query\")): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results ","date":"2021-12-28","objectID":"/posts/fastapi-1/:20:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"数值校验 gt：大于（greater than） ge：大于等于（greater than or equal） lt：小于（less than） le：小于等于（less than or equal） @app.get(\"/items/{item_id}\") async def read_items( *, item_id: int = Path(..., title=\"The ID of the item to get\", ge=1), q: str ): results = {\"item_id\": item_id} if q: results.update({\"q\": q}) return results ","date":"2021-12-28","objectID":"/posts/fastapi-1/:21:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"浮点数校验 @app.get(\"/items/{item_id}\") async def read_items( *, item_id: int = Path(..., title=\"The ID of the item to get\", ge=0, le=1000), q: str, size: float = Query(..., gt=0, lt=10.5) ): results = {\"item_id\": item_id} if q: results.update({\"q\": q}) return results ","date":"2021-12-28","objectID":"/posts/fastapi-1/:22:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["FastAPI"],"content":"在Pydantic内部校验 class Item(BaseModel): name: str description: Optional[str] = Field( None, title=\"The description of the item\", max_length=300 ) price: float = Field(..., gt=0, description=\"The price must be greater than zero\") tax: Optional[float] = None @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item = Body(..., embed=True)): results = {\"item_id\": item_id, \"item\": item} return results 实际上，Query、Path 和其他你将在之后看到的类，创建的是由一个共同的 Params 类派生的子类的对象，该共同类本身又是 Pydantic 的 FieldInfo 类的子类。 Pydantic 的 Field 也会返回一个 FieldInfo 的实例。 Body 也直接返回 FieldInfo 的一个子类的对象。还有其他一些你之后会看到的类是 Body 类的子类。 请记住当你从 fastapi 导入 Query、Path 等对象时，他们实际上是返回特殊类的函数。 注意每个模型属性如何使用类型、默认值和 Field 在代码结构上和路径操作函数的参数是相同的，区别是用 Field 替换Path、Query 和 Body。 ","date":"2021-12-28","objectID":"/posts/fastapi-1/:23:0","tags":["FastAPI基础"],"title":"FastAPI","uri":"/posts/fastapi-1/"},{"categories":["Git"],"content":"gitignore文件的使用 ","date":"2021-12-25","objectID":"/posts/git-5/:0:0","tags":["Github"],"title":"gitignore配置","uri":"/posts/git-5/"},{"categories":["Git"],"content":"刷新gitignore文件 git rm-r --cached . git add . git commit -m 'update .gitignore' ","date":"2021-12-25","objectID":"/posts/git-5/:1:0","tags":["Github"],"title":"gitignore配置","uri":"/posts/git-5/"},{"categories":["Git"],"content":"规则 常用的规则 /mtk/ # 过滤整个文件夹 *.zip # 过滤所有.zip文件 /mtk/do.c # 过滤某个具体文件 指定要将哪些文件添加到版本管理中 !src/ # 不过滤该文件夹 !*.zip # 不过滤所有.zip文件 !/mtk/do.c # 不过滤该文件 ","date":"2021-12-25","objectID":"/posts/git-5/:2:0","tags":["Github"],"title":"gitignore配置","uri":"/posts/git-5/"},{"categories":["Git"],"content":"配置语法 以斜杠/开头表示目录； 以星号*通配多个字符； 以问号?通配单个字符 以方括号[]包含单个字符的匹配列表； 以叹号!表示不忽略(跟踪)匹配到的文件或目录； 此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； ","date":"2021-12-25","objectID":"/posts/git-5/:3:0","tags":["Github"],"title":"gitignore配置","uri":"/posts/git-5/"},{"categories":["Git"],"content":"示例说明 ","date":"2021-12-25","objectID":"/posts/git-5/:4:0","tags":["Github"],"title":"gitignore配置","uri":"/posts/git-5/"},{"categories":["Git"],"content":"规则： fd1/* # 说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/* # 说明：忽略根目录下的 /fd1/ 目录的全部内容； /* !.gitignore !/fw/bin/ !/fw/sf/ # 说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录； ","date":"2021-12-25","objectID":"/posts/git-5/:4:1","tags":["Github"],"title":"gitignore配置","uri":"/posts/git-5/"},{"categories":["Ubuntu"],"content":"Ubuntu crontab 测试脚本 # 测试脚本 timer_test.py # 路径 /home/li/d/pythonwork/test/timer_test.py #coding:utf-8 import time t = time.strftime('%Y-%m-%d%H:%M:%S',time.localtime(time.time())) str = '执行时间：' + t + '\\n' print(str) 设定定时任务 sudo crontab -e */1 * * * * python /home/path/timer_test.py \u003e\u003e /home/path/testcrontab.log 2\u003e\u00261 # /home/path/testcrontab.log 为日志文件,程序的输出都在该文件中 查看脚本 sudo crontab -l 可看到自己编辑好的文件 时间参数解释 分钟 0 - 59 小时 0 - 23 天 1 - 31 月 1 - 12 星期 0 - 6 0表示星期天 除了这些固定值外，还可以配合星号（*），逗号（,），和斜线（/）来表示一些其他的含义： 星号：表示任意值，比如在小时部分填写 * 代表任意小时（每小时） 逗号：可以允许在一个部分中填写多个值，比如在分钟部分填写 1,3 表示一分钟或三分钟 斜线：一般配合 * 使用，代表每隔多长时间，比如在小时部分填写 */2 代表每隔两分钟。所以 */1 和 * 没有区别 * * * * * # 每隔一分钟执行一次任务 0 * * * * # 每小时的0分执行一次任务，比如6:00，10:00 6, 10 * 2 * * # 每个月2号，每小时的6分和10分执行一次任务 */3, */5 * * * * # 每隔3分钟或5分钟执行一次任务，比如10:03，10:05，10:06 0 7 * * * /bin/ls #每天早上7点执行一次 /bin/ls 0 6-12/3 * 12 * /usr/bin/backup #在 12 月内, 每天的早上 6 点到 12 点中，每隔3个小时执行一次 /usr/bin/backup 0 17 * * 1-5 mail -s \"hi\" alex@domain.name \u003c /tmp/maildata #周一到周五每天下午 5:00 寄一封信给 alex@domain.name 20 0-23/2 * * * echo \"haha\" \u003e\u003e /tmp/haha.txt #每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分....向 /tmp/haha.txt 文件中写入 haha ","date":"2021-12-23","objectID":"/posts/ubuntu-31/:0:0","tags":["Linux定时任务"],"title":"Ubuntu设定定时任务","uri":"/posts/ubuntu-31/"},{"categories":["Ubuntu"],"content":"Nginx 部署 hexo 安装环境 ","date":"2021-12-20","objectID":"/posts/ubuntu-32/:0:0","tags":["Linux-Ubuntu","Hexo"],"title":"云服务器部署hexo","uri":"/posts/ubuntu-32/"},{"categories":["Ubuntu"],"content":"安装Nginx和Git apt-get update apt-get install git nginx -y ","date":"2021-12-20","objectID":"/posts/ubuntu-32/:1:0","tags":["Linux-Ubuntu","Hexo"],"title":"云服务器部署hexo","uri":"/posts/ubuntu-32/"},{"categories":["Ubuntu"],"content":"建立文件 mkdir /var/repo/ # 修改权限 chown -R $USER:$USER /var/repo/ chmod -R 755 /var/repo/ ","date":"2021-12-20","objectID":"/posts/ubuntu-32/:2:0","tags":["Linux-Ubuntu","Hexo"],"title":"云服务器部署hexo","uri":"/posts/ubuntu-32/"},{"categories":["Ubuntu"],"content":"创建远程仓库 cd /var/repo git init --bare CloudHexo.git 配置Nginx文件目录 mkdir -p /var/www/hexo chown -R $USER:$USER /var/www/hexo chmod -R 755 /var/www/hexo 修改 Nginx 的 default 文件使得 root 指向刚刚创建的 /var/www/hexo目录： vim /etc/nginx/sites-available/default 替换为以下内容 server { listen 443 ssl; #填写绑定证书的域名 server_name tronwei.com; #证书文件名称 ssl_certificate cert/tronwei.com_bundle.crt; #私钥文件名称 ssl_certificate_key cert/tronwei.com.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。 #例如，您的网站运行目录在/etc/www下，则填写/etc/www。 root /var/www/hexo; index index.html index.htm; } } server { listen 80; #填写绑定证书的域名 server_name tronwei.com; #把http的域名请求转成https return 301 https://$host$request_uri; } 腾讯云部署证书 ","date":"2021-12-20","objectID":"/posts/ubuntu-32/:3:0","tags":["Linux-Ubuntu","Hexo"],"title":"云服务器部署hexo","uri":"/posts/ubuntu-32/"},{"categories":["Ubuntu"],"content":"重启 nginx 服务 service nginx restart 创建Git钩子(hooks) 执行下面的命令，在自动生成的ganahBlog.git/hooks 目录下创建一个新的钩子文件： vim /var/repo/CloudHexo.git/hooks/post-receive 打开文件后，加入下面的代码： #!/bin/bash git --work-tree=/var/www/hexo --git-dir=/var/repo/CloudHexo.git checkout -f 将文件保存（方法参加上文）后，赋予该文件可执行权限： chmod +x /var/repo/CloudHexo.git/hooks/post-receive 使用 Git 部署本地 Hexo 到远端服务器 服务器地址添加到受信任的站点，在本地任意目录从服务器上把hexo_static仓库克隆下来： git clone root@{云服务器IP}:/var/repo/CloudHexo.git 编辑站点配置文件_config.yml , 将 url 改成https://{云服务器IP}/ 将 deploy 目标改为 {服务器用户名}@{服务IP}:/var/repo/CloudHexo.git： hexo clean \u0026\u0026 hexo g -d # 部署 ","date":"2021-12-20","objectID":"/posts/ubuntu-32/:4:0","tags":["Linux-Ubuntu","Hexo"],"title":"云服务器部署hexo","uri":"/posts/ubuntu-32/"},{"categories":["Docker"],"content":"Docker 部署 Python 和 Mysql 环境 安装docker curl -sSL https://get.daocloud.io/docker | sh # 启动docker sudo service docker start 拉取镜像 docker pull ubuntu:20.04 docker pull mysql:8.0.26 操作镜像 ","date":"2021-12-19","objectID":"/posts/docker-6/:0:0","tags":["Docker基础"],"title":"部署Docker","uri":"/posts/docker-6/"},{"categories":["Docker"],"content":"查看host中的镜像 docker images ","date":"2021-12-19","objectID":"/posts/docker-6/:1:0","tags":["Docker基础"],"title":"部署Docker","uri":"/posts/docker-6/"},{"categories":["Docker"],"content":"删除指定id的镜像 docker rmi \u003cimage id\u003e 操作容器 ","date":"2021-12-19","objectID":"/posts/docker-6/:2:0","tags":["Docker基础"],"title":"部署Docker","uri":"/posts/docker-6/"},{"categories":["Docker"],"content":"停止容器 docker stop id ","date":"2021-12-19","objectID":"/posts/docker-6/:3:0","tags":["Docker基础"],"title":"部署Docker","uri":"/posts/docker-6/"},{"categories":["Docker"],"content":"删除容器 docker rm id 运行Image docker run -idt --name docker_ubuntu -d ubuntu:20.04 docker run -itd --name docker_mysql -p 3309:3306 -e MYSQL_ROOT_PASSWORD=980215 mysql:8.0.26 # 因为默认的3306端口被占用,所以调整为3309 -p 3309:3306：-p 宿主机端口:容器端口，即将宿主机3309端口映射到容器的3306端口，在宿主机登录容器数据库的时候，使用宿主机端口，如3309 MYSQL_ROOT_PASSWORD 为mysql的默认密码 进入ubuntu容器 ","date":"2021-12-19","objectID":"/posts/docker-6/:4:0","tags":["Docker基础"],"title":"部署Docker","uri":"/posts/docker-6/"},{"categories":["Docker"],"content":"查看容器id docker ps -a ","date":"2021-12-19","objectID":"/posts/docker-6/:5:0","tags":["Docker基础"],"title":"部署Docker","uri":"/posts/docker-6/"},{"categories":["Docker"],"content":"进入容器 docker exec -it 容器id /bin/bash apt update apt install software-properties-common add-apt-repository ppa:deadsnakes/ppa apt install python3.8 ln -s /usr/bin/python3.8 /usr/bin/python # 创建软连接 #win查看端口被占用情况 netstat -an ","date":"2021-12-19","objectID":"/posts/docker-6/:6:0","tags":["Docker基础"],"title":"部署Docker","uri":"/posts/docker-6/"},{"categories":["Docker"],"content":"进入mysql容器 #访问mysql docker exec -it mysql bash mysql -uroot -p123456 # 进入mysql终端 mysql -uroot -p123456 -h127.0.0.1 -P 3306 -D mysql # 修改密码 set password for 'username'@'host' = password('newpassword') ","date":"2021-12-19","objectID":"/posts/docker-6/:7:0","tags":["Docker基础"],"title":"部署Docker","uri":"/posts/docker-6/"},{"categories":["Docker"],"content":"退出容器 # Ctrl + D 退出容器 MySQL8连接的问题 使用DBeaver连接docker_mysql会产生报错 Public Key Retrieval is not allowed ","date":"2021-12-19","objectID":"/posts/docker-6/:8:0","tags":["Docker基础"],"title":"部署Docker","uri":"/posts/docker-6/"},{"categories":["Docker"],"content":"解决方式 报错是安全相关的问题，高版本mysql对安全的管理更加严格，在自己的开发环境下不用那么严格，于是解决思路就是允许其使用Public Key。右键建好的连接，选择编辑连接，找到驱动属性allowPublicKeyRetrieval，将其值设置为TRUE即可 run指令 ","date":"2021-12-19","objectID":"/posts/docker-6/:9:0","tags":["Docker基础"],"title":"部署Docker","uri":"/posts/docker-6/"},{"categories":["win"],"content":"便捷小工具 SwitchHost ","date":"2021-12-19","objectID":"/posts/win-11/:0:0","tags":["qrcp"],"title":"qrcp \u0026 SwitchHosts","uri":"/posts/win-11/"},{"categories":["win"],"content":"自动同步github host文件 scoop gitee文档地址 qrcp文件传输 Github项目地址 ","date":"2021-12-19","objectID":"/posts/win-11/:1:0","tags":["qrcp"],"title":"qrcp \u0026 SwitchHosts","uri":"/posts/win-11/"},{"categories":["win"],"content":"常用命令 ","date":"2021-12-19","objectID":"/posts/win-11/:2:0","tags":["qrcp"],"title":"qrcp \u0026 SwitchHosts","uri":"/posts/win-11/"},{"categories":["win"],"content":"发送文件 # 发送文件 qrcp MyDocument.pdf # 发送多个文件 Multiple files qrcp MyDocument.pdf IMG0001.jpg # 发送一个文件夹 qrcp Documents/ # 发送一个文件的压缩版本 qrcp --zip LongVideo.avi ","date":"2021-12-19","objectID":"/posts/win-11/:2:1","tags":["qrcp"],"title":"qrcp \u0026 SwitchHosts","uri":"/posts/win-11/"},{"categories":["win"],"content":"接收文件 # 接收文件 qrcp receive # 接收文件到指定目录 Note: the folder must exist qrcp receive --output=/tmp/dir ","date":"2021-12-19","objectID":"/posts/win-11/:2:2","tags":["qrcp"],"title":"qrcp \u0026 SwitchHosts","uri":"/posts/win-11/"},{"categories":["win"],"content":"scoop scoop是可用于windows的一款包管理工具，今天试着安装了一下，在这里记录一些遇到的问题和解决方法。 安装流程 先进入powershell，windows徽标键输入powershell或者cmd输入powershell均可 然后先输入以下代码，以保证后面的脚本有运行权限 Copyset-executionpolicy remotesigned -scope currentuser 然后开始正式安装 Copyiex (new-object net.webclient).downloadstring('https://get.scoop.sh') ","date":"2021-12-18","objectID":"/posts/win-12/:0:0","tags":["win"],"title":"安装scoop包管理器","uri":"/posts/win-12/"},{"categories":["Python"],"content":"多线程 / 线程池 pyhton多线程 ","date":"2021-12-18","objectID":"/posts/python-9/:0:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"Python多线程的默认情况 当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行流的最小单元，当设置多线程时，主线程会创建多个子线程，在python中，默认情况下（其实就是setDaemon(False)），主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。 import threading import time def run(): time.sleep(2) print(\"当前线程的名字是: %s-\" %threading.current_thread().name) time.sleep(2) if __name__ == '__main__': start_time = time.time() print('这是主线程：', threading.current_thread().name) thread_list = [] for i in range(5): t = threading.Thread(target=run) thread_list.append(t) for t in thread_list: t.start() print('主线程结束！' , threading.current_thread().name) print('一共用时：', time.time()-start_time) \"\"\" output: 这是主线程： MainThread 主线程结束！ MainThread 一共用时： 0.0020024776458740234 当前线程的名字是: Thread-49 - 当前线程的名字是: Thread-53 - 当前线程的名字是: Thread-52 - 当前线程的名字是: Thread-51 - 当前线程的名字是: Thread-50 - \"\"\" 我们的计时是对主线程计时，主线程结束，计时随之结束，打印出主线程的用时。 主线程的任务完成之后，主线程随之结束，子线程继续执行自己的任务，直到全部的子线程的任务全部结束，程序结束 ","date":"2021-12-18","objectID":"/posts/python-9/:1:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"设置守护线程 当我们使用setDaemon(True)方法，设置子线程为守护线程时，主线程一旦执行结束，则全部线程全部被终止执行，可能出现的情况就是，子线程的任务还没有完全执行结束，就被迫停止。 import threading import time def run(): time.sleep(2) print('当前线程的名字是： ', threading.current_thread().name) time.sleep(2) if __name__ == '__main__': start_time = time.time() print('这是主线程：', threading.current_thread().name) thread_list = [] for i in range(5): t = threading.Thread(target=run) thread_list.append(t) for t in thread_list: t.setDaemon(True) t.start() print('主线程结束了！' , threading.current_thread().name) print('一共用时：', time.time()-start_time) \"\"\" output 这是主线程： MainThread 主线程结束了！ MainThread 一共用时： 0.0020020008087158203 \"\"\" 主线程结束以后，子线程还没有来得及执行，整个程序就退出了 ","date":"2021-12-18","objectID":"/posts/python-9/:2:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"join的用法 此时join的作用就凸显出来了，join所完成的工作就是线程同步，即主线程任务结束之后，进入阻塞状态，一直等待其他的子线程执行结束之后，主线程在终止。 import threading import time def run(): time.sleep(2) print('当前线程的名字是： ', threading.current_thread().name) time.sleep(2) if __name__ == '__main__': start_time = time.time() print('这是主线程：', threading.current_thread().name) thread_list = [] for i in range(5): t = threading.Thread(target=run) thread_list.append(t) for t in thread_list: t.setDaemon(True) t.start() for t in thread_list: t.join() print('主线程结束了！' , threading.current_thread().name) print('一共用时：', time.time()-start_time) \"\"\" 这是主线程： MainThread 当前线程的名字是： Thread-85 当前线程的名字是： Thread-84 当前线程的名字是： Thread-86 当前线程的名字是： Thread-88 当前线程的名字是： Thread-87 主线程结束了！ MainThread 一共用时： 4.0279927253723145 \"\"\" 主线程一直等待全部的子线程结束之后，主线程自身才结束，程序退出 ","date":"2021-12-18","objectID":"/posts/python-9/:3:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"实践 import threading threads = [] for k, record in enumerate(data['supplyname']): # get_list # get_page thread_spider = None if method == 'get_list': thread_spider = threading.Thread(target=get_list, args=[url, ws_data, record, json_list]) elif method == 'get_page': thread_spider = threading.Thread(target=get_page, args=[url, ws_data, record, json_list]) thread_spider.start() threads.append(thread_spider) print('当前进度: %s/ %s' % (k + 1, str(data_num))) for t in threads: t.join() 线程池 ","date":"2021-12-18","objectID":"/posts/python-9/:4:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"创建线程池 之前用信号量,感觉不太好用…发现多线程自带一个线程池功能 concurrent.futures模块，它提供了ThreadPoolExecutor和ProcessPoolExecutor两个类，实现了对threading和multiprocessing的进一步抽象（这里主要关注线程池），不仅可以帮我们*自动调度线程*，还可以做到： 主线程可以获取某一个线程（或者任务的）的状态，以及返回值。 当一个线程完成的时候，主线程能够立即知道。 让多线程和多进程的编码接口一致。 from concurrent.futures import ThreadPoolExecutor import time # 参数times用来模拟网络请求的时间 def get_html(times): time.sleep(times) print(\"get page {}s finished\".format(times)) return times executor = ThreadPoolExecutor(max_workers=2) # 通过submit函数提交执行的函数到线程池中，submit函数立即返回，不阻塞 task1 = executor.submit(get_html, (3)) task2 = executor.submit(get_html, (2)) # done方法用于判定某个任务是否完成 print(task1.done()) # cancel方法用于取消某个任务,该任务没有放入线程池中才能取消成功 print(task2.cancel()) time.sleep(4) print(task1.done()) # result方法可以获取task的执行结果 print(task1.result()) ","date":"2021-12-18","objectID":"/posts/python-9/:5:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"利用as_completed取出所有结果 from concurrent.futures import ThreadPoolExecutor, as_completed import time # 参数times用来模拟网络请求的时间 def get_html(times): time.sleep(times) print(\"get page {}s finished\".format(times)) return times executor = ThreadPoolExecutor(max_workers=2) urls = [3, 2, 4] # 并不是真的url all_task = [executor.submit(get_html, (url)) for url in urls] for future in as_completed(all_task): data = future.result() print(\"in main: get page {}s success\".format(data)) as_completed()方法是一个生成器，在没有任务完成的时候，会阻塞，在有某个任务完成的时候，会yield这个任务，就能执行for循环下面的语句，然后继续阻塞住，循环到所有的任务结束。从结果也可以看出，先完成的任务会先通知主线程 ","date":"2021-12-18","objectID":"/posts/python-9/:6:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"通过map提交任务 from concurrent.futures import ThreadPoolExecutor import time # 参数times用来模拟网络请求的时间 def get_html(times): time.sleep(times) print(\"get page {}s finished\".format(times)) return times executor = ThreadPoolExecutor(max_workers=2) urls = [3, 2, 4] # 并不是真的url for data in executor.map(get_html, urls): print(\"in main: get page {}s success\".format(data)) # 执行结果 # get page 2s finished # get page 3s finished # in main: get page 3s success # in main: get page 2s success # get page 4s finished # in main: get page 4s success ''' 使用map方法，无需提前使用submit方法，map方法与python标准库中的map含义相同，都是将序列中的每个元素都执行同一个函数。上面的代码就是对urls的每个元素都执行get_html函数，并分配各线程池。可以看到执行结果与上面的as_completed方法的结果不同，输出顺序和urls列表的顺序相同，就算2s的任务先执行完成，也会先打印出3s的任务先完成，再打印2s的任务完成。 ''' ","date":"2021-12-18","objectID":"/posts/python-9/:7:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"多参数传入submit from concurrent.futures import ThreadPoolExecutor,as_completed def doFileParse(filepath,segment,wordslist): print(filepath) print(segment) #调用方法 #实质就是通过lambda表达式过渡。传入的参数是一个，但是通过lambda表达多后拆散为多个传入。这是很巧妙的方法，实际 就是 *p 这个表达式。 args =[filepath,thu1,Words] newTask=executor.submit(lambda p: doFileParse(*p),args) 临界资源互斥访问 threading 模块提供了 Lock 类 acquire()：对 Lock加锁，其中timeout参数指定加锁多少秒 release()：释放锁 RLock被称为重入锁，可以被一个线程请求多次，即锁中可以嵌套锁 ","date":"2021-12-18","objectID":"/posts/python-9/:8:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"单锁 class Account: def __init__(self, card_id, balance): # 封装账户ID、账户余额的两个变量 self.card_id= card_id self.balance = balance def withdraw(account, money): # 进行加锁 lock.acquire() # 账户余额大于取钱数目 if account.balance \u003e= money: # 吐出钞票 print(threading.current_thread().name + \"取钱成功！吐出钞票:\" + str(money),end=' ') # 修改余额 account.balance -= money print(\"\\t余额为: \" + str(account.balance)) else: print(threading.current_thread().name + \"取钱失败！余额不足\") # 进行解锁 lock.release() # 创建一个账户，银行卡id为8888，存款1000元 acct = Account(\"8888\" , 1000) # 模拟两个对同一个账户取钱 # 在主线程中创建一把锁 lock = threading.Lock() threading.Thread(name='窗口A', target=withdraw , args=(acct , 800)).start() threading.Thread(name='窗口B', target=withdraw , args=(acct , 800)).start() ","date":"2021-12-18","objectID":"/posts/python-9/:9:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"多重锁 import threading import time def fun_1(): print('开始') time.sleep(1) lock.acquire() print(\"第一道锁\") fun_2() lock.release() def fun_2(): lock.acquire() print(\"第二道锁\") lock.release() if __name__ == '__main__': lock = threading.RLock() t1 = threading.Thread(target=fun_1) t2 = threading.Thread(target=fun_1) t1.start() t2.start() ","date":"2021-12-18","objectID":"/posts/python-9/:10:0","tags":["多线程"],"title":"Python多线程","uri":"/posts/python-9/"},{"categories":["Python"],"content":"PY设计模式 适配器模式 将一个类的接口转换成客户希望的另外一个接口，适配器使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。实现适配器的两种方式，类适配器使用多继承，对象适配器使用组合。组合就是一个类中放入另一类的对象。 先来看下组合： class A: pass class B: def __init__(): self.a = A() 类适配器模式使用示例： # 类适配器模式使用示例： from abc import ABCMeta, abstractmethod # 目标接口 class Payment(object, metaclass=ABCMeta): @abstractmethod def pay(self, money): pass class Alipay(Payment): def pay(self, money): print('支付了%d' % money) # 待适配的类 class BankPay(): def cost(self, money): print('银联支付了%d' % money) # 类适配器 class PaymentAdapter(Payment, BankPay): \"\"\" 把不兼容cost转换成pay \"\"\" def pay(self, money): self.cost(money) p = PaymentAdapter() p.pay(100) \"\"\" 银联支付了100 \"\"\" 对象适配器模式使用示例： # 类适配器模式使用示例： from abc import ABCMeta, abstractmethod # 目标接口 class Payment(object, metaclass=ABCMeta): @abstractmethod def pay(self, money): pass class Alipay(Payment): def pay(self, money): print('支付了%d' % money) # 待适配的类 class BankPay(): def cost(self, money): print('银联支付了%d' % money) # 待适配的类 class ApplePay(): def cost(self, money): print('苹果支付了%d' % money) # 对象适配器 class PaymentAdapter(Payment): def __init__(self, payment): self.payment = payment def pay(self, money): self.payment.cost(money) p = PaymentAdapter(ApplePay()) p.pay(100) p = PaymentAdapter(BankPay()) p.pay(100) \"\"\" 苹果支付了100 银联支付了100 \"\"\" 适配器模式有三种角色，分别是目标接口、待适配的类和适配器。适用场景是：想使用一个已存在的类，而它的接口不符合你的要求。想使用一些已经存在的类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 桥模式 桥模式是将一个事物的两个维度分离，使其都可以独立地变化。当事物有两个维度的表现，两个维度都可能扩展时使用。优点是：抽象和实现相分离，扩展能力强。如果不使用桥模式，在任何维度进行扩展，需要改好多代码，因为使用到了继承： class Shape: pass class Rectangle(Shape): pass class Circle(Shape): pass class RedRectangle(Rectangle): pass class GreenRectangle(Rectangle): pass class RedCircle(Circle): pass class GreenCircle(Circle): pass 以上代码形状和颜色两个维度是通过类的继承关系紧密结合在一起，是紧耦合。紧耦合是是不可取的，应用桥模式的思想，可以使用组合来实现（松耦合）。如果需要画直线，直接加上直线的类。需要新颜色，直接加上颜色的类。两个维度都可以自由扩展，不需要添加很多代码。这里的角色有抽象、细化抽象、实现者和具体实现者： from abc import ABCMeta, abstractmethod # 抽象 class Shape(metaclass=ABCMeta): def __init__(self, color): self.color = color @abstractmethod def draw(self): pass # 实现 class Color(metaclass=ABCMeta): @abstractmethod def paint(self, shape): pass # 细化抽象 class Rectangle(Shape): name = '长方形' def draw(self): self.color.paint(self) # 如果要扩展形状，只需要添加形状类 class Circle(Shape): name = '圆形' def draw(self): self.color.paint(self) # 细化实现 class Red(Color): def paint(self, shape): print('画红色的%s' % shape.name) # 如果要扩展颜色，只需要添加颜色类 class Green(Color): def paint(self, shape): print('画绿色的%s' % shape.name) rectangle = Rectangle(Red()) rectangle.draw() circle = Circle(Green()) circle.draw() \"\"\" 画红色的长方形 画绿色的圆形 \"\"\" 组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构(特别是结构是递归的)，组合模式使得用户对单个对象和组合对象的使用具有一致性。优点是定义了包含基本对象和组合对象的层次结构；简化客户端代码，客户端可以一致地使用组合对象和单个对象；更加容易增加新类型的组件。 from abc import ABCMeta, abstractmethod # 抽象组件 class Graphic(metaclass=ABCMeta): @abstractmethod def draw(self): pass # 叶子组件 class Point(Graphic): def __init__(self, x, y): self.x = x self.y = y def __str__(self): return '点(%s,%s)' % (self.x, self.y) def draw(self): print(self) # 叶子组件 class Line(Graphic): def __init__(self, p1, p2): self.p1 = p1 self.p2 = p2 def __str__(self): return '线段[(%s,%s)]' % (self.p1, self.p2) def draw(self): print(self) # 复合组件 class Picture(Graphic): def __init__(self, iterable): self.children = [] for g in iterable: self.add(g) def add(self, graphic): self.children.append(graphic) def draw(self): for g in self.children: g.draw() # 简单图形 print('------简单图形------') p = Point(1, 2) l1 = Line(Point(1, 2), Point(3, 4)) l2 = Line(Point(5, 6), Point(7, 8)) print(p) print(l1) print(l2) print('------复合图形(p,l1,l2)------') # 复合图形 pic = Picture([p, l1, l2]) pic.draw() 外观模式 外观模式为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层的接口，这个接口使得这一子系统更加容易使用。外观模式下的角色有外观和子系统类，优点是：减少系统相互依赖，提高灵活性，提高了安全性。下面看一个例子： # 子系统类 class CPU: def run(self): print('CPU start to run...') def stop(self): print('CPU stop to run...') # 子系统类 class Disk: def run(self): print('Disk start to run...') def stop(self): print('Disk stop to run...') # 子系统类 class Memory: def run(self): print('Memory start to run...') def stop(self): print('Memory stop to run...'","date":"2021-11-20","objectID":"/posts/Pattern-5/:0:0","tags":["设计模式"],"title":"结构型模式","uri":"/posts/Pattern-5/"},{"categories":["Python"],"content":"PY设计模式 责任链模式 责任链模式的内容：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链并沿着这条链传递该请求，直到有一个对象处理它为止。责任链的角色有抽象处理者、具体处理者和客户端。 from abc import ABCMeta, abstractmethod # 抽象的处理者 class Handler(metaclass=ABCMeta): @abstractmethod def handle_leave(self, day): pass # 具体的处理者 class GeneralManager(Handler): def handle_leave(self, day): if day \u003c= 30: print('总经理准假%d' % day) else: print('可以辞职了！') # 具体的处理者 class DepartmentManager(Handler): def __init__(self): self.next = GeneralManager() def handle_leave(self, day): if day \u003c= 7: print('项目主管准假%d' % day) else: print('部门经理职权不足') self.next.handle_leave(day) # 具体的处理者 class ProjectDirector(Handler): def __init__(self): self.next = DepartmentManager() def handle_leave(self, day): if day \u003c= 3: print('项目主管准假%d' % day) else: print('项目主管职权不足') self.next.handle_leave(day) day = 20 p = ProjectDirector() p.handle_leave(day) \"\"\" 项目主管职权不足 部门经理职权不足 总经理准假20 \"\"\" 使用场景：有多个对象可以处理一个请求，哪个对象处理由运行时决定；在不明确接收者的情况下，向多个对象中的一个提交一个请求。优点是降低耦合度，一个对象无需知道是其它哪一个对象处理其请求。 观察者模式 观察者模式应用比较广泛，又被称为“发布-订阅”模式。它用来定义对象间一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都得到通知并被自动更新。观察者模式的角色有：抽象主题、具体主题（发布者）、抽象观察者和具体观察者（订阅者）。 from abc import ABCMeta, abstractmethod # 抽象的订阅者 class Observer(metaclass=ABCMeta): @abstractmethod def update(self, notice): \"\"\" :param notice: Notice类的对象 :return: \"\"\" pass # 抽象的发布者：可以是接口，子类不需要实现，所以不需要定义抽象方法！ class Notice: def __init__(self): self.observers = [] def attach(self, obs): self.observers.append(obs) def detach(self, obs): self.observers.remove(obs) def notify(self): \"\"\" 推送 :return: \"\"\" for obs in self.observers: obs.update(self) # 具体的发布者 class StaffNotice(Notice): def __init__(self, company_info): super().__init__() # 调用父类对象声明observers属性 self.__company_info = company_info @property def company_info(self): return self.__company_info @company_info.setter def company_info(self, info): self.__company_info = info self.notify() # 具体的订阅者 class Staff(Observer): def __init__(self): self.company_info = None def update(self, notice): self.company_info = notice.company_info staff_notice = StaffNotice('初始化公司信息') staff1 = Staff() staff2 = Staff() staff_notice.attach(staff1) staff_notice.attach(staff2) # print(staff1.company_info) None # print(staff2.company_info) None staff_notice.company_info = '假期放假通知！' print(staff1.company_info) print(staff2.company_info) staff_notice.detach(staff2) staff_notice.company_info = '明天开会！' print(staff1.company_info) print(staff2.company_info) \"\"\" 假期放假通知！ 假期放假通知！ 明天开会！ 假期放假通知！ \"\"\" 使用场景：当一个抽象模型有两个方面，其中一个方面依赖另一个方面。将这两者封装在独立对象中以使它们可以各自独立地改变和复用；当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象待改变；当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧耦合的。优点：目标和观察者之间的抽象耦合最小；支持广播通信。 策略模式 定义一个个算法，把它们封装起来，并且使它们可以相互替换。本模式使得算法可独立于使用它的客户而变化。角色有：抽象策略、具体策略和上下文。 from abc import abstractmethod, ABCMeta from datetime import datetime # 抽象策略 class Strategy(metaclass=ABCMeta): @abstractmethod def execute(self, data): pass # 具体策略 class FastStrategy(Strategy): def execute(self, data): print(\"使用较快的策略处理%s\" % data) # 具体策略 class SlowStrategy(Strategy): def execute(self, data): print(\"使用较慢的策略处理%s\" % data) # 上下文 class Context: def __init__(self, strategy, data): self.data = data self.strategy = strategy # 可以定义用户不知道的东西 self.date = datetime.now() def set_strategy(self, strategy): self.strategy = strategy def do_strategy(self): self.strategy.execute(self.data) data = \"Hello!\" # 使用较快的策略处理 fast_strategy = FastStrategy() context = Context(fast_strategy, data) context.do_strategy() # 使用较慢的策略处理 slow_strategy = SlowStrategy() context = Context(slow_strategy, data) context.do_strategy() \"\"\" 使用较快的策略处理Hello! 使用较慢的策略处理Hello! \"\"\" 优点：定义了一些列可重用的算法和行为；消除了一些条件语句；可以提供相同行为的不同实现；缺点：客户必须了解不同的策略。 模板方法模式 内容：定义一个操作中的算法骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。使用模板方法，需要用到两种角色，分别是抽象类和具体类。抽象类的作用是是定义抽象类（钩子操作），实现一个模板方法作为算法的骨架。具体类的作用实现原子操作。 from abc import ABCMeta, abstractmethod from time import sleep # 抽象类 class Window(metaclass=ABCMeta): @abstractmethod def start(self): # 原子操作/钩子操作 pass @abstractmethod def repaint(self): # 原子操作/钩子操作 pass @abstractmethod def stop(self): # 原子操作/钩子操作 pass def ","date":"2021-11-20","objectID":"/posts/Pattern-4/:0:0","tags":["设计模式"],"title":"行为型模式","uri":"/posts/Pattern-4/"},{"categories":["Python"],"content":"PY设计模式 开放封闭原则 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。即软件实体应该在不修改原代码的情况下进行修改。 里氏替换原则 所有引用父类的地方必须能透明地使用其子类地方必须能透明地使用其子类的对象，一个简单的例子加强理解 class User(object): def print_name(self): pass class VipUser(User): def print_name(self): \"\"\" 保证参数和返回值类型需要和父类一样 :return: \"\"\" pass def print_name(u): \"\"\" 不论使用User还是继承User的VipUser，调用的方式是一样的。这就要求User和VipUser的方法参数和返回值类型是一样的 :param u: :return: \"\"\" u.print_name() 依赖倒置原则 高层模块不应该依赖底层模块，二者都应该依赖抽象。抽象不应该依赖细节，细节应该应该依赖抽象。要针对接口编程，而不是针对实现变成。通过例子加强理解： from abc import ABCMeta, abstractmethod # 接口，抽象不应该依赖细节 class Payment(metaclass=ABCMeta): @abstractmethod def pay(self, money): pass # 底层代码和高层代码都是细节，细节应该依赖抽象 # 底层代码 class Alipay(Payment): def pay(self, money): print(\"支付宝支付了{0}元!\".format(money)) class WechatPay(Payment): def pay(self, money): print(\"微信支付了%d元!\" % (money)) # 高层代码，高层模块不应该依赖底层模块，二者都应该依赖抽象 a = Alipay() w = WechatPay() a.pay(100) w.pay(100) 接口隔离原则 使用多个专门的接口，而不使用单一的总结口，高层的代码不应该依赖那些它不需要的接口。通过例子加强理解： from abc import ABCMeta, abstractmethod class LandAnimal(metaclass=ABCMeta): @abstractmethod def walk(self): pass class WaterAnimal(metaclass=ABCMeta): @abstractmethod def swim(self): pass class SkyAnimal(metaclass=ABCMeta): @abstractmethod def fly(self): pass # 高层的代码不应该依赖那些它不需要的接口 class Tiger(LandAnimal): def walk(self): pass # 高层的代码不应该依赖那些它不需要的接口 class Frog(LandAnimal, WaterAnimal): def walk(self): pass 单一职责原则 不要存在多于一个导致类变更的原因，一个类只负责一项职责，一个类只做一件事。把面向过程的代码放到类中，虽然用到了类，但不是面向对象。 ","date":"2021-11-20","objectID":"/posts/Pattern-1/:0:0","tags":["设计模式"],"title":"Python设计模式","uri":"/posts/Pattern-1/"},{"categories":["Python"],"content":"PY设计模式 设计模式 设计模式是对软件设计中普遍存在或反复出向的各种问题所提出的解决方案。每一个设计模式系统地被命名、解释和评价了面向对象系统中一个重要和重复出现的设计。 设计模式的分类 创建型模式：工厂方法模式、抽象工厂模式、创建者模式、原型模式、单例模式。隐藏底层模块的逻辑，关注怎么创建对象。 结构型模式：适配器模式、桥模式、组合模式、装饰模式、外观模式、享元模式、代理模式。类之间如何协同工作，应该组成什么结构。 行为型模式：解释器模式、责任链模式、命令模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、访问者模式、模板方法模式。关注行为，也就是方法，应该怎样某些行为。 面向对象 设计模式解决的就是面向对象中的问题。需要指导面向对象的三大特性是 封装、继承和多态 ，封装是把数据和方法封装到类中，继承是类之间复用代码，多态在Python中默认支持的，Python是一种多态的语言。 接口 接口是若干抽象方法的集合。接口的作用是限制实现接口的类必须按照接口给定的调用方式实现这些方法，对高层模块隐藏了类的内部实现。下面通过一个简单的例子来加强对接口的理解： from abc import ABCMeta, abstractmethod # 具有抽象方法的类就是接口类， class Payment(metaclass=ABCMeta): @abstractmethod def pay(self, money): \"\"\" 抽象方法，在实现的类中必须实现的方法。限制实现接口的类必须按照接口给定的调用方式实现这些方法 :param money: :return: \"\"\" pass # 不能说是继承接口类，应该说是实现接口 class Alipay(Payment): def pay(self, money): \"\"\" 实现接口类中的必须实现的方法 :param money: :return: \"\"\" print(\"支付宝支付了{0}元!\".format(money)) class WechatPay(Payment): def pay(self, money): \"\"\" 实现接口类中的必须实现的方法 :param money: :return: \"\"\" print(\"微信支付了%d元!\" % (money)) # 下面是高层代码，在调用的时候是看不到底层类的内部实现 a = Alipay() w = WechatPay() a.pay(100) w.pay(100) ","date":"2021-11-20","objectID":"/posts/Pattern-2/:0:0","tags":["设计模式"],"title":"设计模式与面向对象","uri":"/posts/Pattern-2/"},{"categories":["Python"],"content":"PY设计模式 简单工厂模式 简单工厂模式不是23种设计模式中的，但是必须要知道。简单工厂模式不直接向客户端暴露对象创建的细节，而是通过一个工厂类来负责创建产品类的实例。简单工程模式的角色有：工厂角色、抽象产品角色、具体产品角色，通过例子来加深理解： from abc import ABCMeta, abstractmethod # 抽象产品角色，以什么样的表现去使用 class Payment(metaclass=ABCMeta): @abstractmethod def pay(self, money): pass # 产品角色 class Alipay(Payment): def __init__(self, use_huabei=False): self.use_huabei = use_huabei def pay(self, money): if self.use_huabei == True: print(\"花呗支付了{0}元!\".format(money)) else: print(\"支付宝余额支付了{0}元!\".format(money)) # 产品角色 class WechatPay(Payment): def pay(self, money): print(\"微信支付了%d元!\" % (money)) # 工厂类角色 class PaymentFactory: def ctreate_payment(self, method): if method == 'Alipay': return Alipay() elif method == 'WechatPay': return WechatPay() elif method == 'HuabeiPay': return Alipay(use_huabei=True) else: raise TypeError('No such payment named %s' % method) # 客户端调用。不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例 pf = PaymentFactory() p = pf.ctreate_payment('HuabeiPay') p.pay(100) 工厂方法模式 简单工厂模式只创建一个工厂类，当有新的产品时，需要修改工厂类代码。而 工厂方法模式的每个具体产品对应一个具体的工厂类，不需要修改工厂类代码，并且同时也能满足隐藏对象创建的细节。但是工厂方法模式也是有缺点的，就是 每增加一个具体产品类，就必须增加一个相应的具体方法。 工厂模式方法模式的概念是定义了一个用于创建对象的接口(工厂接口)，让子类决定实例化那一个产品类。角色有抽象工厂角色、具体工厂角色、抽象产品角色和具体产品角色。通过例子来加深理解，每个具体产品对应一个具体的工厂类： from abc import ABCMeta, abstractmethod # 抽象产品角色 class Payment(metaclass=ABCMeta): @abstractmethod def pay(self, money): pass # 具体产品角色 class Alipay(Payment): def __init__(self, use_huabei=False): self.use_huabei = use_huabei def pay(self, money): if self.use_huabei == True: print(\"花呗支付了{0}元!\".format(money)) else: print(\"支付宝余额支付了{0}元!\".format(money)) class WechatPay(Payment): def pay(self, money): print(\"微信支付了%d元!\" % (money)) # 抽象工厂角色 class PaymentFactory(metaclass=ABCMeta): @abstractmethod def create_payment(self): pass # 具体工厂角色 class AlipayFactory(PaymentFactory): def create_payment(self): return Alipay() class WechatPayFactory(PaymentFactory): def create_payment(self): return Alipay() class HuabeiFactory(PaymentFactory): def create_payment(self): return Alipay(use_huabei=True) hfp = HuabeiFactory().create_payment() hfp.pay(100) # 花呗支付了100元! 缺点是每增加一个具体产品类，就必须增加一个相应的具体方法： from abc import ABCMeta, abstractmethod class Payment(metaclass=ABCMeta): @abstractmethod def pay(self, money): pass class Alipay(Payment): def __init__(self, use_huabei=False): self.use_huabei = use_huabei def pay(self, money): if self.use_huabei == True: print(\"花呗支付了{0}元!\".format(money)) else: print(\"支付宝余额支付了{0}元!\".format(money)) class WechatPay(Payment): def pay(self, money): print(\"微信支付了%d元!\" % (money)) class BankPay(Payment): def pay(self, money): print(\"银行支付了%d元!\" % (money)) # 创建产品的工厂类的接口 class PaymentFactory(metaclass=ABCMeta): @abstractmethod def create_payment(self): pass # 工厂类 class AlipayFactory(PaymentFactory): def create_payment(self): return Alipay() # 工厂类 class WechatPayPayFactory(PaymentFactory): def create_payment(self): return Alipay() # 工厂类 class HuabeiPayFactory(PaymentFactory): def create_payment(self): return Alipay(use_huabei=True) # 新增加银行支付的工厂类 class BankPayFactory(PaymentFactory): def create_payment(self): return BankPay() bfp = BankPayFactory().create_payment() bfp.pay(100) # 银行支付了100元! 抽象工厂模式 抽象工厂模式：定义一个工厂类的接口让工厂子类来创建一系列相关或者相互依赖的对象。相比工厂方法模式，抽象工厂模式中的每一个具体工厂都生产一套产品。下面是生产厂商生产一部手机的例子：生产一部手机如果说只需要手机壳、CPU和操作系统这三个类对象，其中每个类对象都有不同的种类。对每个具体工厂，分别生产一部手机需要的三个对象。通过例子来加深理解： from abc import ABCMeta, abstractmethod # ------抽象的产品------ class PhoneShell(metaclass=ABCMeta): @abstractmethod def show_shell(self): pass class PhoneCPU(metaclass=ABCMeta): @abstractmethod def show_cpu(self): pass class PhoneOS(metaclass=ABCMeta): @abstractmethod def show_os(self): pass # ------具体的产品------ class SmallShell(PhoneShell): def show_shell(self): print('普通手机小手机壳') class BigShell(PhoneShell): def show_shell(self): print('普通手机大手机壳') class AppleShell(PhoneShell): def show_shell(self): print('苹果手机壳') class SnapDragonCPU(PhoneCPU): def show_cpu(self): print('骁龙CPU') class HuaweiCPU(PhoneCPU): def show_cpu(self): print('化为CPU') class AppleCPU(PhoneCPU): def show_cpu(self): print('苹果CPU') cla","date":"2021-11-20","objectID":"/posts/Pattern-3/:0:0","tags":["设计模式"],"title":"创建型模式","uri":"/posts/Pattern-3/"},{"categories":["Python"],"content":"openpyxl操作Excel openpyxl 写入Excel文件 由于xlwt只支持xls文件，所以对于Excel文件的处理，建议使用openpyxl进行操作 参考博客 官方文档 ","date":"2021-11-15","objectID":"/posts/openpyxl/:0:0","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"创建文件 def init_excel(): wb = Workbook() # 创建Excel ws = wb.active # 激活worksheet lis = ['A', 'B', 'C', 'D', 'E', 'F'] for i in lis: col = ws.column_dimensions[i] col.width = 13 # 设置列宽 return wb, ws 在工作表中，列的索引是对应的英文字幕，行的索引是数字 ","date":"2021-11-15","objectID":"/posts/openpyxl/:1:0","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"读取Excel文件 from pandas import read_excel def readexcel(filename, row_end): try: data = read_excel(filename, 0) pass except Exception as e: print(str(e)) else: res = data[0:row_end] return res 其中data数据不包含标题，0行表示第一条数据，一直到row_end-1行数据，即row_end条数据 ","date":"2021-11-15","objectID":"/posts/openpyxl/:2:0","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"写入数据 ","date":"2021-11-15","objectID":"/posts/openpyxl/:3:0","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"合并单元格 worksheet.merge_cells(start_row=, end_row=, start_column=, end_column=) 其中行和列的索引都是从1开始 ","date":"2021-11-15","objectID":"/posts/openpyxl/:3:1","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"单元格赋值 worksheet.cell(row, column).value = 'xxx' ","date":"2021-11-15","objectID":"/posts/openpyxl/:3:2","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"添加一行值 worksheet.append(value_list) # 其中 value_list 为数组元素 ","date":"2021-11-15","objectID":"/posts/openpyxl/:3:3","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"样式设定 ","date":"2021-11-15","objectID":"/posts/openpyxl/:4:0","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"单元格填充颜色 worksheet.cell(row, column).fill = PatternFill(patternType='solid', fgColor=Color(rgb='00D9EAF4')) # fgColor 前景色 # bgColor 后景色 # 参数可选项 patternType = {'darkDown', 'darkUp', 'lightDown', 'darkGrid', 'lightVertical', 'solid', 'gray0625', 'darkHorizontal', 'lightGrid', 'lightTrellis', 'mediumGray', 'gray125', 'darkGray', 'lightGray', 'lightUp', 'lightHorizontal', 'darkTrellis', 'darkVertical'} ","date":"2021-11-15","objectID":"/posts/openpyxl/:4:1","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"对齐样式 worksheet.cell(row, column).alignment = Alignment(horizontal='center',vertical='center') # 参数可选项 #horizontal = {'fill', 'distributed', 'centerContinuous', 'right', 'justify', 'center', 'left', 'general'} #vertical = {'distributed', 'justify', 'center', 'bottom', 'top'} ","date":"2021-11-15","objectID":"/posts/openpyxl/:4:2","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"设置字体 worksheet.cell(row, column).font = Font(name='宋体', size=10, color=Color(rgb='00083866'), b=True) # size: 字体大小 # b: bold 是否粗体 # i: italic 是否斜体 # name: 字体样式 ","date":"2021-11-15","objectID":"/posts/openpyxl/:4:3","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"示例代码 def write_card(wt, dic, row_num): # content wt.merge_cells(start_row = row_num, end_row = row_num, start_column = 1, end_column = 6) wt.cell(row_num + 1, 1).value = '固定资产卡片' wt.merge_cells(start_row = row_num + 1, end_row = row_num + 1, start_column = 1, end_column = 6) wt.merge_cells(start_row = row_num + 2, end_row = row_num + 2, start_column = 1, end_column = 6) # TODO : use append method tmp_list1 = ['卡片编号', dic['card_no'], '资产名称', dic['name']] tmp_list2 = ['电商编号', dic['ec_code'], '分配人员', dic['person']] tmp_list3 = ['原值', dic['price'], '启用日期', dic['time'], '备注', dic['mark']] wt.append(tmp_list1) wt.append(tmp_list2) wt.append(tmp_list3) wt.merge_cells(start_row=row_num + 3, end_row=row_num + 3, start_column=4, end_column=6) wt.merge_cells(start_row=row_num + 4, end_row=row_num + 4, start_column=4, end_column=6) wt.merge_cells(start_row=row_num + 6, end_row=row_num + 6, start_column=1, end_column=6) # style wt.cell(row_num + 1, 1).fill = PatternFill(patternType='solid', fgColor=Color(rgb='00D9EAF4')) wt.cell(row_num + 1, 1).alignment = Alignment(horizontal='center',vertical='center') row1 = wt.row_dimensions[row_num + 1] row1.height = 18 wt.cell(row_num + 6, 1).fill = PatternFill(patternType='solid', fgColor=Color(rgb='00D9EAF4')) wt.cell(row_num + 1, 1).font = Font(name='宋体', size=10, color=Color(rgb='00083866'), b=True) for i in range(3, 6): for j in range(1, 5): wt.cell(row_num + i, j).font = Font(name='SimSun', size=9) wt.cell(row_num + i, j).alignment = Alignment(horizontal='left', vertical='center') wt.cell(row_num + 5, 5).font = Font(name='SimSun', size=9) wt.cell(row_num + 5, 5).alignment = Alignment(horizontal='left', vertical='center') wt.cell(row_num + 5, 6).font = Font(name='SimSun', size=9) wt.cell(row_num + 5, 6).alignment = Alignment(horizontal='left', vertical='center') ","date":"2021-11-15","objectID":"/posts/openpyxl/:5:0","tags":["Excel"],"title":"openpyxl基础操作","uri":"/posts/openpyxl/"},{"categories":["Python"],"content":"Selenium Webdriver 配置webdriver ","date":"2021-11-10","objectID":"/posts/python-8/:0:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"创建webdriver option = webdriver.ChromeOptions() option.binary_location = r\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" # 设定英文启动 # option.add_argument(\"--lang=en-US\"); browser = webdriver.Chrome(executable_path =\"E:\\Webdriver\\chromedriver\", options=option) ","date":"2021-11-10","objectID":"/posts/python-8/:1:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"隐藏图片 加快运行速度 prefs = { 'profile.default_content_setting_values':{ 'images': 2, } } option.add_experimental_option('prefs', prefs) ","date":"2021-11-10","objectID":"/posts/python-8/:2:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"设定窗口大小 browser.set_window_size(1500,1000) 定位元素 ","date":"2021-11-10","objectID":"/posts/python-8/:3:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"访问网址 # 访问网址 browser.get(\"http://tang.cdt-ec.com/cpu-portal-fe/login1.html\") ","date":"2021-11-10","objectID":"/posts/python-8/:4:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"填充元素 username = browser.find_element_by_id('username').send_keys('***') password = browser.find_element_by_id('password').send_keys('***') ","date":"2021-11-10","objectID":"/posts/python-8/:5:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"通过class定位 login_btn = browser.find_element_by_class_name('btn-submit') login_btn.click() time.sleep(5) browser.get(\"http://bid.cdt-ec.com/dtdzzb/loginController.do?login\u0026loginType=zb\") time.sleep(1) browser.get(\"http://bid.cdt-ec.com/dtdzzb/tBContractInfoController.do?sendList\") time.sleep(5) ","date":"2021-11-10","objectID":"/posts/python-8/:6:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"获得内部元素值 count = browser.find_element_by_css_selector('.pagination-info').get_attribute('innerText') #总数量 ","date":"2021-11-10","objectID":"/posts/python-8/:7:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"正则表达式查找值 num = re.search(r'Total (.*)Item', str(count), re.M | re.I).group(1) print(num) ","date":"2021-11-10","objectID":"/posts/python-8/:8:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"通过元素的Text属性查找 lbtn_push = browser.find_elements_by_link_text(\"推送法务系统\") ","date":"2021-11-10","objectID":"/posts/python-8/:9:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"find_elements和find_element elements返回所有匹配的数组 element只适用于查找单个存在的元素 循环执行操作 num = int(num) if num%10 != 0: shit = num/10+1 else: shit = num/10 for i in range(int(shit)-1): lbtn_push = browser.find_elements_by_link_text(\"推送法务系统\") # 推送按钮 j = 0 while j \u003c len(lbtn_push): btn_push = browser.find_elements_by_link_text(\"推送法务系统\") # 推送按钮 tmp_id = \"\" # noinspection PyBroadException try: order_id = browser.find_elements_by_class_name(\"datagrid-cell-c1-tenderno\") # 项目编号 print(str(order_id[j].text)) tmp_id = str(order_id[j].text) btn_push[j].click() click_ok = browser.find_element_by_link_text(\"确定\") click_ok.click() time.sleep(4) except: pass window = \"\" # noinspection PyBroadException try: click_ok2 = browser.find_element_by_link_text(\"确定\") window = browser.find_element_by_class_name(\"window-body\").get_attribute('innerText') except: time.sleep(260) click_ok2 = browser.find_element_by_link_text(\"确定\") window = browser.find_element_by_class_name(\"window-body\").get_attribute('innerText') if str(window).find(\"成功\") != -1: f = open('info.txt', 'a') strtime = time.strftime(\"%Y-%m-%d-%H:%M:%S\", time.localtime()) f.write('\\n' + tmp_id + \" \" +strtime) f.close() j = j-1 click_ok2.click() j = j+1 time.sleep(2) next_btn = browser.find_element_by_class_name(\"pagination-next\") next_btn.click() time.sleep(2) ","date":"2021-11-10","objectID":"/posts/python-8/:10:0","tags":["Selenium"],"title":"Selenium执行自动化操作","uri":"/posts/python-8/"},{"categories":["Python"],"content":"搭建TF-GPU环境 conda命令 conda create -n \u003cenvname\u003e python=x.x # 安装虚拟环境 conda remove -n \u003cenvname\u003e --all # 删除虚拟环境 创建py环境 conda create --name py35_tensorflow python=3.7 activate py37_tensorflow pip install tensorflow_gpu==2.5.0 TF1安装keras-contrib pip install git+https://www.github.com/keras-team/keras-contrib.git 镜像 清华 -i https://pypi.tuna.tsinghua.edu.cn/simple 豆瓣 -i https://pypi.doubanio.com/simple TF2 配置要求 Tensorflow 2.5.0 Python 3.7 cuda 11.2 cudnn 8.1.1 参考项目 https://github.com/saiwaiyanyu/bi-lstm-crf-ner-tf2.0 ","date":"2021-11-10","objectID":"/posts/build_ner/:0:0","tags":["Tensorflow"],"title":"搭建TF-GPU环境","uri":"/posts/build_ner/"},{"categories":["Python"],"content":"基于用户的(user-base)协同过滤推荐系统(cosine_similarity) 使用sklearn库进行余弦计算 import numpy as np import pandas as pd from sklearn.preprocessing import LabelEncoder from sklearn.metrics.pairwise import cosine_similarity import Loc_list df = pd.read_csv('../final_res.csv', sep=',', header=0) # 供应商数量和商品数量 n_users = df.Name.unique().shape[0] n_items = df.Scode.unique().shape[0] ","date":"2021-10-26","objectID":"/posts/python-7/:0:0","tags":["推荐系统"],"title":"余弦相似度推荐系统","uri":"/posts/python-7/"},{"categories":["Python"],"content":"数据编码 # 进行数据编码 encoder_name = LabelEncoder() user_id = encoder_name.fit_transform(df['Name']) encoder_scode = LabelEncoder() itm_id = encoder_scode.fit_transform(df['Scode']) # 复制到新的DF中 tmp = df.copy() # 编码增加到新的一列 tmp['user_id'] = user_id tmp['item_id'] = itm_id ","date":"2021-10-26","objectID":"/posts/python-7/:1:0","tags":["推荐系统"],"title":"余弦相似度推荐系统","uri":"/posts/python-7/"},{"categories":["Python"],"content":"lambda修改dataframe的一列数据 tmp['Name'] = list(map(lambda x: x, user_id)) tmp['Scode'] = list(map(lambda x: x, itm_id)) ","date":"2021-10-26","objectID":"/posts/python-7/:2:0","tags":["推荐系统"],"title":"余弦相似度推荐系统","uri":"/posts/python-7/"},{"categories":["Python"],"content":"查找该地区供应商 area = \"黑龙江省\" loc = Loc_list.open_Loc(area) loc_supplier = tmp.loc[tmp['Name'].isin(loc)] # 数组范围内查询 ","date":"2021-10-26","objectID":"/posts/python-7/:3:0","tags":["推荐系统"],"title":"余弦相似度推荐系统","uri":"/posts/python-7/"},{"categories":["Python"],"content":"创建训练集数据类型转换 train_data = tmp # 第一步是创建uesr-item矩阵，此处需创建训练和测试两个UI矩阵 train_data_matrix = np.zeros((n_users, n_items)) for line in train_data.itertuples(): # 遍历每一行,返回tuple元组 #print(line) train_data_matrix[line[4]][line[5]] = line[3] ","date":"2021-10-26","objectID":"/posts/python-7/:4:0","tags":["推荐系统"],"title":"余弦相似度推荐系统","uri":"/posts/python-7/"},{"categories":["Python"],"content":"相似度计算 user_similarity = cosine_similarity(train_data_matrix) # 返回 n_users * n_users 的矩阵 user_similarity = np.round(user_similarity, 3) # 小数点保留三位,方便计算和比较 ","date":"2021-10-26","objectID":"/posts/python-7/:5:0","tags":["推荐系统"],"title":"余弦相似度推荐系统","uri":"/posts/python-7/"},{"categories":["Python"],"content":"供应商相似度计算 res = encoder_name.transform(['江西远途电力技术服务有限公司']) #反向编码,键值获得编码值 dic = {} for i in range(0, user_similarity[res].shape[1]): tmp_list = [i] dic[encoder_name.inverse_transform(tmp_list)[0]] = user_similarity[res][0][i] res = sorted(dic.items(), key = lambda kv:(kv[1], kv[0]), reverse=True) # 对字典的value进行排序 print(res[1:10]) # 返回前十个相似度最高的供应商 ","date":"2021-10-26","objectID":"/posts/python-7/:6:0","tags":["推荐系统"],"title":"余弦相似度推荐系统","uri":"/posts/python-7/"},{"categories":["Python"],"content":"基于用户的(user-base)协同过滤推荐系统 用于参加集团大数据竞赛 基于用户的(user-base)协同过滤推荐系统 Pandas+openpyxl操作Excel from pandas import read_excel from openpyxl import * # 定义文件地址 addr = \"res.xlsx\" # 加载excel文件 wb = load_workbook(addr) # 加载sheet ws = wb[\"Sheet1\"] # pandas读取excel文件 取第二个sheet data = read_excel(r'1020.xlsx', 1) for i in range(1, num-1): col1 = data.iloc[i][\"loc\"] # 读取第i+1行的 'loc'字段 col2 = str(data.iloc[i][\"fcode\"]) col3 = str(data.iloc[i][\"scode\"]) col4 = str(data.iloc[i][\"order\"]) col5 = data.iloc[i][\"supplier\"] res = col5.split(\",\", -1) # 对字符串进行分割,返回数组,参数为'-1',表示全部分割 print(i) for j in range(0, len(res)): row = count # 在sheet中写入行 ws.append([col1, col2, col3, col4, res[j]]) count = count + 1 # 保存文件 wb.save(addr) 数据归一化处理 import pandas as pd # 归一化函数,对count列数值进行归一操作 def horizon(value): value[\"count\"] = round((value[\"count\"]/(value[\"count\"].max() - value[\"count\"].min()+1))*5,2) return value list_code = pd.read_csv(r'code_list.csv') data = pd.read_csv(r'../Mid_Data/train_data.csv') for i in range(0, len(list_code)): # 对dataframe进行条件筛选 data.loc[data[\"Scode\"] == str(list_code.loc[i][\"Scode\"])] = horizon(data.loc[data[\"Scode\"] == str(list_code.loc[i][\"Scode\"])]) data.to_csv(r'final_res.csv', index = False) ","date":"2021-10-25","objectID":"/posts/python-6/:0:0","tags":["推荐系统"],"title":"协同过滤推荐系统","uri":"/posts/python-6/"},{"categories":["Python"],"content":"Dataframe条件筛选 # data.loc[条件语句] data.loc[data[\"Scode\"] == str(list_code.loc[i][\"Scode\"])] 归类数据返回字典 def open_Loc(provice_name): file_data = open(\"../locANDname.csv\",'r', encoding='UTF-8') tmpdata = {} for line in file_data.readlines()[1:]: line = line.strip().split(',') if not line[0] in tmpdata.keys(): tmpdata[line[0]] = [line[1]] else: tmpdata[line[0]].append(line[1]) return tmpdata[provice_name] 推荐系统算法 from math import * import Loc_list as loc_data # 返回rating字典 def open_Rateing(): file = open(\"one_res.csv\", 'r', encoding='UTF-8') data = {} for tmpline in file.readlines()[1:]: tmpline = tmpline.strip().split(',') if not tmpline[0] in data.keys(): data[tmpline[0]] = {tmpline[1]: tmpline[2]} else: data[tmpline[0]][tmpline[1]] = tmpline[2] return data ","date":"2021-10-25","objectID":"/posts/python-6/:1:0","tags":["推荐系统"],"title":"协同过滤推荐系统","uri":"/posts/python-6/"},{"categories":["Python"],"content":"欧氏距离 计算的是两点间的直线距离 数值上的绝对差异 def Euclidean(data, user1, user2): user1_data = data[user1] user2_data = data[user2] distance = 0 for key in user1_data.keys(): if key in user2_data.keys(): distance += pow(float(user1_data[key]) - float(user2_data[key]), 2) return 1 / (1 + sqrt(distance)) ","date":"2021-10-25","objectID":"/posts/python-6/:2:0","tags":["推荐系统"],"title":"协同过滤推荐系统","uri":"/posts/python-6/"},{"categories":["Python"],"content":"皮尔逊相似系数 def pearson_sim(data, user1, user2): user1_data = data[user1] user2_data = data[user2] common = {} for key in user1_data.keys(): if key in user2_data.keys(): common[key] = 1 if len(common) == 0: return 0 n = len(common) print(n, common) ##计算评分和 sum1 = sum([float(user1_data[movie]) for movie in common]) sum2 = sum([float(user2_data[movie]) for movie in common]) ##计算评分平方和 sum1Sq = sum([pow(float(user1_data[movie]), 2) for movie in common]) sum2Sq = sum([pow(float(user2_data[movie]), 2) for movie in common]) ##计算乘积和 PSum = sum([float(user1_data[it]) * float(user2_data[it]) for it in common]) ##计算相关系数 num = PSum - (sum1 * sum2 / n) den = 0 # noinspection PyBroadException try: shit1 = sum1Sq - pow(sum1, 2) / n shit2 = sum2Sq - pow(sum2, 2) / n cal_tmp = shit1 * shit2 cal_tmp = round(cal_tmp, 3) den = sqrt(cal_tmp) except Exception as a: print(str(a)) if den == 0: return 0 r = num / den return r ","date":"2021-10-25","objectID":"/posts/python-6/:3:0","tags":["推荐系统"],"title":"协同过滤推荐系统","uri":"/posts/python-6/"},{"categories":["Python"],"content":"杰卡德相似度 Jaccard（杰卡德）相似性系数主要用于计算符号度量或布尔值度量的样本间的相似度。 若样本间的特征属性由符号和布尔值标识，无法衡量差异具体值的大小，只能获得“是否相同*”*这样一种结果，而Jaccard系数关心的是样本间共同具有的特征。 def jaccard(data, user1, user2): user1_data = data[user1] user2_data = data[user2] tmp = 0 for key in user1_data.keys(): if key in user2_data.keys(): tmp = tmp+1 fenmu = len(user1_data) + len(user2_data) - tmp # 并集 jaccard_coefficient = float(tmp / fenmu) # 交集 return jaccard_coefficient ","date":"2021-10-25","objectID":"/posts/python-6/:4:0","tags":["推荐系统"],"title":"协同过滤推荐系统","uri":"/posts/python-6/"},{"categories":["Python"],"content":"返回相似度最高的10个 def top10_simliar(data, AreaUser, userID): tmpres = [] for userid in AreaUser: # 排除与自己计算相似度 if not userid == userID: simliar = jaccard(data, userID, userid) #simliar = pearson_sim(data, userID, userid) tmpres.append((userid, simliar)) #res.sort(key=lambda val: val[1]) tmpres.sort(key=lambda val: val[1], reverse=True) return tmpres[:10] ","date":"2021-10-25","objectID":"/posts/python-6/:5:0","tags":["推荐系统"],"title":"协同过滤推荐系统","uri":"/posts/python-6/"},{"categories":["Python"],"content":"主函数 if __name__ == '__main__': rating_data = open_Rateing() area = \"黑龙江省\" area_list = loc_data[area] res = top10_simliar(rating_data, area_list, \"江西远途电力技术服务有限公司\") print(res) ","date":"2021-10-25","objectID":"/posts/python-6/:6:0","tags":["推荐系统"],"title":"协同过滤推荐系统","uri":"/posts/python-6/"},{"categories":["Python"],"content":"爬虫接口监控 获取cookies import requests # 返回所需要的登录牌照 def get_cookies(): data = {'j_username': '***', 'j_password': '***'} login_url = '***' session = requests.Session() session.keep_alive = False session.post(login_url, data) return session.cookies 处理json文件 import json def readJson(filename): filen = \"./%s\"%filename with open(filen, \"r\", encoding='utf-8') as f: loaded_dic = json.load(f) print(loaded_dic) return loaded_dic def writeJson(filename, data): filen = \"./%s\" % filename with open(filen, \"w\", encoding='utf-8') as f: json.dump(data, f, ensure_ascii=False) return True 得到监控数据 import requests headers = { 'User-agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36' } def get_interfaceList(post_url,cook): \"\"\" 获得各个接口的报错 总数 和 接口唯一标识码 目前仅支持服务端报错和客户端报错 :param post_url: 请求网址 :param cook: cookie登录令牌 :return: list\u003cdic\u003e \"\"\" result = requests.get(post_url, headers=headers, cookies=cook) result = result.json() return result[\"rows\"] 建立监控url的枚举器 from enum import Enum class get_ClassUrl(Enum): server = \"url1\" client = \"url2\" suc_server = \"url3\" suc_client = \"url4\" 匹配异常接口数量 def equal_error(info_data, online_data, resadd): count = len(online_data) for i in range(count): interface_name = online_data[i]['interfaceName'] iserror = interface_name in info_data offline = int(info_data[interface_name]) online = int(online_data[i]['errorNum']) if iserror: if offline != online: tmp = {\"num\": interface_name + \" 失败数量异常\", \"current\": \"当前数量:\"+str(online), \"increase\": \"新增失败:\"+str(online-offline)} info_data[interface_name] = online resadd.append(tmp) else: tmp = {\"num\": \"失败接口 数量发生异常\", \"current\": \"新增%s接口\" % interface_name, \"increase\": \"新增数量%s\" % str(online)} resadd.append(tmp) #print(\"当前 失败接口 数量发生异常, 新增%s接口 新增数量%s\"%(interface_name, str(online))) info_data[interface_name] = online # 校验成功 def equal_suc(info_data, online_data, resadd): count = len(online_data) for i in range(count): interface_name = online_data[i]['interfaceName'] iserror = interface_name in info_data offline = int(info_data[interface_name]) online = int(online_data[i]['successNum']) if iserror: if offline != online: tmp = {\"num\": interface_name +\" 成功数量异常\", \"current\": \"当前数量:\" + str(online), \"increase\": \"新增成功:\" + str(online - offline)} info_data[interface_name] = int(online) resadd.append(tmp) else: tmp = {\"num\": \"成功接口 数量发生异常\", \"current\": \"新增%s接口\"%interface_name, \"increase\": \"新增数量%s\"%str(online)} resadd.append(tmp) #print(\"当前 成功接口 数量发生异常, 新增%s接口 新增数量%s\"%(interface_name, str(online))) info_data[interface_name] = online 主函数文件 from GetCookies import get_cookies from GetList import get_interfaceList from UrlSelector import get_ClassUrl import ExcData import SendEmail session = get_cookies() json_data = ExcData.readJson(\"data.json\") # 读取json文件方式 server_data = get_interfaceList(get_ClassUrl.server.value, session) client_data = get_interfaceList(get_ClassUrl.client.value, session) server_data2 = get_interfaceList(get_ClassUrl.suc_server.value, session) client_data2 = get_interfaceList(get_ClassUrl.suc_client.value, session) # 验证 res = [] equal_error(json_data[\"fail_server\"], server_data, res) equal_error(json_data[\"fail_client\"], client_data, res) equal_suc(json_data[\"suc_server\"], server_data2, res) equal_suc(json_data[\"suc_client\"], client_data2, res) #print(json_data) result = ExcData.writeJson(\"data.json\", json_data) if result: SendEmail.send_email(\"weixusheng@cweme.com\", res) else: print(\"System Error\") ","date":"2021-10-21","objectID":"/posts/python-4/:0:0","tags":["Python-Spider"],"title":"自动化接口监控","uri":"/posts/python-4/"},{"categories":["Ubuntu"],"content":"远程服务器开发环境 Anaconda ","date":"2021-10-20","objectID":"/posts/ubuntu-30/:0:0","tags":["CloudServer","Linux-Ubuntu"],"title":"配置云服务器Python环境","uri":"/posts/ubuntu-30/"},{"categories":["Ubuntu"],"content":"安装 bash ~/Downloads/Anaconda3-2020.02-Linux-x86_64.sh # 安装anconda source ~/.bashrc # 激活 ","date":"2021-10-20","objectID":"/posts/ubuntu-30/:1:0","tags":["CloudServer","Linux-Ubuntu"],"title":"配置云服务器Python环境","uri":"/posts/ubuntu-30/"},{"categories":["Ubuntu"],"content":"重装 sudo su root # 切换root权限 conda info # 查看conda路径 rm -rf /home/ubuntu/anaconda3 # 删除文件 sudo gedit ~/.bashrc # 清除配置文件启动路径 在.bashrc文件末尾用#号注释掉之前添加的路径(或直接删除), 保存并关闭文件 #export PATH=/home/lq/anaconda3/bin:$PATH source ~/.bashrc # 立即生效 VNC粘贴 vncconfig\u0026 # 这个看起来有用,但是好像不好使 vncconfig -nowin\u0026 # 这个有用 关闭VNC服务 vncserver -kill :1 # 提示 Killing Xvnc process ID xxx 查找安装的包 apt list --installed # 列出所有的包 apt list --installed |grep python # 模糊查找python的包 vscode remote-ssh连接ubuntu ","date":"2021-10-20","objectID":"/posts/ubuntu-30/:2:0","tags":["CloudServer","Linux-Ubuntu"],"title":"配置云服务器Python环境","uri":"/posts/ubuntu-30/"},{"categories":["Ubuntu"],"content":"账号密码登录 安装remote-ssh插件 新建ssh窗口 配置文件选择 user/xxx/.ssh/config 文件 config文件 Host servername HostName ip User username ","date":"2021-10-20","objectID":"/posts/ubuntu-30/:3:0","tags":["CloudServer","Linux-Ubuntu"],"title":"配置云服务器Python环境","uri":"/posts/ubuntu-30/"},{"categories":["Ubuntu"],"content":"免密登录 window下生成秘钥 ssh-keygen # 生成id_rsa文件和id_rsa.pub文件 将id_rsa.pub文件拷贝到服务器的/root/.ssh目录下 打开/etc/ssh/sshd_config文件 PubkeyAuthentication ys # 去除注释 AuthorizedKeysFile .ssh/authorized_keys # 去除注释 执行cat id_rsa.pub \u003e\u003e authorized_keys 重启sshd服务: sudo /etc/init.d/ssh restart # 重启sshd服务 /etc/init.d/ssh start # 开启sshd服务 vim :w # 保存当前文件 :wq # 保存当前文件,并退出 :q! # 放弃修改,退出 :n # 将光标移到第n行 :f # 显示文件名称,总行数 :%s/a/b/g # 将文中所有a替换为b :split(sp) # 上下分屏显示 :vsplit(vsp) # 左右分屏显示 :set number # 设置显示正文行号 配置Pycharm远程开发 ","date":"2021-10-20","objectID":"/posts/ubuntu-30/:4:0","tags":["CloudServer","Linux-Ubuntu"],"title":"配置云服务器Python环境","uri":"/posts/ubuntu-30/"},{"categories":["Ubuntu"],"content":"1. 新建项目 file–\u003esettings–\u003eproject 或者新建项目时就选好： ","date":"2021-10-20","objectID":"/posts/ubuntu-30/:5:0","tags":["CloudServer","Linux-Ubuntu"],"title":"配置云服务器Python环境","uri":"/posts/ubuntu-30/"},{"categories":["Ubuntu"],"content":"2. 配置ssh环境(省略) ","date":"2021-10-20","objectID":"/posts/ubuntu-30/:6:0","tags":["CloudServer","Linux-Ubuntu"],"title":"配置云服务器Python环境","uri":"/posts/ubuntu-30/"},{"categories":["Ubuntu"],"content":"3. 配置文件映射关系 ","date":"2021-10-20","objectID":"/posts/ubuntu-30/:7:0","tags":["CloudServer","Linux-Ubuntu"],"title":"配置云服务器Python环境","uri":"/posts/ubuntu-30/"},{"categories":["Ubuntu"],"content":"注意:要设置登录账号为root, 否则上传项目文件到ubuntu会权限不足 服务器设置root登录 1、先用ubuntu账号登录，执行sudo passwd root 2、按要求输入密码，请牢记。 3、执行sudo vi /etc/ssh/sshd_config 4、找到PermitRootLogin without-password这一行，把后面的without-password改为yes，取消注释，保存文件。 5、执行sudo service ssh restart PermitRootLogin yes 允许root登录 设为yes PermitRootLogin prohibit-password 允许root登录，但是禁止root用密码登录 xlrd报错 pandas无法打开.xlsx文件，xlrd.biffh.XLRDError: Excel xlsx file； not supported 原因是最近xlrd更新到了2.0.1版本，只支持.xls文件。所以pandas.read_excel(‘xxx.xlsx’)会报错。 可以安装旧版xlrd1.2.0 pip uninstall xlrd pip install xlrd==1.2.0 ","date":"2021-10-20","objectID":"/posts/ubuntu-30/:8:0","tags":["CloudServer","Linux-Ubuntu"],"title":"配置云服务器Python环境","uri":"/posts/ubuntu-30/"},{"categories":["Python"],"content":"xlwt写入Excel文件 创建 workbook = xlwt.Workbook() worksheet = workbook.add_sheet('推送失败') 表格样式 ","date":"2021-10-16","objectID":"/posts/python-3/:0:0","tags":["Excel"],"title":"Python创建excel文件","uri":"/posts/python-3/"},{"categories":["Python"],"content":"行高 worksheet.row(0).height_mismatch = True # 开启设置行高 worksheet.row(0).height = 20 * 30 # 20为基准数，40磅 ","date":"2021-10-16","objectID":"/posts/python-3/:1:0","tags":["Excel"],"title":"Python创建excel文件","uri":"/posts/python-3/"},{"categories":["Python"],"content":"表格文字居中 style = xlwt.XFStyle() # 创建一个样式对象，初始化样式 al = xlwt.Alignment() # al.horz = 0x02 # 设置水平居中 al.vert = 0x01 # 设置垂直居中 style.alignment = al style2 = xlwt.XFStyle() style2.alignment = al pattern = xlwt.Pattern() # Create the Pattern # 设置表格底色(颜色标记) pattern.pattern = xlwt.Pattern.SOLID_PATTERN # May be: NO_PATTERN, SOLID_PATTERN, or 0x00 through 0x12 pattern.pattern_fore_colour = 5 # May be: 8 through 63. 0 = Black, 1 = White, 2 = Red, 3 = Green, 4 = Blue, 5 = Yellow, 6 = Magenta, 7 = Cyan, 16 = Maroon, 17 = Dark Green, 18 = Dark Blue, 19 = Dark Yellow , almost brown), 20 = Dark Magenta, 21 = Teal, 22 = Light Gray, 23 = Dark Gray, the list goes on... style2.pattern = pattern 写入数据 worksheet.write(0, 0, '法务系统机构名称', style2) # 第1行,第1列 worksheet.col(0).width = 10000 # 规定列宽 worksheet.write(0, 0, '法务系统机构名称', style2) # 第1行,第2列 worksheet.write(0, 1, '法务系统登陆账号', style2) # 第1行,第3列 worksheet.col(1).width = 7000 worksheet.write(0, 2, '电商平台机构名称', style2) worksheet.col(2).width = 10000 worksheet.write(0, 3, '机构ID', style2) worksheet.col(3).width = 7000 worksheet.write(0, 4, '人员名称', style2) worksheet.col(4).width = 7000 worksheet.write(0, 5, '人员ID', style2) worksheet.col(5).width = 7000 ... workbook.save('excel_name.xls') # 保存文件 ","date":"2021-10-16","objectID":"/posts/python-3/:2:0","tags":["Excel"],"title":"Python创建excel文件","uri":"/posts/python-3/"},{"categories":["Python"],"content":"使用第三方SMTP发送HTML邮件 引入库 import smtplib from email.mime.text import MIMEText from email.header import Header 设置smtp基本信息 mail_host = \"smtp.163.com\" # 设置服务器 mail_user = \"cdt_cweme@163.com\" # 邮箱用户名 mail_pass = \"xxx\" # 口令(需要在stmp设置页面上查看\" 邮箱内容 sender = 'cdt_cweme@163.com' # 发送方 email_addrs = 'xxx@qq.com' # 接收方 mail_msg = \"\"\" \u003cp\u003e您的推送失败合同，法务正在处理中,请在一个小时后查看合同状态\u003c/p\u003e \u003cp\u003e\u003ca href=\"https://docs.qq.com\"\u003e可查看当前处理状态\u003c/a\u003e\u003c/p\u003e \"\"\" message = MIMEText(mail_msg, 'html', 'utf-8') # 发送内容的格式 message['From'] = sender # 发送方 message['To'] = email_addrs # 接收方 subject = '合同推送法务失败-处理进度反馈' # 邮件主题 message['Subject'] = Header(subject, 'utf-8') # 主题文本格式 发送 smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) # 25 为 SMTP 端口号 smtpObj.login(mail_user, mail_pass) smtpObj.sendmail(sender, email_addrs, message.as_string()) ","date":"2021-10-16","objectID":"/posts/python-5/:0:0","tags":["Python-Email"],"title":"Python发送邮件","uri":"/posts/python-5/"},{"categories":["ShortCut"],"content":"删除重复书签 Bookmarks clean up 可以合并同名文件夹，删除失效书签，删除重复书签 太好用了！！！！！！！ 由于Bookmarks clean up 展示完重复书签，不能自动选，而需要用户手动选中 如果书签量很大的话，就需要大量的工作了，下面代码功能就是自动选中其他书签 可以自己改代码，根据书签特征来选择 Step: 打开Bookmarks clean up Find duplicated bookmarks 打开Chrome 控制台 控制台输入下面代码 var dupArray = document.getElementsByClassName(\"duplicate card\") for ( var i = 0; i \u003cdupArray.length; i++){ var items = dupArray[i].getElementsByClassName(\"list-group-item\"); if (items.length \u003e= 2) { // 默认设置第一个以外的item选中 for (var j = 1; j \u003c items.length; j++) { var item = items[j] var checkbox = item.getElementsByClassName(\"custom-control-input\") console.log(checkbox) checkbox.item(0).click() } } } ","date":"2021-10-14","objectID":"/posts/shortcut-2/:0:0","tags":["Chrome"],"title":"Chrome删除重复书签","uri":"/posts/shortcut-2/"},{"categories":["Python"],"content":"读写Excel.写入Word 写入Word(docx) ","date":"2021-10-11","objectID":"/posts/python-2/:0:0","tags":["Excel","Word"],"title":"Python自动化办公","uri":"/posts/python-2/"},{"categories":["Python"],"content":"引入库 from docx import Document # 文档 from docx.shared import Inches # 设置距离 from docx.shared import Cm, Pt # 设置单位 from docx.oxml.ns import qn # 设置中文字体 from docx.enum.text import WD_PARAGRAPH_ALIGNMENT # 段落居中样式 from docx.enum.table import WD_CELL_VERTICAL_ALIGNMENT # 表格居中样式 ","date":"2021-10-11","objectID":"/posts/python-2/:1:0","tags":["Excel","Word"],"title":"Python自动化办公","uri":"/posts/python-2/"},{"categories":["Python"],"content":"创建word文件 document = Document() ","date":"2021-10-11","objectID":"/posts/python-2/:2:0","tags":["Excel","Word"],"title":"Python自动化办公","uri":"/posts/python-2/"},{"categories":["Python"],"content":"添加图片 document.add_picture('dt_logo.png', width=Inches(4.165)) ","date":"2021-10-11","objectID":"/posts/python-2/:3:0","tags":["Excel","Word"],"title":"Python自动化办公","uri":"/posts/python-2/"},{"categories":["Python"],"content":"增加段落和文字 p = document.add_paragraph() p.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER # 设置段落样式 居中 p4.paragraph_format.first_line_indent = Cm(0.74) # 设置首段缩进 a = p.add_run('电子商务平台交易服务费付款通知') # 段落中添加文字 a.font.name = u'仿宋_GB2312' # 设置字体 a._element.rPr.rFonts.set(qn('w:eastAsia'), u'仿宋_GB2312') a.font.size = Pt(22) # 设置文字大小 单位:磅 a3.bold = True # 设置文字粗体 ","date":"2021-10-11","objectID":"/posts/python-2/:4:0","tags":["Excel","Word"],"title":"Python自动化办公","uri":"/posts/python-2/"},{"categories":["Python"],"content":"添加空行 # 用了笨方法,添加一个没有内容的段落 blank1 = document.add_paragraph() b1 = blank1.add_run(' ') b1.font.name = u'仿宋_GB2312' b1.font.size = Pt(22) ","date":"2021-10-11","objectID":"/posts/python-2/:5:0","tags":["Excel","Word"],"title":"Python自动化办公","uri":"/posts/python-2/"},{"categories":["Python"],"content":"表格 table = document.add_table(rows=2, cols=2, style='Medium Shading 1 Accent 6') # 两行两列,选取官方表格样式 table.rows[0].height=Pt(25) # 第一行的高度 table.rows[1].height=Pt(50) # 第二行的高度 run = table.cell(0,0).paragraphs[0].add_run(u'收款单号') # 在(0,0)表格中添加文字 run.font.name = '仿宋' # 设置文字样式 run.font.size = Pt(11) k1 = run._element k1.rPr.rFonts.set(qn('w:eastAsia'), '仿宋') table.cell(0,0).paragraphs[0].alignment = WD_PARAGRAPH_ALIGNMENT.CENTER # 水平居中 table.cell(0,0).vertical_alignment = WD_CELL_VERTICAL_ALIGNMENT.CENTER # 垂直居中 ","date":"2021-10-11","objectID":"/posts/python-2/:6:0","tags":["Excel","Word"],"title":"Python自动化办公","uri":"/posts/python-2/"},{"categories":["Python"],"content":"段落统一文字样式 p5 = document.add_paragraph() list_font = [] list_font.append(p5.add_run('支付方式：\\n')) tmp = p5.add_run('在线支付【推荐，实时结算】。') tmp.bold = True list_font.append(tmp) list_font.append(p5.add_run('登录平台后，通过管理中心-支付平台-交易费收款单，弹出缴纳页面进行支付。\\n联系人：大唐电子商务平台\\n')) list_font.append(p5.add_run('联系电话：400-888-6262\\n\\n\\n\\n')) for i in range(len(list_font)): list_font[i].font.name = u'仿宋_GB2312' list_font[i]._element.rPr.rFonts.set(qn('w:eastAsia'), u'仿宋_GB2312') list_font[i].font.size = Pt(12) 读取Excel Pandas Pandas 读取 Excel 是基于 xlrd 的封装 操作更方便,并且可使用Pandas各种数据处理方法 from pandas import read_excel try: #readbook = xlrd.open_workbook(r'info.xlsx') data = read_excel(r'info.xlsx', 1) pass except Exception as e: print(str(e)) else: row_num = input(\"请输入数量:\") row_num = int(row_num) res = data[0:row_num] # 返回前row_num行的数据 return res ''' 返回DataFrame数据 ''' ","date":"2021-10-11","objectID":"/posts/python-2/:7:0","tags":["Excel","Word"],"title":"Python自动化办公","uri":"/posts/python-2/"},{"categories":["Python"],"content":"xlrd import xlrd # noinspection PyBroadException try: readbook = xlrd.open_workbook(r'info.xlsx') pass except Exception as e: #print(\"文件打开异常\") print(str(e)) else: # 失败 sheet = readbook.sheet_by_index(0) # 读取第一个sheet data_server = sheet.col_values(2, start_rowx=1, end_rowx=18) #读取服务端 #server_data = get_interfaceList(get_ClassUrl.server.value, session) data_client = sheet.col_values(2, start_rowx=19, end_rowx=24) #读取客户端 #client_data = get_interfaceList(get_ClassUrl.client.value, session) # 成功 sheet = readbook.sheet_by_index(1) data_server2 = sheet.col_values(2, start_rowx=1, end_rowx=3) # 读取服务端 #server_data2 = get_interfaceList(get_ClassUrl.suc_server.value, session) data_client2 = sheet.col_values(2, start_rowx=4, end_rowx=7) # 读取客户端 #client_data2 = get_interfaceList(get_ClassUrl.suc_client.value, session) ","date":"2021-10-11","objectID":"/posts/python-2/:8:0","tags":["Excel","Word"],"title":"Python自动化办公","uri":"/posts/python-2/"},{"categories":["Python"],"content":"读取数据 sheet = readbook.sheet_by_index(0) # 读取第一个sheet data_server = sheet.col_values(2, start_rowx=1, end_rowx=18) # 读取第三列 起始为第二行,终点为17行 ''' 返回数组 ''' ","date":"2021-10-11","objectID":"/posts/python-2/:9:0","tags":["Excel","Word"],"title":"Python自动化办公","uri":"/posts/python-2/"},{"categories":["Python"],"content":"Jupyter Notebook和conda ","date":"2021-09-17","objectID":"/posts/Jupyter/:0:0","tags":["Jupyter"],"title":"关联Jupyter Notebook和conda","uri":"/posts/Jupyter/"},{"categories":["Python"],"content":"关联Jupyter Notebook和conda 安装nb_conda conda install nb_conda env环境错误的问题 更改文件： \\anaconda\\Lib\\sitepackages\\\rnb_conda\\[envmanger.py] 搜索其中的： 将其改为： 重新打开Jupyter Notebook，问题得到解决。 ","date":"2021-09-17","objectID":"/posts/Jupyter/:0:1","tags":["Jupyter"],"title":"关联Jupyter Notebook和conda","uri":"/posts/Jupyter/"},{"categories":["Python"],"content":"修改Jupyter启示文件位置 打开 Anaconda Prompt输入 jupyter notebook --generate-config 生成 Jupyter notebook 的配置文件 打开此文件jupyter_notebook_config.py 找到c.NotebookApp.notebook_dir 这个变量 1. 确保删除 “#”，取消这一行的注释模式。 2. 这一行代码前不能有空格。 3. 路径一定要是已经存在的，否则会闪退。且路径要用英文单引号括起来。 4. 路径要写\\\\转义, 或者在路径字符串前用r标识. 例:c.NotebookApp.notebook_dir = r'C:\\Users\\Administrator\\Desktop\\jupyter' ","date":"2021-09-17","objectID":"/posts/Jupyter/:0:2","tags":["Jupyter"],"title":"关联Jupyter Notebook和conda","uri":"/posts/Jupyter/"},{"categories":["Python"],"content":"ORM sqlalchemy ","date":"2021-09-15","objectID":"/posts/python_SQL-1/:0:0","tags":["SQLAlchemy"],"title":"SQLAlchemy","uri":"/posts/python_SQL-1/"},{"categories":["Python"],"content":"连接mysql from sqlalchemy.orm import sessionmaker DBSession = sessionmaker(bind=engine) session = DBSession() ","date":"2021-09-15","objectID":"/posts/python_SQL-1/:0:1","tags":["SQLAlchemy"],"title":"SQLAlchemy","uri":"/posts/python_SQL-1/"},{"categories":["Python"],"content":"创建表 from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String engine = create_engine('mysql+pymysql://fxq:123456@192.168.100.101/sqlalchemy') metadata = MetaData(engine) student = Table('student', metadata, Column('id', Integer, primary_key=True), Column('name', String(50), ), Column('age', Integer), Column('address', String(10)), ) metadata.create_all(engine) ","date":"2021-09-15","objectID":"/posts/python_SQL-1/:0:2","tags":["SQLAlchemy"],"title":"SQLAlchemy","uri":"/posts/python_SQL-1/"},{"categories":["Python"],"content":"添加 student1 = Student(id=1001, name='ling', age=25, address=\"beijing\") student2 = Student(id=1002, name='molin', age=18, address=\"jiangxi\") student3 = Student(id=1003, name='karl', age=16, address=\"suzhou\") session.add_all([student1, student2, student3]) session.commit() session.close() ","date":"2021-09-15","objectID":"/posts/python_SQL-1/:0:3","tags":["SQLAlchemy"],"title":"SQLAlchemy","uri":"/posts/python_SQL-1/"},{"categories":["Python"],"content":"查询 my_stdent = session.query(Student).filter_by(name=\"fengxiaoqing2\").first() print(my_stdent.id,my_stdent.name,my_stdent.age,my_stdent.address) filter() 过滤表的条件 my_stdent = session.query(Student).filter(Student.name.like(\"%feng%\")) # equals: query(Student).filter(Student.id == 10001) # not equals: query(Student).filter(Student.id != 100) # LIKE: query(Student).filter(Student.name.like(“%feng%”)) # IN: query(Student).filter(Student.name.in_(['feng', 'xiao', 'qing'])) not in query(Student).filter(~Student.name.in_(['feng', 'xiao', 'qing'])) # AND: from sqlalchemy import and_ query(Student).filter(and_(Student.name == 'fengxiaoqing', Student.id ==10001)) # 或者 query(Student).filter(Student.name == 'fengxiaoqing').filter(Student.address == 'chengde') # OR: from sqlalchemy import or_ query.filter(or_(Student.name == 'fengxiaoqing', Student.age ==18)) all()返回列表 my_stdent = session.query(Student).filter(Student.name.like(\"%feng%\")).all() filter()和filter_by() Filter： 可以像写 sql 的 where 条件那样写 \u003e \u003c 等条件，但引用列名时，需要通过 类名.属性名 的方式。 filter_by： 可以使用 python 的正常参数传递方法传递条件，指定列名时，不需要额外指定类名。，参数名对应名类中的属性名，但似乎不能使用 \u003e \u003c 等条件。 当使用filter的时候条件之间是使用“==\"，fitler_by使用的是\"=\" user1 = session.query(User).filter_by(id=1).first() user1 = session.query(User).filter(User.id==1).first() # 多重查询 q = sess.query(IS).filter(IS.node == node and IS.password == password).all() ","date":"2021-09-15","objectID":"/posts/python_SQL-1/:0:4","tags":["SQLAlchemy"],"title":"SQLAlchemy","uri":"/posts/python_SQL-1/"},{"categories":["Python"],"content":"更新 my_stdent = session.query(Student).filter(Student.id == 1002).first() my_stdent.name = \"fengxiaoqing\" my_stdent.address = \"chengde\" session.commit() student1 = session.query(Student).filter(Student.id == 1002).first() print(student1.name, student1.address) ","date":"2021-09-15","objectID":"/posts/python_SQL-1/:0:5","tags":["SQLAlchemy"],"title":"SQLAlchemy","uri":"/posts/python_SQL-1/"},{"categories":["Python"],"content":"删除 session.query(Student).filter(Student.id == 1001).delete() session.commit() session.close() ","date":"2021-09-15","objectID":"/posts/python_SQL-1/:0:6","tags":["SQLAlchemy"],"title":"SQLAlchemy","uri":"/posts/python_SQL-1/"},{"categories":["Python"],"content":"统计 session.query(Student).filter(Student.name.like(\"%feng%\")).count() ","date":"2021-09-15","objectID":"/posts/python_SQL-1/:0:7","tags":["SQLAlchemy"],"title":"SQLAlchemy","uri":"/posts/python_SQL-1/"},{"categories":["Python"],"content":"group_by() std_group_by = session.query(Student).group_by(Student.age) print(std_group_by) ","date":"2021-09-15","objectID":"/posts/python_SQL-1/:0:8","tags":["SQLAlchemy"],"title":"SQLAlchemy","uri":"/posts/python_SQL-1/"},{"categories":["Python"],"content":"排序反序 std_ord_desc = session.query(Student).filter(Student.name.like(\"%feng%\")).order_by(Student.id.desc()).all() for i in std_ord_desc: print(i.id) ","date":"2021-09-15","objectID":"/posts/python_SQL-1/:0:9","tags":["SQLAlchemy"],"title":"SQLAlchemy","uri":"/posts/python_SQL-1/"},{"categories":["Python"],"content":"ORM sqlalchemy merge 在新增数据时,使用 session.merge() 方法替代 session.add()，其实就是 SELECT + UPDATE merge的作用是合并，查找primary key是否一致，一致则合并，不一致则新建 def insert_interfaceList(data_list): \"\"\" 数据库-写入更新接口报错数目 :param data_list: 数据源 list\u003cdic\u003e :return: null \"\"\" session = con_sql.init_sql() v2 = timestr for i in range(0, len(data_list)): v1 = data_list[i][\"interfaceCode\"] v3 = data_list[i][\"errorNum\"] add_data = mysql_table.InterfaceError(interfaceCode=v1, monitorTime=v2, errorNum=v3) session.merge(add_data) session.commit() session.close() 映射当前存在的表 from sqlalchemy.orm import sessionmaker from sqlalchemy import create_engine, MetaData, Table from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.ext.automap import automap_base, name_for_collection_relationship from sqlalchemy.orm import Session engine = create_engine('mysql+pymysql://username:password@127.0.0.1/dtec',encoding='utf-8', echo = False) ","date":"2021-09-15","objectID":"/posts/python_SQL-2/:0:0","tags":["SQLAlchemy"],"title":"SQLAlchemy-2","uri":"/posts/python_SQL-2/"},{"categories":["Python"],"content":"使用automap方式映射表 Base = automap_base() Base.prepare(engine, reflect=True) sim_all = Base.classes.bigdata_sim_all session = Session(bind=engine) add_data = sim_all(supplier_1 = \"test5\", supplier_2 = \"test5\", sim_value = 0.7) session.merge(add_data) # 可以使用session进行操作 session.commit() session.close() ","date":"2021-09-15","objectID":"/posts/python_SQL-2/:1:0","tags":["SQLAlchemy"],"title":"SQLAlchemy-2","uri":"/posts/python_SQL-2/"},{"categories":["Python"],"content":"使用Table映射 md = MetaData(bind=engine) session = Session(bind=engine) test_table= Table('bigdata_sim_all', md, autoload=True, autoload_with=engine) add_dic = {\"supplier_1\": \"test1\",\"supplier_2\": \"test3\", \"sim_value\": 0.9} session.execute(test_table.insert(),add_dic)#增加新数据 session.commit() session.close() ","date":"2021-09-15","objectID":"/posts/python_SQL-2/:2:0","tags":["SQLAlchemy"],"title":"SQLAlchemy-2","uri":"/posts/python_SQL-2/"},{"categories":["Python"],"content":"使用类映射 Base = declarative_base() md = MetaData(bind=engine) session = Session(bind=engine) class Role(Base): #第一个参数是数据表名，第二个参数是元数据，第三个参数表示自动加载 __table__ = Table(\"bigdata_sim_all\",md,autoload=True) add_data = Role(supplier_1 = \"test1\", supplier_2 = \"test2\", sim_value = 0.7) session.merge(add_data) session.commit() session.close() ","date":"2021-09-15","objectID":"/posts/python_SQL-2/:3:0","tags":["SQLAlchemy"],"title":"SQLAlchemy-2","uri":"/posts/python_SQL-2/"},{"categories":["DTEC"],"content":"几种招标流程 ","date":"2021-09-06","objectID":"/posts/dtec-1/:0:0","tags":["招标"],"title":"招标流程图","uri":"/posts/dtec-1/"},{"categories":["Git"],"content":"Git常用命令 ","date":"2021-09-05","objectID":"/posts/git-3/:0:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"初始化git git config --global user.name \"name\" git config --global user.email tronwei@163.com ","date":"2021-09-05","objectID":"/posts/git-3/:1:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"set default editor git config --global core.editor \"code --wait\" ","date":"2021-09-05","objectID":"/posts/git-3/:2:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"edit config git config --global -e ","date":"2021-09-05","objectID":"/posts/git-3/:3:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"设置结尾符号 兼容windows和linux文件 git config --global core.autocrlf true # windows git config --global core.autocrlf input # macos/linux ","date":"2021-09-05","objectID":"/posts/git-3/:4:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"get help git config --help git config --h # get the short help ","date":"2021-09-05","objectID":"/posts/git-3/:5:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"take the snapshot mkdir moon_file cd moob_file git init ls -a # 显示所有文件(隐藏文件) ","date":"2021-09-05","objectID":"/posts/git-3/:6:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"写入文件 echo hello \u003e\u003e file1.txt git status git add file1.txt ","date":"2021-09-05","objectID":"/posts/git-3/:7:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"add+commit git commit -am \"initial commit\" ","date":"2021-09-05","objectID":"/posts/git-3/:8:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"查看staging area git ls-files ","date":"2021-09-05","objectID":"/posts/git-3/:9:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"rename file mv file1.txt main.js git add file1.txt # track the deleted file1.txt git add main.js # track the new file main.js # 简单的方式,直接用git命令rename git mv file1.txt main.js ","date":"2021-09-05","objectID":"/posts/git-3/:10:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"echo \u003e 和 » echo \"xxx\" \u003e\u003e file.txt # 重写文件为\"xxx\" echo \"xxx\" \u003e file.txt # 追加到文件最后\"xxx\" ","date":"2021-09-05","objectID":"/posts/git-3/:11:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"添加gitignore文件 echo logs/ \u003e .gitigore # logs文件夹下的文件都忽略 ","date":"2021-09-05","objectID":"/posts/git-3/:12:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"删除staging area的文件 git rm -h # 查看help git rm --cached -r bin/ # -r 参数 recursive 递归删除目录 ","date":"2021-09-05","objectID":"/posts/git-3/:13:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"可视化查看更改 git config --global diff.tool vscode git config --global difftool.vscode.cmd \"code --wait --diff $LOCAL$REMOTE\" git config --global -e # 在最后的参数中添加 \"$LOCAL $REMOTE\" git difftool # 查看当前文件的更改 git difftool --staged # 查看stage中与上次commit的对比 ","date":"2021-09-05","objectID":"/posts/git-3/:14:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"查看历史 git log git log --oneline # 简洁模式 git log --oneline --reverse # 按照时间轴(反向)顺序显示 ","date":"2021-09-05","objectID":"/posts/git-3/:15:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"查看具体commit内容 git show id # id 为commmit的id git show id:.gitignore # 查看具体文件.gitignore ","date":"2021-09-05","objectID":"/posts/git-3/:16:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"撤回更改 git restore --staged . # 撤回到上一次的commit ","date":"2021-09-05","objectID":"/posts/git-3/:17:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"还原删除文件 git rm file1.txt git commit -m \"delete the file\" git restore --sourse=HEAD~1 file1.txt ","date":"2021-09-05","objectID":"/posts/git-3/:18:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"查看历史 git log --stat git log --oneline -3 #last three command git log --oneline --author=\"name\" # 根据提交作者查询 git log --oneline --before=\"2021-4-4\" # 根据时间查询 git log --oneline --after=\"2021-4-1\" git log --oneline --after=\"yesterday\" git log --oneline --after=\"one week ago\" git log --oneline --grep=\"search_thing\" # grep: 正则表达式 git log --oneline -S\"hello world\" # 查看\"hello world\"什么时候添加到代码中的' git log --oneline toc.txt # 查看toc.txt文件被修改过的记录 git log --oneline --patch toc.txt # 查看补丁详情 git show HEAD~2 --name-only # 查看更改的文件 git show HEAD~2 --name-status # 查看被修改文件的状态 git log --oneline --all # 查看所有结点 git checkout master # 将head转移到master ","date":"2021-09-05","objectID":"/posts/git-3/:19:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"查找bug bisect(二分法查询bug) 一端标记good, 一端标记bad,之后HEAD指向中间结点 git bisect start git bisect bad git bisect good commit_id #此时HEAD指向中间结点 git log --oneline --all # 查看所有结点 ","date":"2021-09-05","objectID":"/posts/git-3/:20:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"查看contributor的commit git shortlog #查看完整信息 git shortlog -n -s -e # -n查看提交次数 -s省略详细信息 -e显示email ","date":"2021-09-05","objectID":"/posts/git-3/:21:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"查看单个文件的修改记录 git log --oneline --stat toc.txt # stat显示修改状态 ","date":"2021-09-05","objectID":"/posts/git-3/:22:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"恢复删除的文件 git checkout commit_id toc.txt # checkout检出(撤销) ","date":"2021-09-05","objectID":"/posts/git-3/:23:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"标签 git tag v1.0 commit_id # 增加标签 git tag -n # 查看标签历史 git tag -d v1.1 # 删除标签 ","date":"2021-09-05","objectID":"/posts/git-3/:24:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"分支 git branch bugfix #创建分支 git branch #显示所有分支 git switch bugfix #切换分支 git branch -m bugfix bugfix/signup-bug #重命名 git branch -d bugfix # 删除分支 git branch -D bugfix # 强制删除分支 git log master..bugfix # 查看分支之间的区别(commit) git diff master..bugfix #查看分支之间的详细区别 git diff --name-only master..bugfix #查看分支之间的区别(受影响的文件名) git diff --name-stat master..bugfix #查看分支之间的区别(文件状态) git stash push -m \"new stash push\" # 提交缓存 git stash -a -m \"push all stash\" # 提交所有文件进入缓存 git stash list # 查看所有缓存 git stash drop 1 # 删除缓存 git stash clear # 清空缓存 git stash pop # 恢复缓存 git stash apply # 恢复缓存 ","date":"2021-09-05","objectID":"/posts/git-3/:25:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"Merge ","date":"2021-09-05","objectID":"/posts/git-3/:26:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"fast-forward merges fast-forward是直接将HEAD指向分支 git merge bugfix # 合并分支到master git switch -C bugfix # 创建分支并切换到分支 ","date":"2021-09-05","objectID":"/posts/git-3/:26:1","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"no-fase-forward merges 将master和分支,作为一个新的commit进行合并 git merge --no-ff bugfix # 合并分支(no fast forward) git config ff no # 关闭fast forward git config --global ff no ","date":"2021-09-05","objectID":"/posts/git-3/:26:2","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"查看分支图像 git log --oneline --all --graph ","date":"2021-09-05","objectID":"/posts/git-3/:27:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"查看分支 git branch --merged # 查看已并入master的分支 git branch --no-merged # 查看没有并入master的分支 ","date":"2021-09-05","objectID":"/posts/git-3/:28:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"分支冲突 如果在合并时,存在文件被分支和master同时修改,那么就会发生冲突 手动解决方式: 在vscode中,将分支修改或master修改删除,再commit ","date":"2021-09-05","objectID":"/posts/git-3/:29:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"可视化合并分支 使用工具p4merge git config --global merge.tool p4merge # 设置p4merge为默认工具 git config --global mergetool.p4merge.path \"D:/p4merge/\" # 设定p4merge程序路径 git mergetool ","date":"2021-09-05","objectID":"/posts/git-3/:30:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"终止merge git merge --abort ","date":"2021-09-05","objectID":"/posts/git-3/:31:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"撤销merge git reset –-soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可； git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉； git reset --hard HEAD~1 # 撤回到上一个master结点 ","date":"2021-09-05","objectID":"/posts/git-3/:32:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"squash merging 将分支节点进行合并,合并出的新节点,作为新的master结点 此时新节点只有一个parent—\u003emaster git merge --squash bugfix ","date":"2021-09-05","objectID":"/posts/git-3/:33:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"rebasing 将分支节点连接到当前的master结点(linear) 之后执行fast-forward,即可将分支结点与master连接,成为linear git rebase master 如果产生冲突,则在mergetool中解决 git mergetool git rebase --continue 终止rebase git reabse --abort ","date":"2021-09-05","objectID":"/posts/git-3/:34:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"cherry picking 从分支中,拿出一个结点,作为master上的新节点(过程中没有合并) git cherry-pick commit_id ","date":"2021-09-05","objectID":"/posts/git-3/:35:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Git"],"content":"branch file add master git restore --sourse=fixbug toc.txt ","date":"2021-09-05","objectID":"/posts/git-3/:36:0","tags":["Git基础"],"title":"Git命令-3","uri":"/posts/git-3/"},{"categories":["Java"],"content":"了解一下单元测试! 什么是Junit JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一 JUnit 促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。这个方法就好比“测试一点，编码一点，测试一点，编码一点……”，增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间 什么是单元测试 单元测试用例是一部分代码，可以确保另一端代码（方法）按预期工作。为了迅速达到预期的结果，就需要测试框架。JUnit 是 java 编程语言理想的单元测试框架。 ","date":"2021-05-11","objectID":"/posts/junit-1/:0:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"人工测试 手动执行测试用例并不借助任何工具的测试被称为人工测试。 - 消耗时间并单调：由于测试用例是由人力资源执行，所以非常缓慢并乏味。 - 人力资源上投资巨大：由于测试用例需要人工执行，所以在人工测试上需要更多的试验员。 - 可信度较低：人工测试可信度较低是可能由于人工错误导致测试运行时不够精确。 - 非程式化：编写复杂并可以获取隐藏的信息的测试的话，这样的程序无法编写。 ","date":"2021-05-11","objectID":"/posts/junit-1/:1:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"自动测试 借助工具支持并且利用自动工具执行用例被称为自动测试。 - 快速自动化运行测试用例时明显比人力资源快。 - 人力资源投资较少：测试用例由自动工具执行，所以在自动测试中需要较少的试验员。 - 可信度更高：自动化测试每次运行时精确地执行相同的操作。 - 程式化：试验员可以编写复杂的测试来显示隐藏信息。 一个正式的编写好的单元测试用例的特点是：已知输入和预期输出，即在测试执行前就已知。已知输入需要测试的先决条件，预期输出需要测试后置条件。 优点 可以书写一系列的测试方法，对项目所有的接口或者方法进行单元测试。 启动后，自动化测试，并判断执行结果, 不需要人为的干预。 只需要查看最后结果，就知道整个项目的方法接口是否通畅。 每个单元测试用例相对独立，由Junit 启动，自动调用。不需要添加额外的调用语句。 添加，删除，屏蔽测试方法，不影响其他的测试方法。 开源框架都对JUnit 有相应的支持。 编写一个Junit ","date":"2021-05-11","objectID":"/posts/junit-1/:2:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"引入jar包 使用Maven管理器,在pom.xml中添加 \u003c!-- https://mvnrepository.com/artifact/junit/junit --\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e ","date":"2021-05-11","objectID":"/posts/junit-1/:3:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"项目目录 新建Maven项目,目录正好符合要求 其中test就是存放测试代码的地方 被测试代码放在main下的java目录中，junit测试代码放在test下的java目录中，形成一一对应关系，测试代码使用Test开头命名 ","date":"2021-05-11","objectID":"/posts/junit-1/:4:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"单一单元测试实例 ","date":"2021-05-11","objectID":"/posts/junit-1/:5:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"MessageDemo.java // path: src/main/java/MessageDemo.java public class MessageDemo { private String message; public MessageDemo(String message){ this.message = message; } public String printMessage(){ System.out.println(this.message); return message; } } ","date":"2021-05-11","objectID":"/posts/junit-1/:5:1","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"TestMessageDemo.java // path: src/test/java/TestMessageDemo.java import org.junit.Test; import static org.junit.Assert.assertEquals; public class TestMessageDemo { private String message = \"HelloWorld\"; private MessageDemo messageDemo = new MessageDemo(this.message); @Test public void testPrintMessage(){ assertEquals(message, messageDemo.printMessage()); } } TestRunner.java // path: src/test/java/TestRunner import org.junit.Test; import org.junit.runner.JUnitCore; import org.junit.runner.Result; import org.junit.runner.notification.Failure; public class TestRunner { public static void main(String[] args) { Result result = JUnitCore.runClasses(TestMessageDemo.class); for (Failure failure : result.getFailures()){ System.out.println(failure.toString()); } System.out.println(\"测试结果\" + result.wasSuccessful()); } } MessageDemo.java为业务代码(待测试代码) TestMessageDemo为测试代码,对业务代码进行判断assertEquals TestRunner为测试运行代码,是main主函数 ","date":"2021-05-11","objectID":"/posts/junit-1/:5:2","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"JUnit 断言 什么是断言？刚开始我也很困惑，后来搞了大半天才明白断言就是\"判断\"。 Junit所有的断言都包含在 Assert 类中。 这个类提供了很多有用的断言方法来编写测试用例。只有失败的断言才会被记录。Assert 类中的一些有用的方法列式如下： void assertEquals(boolean expected, boolean actual):检查两个变量或者等式是否平衡 void assertTrue(boolean expected, boolean actual):检查条件为真 void assertFalse(boolean condition):检查条件为假 void assertNotNull(Object object):检查对象不为空 void assertNull(Object object):检查对象为空 void assertSame(boolean condition):assertSame() 方法检查两个相关对象是否指向同一个对象 void assertNotSame(boolean condition):assertNotSame() 方法检查两个相关对象是否不指向同一个对象 void assertArrayEquals(expectedArray, resultArray):assertArrayEquals() 方法检查两个数组是否相等 ","date":"2021-05-11","objectID":"/posts/junit-1/:6:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"JUnit 注解 @Test:这个注释说明依附在 JUnit 的 public void 方法可以作为一个测试案例。 @Before:有些测试在运行前需要创造几个相似的对象。在 public void 方法加该注释是因为该方法需要在 test 方法前运行。 @After:如果你将外部资源在 Before 方法中分配，那么你需要在测试运行后释放他们。在 public void 方法加该注释是因为该方法需要在 test 方法后运行。 @BeforeClass:在 public void 方法加该注释是因为该方法需要在类中所有方法前运行。 @AfterClass:它将会使方法在所有测试结束后执行。这个可以用来进行清理活动。 @Ignore:这个注释是用来忽略有关不需要执行的测试的。 ","date":"2021-05-11","objectID":"/posts/junit-1/:7:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"JUnit 加注解执行过程 beforeClass(): 方法首先执行，并且只执行一次。 afterClass():方法最后执行，并且只执行一次。 before():方法针对每一个测试用例执行，但是是在执行测试用例之前。 after():方法针对每一个测试用例执行，但是是在执行测试用例之后。 在 before() 方法和 after() 方法之间，执行每一个测试用例。 ","date":"2021-05-11","objectID":"/posts/junit-1/:7:1","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"JUnit 执行测试 测试用例是使用 JUnitCore 类来执行的。JUnitCore 是运行测试的外观类。要从命令行运行测试，可以运行java org.junit.runner.JUnitCore。对于只有一次的测试运行，可以使用静态方法 runClasses(Class[])。 ","date":"2021-05-11","objectID":"/posts/junit-1/:8:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"多单元测试实例 ","date":"2021-05-11","objectID":"/posts/junit-1/:9:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"JUnit 套件测试 测试套件意味着捆绑几个单元测试用例并且一起执行他们。在 JUnit 中，@RunWith和@Suite注释用来运行套件测试。 ","date":"2021-05-11","objectID":"/posts/junit-1/:9:1","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"文件组成 main/java/SuiteDemo test/java/TestDemo1 test/java/TestDemo2 test/java/TestSuite test/java/TestSuiteRun 其中SuiteDemo为待测单元(业务)代码 TestDemo1,TestDemo2为两个测试单元 TestSuite将两个测试单元引入套件 TestSuiteRun为main函数,启动单元测试 ","date":"2021-05-11","objectID":"/posts/junit-1/:9:2","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"SuiteDemo public class SuiteDemo { private String message; public SuiteDemo(String message){ this.message = message; } public String printmessage(){ System.out.println(this.message); return message; } } ","date":"2021-05-11","objectID":"/posts/junit-1/:9:3","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"TestDemo1 import org.junit.Test; import static org.junit.Assert.assertEquals; public class TestDemo { private String message = \"Helloworld\"; private SuiteDemo suiteDemo = new SuiteDemo(this.message); @Test public void testPrintMessage(){ assertEquals(message, suiteDemo.printmessage()); } } ","date":"2021-05-11","objectID":"/posts/junit-1/:9:4","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"TestDemo2 import org.junit.Test; import static org.junit.Assert.assertEquals; public class TestDemo2 { private String message = \"Robert\"; private SuiteDemo suiteDemo = new SuiteDemo(this.message); @Test public void testPrintMessage(){ message = \"HI\"; assertEquals(message, suiteDemo.printmessage()); } } ","date":"2021-05-11","objectID":"/posts/junit-1/:9:5","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"TestSuite import org.junit.runner.RunWith; import org.junit.runners.Suite; @RunWith(Suite.class) @Suite.SuiteClasses({ TestDemo.class, TestDemo2.class }) public class TestSuite { } ","date":"2021-05-11","objectID":"/posts/junit-1/:9:6","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"TestSuiteRun import org.junit.runner.JUnitCore; import org.junit.runner.Result; import org.junit.runner.notification.Failure; public class TestSuiteRun { public static void main(String[] args) { Result result = JUnitCore.runClasses(TestSuite.class); for(Failure failure : result.getFailures()){ System.out.println(failure.toString()); } System.out.println(\"测试结果\" + result.wasSuccessful()); } } ","date":"2021-05-11","objectID":"/posts/junit-1/:9:7","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"Junit时间测试 如果一个测试用例比起指定的毫秒数花费了更多的时间，那么 Junit 将自动将它标记为失败。timeout参数和 @Test 注释一起使用。是不是很强大？ @Test(timeout=1000) //时间单位是毫秒 ","date":"2021-05-11","objectID":"/posts/junit-1/:10:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"JUnit 异常测试 Junit 用代码处理提供了一个追踪异常的选项。你可以测试代码是否它抛出了想要得到的异常。expected 参数和 @Test 注释一起使用。 @Test(expected = ArithmeticException.class) ","date":"2021-05-11","objectID":"/posts/junit-1/:11:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"JUnit参数化测试 使用@RunWith（Parameterized.class）注释测试类。 创建一个使用@Parameters注释的公共静态方法，该方法返回一个对象集合（作为数组）作为测试数据集。 创建一个公共构造函数，它接受相当于一行“测试数据”的内容。 为测试数据的每个“列”创建一个实例变量。 使用实例变量作为测试数据的来源创建测试用例。 对于每行数据，将调用一次测试用例 ","date":"2021-05-11","objectID":"/posts/junit-1/:12:0","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"文件结构 src/main/java/NumsDemo src/test/java/TestNumsChecker src/test/java/TestNums 其中NumsDemo为待测单元(业务)代码 TestNumsChecker为测试代码,其中包含多条测试参数 TestNums为测试执行main函数 ","date":"2021-05-11","objectID":"/posts/junit-1/:12:1","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"NumsDemo.java //path: src/main/java/NumsDemo public class NumsDemo { public boolean validate(final int primeNumber){ for(int i=2; i\u003c(primeNumber/2); i++){ if(primeNumber % i == 0){ return false; } } return true; } } ","date":"2021-05-11","objectID":"/posts/junit-1/:12:2","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"TestNumsChecker.java //path: src/test/java/TestNumsChecker import java.util.Arrays; import java.util.Collection; import org.junit.Test; import org.junit.Before; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; import org.junit.runner.RunWith; import static org.junit.Assert.assertEquals; @RunWith(Parameterized.class) public class TestNumsChecker { private Integer inputNumber; private Boolean expectedResult; private NumsDemo primeNumberChecker; @Before public void initialize() { primeNumberChecker = new NumsDemo(); } // Each parameter should be placed as an argument here // Every time runner triggers, it will pass the arguments // from parameters we defined in primeNumbers() method public TestNumsChecker(Integer inputNumber, Boolean expectedResult) { this.inputNumber = inputNumber; this.expectedResult = expectedResult; } @Parameterized.Parameters public static Collection primeNumbers() { return Arrays.asList(new Object[][] { { 2, true }, { 6, false }, { 19, true }, { 22, false }, { 23, true } }); } // This test will run 4 times since we have 5 parameters defined @Test public void testPrimeNumberChecker() { System.out.println(\"Parameterized Number is : \" + inputNumber); assertEquals(expectedResult, primeNumberChecker.validate(inputNumber)); } } ","date":"2021-05-11","objectID":"/posts/junit-1/:12:3","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"TestNums.java //path: src/test/java/TestNums import org.junit.runner.JUnitCore; import org.junit.runner.Result; import org.junit.runner.notification.Failure; public class TestNums { public static void main(String[] args) { Result result = JUnitCore.runClasses(TestNumsChecker.class); for (Failure failure : result.getFailures()) { System.out.println(failure.toString()); } System.out.println(result.wasSuccessful()); } } ","date":"2021-05-11","objectID":"/posts/junit-1/:12:4","tags":["Java测试"],"title":"初识Junit","uri":"/posts/junit-1/"},{"categories":["Java"],"content":"Java学学学! SSM这种大框架总是避不开包管理器,java我之前学的很少呜呜呜,从头开始捋吧 感觉和前一阵学的npm很像,都是自动调节包关系的,全是配置文件,没啥难的!(坚信) 安装 安装的话,下载安装包文件,配置一下环境变量就ok 参考教程 文件结构 目录 目的 / 存放pom.xml和所有的子目录 /src/main/java 项目的java源代码 /src/main/resources 项目的资源，比如说property文件，springmvc.xml /src/test/java 项目的测试类，比如说Junit代码 /src/test/resources 测试用的资源 /src/main/webapp/WEB-INF web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面 /target 打包输出目录 /target/classes 编译输出目录 /target/test-classes 测试编译输出目录 Test.java Maven只会自动运行符合该命名规则的测试类 ~/.m2/repository Maven默认的本地仓库目录位置 基本命令 compile: 编译(将java源文件编译成class文件) test: 测试项目(执行test目录下的测试用例) package: 打包(将项目打成jar包) clean: 删除target文件夹 install: 安装(将当前项目放到Maven的本地仓库中。供其他项目使用) 仓库 Maven仓库用来存放Maven管理的所有Jar包。分为：本地仓库 和 中央仓库 本地仓库：Maven本地的Jar包仓库 中央仓库： Maven官方提供的远程仓库 当项目编译时，Maven首先从本地仓库中寻找项目所需的Jar包，若本地仓库没有，再到Maven的中央仓库下载所需Jar包 坐标 在Maven中，坐标是Jar包的唯一标识，Maven通过坐标在仓库中找到项目所需的Jar包 groupId和artifactId构成了一个Jar包的坐标 \u003cdependency\u003e \u003cgroupId\u003ecn.missbe.web.search\u003c/groupId\u003e \u003cartifactId\u003eresource-search\u003c/artifactId\u003e \u003cpackaging\u003ejar\u003c/packaging\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e groupId: 所需Jar包的项目名 artifactId: 所需Jar包的模块名 version: 所需Jar包的版本号 传递依赖 与 排除依赖 传递依赖：如果我们的项目引用了一个Jar包，而该Jar包又引用了其他Jar包，那么在默认情况下项目编译时，Maven会把直接引用和简洁引用的Jar包都下载到本地。 排除依赖：如果我们只想下载直接引用的Jar包，那么需要在pom.xml中做如下配置：(将需要排除的Jar包的坐标写在中) \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003ecn.missbe.web.search\u003c/groupId\u003e \u003cartifactId\u003eresource-search\u003c/artifactId\u003e \u003cpackaging\u003epom\u003c/packaging\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e 依赖范围scope 在项目发布过程中，帮助决定哪些构件被包括进来 compile ：用于编译 (默认范围) provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath runtime: 在执行时需要使用 test: 用于test任务时使用 system: 需要外在提供相应的元素。通过systemPath来取得 systemPath: 仅用于范围为system。提供相应的路径 optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003cscope\u003ecompile\u003c/scope\u003e \u003c/dependency\u003e 依赖冲突 若项目中多个Jar同时引用了相同的Jar时，会产生依赖冲突，但Maven采用了两种避免冲突的策略，因此在Maven中是不存在依赖冲突的 ","date":"2021-05-07","objectID":"/posts/maven/:0:0","tags":["Maven"],"title":"Maven知识点","uri":"/posts/maven/"},{"categories":["Java"],"content":"1.短路优先 本项目——\u003eA.jar——\u003eB.jar——\u003eX.jar\r本项目——\u003eC.jar——\u003eX.jar\r 若本项目引用了A.jar，A.jar又引用了B.jar，B.jar又引用了X.jar，并且C.jar也引用了X.jar,此时，Maven只会引用引用路径最短的Jar ","date":"2021-05-07","objectID":"/posts/maven/:1:0","tags":["Maven"],"title":"Maven知识点","uri":"/posts/maven/"},{"categories":["Java"],"content":"2.声明优先 若引用路径长度相同时，在pom.xml中谁先被声明就使用谁 聚合 什么是聚合？ : 将多个项目同时运行就称为聚合。 如何实现聚合？ : 只需在pom中作如下配置即可实现聚合： \u003cmodules\u003e \u003cmodule\u003eweb-connection-pool\u003c/module\u003e \u003cmodule\u003eweb-java-crawler\u003c/module\u003e \u003c/modules\u003e 继承 ","date":"2021-05-07","objectID":"/posts/maven/:2:0","tags":["Maven"],"title":"Maven知识点","uri":"/posts/maven/"},{"categories":["Java"],"content":"什么是继承? 在聚合多个项目时，如果这些被聚合的项目中需要引入相同的Jar，那么可以将这些Jar写入父pom中，各个子项目继承该pom即可。 ","date":"2021-05-07","objectID":"/posts/maven/:3:0","tags":["Maven"],"title":"Maven知识点","uri":"/posts/maven/"},{"categories":["Java"],"content":"如何实现继承？ ","date":"2021-05-07","objectID":"/posts/maven/:4:0","tags":["Maven"],"title":"Maven知识点","uri":"/posts/maven/"},{"categories":["Java"],"content":"父pom配置 将需要继承的Jar包的坐标放入标签即可。 \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.missbe.web.search\u003c/groupId\u003e \u003cartifactId\u003eresource-search\u003c/artifactId\u003e \u003cpackaging\u003epom\u003c/packaging\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencyManagement\u003e ","date":"2021-05-07","objectID":"/posts/maven/:4:1","tags":["Maven"],"title":"Maven知识点","uri":"/posts/maven/"},{"categories":["Java"],"content":"子pom配置： \u003cparent\u003e \u003cgroupId\u003e父pom所在项目的groupId\u003c/groupId\u003e \u003cartifactId\u003e父pom所在项目的artifactId\u003c/artifactId\u003e \u003cversion\u003e父pom所在项目的版本号\u003c/version\u003e \u003c/parent\u003e \u003cparent\u003e \u003cartifactId\u003eresource-search\u003c/artifactId\u003e \u003cgroupId\u003ecn.missbe.web.search\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e POM POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖等 执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标 ","date":"2021-05-07","objectID":"/posts/maven/:4:2","tags":["Maven"],"title":"Maven知识点","uri":"/posts/maven/"},{"categories":["Java"],"content":"groupId/artifactId 描述项目组 (groupId), 项目的唯一ID(artifactId) \u003cproject xmlns = \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003c!-- 模型版本 --\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003c!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --\u003e \u003cgroupId\u003ecom.companyname.project-group\u003c/groupId\u003e \u003c!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --\u003e \u003cartifactId\u003eproject\u003c/artifactId\u003e \u003c!-- 版本号 --\u003e \u003cversion\u003e1.0\u003c/version\u003e \u003c/project\u003e 节点 描述 project 工程的根标签。 modelVersion 模型版本需要设置为 4.0。 groupId 这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。 artifactId 这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。 version 这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如： com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1 ","date":"2021-05-07","objectID":"/posts/maven/:5:0","tags":["Maven"],"title":"Maven知识点","uri":"/posts/maven/"},{"categories":["Java"],"content":"POM参考文档 参考文档runoob \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd\"\u003e \u003c!--父项目的坐标。如果项目中没有规定某个元素的值， 那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--\u003e \u003cparent\u003e \u003c!--被继承的父项目的构件标识符--\u003e \u003cartifactId/\u003e \u003c!--被继承的父项目的全球唯一标识符--\u003e \u003cgroupId/\u003e \u003c!--被继承的父项目的版本--\u003e \u003cversion/\u003e \u003c/parent\u003e \u003c!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此， 但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候， 确保稳定性。--\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003c!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。 并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为： /com/mycompany/app--\u003e \u003cgroupId\u003ecn.missbe.web\u003c/groupId\u003e \u003c!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说， 你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西， Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。--\u003e \u003cartifactId\u003esearch-resources\u003c/artifactId\u003e \u003c!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建 他们自己的构件类型，所以前面列的不是全部构件类型--\u003e \u003cpackaging\u003ewar\u003c/packaging\u003e \u003c!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c!--项目的名称, Maven产生的文档用--\u003e \u003cname\u003esearch-resources\u003c/name\u003e \u003c!--项目主页的URL, Maven产生的文档用--\u003e \u003curl\u003ehttp://www.missbe.cn\u003c/url\u003e \u003c!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时 （例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面， 你应该修改你自己的索引页文件，而不是调整这里的文档。--\u003e \u003cdescription\u003eA maven project to study maven.\u003c/description\u003e \u003c!--描述了这个项目构建环境中的前提条件。--\u003e \u003cprerequisites\u003e \u003c!--构建该项目或使用该插件所需要的Maven的最低版本--\u003e \u003cmaven/\u003e \u003c/prerequisites\u003e \u003c!--构建项目需要的信息--\u003e \u003cbuild\u003e \u003c!--该元素设置了项目源码目录，当构建项目的时候， 构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--\u003e \u003csourceDirectory/\u003e \u003c!--该元素设置了项目脚本源码目录，该目录和源码目录不同： 绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--\u003e \u003cscriptSourceDirectory/\u003e \u003c!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候， 构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--\u003e \u003ctestSourceDirectory/\u003e \u003c!--被编译过的应用程序class文件存放的目录。--\u003e \u003coutputDirectory/\u003e \u003c!--被编译过的测试class文件存放的目录。--\u003e \u003ctestOutputDirectory/\u003e \u003c!--使用来自该项目的一系列构建扩展--\u003e \u003cextensions\u003e \u003c!--描述使用到的构建扩展。--\u003e \u003cextension\u003e \u003c!--构建扩展的groupId--\u003e \u003cgroupId/\u003e \u003c!--构建扩展的artifactId--\u003e \u003cartifactId/\u003e \u003c!--构建扩展的版本--\u003e \u003cversion/\u003e \u003c/extension\u003e \u003c/extensions\u003e \u003c!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件， 这些资源被包含在最终的打包文件里。--\u003e \u003cresources\u003e \u003c!--这个元素描述了项目相关或测试相关的所有资源路径--\u003e \u003cresource\u003e \u003c!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。 然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--\u003e \u003ctargetPath/\u003e \u003c!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性， 文件在filters元素里列出。--\u003e \u003cfiltering/\u003e \u003c!--描述存放资源的目录，该路径相对POM路径--\u003e \u003cdirectory/\u003e \u003c!--包含的模式列表，例如**/*.xml.--\u003e \u003cincludes/\u003e \u003c!--排除的模式列表，例如**/*.xml--\u003e \u003cexcludes/\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--\u003e \u003ctestResources\u003e \u003c!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--\u003e \u003ctestResource\u003e \u003ctargetPath/\u003e \u003cfiltering/\u003e \u003cdirectory/\u003e \u003cincludes/\u003e \u003cexcludes/\u003e \u003c/testResource\u003e \u003c/testResources\u003e \u003c!--构建产生的所有文件存放的目录--\u003e \u003cdirectory/\u003e \u003c!--产生的构件的文件名，默认值是${artifactId}-${version}。--\u003e \u003cfinalName/\u003e \u003c!--当filtering开关打开时，使用到的过滤器属性文件列表--\u003e \u003cfilters/\u003e \u003c!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。 给定插件的任何本地配置都会覆盖这里的配置--\u003e \u003cpluginManagement\u003e \u003c!--使用的插件列表 。--\u003e \u003cplugins\u003e \u003c!--plugin元素包含描述插件所需要的信息。--\u003e \u003cplugin\u003e \u003c!--插件在仓库里的group ID--\u003e \u003cgroupId/\u003e \u003c!--插件在仓库里的artifact ID--\u003e \u003cartifactId/\u003e \u003c!--被使用的插件的版本（或版本范围）--\u003e \u003cversion/\u003e \u003c!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因， 只有在真需要下载时，该元素才被设置成enabled。--\u003e \u003cextensions/\u003e \u003c!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--\u003e \u003cexecutions\u003e \u003c!--execution元素包含了插件执行需要的信息--\u003e \u003cexecution\u003e \u003c!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--\u003e \u003cid/\u003e \u003c!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--\u003e \u003cphase/\u003e \u003c!--配置的执行目标--\u003e \u003cgoals/\u003e \u003c!--配置是否被传播到子POM--\u003e \u003cinherited/\u003e \u003c!--作为DOM对象的配置--\u003e \u003cconfiguration/\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c!--项目引入插件所需要的额外依赖--\u003e \u003cdependencies\u003e \u003c!--参见dependencies/dependency元素--\u003e \u003cdependency\u003e......\u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--任何配置是否被传播到子项目--\u003e \u003cinherited/\u003e \u003c!--作为DOM对象的配置--\u003e \u003cconfiguration/\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/pluginManagement\u003e \u003c!--使用的插件列表--\u003e \u003cplugins\u003e \u003c!--参见build/pluginManagement/plugins/pl","date":"2021-05-07","objectID":"/posts/maven/:6:0","tags":["Maven"],"title":"Maven知识点","uri":"/posts/maven/"},{"categories":["Java"],"content":"突然准备接一个项目的运维了…技术栈是SSM 五一这几天一直在搬家,今天开始搞吧 Java学学学 IDEA设置 ","date":"2021-05-07","objectID":"/posts/java-2/:0:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"设置IDE编码方式 ","date":"2021-05-07","objectID":"/posts/java-2/:1:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"显示行号和空格 ","date":"2021-05-07","objectID":"/posts/java-2/:2:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"设置最大空行数量 ","date":"2021-05-07","objectID":"/posts/java-2/:3:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"添加main函数快捷键 psvm ","date":"2021-05-07","objectID":"/posts/java-2/:4:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"调试过程快捷键 f7逐条执行,进入方法中的方法内部 f8逐条执行,跳过方法中方法 f9直接运行到下一个断点 ","date":"2021-05-07","objectID":"/posts/java-2/:5:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"IDEA开启时不打开上一次的项目 ","date":"2021-05-07","objectID":"/posts/java-2/:6:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"添加第三方插件 WEB-INF下增加文件夹lib 将jar包添加到lib文件夹下 ","date":"2021-05-07","objectID":"/posts/java-2/:7:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"配置生效 ","date":"2021-05-07","objectID":"/posts/java-2/:8:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"创建Servlet ","date":"2021-05-07","objectID":"/posts/java-2/:9:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"配置IDEA 点击项目中iml类型的文件 增加代码 \u003csourceRoots\u003e \u003croot url=\"file://$MODULE_DIR$/src\" /\u003e \u003croot url=\"file://$MODULE_DIR$/src/main/java\" /\u003e \u003c/sourceRoots\u003e ","date":"2021-05-07","objectID":"/posts/java-2/:9:1","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"新建Servlet ","date":"2021-05-07","objectID":"/posts/java-2/:9:2","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"添加Tomcat依赖 ","date":"2021-05-07","objectID":"/posts/java-2/:9:3","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"编写返回报文 public class HelloServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.getWriter().write(\"hello,tronwei\"); } } ","date":"2021-05-07","objectID":"/posts/java-2/:9:4","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"插件运行Tomcat \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.tomcat.maven\u003c/groupId\u003e \u003cartifactId\u003etomcat7-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e2.2\u003c/version\u003e \u003cconfiguration\u003e \u003cport\u003e9990\u003c/port\u003e \u003cpath\u003e/\u003c/path\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e 可以选择执行命令运行tomcat tomcat7:run ","date":"2021-05-07","objectID":"/posts/java-2/:10:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"创建聚合工程 电商系统,其中有聚合后台子模块和聚合前台子模块 前后台系统中都有dao,service,web三层结构 Spring mvc框架 M是Model（中文名称是数据模型），一般是实体类，可以被多个视图共用；V是View（中文名称是视图），可以是JSP、ASP等动态页面；C是Controller（中文名称是控制器），用于接收视图发起的请求或返回已处理的内容到视图。程序员要使用MVC开发Web应用程序，就必须遵守MVC规定的设计模式。 视图就是JSP页面，JSP页面发送请求到Controll类，也就是MVC的控制器，Controll类收到视图发出的请求后，会对请求进行分发，并调用相关的业务类对请求进行处理；POJO类（实体类，也就是MVC的数据模型）是业务类要处理的数据对象，处理的数据对象可以由控制器返回到视图。 SSM框架概念 SSM是三个开发框架的集成，第一个字母S是指Spring开发框架，第二个字母S是指Spring MVC开发框架，第三个字母M是指Mybatis数据库开发框架。实际上Spring MVC是Spring框架的扩展，是属于Spring框架的一部分，因此应该是两个开发框架的集成。SSM现在已经成为主流的Web应用程序开发框架 Spring Boot Tomcat ","date":"2021-05-07","objectID":"/posts/java-2/:11:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"文件的结构目录 ","date":"2021-05-07","objectID":"/posts/java-2/:12:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"应用部署目录 ","date":"2021-05-07","objectID":"/posts/java-2/:13:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"框架机制 ","date":"2021-05-07","objectID":"/posts/java-2/:14:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"原理： Tomcat主要组件 服务器Server 服务Service 连接器Connector 容器Container 连接器Connector和容器Container是Tomcat的核心 一个Container容器和一个或多个Connector组合在一起，加上其他一些支持的组件共同组成一个Service服务，有了Service服务便可以对外提供能力了，但是Service服务的生存需要一个环境，这个环境便是Server，Server组件为Service服务的正常使用提供了生存环境，Server组件可以同时管理一个或多个Service服务 ","date":"2021-05-07","objectID":"/posts/java-2/:15:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"两大组件： ","date":"2021-05-07","objectID":"/posts/java-2/:16:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"Connector 一个Connecter将在某个指定的端口上侦听客户请求，接收浏览器的发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据，然后会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理Engine(Container中的一部分)，从Engine出获得响应并返回客户。 Tomcat中有两个经典的Connector，一个直接侦听来自Browser的HTTP请求，另外一个来自其他的WebServer请求 HTTP/1.1 Connector在端口8080处侦听来自客户Browser的HTTP请求，AJP/1.3 Connector在端口8009处侦听其他Web Server（其他的HTTP服务器）的Servlet/JSP请求。 Connector 最重要的功能就是接收连接请求然后分配线程让 Container 来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心 ","date":"2021-05-07","objectID":"/posts/java-2/:16:1","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"Container Container是容器的父接口，该容器的设计用的是典型的责任链的设计模式，它由四个自容器组件构成，分别是Engine、Host、Context、Wrapper。这四个组件是负责关系，存在包含关系。通常一个Servlet class对应一个Wrapper，如果有多个Servlet定义多个Wrapper，如果有多个Wrapper就要定义一个更高的Container，如Context。 Context 还可以定义在父容器 Host 中，Host 不是必须的，但是要运行 war 程序，就必须要 Host，因为 war 中必有 web.xml 文件，这个文件的解析就需要 Host 了，如果要有多个 Host 就要定义一个 top 容器 Engine 了。而 Engine 没有父容器了，一个 Engine 代表一个完整的 Servlet 引擎。 Engine 容器 Engine 容器比较简单，它只定义了一些基本的关联关系 Host 容器 Host 是 Engine 的子容器，一个 Host 在 Engine 中代表一个虚拟主机，这个虚拟主机的作用就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分它们。它的子容器通常是 Context，它除了关联子容器外，还有就是保存一个主机应该有的信息。 Context 容器 Context 代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，理论上只要有 Context 就能运行 Servlet 了。简单的 Tomcat 可以没有 Engine 和 Host。Context 最重要的功能就是管理它里面的 Servlet 实例，Servlet 实例在 Context 中是以 Wrapper 出现的，还有一点就是 Context 如何才能找到正确的 Servlet 来执行它呢？ Tomcat5 以前是通过一个 Mapper 类来管理的，Tomcat5 以后这个功能被移到了 request 中，在前面的时序图中就可以发现获取子容器都是通过 request 来分配的。 Wrapper 容器 Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。 Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了拥有一个 Servlet 初始化信息的 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。 Catalina负责管理Server,而server表示整个服务器,server下面有多个服务service,每个服务都包含多个连接器组件conductor和一个容器组件container 一个连接器组件主要包含着一个connector和多个processor,connector负责监听客户请求,然后交给processor来寻找container处理 和连接器关联的容器一般指的是Engine,Host,Context,Wrapper也都是容器,这里是层层嵌套的关系,最底层的Wrapper包裹着Servlet,最后请求都会传递到Servlet来执行 在Tomcat启动的时候,会初始化一个Catalina实例 Catalina负责的是解析Tomcat的配置文件,以此来创建服务器server组件,并根据命令对其进行管理 Server服务器表示整个Catalina Servlet容器以及其他组件,负责组装并启动Servlet引擎,Tomcat连接器,server通过实现lifecycle接口,提供了一种优雅的启动和关闭整个系统的方式 service服务是server内部的组件,一个server包含多个service,他将若干个connector组件绑定在一个Container(Engine)上 Connector连接器,处理与用户端的通信,他负责接收客户请求,然后转向相关的容器进行处理,然后向客户返回相应的结果,连接器包含四个重要的部分 连接器类HttpConnector 支撑类HttpProcessor 请求类HttpRequest 响应类HttpResponse Container容器负责处理用户的Servlet请求,并返回对象给Web用户的模块 Tomcat中定义了四种容器 Engine表示整个Catalina的servlet引擎,一个引擎包含若干个Host Host表示一个虚拟主机,一个主机包含若干个Context Context表示一个Web应用,一个上下文包含若干个Wrapper Wrapper表示一个独立的servlet,包装器作为容器的最底层,不能包含子容器 Servlet ","date":"2021-05-07","objectID":"/posts/java-2/:16:2","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"基本概念 处理请求和发送响应的过程是由一种叫做Servlet的程序来完成的，并且Servlet是为了解决实现动态页面而衍生的东西。理解这个的前提是了解一些http协议的东西，并且知道B/S模式(浏览器/服务器)。 B/S:浏览器/服务器。 浏览器通过网址来访问服务器，比如访问百度，在浏览器中输入www.baidu.com，这个时候浏览器就会显示百度的首页 ","date":"2021-05-07","objectID":"/posts/java-2/:17:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["Java"],"content":"tomcat和servlet的关系 Tomcat 是Web应用服务器,是一个Servlet/JSP容器. Tomcat 作为Servlet容器,负责处理客户请求,把请求传送给Servlet,并将Servlet的响应传送回给客户.而Servlet是一种运行在支持Java语言的服务器上的组件. Servlet最常见的用途是扩展Java Web服务器功能,提供非常安全的,可移植的,易于使用的CGI替代品. 从http协议中的请求和响应可以得知，浏览器发出的请求是一个请求文本，而浏览器接收到的也应该是一个响应文本。但是在上面这个图中，并不知道是如何转变的，只知道浏览器发送过来的请求也就是request，我们响应回去的就用response。忽略了其中的细节，现在就来探究一下。 Tomcat将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，所有的HTTP头数据读可以通过request对象调用对应的方法查询到。 Tomcat同时会要响应的信息封装为HttpServletResponse类型的response对象，通过设置response属性就可以控制要输出到浏览器的内容，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器 Java Servlet API 是Servlet容器(tomcat)和servlet之间的接口，它定义了serlvet的各种方法，还定义了Servlet容器传送给Servlet的对象类，其中最重要的就是ServletRequest和ServletResponse。所以说我们在编写servlet时，需要实现Servlet接口，按照其规范进行操作。 ","date":"2021-05-07","objectID":"/posts/java-2/:18:0","tags":["Spring"],"title":"SSM初识","uri":"/posts/java-2/"},{"categories":["DTEC"],"content":"工程采购业务模式EPC EPC业务模式 百度百科参考 参考-工程总承包各种模式 参考-EPC总承包业务讲解 参考-EPC、DB、EPCM、PMC四种典型总承包管理模式的介绍和比较 参考-EPC业务 电力公司/业主—\u003e管理 业主—\u003e投资 设计院—\u003e设计 供应商—\u003e供货 监理—\u003e监管 施工单位—\u003e施工 EPC作为一站式解决方案,包括Egineering(设计), Procurement(采购), Construction(施工)三个方面 意味着工程项目业主将工程项目建设的设计,材料和设备采购,施工全部工作都交给一个承包商实施,并且要求实施方按照合同约定的质量.工期,造价向业主交付符合合同要求的工程项目 其中设计对于造价的影响最大 EPC的优点 EPC模式的总承包商在设计的早期阶段就介入项目,因此能将施工方法,降低成本,缩短工期,设计以及施工方面的知识,专业技能和经验总结起来体现在设计文件之中 另外承包商在设计阶段就对施工阶段可能遇到的问题有了初步的准备 工程总承包是市场专业化分工的必然趋势和业主规避风险的客观要求 在总承包模式下,一旦总包含合同签订,合同价格固定,总包方就要为业主承担一定的资金风险,技术风险,政策风险,法律风险 EPC模式的工程总承包项目外部接口少,有利于解决设计,施工接口不顺的体制问题,优化组合社会资源,靠优化设计和加强施工管理最大限度地节约投资成本 工程总承包能有效的控制建设周期和工程质量 EPC模式的工程总承包项目可以实现设计采购施工,试运行全过程的质量控制,能够在很大程度上消除质量不稳定因素 ","date":"2021-04-20","objectID":"/posts/dtec-2/:0:0","tags":["招标"],"title":"EPC业务模式","uri":"/posts/dtec-2/"},{"categories":["DTEC"],"content":"EPC业务模式的分类 ","date":"2021-04-20","objectID":"/posts/dtec-2/:1:0","tags":["招标"],"title":"EPC业务模式","uri":"/posts/dtec-2/"},{"categories":["DTEC"],"content":"E+P+C 模式 设计采购施工/交钥匙总承包 设计采购施工总承包（EPC：即Engineering(设计)、Procurement(采购)、Construction(施工)的组合）是指工程总承包企业按照合同约定，承担工程项目的设计、采购、施工、试运行服务等工作，并对承包工程的质量、安全、工期、造价全面负责，是我国目前推行总承包模式最主要的一种。交钥匙总承包是设计采购施工总承包业务和责任的延伸，最终是向业主提交一个满足使用功能、具备使用条件的工程项目。 ","date":"2021-04-20","objectID":"/posts/dtec-2/:1:1","tags":["招标"],"title":"EPC业务模式","uri":"/posts/dtec-2/"},{"categories":["DTEC"],"content":"E+P+CM模式 设计采购与施工管理总承包(EPCM：即Engineering(设计) 、procurement (采购)、Construcion management（施工管理）的组合)是国际建筑市场较为通行的项目支付与管理模式之一，也是我国目前推行总承包模式的一种。EPCM 承包商是通过业主委托或招标而确定的，承包商与业主直接签订合同，对工程的设计、材料设备供应、施工管理进行全面的负责。根据业主提出的投资意图和要求，通过招标为业主选择、推荐最合适的分包商来完成设计、采购、施工任务。 **设计、采购分包商对EPCM承包商负责，而施工分包商则不与EPCM承包商签订合同，但其接受EPCM承包商的管理，施工分包商直接与业主具有合同关系。**因此，EPCM承包商无需承担施工合同风险和经济风险。当EPCM总承包模式实施一次性总报价方式支付时，EPCM承包商的经济风险被控制在一定的范围内，承包商承担的经济风险相对较小，获利较为稳定。 ","date":"2021-04-20","objectID":"/posts/dtec-2/:1:2","tags":["招标"],"title":"EPC业务模式","uri":"/posts/dtec-2/"},{"categories":["DTEC"],"content":"设计+施工总承包（D+B） 设计—施工总承包是指工程总承包企业按照合同约定，承担工程项目设计和施工，并对承包工程的质量、安全、工期、造价全面负责。 ","date":"2021-04-20","objectID":"/posts/dtec-2/:1:3","tags":["招标"],"title":"EPC业务模式","uri":"/posts/dtec-2/"},{"categories":["DTEC"],"content":"采购总承包（E-P） ","date":"2021-04-20","objectID":"/posts/dtec-2/:1:4","tags":["招标"],"title":"EPC业务模式","uri":"/posts/dtec-2/"},{"categories":["DTEC"],"content":"采购—施工总承包(P-C) 融资运营 ","date":"2021-04-20","objectID":"/posts/dtec-2/:1:5","tags":["招标"],"title":"EPC业务模式","uri":"/posts/dtec-2/"},{"categories":["DTEC"],"content":"项目BOT模式 BOT（Build-Operation-Transfer) 建设—-经营—-移交 指一国政府或其授权的政府部门经过一定程序并签订特许协议将专属国家的特定的基础设施、公用事业或工业项目的筹资、投资、建设、营运、管理和使用的权利在一定时期内赋予给本国或/和外国民民间企业，政府保留该项目、设施以及其相关的自然资源永久所有权；由民间企业建立项目公司并按照政府与项目公司签订的特许协议投资、开发、建设、营运和管理特许项目，以营运所得清偿项目债务、收回投资、获得利润，在特许权期限届满时将该项目、设施无偿移交给政府。有时,BOT 模式被称为“暂时私有化”过程(Temporary Privatization)。而国家体育馆、国家会议中心、位于五棵松的北京奥林匹克篮球馆等项目实践了BOT模式，由政府对项目建设、经营提供特许权协议，投资者需全部承担项目的设计、投资、建设和运营，在有限时间内获得商业利润，期满后需将场馆交付政府 BOT可演化的方向： BOO（build—own—operate）即：建设—拥有—经营。项目一旦建成，项目公司对其拥有所有权，当地政府只是购买项目服务。 BOOT（build—own—operate—transfer）即：建设—拥有—经营—转让。项目公司对所建项目设施拥有所有权并负责经营，经过一定期限后，再将该项目移交给政府。 BLT（build—lease—transfer）即：建设—租赁—转让。项目完工后一定期限内出租给第三者，以租赁分期付款方式收回工程投资和运营收益，以后再行将所有权转让给政府。 BTO（build—transfer—operate）即：建设—转让—经营。项目的公共性很强，不宜让私营企业在运营期间享有所有权，须在项目完工后转让所有权，其后再由项目公司进行维护经营。 ROT（rehabilitate—operate—transfer）即：修复—经营—转让项目在使用后，发现损毁，项目设施的所有人进行修复恢复整顿—经营—转让。 DBFO（design—build—finance—operate）即：设计—建设—融资—经营。 BT(build–transfer)即：建设—转让 BOOST(build—own—operate—subsidy—transfer)即：建设—拥有—经营—补贴—转让 ROMT(rehabilitate—operate—maintain—transfer)即：修复—经营—维修—转让 ROO(rehabilitate—own—operate)即：修复—拥有—经营 ","date":"2021-04-20","objectID":"/posts/dtec-2/:2:0","tags":["招标"],"title":"EPC业务模式","uri":"/posts/dtec-2/"},{"categories":["DTEC"],"content":"项目BT模式 BT是英文Build（建设）和Transfer（移交）缩写形式 建设—-移交 是政府或开发商利用承包商资金来进行融资建设项目的一种模式。BT模式是BOT模式的一种变换形式，指一个项目的运作通过项目公司总承包，融资、建设验收合格后移交给业主，业主向投资方支付项目总投资加上合理回报的过程。采用BT模式筹集建设资金成了项目融资的一种新模式 EPC的特点 工程项目模式代表了现代西方工程项目管理的主流，是建筑工程管理模式(CM)和设计的完美结合，也是成功运用这种模式达到缩短工期、降低投资目的的典范。 曾经因其建筑工程承包业以高速度、低成本地建造高层建筑和大型工业项目而著称于世。EPC的关键是依赖称职的专业分包商及标准化的过程控制与程序，因此在西方发达国家广泛采用。这是其实现简洁高效的设计、制造与施工的基础。 EPC模式的重要特点是充分发挥市场机制的作用。不仅业主将工程首先视为投资项目，而且建筑师、承包商都从这一优先次序出发。在指定专业分包商时，通常只规定基本要求，以使建筑师、承包商共同寻求最经济的方法。 为了有效地参与竞争，一般都将整个项目划分成若干相对独立的工作包。由不同的专业分包商负责各个工作包的设计、制造或提供材料与构件并负责施工与安装。 分包商的设计工作由建筑师负责协调，工程构件、设备制造或供货、施工由总承包商协调，而在大型项目中，通常由管理经理（CM）负责协调。虽然这种协调对施工程序进行了详细规定，但仍然有许多一时难以确定或未预料到的问题留给专业分包商在项目进行过程中逐步解决。专业承包商必须保证其分包部分的工程施工与其他分包商的工程在设计和管理上的准确衔接。这种双重的协调反馈、依靠项目相关各方均能遵循公认的控制程序、规范和技术标准。 EPC模式的系统性和有效性依靠广泛使用成熟的通用技术。设计和施工过程中不会为解决同样问题发生重复劳动。专业分包商使用他们所熟悉的通用方法，并在很大程度上依赖能够在短期内及时供货的材料、半成品与构件。 EPC 模式的另一重要特点是咨询工程师提供各专业完整的设计，但设计阶段只到初步设计或扩大初步设计的深度，不出详细设计即施工图，而后者是由承包商完成的。特别是一些较独立的分包工程的施工图设计，有时亦称二次设计，是由专业分包商独立完成的，但需由建筑师批准。如钢结构工程、装饰工程。分包商的分包工程施工报价中自然已含有设计费用，不再单独提出。有时设计人员也会选定重要或用量大的标准化材料、构件或设备，但必须明确说明，以便使专业分包商容易确认所选定的构件。 但在国内目比较常采取的方式是由设计院提供专业完整的施工图设计，然后分包给专业施工单位完成施工任务，只有少量的专业施工图由专业承包商完善设计并施工建造。 而施工用的设备和材料采购一般由专业分包商进行，但一些重要的大宗材料和设备须经总承包商确认或指定品牌及型号；也由直接由总承包商全面负责采购管理，提供给专业分包商。无论采用哪种方式选定构件或设备，专业分包商都必须利用其在本领域熟悉掌握的市场信息和专有技术选用或提出选用某种构件、材料或设备的决策或建议，从而可寻求设计要求的性能价格比最优的物料。 同时，两种方法之下，大多数情况下皆由专业分包商出面采购，他对供应商的熟悉和批量规模可大大降低物料成本。其另一重要特点是，建筑师熟知市场状况，他们不仅将其设计看作建筑作品，亦了解其设计是影响业主投资回收成功与否的关键。因此，奠定了EPC模式中承包商早期介入项目的基础，承包商对设计提出的便于施工、缩短工期、降低成本的建议不会受到建筑师的轻视甚至因影响建筑效果引起其反感。没有这种基础存在，承包商对设计的充分介入是很难实现的。 EPC项目管理班子的组织模式和对成员的素质要求也是有别于传统的施工企业组织班子的。这也是EPC项目成功的关键所在。在从事EPC工程项目的公司中，一般采用矩阵式的组织结构。根据EPC项目合同内容，从公司的各部门抽调相关人员组成项目管理组，以工作组（Work Team）的模式运行，由项目经理全面负责工作组的活动。同时，公司的各管理部门根据公司的法定权利对工作组的工作行使领导、监督、指导和控制功能，以确保工作组的活动符合公司、业主和社会的利益。在EPC合同执行完毕后，工作组也随之解散。EPC工程项目对项目经理的要求有别于传统的施工经理或现场经理。EPC的项目经理并不在于掌握多少技术，认识多少朋友，而是对项目全盘的掌控能力，即沟通力，协调力和领悟力。尽管对EPC项目经理在专业技术方面的要求相对较低，但他必须要熟悉工程设计、工程施工管理、工程采购管理、工程的综合协调管理，这些综合知识的要求是远高于普通的项目管理的。由于EPC模式已成为工程建设的最高境界，对于工作组成员的素质要求是远高于具体的施工管理组的。在国际EPC项目的工作组成员不乏MBA、MPA、PMP 以及技术专家，他们往往是在专业上的技术专家，同时也是管理协调方面的能手；不仅在技术工作、设计工作、现场建设方面有着多年的工作经历，而且在组织协调能力、与人沟通能力、对新情况的应变能力、对大局的控制和统筹能力方面均应有出色才能。正是高素质、高效率的团队形成对项目经理的全力支持才得以保证项目的正常实施。 EPC的优点 工程总承包是国内外建设活动中多有使用的发承包方式，有利于理清工程建设中业主与承包商、勘察设计与业主、总包与分包、执法机构与市场主体之间的各种复杂关系。比如，在工程总承包条件下，业主选定总承包商后，勘察、设计、以及采购、工程分包等环节直接由总承包商确定分包，从而业主不必再实行平行发包，避免了发包主体主次不分的混乱状态，也避免了执法机构过去在一个工程中要对多个市场主体实施监管的复杂关系。有利于优化资源配置。国外经验证明，实行工程总承包减少了资源占用与管理成本。 在我国则可以从三个层面予以体现。业主方摆脱了工程建设过程中的杂乱事务，避免了人员与资金的浪费；主包方减少了变更、争议、纠纷和索赔的耗费，使资金、技术、管理各个环节衔接更加紧密；分包方的社会分工专业化程度由此得以提高。有利于优化组织结构并形成规模经济。 能够重构工程总承包、施工承包、分包三大梯度塔式结构形态； 可以在组织形式上实现从单一型向综合型、现代开放型的转变，最终整合成资金、技术、管理密集型的大型企业集团； 便于扩大市场份额； 增强了参与BOT的能力。有利于政府部门打破行业垄断，并集中力量解决建筑市场最突出的问题，也有利于实行风险保障制度。因为惟有综合实力强的大公司方易获得保证担保。有利于控制工程造价，提升招标层次。 在强化设计责任的前提下，通过概念设计与价格的双重竞标，把′′投资无底洞′′消灭在工程发包之中。并且，由于实行整体性发包，招标成本可以大幅度降低。有利于提高全面履约能力，并确保质量和工期。实践证明，工程总承包最便于充分发挥大承包商所具有的较强技术力量、管理能力和丰富经验的优势。同时，由于各建设环节均置于总承包商的指挥下，因此各环节的综合协调余地大大增强，这对于确保质量和进度是十分有利的。有利于推动管理现代化。工程总承包模式作为协调中枢必须建立起计算机系统，使各项工作实现了电子化、信息化、自动化和规范化，提高了管理水平和效率，大力增强我国企业的国际承包竞争力 ","date":"2021-04-20","objectID":"/posts/dtec-2/:3:0","tags":["招标"],"title":"EPC业务模式","uri":"/posts/dtec-2/"},{"categories":["数据库"],"content":"Mosh/SQL -- REGEXP 正则表达式 REGEXP'[gim]p'-- 组合 gp, ip, mp REGEXP'^start'-- 匹配以start开始的 REGEXP'end$'-- 匹配以end结束的 REGEXP'a|b|c'-- 匹配包含有a,或b,或c的 SELECT*FROMsql_testWHEREnameREGEX'sam$'ORDERBYdateLIMIT10-- 以sam结尾的名字,前10个人(默认升序排列,降序使用DESC关键字) LIMIT6,3-- 跳过前6个记录,并选择3个记录返回(7,8,9条记录) -- JOIN 操作 SELECTorder_id,O.custom_id,first_name,last_nameFROMorderOJOINcustomCONO.custom_id=C.custom_id-- order O 表示O为order的缩写 --自身表JOIN查询 SELECTe.employee_id,e.first_name,m.first_nameASmanagerFROMemployeeeJOINemployeemONe.reports_to=m.employee_id--合并三个表 SELECT*FROMorderoJOINcustomscONo.custom_id=c.custom_idJOINorder_statusosONo.status=os.order_status_id--OUTER JOIN -- LEFT JOIN / RIGHT JOIN SELECTc.custom_id,c.first_name,o.order_idFROMcustomcLEFTJOINordersoONc.custon_id=o.custon_idORDERBYc.custon_id-- 其中 c.custom_id = o.custom_id -- 可以用 USING(custom_id) 代替 SELECT*FROMorder_itemsoiJOINorder_item_notesoinONoi.order_id=oin.order_idANDoi.product_id=oin.product_id-- 使用USING关键字 SELECT*FROMorder_itemsoiJOINorder_item_notesoinUSING(order_id,product_id)-- CROSS JOIN笛卡尔积 SELECTc.first_nameAScustomp.nameASproductFROMcustomc,ordersoORDERBYc.first_name-- CROSS JOIN 另一种写法 SELECTc.first_nameAScustomp.nameASproductFROMcustomcCROSSJOINproductspORDERBYc.first_name-- UNION 关键字,组合不同的结果 -- 结合的结果中,列的数量应该相同对应,否则会报错 SELECTfirst_nameFROMcustomersUNIONSELECTnameFROMshippers-- INSERT操作 INSERTINTOcustomVALUES(DEFAULT,'John','Smith')--双引号和引号都可以 -- 内置函数 LAST_INSERT_ID()-- 最后插入的数据的id INSERTINTOorders(custom_id,order_date,status)VALUES(1,'2019-01-02',1);INSERTINTOorder_itemsVALUES(LAST_INSERT_ID(),1,1,1.5)-- 将查找出来的数据,复制到另一个表中 CREATETABLEinvoice_archiveASSELECTi.invoice_id,i.number,c.nameASclient,i.invoice_total,i.payment_total,i.invoice_date,i.payment_datei.due_dateFROMinvoiceiJOINclientcUSING(client_id)WHEREpayment_dateISNOTNULL--更新数据 UPDATEinvoiceSETpayment_total=10,payment_date='2019-03-01'WHEREinvoice_id=1--从查找出来的数据中,进行更新 UPDATEinvoiceSETpayment_total=invoice_total*0.5payment_date=due_dateWHEREclient_idIN(SELECTclient_idFROMclientsWHEREname='MyWorks')--聚合函数 SELECTMAX(invoice_total)AShightest,MIN(invoice_total)ASlowestAVG(invoice_total)ASaverageSUM(invoice_total)AStotalCOUNT(invoice_total)AScount_numFROMinvoice-- GROUP BY SELECTstate,city,SUM(invoice_total)AStotal_saleFROMinvoiceiJOINclientsUSING(client_id)SELECTdate,SUM(amount)AStotalFROMpaymentGROUPBYdateORDERBYdate--聚合函数筛选 SELECTclient_idSUM(invoice_total)AStotal_saleFROMinvoiceGROUPBYclient_idHAVINGtotal_sales\u003e500-- 在GROUP BY之前使用where, 在GROUP BY之后使用HAVING -- 在HAVING中筛选的列,需要是前面select中提出的 --分组求和函数With Rollup SELECTpayment_method,SUM(amount)AStotalFROMpaymentspJOINpayment_methodspmONp.payment_method=pm.payment_method_idGROUPBYpayment_methodWITHROLLUPSELECT*FROMclientsWHEREclient_idNOTIN(SELECTDISTINCTclient_idFROMinvoices)-- ALL关键字查询 SELECT*FROMinvoicesWHEREinvoice_total\u003eALL(SELECTinvoice_totalFROMinvoicesWHEREclient_id=3)--SOME关键字 SELECT*FROMinvoice_total\u003eSOME(SELECTinvoice_totalFROMinvoicesWHEREclient_id=3)--嵌套子查询 SELECT*FROMclientsCWHEREEXISTS(SELECTclient_idFROMinvoicesWHEREclient_id=c.client_id)-- SELECTinvoice_id,invoice_total,(SELECTAVG(invoice_total)FROMinvoice)ASinvoice_average,invoice_total-invoice_averageFROMinvoicesSELECTclient_id,(SELECTSUM(invoice_total)FROMinvoicesWHEREclient_id=c.client_id)AStotal_sales(SELECTAVG(invoice_total)FROMinvoices)ASavg(SELECTtotal_sales-avg)ASdifferenceFROMclientc ","date":"2021-04-18","objectID":"/posts/sql/:0:0","tags":["SQL语法基础"],"title":"SQL常用命令","uri":"/posts/sql/"},{"categories":["Git"],"content":"Mosh/Git git clone url file_name # git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中 # 而git pull 则是将远程主机的最新内容拉下来后直接合并 git pull = git fetch + git merge git fetch origin master # 从远程主机的master分支拉取最新内容 git merge FETCH_HEAD # 将拉取下来的最新内容合并到当前所在的分支中 git fetch git log --online --all --graph # 此时会出现两个分支 git merge origin/master git pull --rebase # 将remote结点插入到本地最新结点之前 ","date":"2021-04-10","objectID":"/posts/git-2/:0:0","tags":["Git基础"],"title":"Git命令-2","uri":"/posts/git-2/"},{"categories":["Git"],"content":"master,origin master, origin/master的区别 master 这个很好理解，它代表本地的某个分支名。 origin master 代表着两个概念，前面的 origin 代表远程名，后面的 master 代表远程分支名。 origin/master 只代表一个概念，即远程分支名，是从远程拉取代码后在本地建立的一份拷贝（因此也有人把它叫作本地分支）。 举几个例子可能会更加清晰地说明问题： 执行 git fetch origin master 时，它的意思是从名为 origin 的远程上拉取名为 master 的分支到本地分支 origin/master 中。既然是拉取代码，当然需要同时指定远程名与分支名，所以分开写。 执行 git merge origin/master 时，它的意思是合并名为 origin/master 的分支到当前所在分支。既然是分支的合并，当然就与远程名没有直接的关系，所以没有出现远程名。需要指定的是被合并的分支。 执行 git push origin master 时，它的意思是推送本地的 master 分支到远程 origin，涉及到远程以及分支，当然也得分开写了。 还可以一次性拉取多个分支的代码：git fetch origin master stable oldstable； 也还可以一次性合并多个分支的代码：git merge origin/master hotfix-2275 hotfix-2276 hotfix-2290； 执行 git branch -a 可以查看所有的分支名 git push -f # 强行推送本地节点,替换远程节点 # 添加标签 git tag v1.0 # 删除远程标签 git push origin --delete v1.0 # 查看branch信息 git branch -vv # 删除远程库分支 git push -d origin feature/change # 切换本地分支 git switch master # 删除本地分支 git branch -d feature/change ","date":"2021-04-10","objectID":"/posts/git-2/:1:0","tags":["Git基础"],"title":"Git命令-2","uri":"/posts/git-2/"},{"categories":["Git"],"content":"Mosh/Git 初始化git git config --global user.name \"name\" git config --global user.email tronwei@163.com ","date":"2021-04-06","objectID":"/posts/git-1/:0:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"set default editor git config --global core.editor \"code --wait\" ","date":"2021-04-06","objectID":"/posts/git-1/:1:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"edit config git config --global -e ","date":"2021-04-06","objectID":"/posts/git-1/:2:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"设置结尾符号 兼容windows和linux文件 git config --global core.autocrlf true # windows git config --global core.autocrlf input # macos/linux ","date":"2021-04-06","objectID":"/posts/git-1/:3:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"get help git config --help git config --h # get the short help 创建项目 ","date":"2021-04-06","objectID":"/posts/git-1/:4:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"take the snapshot mkdir moon_file cd moob_file git init ls -a # 显示所有文件(隐藏文件) ","date":"2021-04-06","objectID":"/posts/git-1/:5:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"写入文件 echo hello \u003e\u003e file1.txt git status git add file1.txt ","date":"2021-04-06","objectID":"/posts/git-1/:6:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"add+commit git commit -am \"initial commit\" ","date":"2021-04-06","objectID":"/posts/git-1/:7:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"查看staging area git ls-files ","date":"2021-04-06","objectID":"/posts/git-1/:8:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"rename file mv file1.txt main.js git add file1.txt # track the deleted file1.txt git add main.js # track the new file main.js # 简单的方式,直接用git命令rename git mv file1.txt main.js ","date":"2021-04-06","objectID":"/posts/git-1/:9:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"echo \u003e 和 » echo \"xxx\" \u003e\u003e file.txt # 重写文件为\"xxx\" echo \"xxx\" \u003e file.txt # 追加到文件最后\"xxx\" ","date":"2021-04-06","objectID":"/posts/git-1/:10:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"添加gitignore文件 echo logs/ \u003e .gitigore # logs文件夹下的文件都忽略 ","date":"2021-04-06","objectID":"/posts/git-1/:11:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"删除staging area的文件 git rm -h # 查看help git rm --cached -r bin/ # -r 参数 recursive 递归删除目录 commit ","date":"2021-04-06","objectID":"/posts/git-1/:12:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"可视化查看更改 git config --global diff.tool vscode git config --global difftool.vscode.cmd \"code --wait --diff $LOCAL$REMOTE\" git config --global -e # 在最后的参数中添加 \"$LOCAL $REMOTE\" git difftool # 查看当前文件的更改 git difftool --staged # 查看stage中与上次commit的对比 ","date":"2021-04-06","objectID":"/posts/git-1/:13:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"查看具体commit内容 git show id # id 为commmit的id git show id:.gitignore # 查看具体文件.gitignore ","date":"2021-04-06","objectID":"/posts/git-1/:14:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"撤回更改 git restore --staged . # 撤回到上一次的commit ","date":"2021-04-06","objectID":"/posts/git-1/:15:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"还原删除文件 git rm file1.txt git commit -m \"delete the file\" git restore --sourse=HEAD~1 file1.txt git log ","date":"2021-04-06","objectID":"/posts/git-1/:16:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"查看历史 git log git log --oneline # 简洁模式 git log --oneline --reverse # 按照时间轴(反向)顺序显示 ","date":"2021-04-06","objectID":"/posts/git-1/:17:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"筛选参数 git log --stat git log --oneline -3 #last three command git log --oneline --author=\"name\" # 根据提交作者查询 git log --oneline --before=\"2021-4-4\" # 根据时间查询 git log --oneline --after=\"2021-4-1\" git log --oneline --after=\"yesterday\" git log --oneline --after=\"one week ago\" git log --oneline --grep=\"search_thing\" # grep: 正则表达式 git log --oneline -S\"hello world\" # 查看\"hello world\"什么时候添加到代码中的' git log --oneline toc.txt # 查看toc.txt文件被修改过的记录 git log --oneline --patch toc.txt # 查看补丁详情 git show HEAD~2 --name-only # 查看更改的文件 git show HEAD~2 --name-status # 查看被修改文件的状态 git log --oneline --all # 查看所有结点 git checkout master # 将head转移到master ","date":"2021-04-06","objectID":"/posts/git-1/:18:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"查看contributor的commit git shortlog #查看完整信息 git shortlog -n -s -e # -n查看提交次数 -s省略详细信息 -e显示email ","date":"2021-04-06","objectID":"/posts/git-1/:19:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"查看单个文件的修改记录 git log --oneline --stat toc.txt # stat显示修改状态 git bisect ","date":"2021-04-06","objectID":"/posts/git-1/:20:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"查找bug bisect(二分法查询bug) 一端标记good, 一端标记bad,之后HEAD指向中间结点 git bisect start git bisect bad git bisect good commit_id #此时HEAD指向中间结点 git log --oneline --all # 查看所有结点 checkout 恢复删除的文件 git checkout commit_id toc.txt # checkout检出(撤销) tag git tag v1.0 commit_id # 增加标签 git tag -n # 查看标签历史 git tag -d v1.1 # 删除标签 branch ","date":"2021-04-06","objectID":"/posts/git-1/:21:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"分支操作 git branch bugfix #创建分支 git branch #显示所有分支 git switch bugfix #切换分支 git branch -m bugfix bugfix/signup-bug #重命名 git branch -d bugfix # 删除分支 git branch -D bugfix # 强制删除分支 git log master..bugfix # 查看分支之间的区别(commit) git diff master..bugfix #查看分支之间的详细区别 git diff --name-only master..bugfix #查看分支之间的区别(受影响的文件名) git diff --name-stat master..bugfix #查看分支之间的区别(文件状态) ","date":"2021-04-06","objectID":"/posts/git-1/:22:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"stash缓存区 git stash push -m \"new stash push\" # 提交缓存 git stash -a -m \"push all stash\" # 提交所有文件进入缓存 git stash list # 查看所有缓存 git stash drop 1 # 删除缓存 git stash clear # 清空缓存 git stash pop # 恢复缓存 git stash apply # 恢复缓存 ","date":"2021-04-06","objectID":"/posts/git-1/:23:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"Merge ","date":"2021-04-06","objectID":"/posts/git-1/:24:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"fast-forward merges fast-forward是直接将HEAD指向分支 git merge bugfix # 合并分支到master git switch -C bugfix # 创建分支并切换到分支 ","date":"2021-04-06","objectID":"/posts/git-1/:24:1","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"no-fase-forward merges 将master和分支,作为一个新的commit进行合并 git merge --no-ff bugfix # 合并分支(no fast forward) git config ff no # 关闭fast forward git config --global ff no ","date":"2021-04-06","objectID":"/posts/git-1/:24:2","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"查看分支图像 git log --oneline --all --graph ","date":"2021-04-06","objectID":"/posts/git-1/:25:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"查看分支 git branch --merged # 查看已并入master的分支 git branch --no-merged # 查看没有并入master的分支 ","date":"2021-04-06","objectID":"/posts/git-1/:26:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"分支冲突 如果在合并时,存在文件被分支和master同时修改,那么就会发生冲突 手动解决方式: 在vscode中,将分支修改或master修改删除,再commit ","date":"2021-04-06","objectID":"/posts/git-1/:27:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"可视化合并分支 使用工具p4merge git config --global merge.tool p4merge # 设置p4merge为默认工具 git config --global mergetool.p4merge.path \"D:/p4merge/\" # 设定p4merge程序路径 git mergetool ","date":"2021-04-06","objectID":"/posts/git-1/:28:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"终止merge git merge --abort ","date":"2021-04-06","objectID":"/posts/git-1/:29:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"撤销merge git reset –-soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可； git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉； git reset --hard HEAD~1 # 撤回到上一个master结点 ","date":"2021-04-06","objectID":"/posts/git-1/:30:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"squash merging 将分支节点进行合并,合并出的新节点,作为新的master结点 此时新节点只有一个parent—\u003emaster git merge --squash bugfix rebasing 将分支节点连接到当前的master结点(linear) 之后执行fast-forward,即可将分支结点与master连接,成为linear git rebase master 如果产生冲突,则在mergetool中解决 git mergetool git rebase --continue 终止rebase git reabse --abort ","date":"2021-04-06","objectID":"/posts/git-1/:31:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"cherry picking 从分支中,拿出一个结点,作为master上的新节点(过程中没有合并) git cherry-pick commit_id ","date":"2021-04-06","objectID":"/posts/git-1/:32:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Git"],"content":"branch file add master git restore --sourse=fixbug toc.txt ","date":"2021-04-06","objectID":"/posts/git-1/:33:0","tags":["Git基础"],"title":"Git命令","uri":"/posts/git-1/"},{"categories":["Java"],"content":"初识java ","date":"2021-03-31","objectID":"/posts/java-1/:0:0","tags":["java命名规范"],"title":"Java简单入门","uri":"/posts/java-1/"},{"categories":["Java"],"content":"命名规范 Classname: 使用帕斯卡命名法: 每个单词都要写``JavaName` Methods: 使用驼峰命名法 除了第一个单词以外,每个单词的首字母都要大写javaName public class Main{ public void main(){ ...code } } ","date":"2021-03-31","objectID":"/posts/java-1/:1:0","tags":["java命名规范"],"title":"Java简单入门","uri":"/posts/java-1/"},{"categories":["Java"],"content":"函数参数 parameter是指函数定义中参数 argument指的是函数调用时的实际参数。 parameter=形参(formal parameter) argument=实参(actual parameter)。 ","date":"2021-03-31","objectID":"/posts/java-1/:2:0","tags":["java命名规范"],"title":"Java简单入门","uri":"/posts/java-1/"},{"categories":["Javascript"],"content":"Mosh/初识nodejs path模块 const path = require('path') //built in module //定义为常量不会被之后命名的变量改变 var pathObj = path.parse(__filename); //返回一个文件路径的对象 OS模块 const os = require('os') var totalMemory = os.totalmem(); //获取系统内存 var freeMemory = os.freemem(); //获取系统空余内存 console.log('Total mem' + totalMemory) console.log('Total freemem' + freeMemory) ","date":"2021-03-31","objectID":"/posts/nodejs-2/:0:0","tags":["Node.js"],"title":"nodejs入门","uri":"/posts/nodejs-2/"},{"categories":["Javascript"],"content":"Template string 打印 /* ${variable_name} */ console.log(`total mem: ${totalMemory}`) console.log(`total mem: ${freeMemory}`) fs模块 /* 同步函数 */ const files = fs.readdirSync('./'); //同步函数 console.log(files); /* 异步函数 */ const fs = require('fs'); fs.readdir('./', function(err, files){ //异步回调函数 if(err) console.log('Error', err) else console.log('Result', files) }) Event模块 events模块是node的核心模块，几乎所有常用的node模块都继承了events模块，比如http、fs等 ","date":"2021-03-31","objectID":"/posts/nodejs-2/:1:0","tags":["Node.js"],"title":"nodejs入门","uri":"/posts/nodejs-2/"},{"categories":["Javascript"],"content":"实例化event对象 const EventEmitter = require('events'); //eventemitter是一个class const emitter = new EventEmitter(); //实例化对象 //emitter.addListener 和 emitter.on 都是监听 //register a listener emitter.on('message logged', function(arg){ //arg传参 console.log('listener called', arg) }) ","date":"2021-03-31","objectID":"/posts/nodejs-2/:2:0","tags":["Node.js"],"title":"nodejs入门","uri":"/posts/nodejs-2/"},{"categories":["Javascript"],"content":"ES6 arrow function arrow function 省略function关键字 用 =\u003e 表示函数 emitter.on('messgae logged', (arg) =\u003e { console.log('listener called', arg) })) ","date":"2021-03-31","objectID":"/posts/nodejs-2/:3:0","tags":["Node.js"],"title":"nodejs入门","uri":"/posts/nodejs-2/"},{"categories":["Javascript"],"content":"激活event emitter.emit('message logged', {id: 1, url: 'https://'}) //making a noise, raise an event 模块化文件 ","date":"2021-03-31","objectID":"/posts/nodejs-2/:4:0","tags":["Node.js"],"title":"nodejs入门","uri":"/posts/nodejs-2/"},{"categories":["Javascript"],"content":"app.js const logger = require('./logger_2'); //console.log(logger); logger.log('message'); ","date":"2021-03-31","objectID":"/posts/nodejs-2/:5:0","tags":["Node.js"],"title":"nodejs入门","uri":"/posts/nodejs-2/"},{"categories":["Javascript"],"content":"logger.js var url = 'http://mylogger.io/log'; function log(message){ console.log(message); } console.log(__filename) console.log(__dirname) module.exports.log = log;//暴露函数 /* 也可以直接暴露对象 module.exports = log 在app.js中使用 log('message'); */ 在nodejs中,模块文件都是被看作为一个函数包(模块包装函数) // module wrapper function (function(exports, require, module, __filename, __dirname){ ...code }) Event+模块 ","date":"2021-03-31","objectID":"/posts/nodejs-2/:6:0","tags":["Node.js"],"title":"nodejs入门","uri":"/posts/nodejs-2/"},{"categories":["Javascript"],"content":"app.js const EventEmitter = require('events'); const Logger = require('./logger_3'); const logger = new Logger(); //类实例化对象 //注册(监听)函数 logger.on('messagelogged', (arg) =\u003e { console.log('listener called', arg) }) logger.log('message'); ","date":"2021-03-31","objectID":"/posts/nodejs-2/:7:0","tags":["Node.js"],"title":"nodejs入门","uri":"/posts/nodejs-2/"},{"categories":["Javascript"],"content":"logger_3.js const EventEmitter = require('events'); //定义类 Logger包含所有EventEmitter的属性 class Logger extends EventEmitter{ log(message){ console.log(message); //激活函数 this.emit('messagelogged', {id: 1, url: 'https'}) } } module.exports = Logger; //返回类 http模块 const http = require('http'); // 路由 const server = http.createServer((req, res) =\u003e { if(req.url === '/'){ res.write('hello world') res.end() } if(req.url === '/api/course'){ res.write(JSON.stringify([1,2,3])) res.end() } }); /* 监听连接和关闭状态 server.on('connection', (socket) =\u003e { console.log('new connection') }) server.on('close', () =\u003e { console.log('TCP server closed'); }) */ server.listen(3000) console.log('listening on port 3000') ","date":"2021-03-31","objectID":"/posts/nodejs-2/:8:0","tags":["Node.js"],"title":"nodejs入门","uri":"/posts/nodejs-2/"},{"categories":["Javascript"],"content":"常用命令 ","date":"2021-03-28","objectID":"/posts/js-2/:0:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"Symbol数据类型 ES 6 引入了一个新的数据类型 Symbol 为了说明 Symbol 的作用，我们先来描述一个使用场景。 我们在做一个游戏程序，用户需要选择角色的种族。 var race = { protoss: 'protoss', // 神族 terran: 'terran', // 人族 zerg: 'zerg' // 虫族 } function createRole(type){ if(type === race.protoss){创建神族角色} else if(type === race.terran){创建人族角色} else if(type === race.zerg){创建虫族角色} } 那么用户选择种族后，就需要调用 createRole 来创建角色： // 传入字符串 createRole('zerg') // 或者传入变量 createRole(race.zerg) 一般传入字符串被认为是不好的做法，所以使用 createRole(race.zerg) 的更多。 如果使用 createRole(race.zerg)，那么聪明的读者会发现一个问题：race.protoss、race.terran、race.zerg 的值为多少并不重要。 改为如下写法，对 createRole(race.zerg) 毫无影响： var race = { protoss: 'askdjaslkfjas;lfkjas;flkj', // 神族 terran: ';lkfalksjfl;askjfsfal;skfj', // 人族 zerg: 'qwieqwoirqwoiruoiwqoisrqwroiu' // 虫族 } 也就是说：race.zerg 的值是多少无所谓，只要它的值跟 race.protoss 和 race.terran 的值不一样就行。 Symbol 的用途就是如此：Symbol 可以创建一个独一无二的值（但并不是字符串）。 用 Symbol 来改写上面的 race： var race = { protoss: Symbol(), terran: Symbol(), zerg: Symbol() } race.protoss !== race.terran // true race.protoss !== race.zerg // true 你也可以给每个 Symbol 起一个名字： var race = { protoss: Symbol('protoss'), terran: Symbol('terran'), zerg: Symbol('zerg') } 不过这个名字跟 Symbol 的值并没有关系，你可以认为这个名字就是个注释。 如下代码可以证明 Symbol 的名字与值无关： var a1 = Symbol('a') var a2 = Symbol('a') a1 !== a2 // true ","date":"2021-03-28","objectID":"/posts/js-2/:1:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"数据类型转换 var a = '123'; var b = parseInt(a); //从左向右,遇到非数字字符串时停止转换.把后面的字符串扔掉 var a = '123abc123'; var b = parseInt(a); // b = 123 //如果首字符时非数字字符,则转换为NaN(Not a number) parseFloat(a) Number(a)//只要字符串中有非数字字符,直接转为NaN,既可以转整数,又可以转为小数 ","date":"2021-03-28","objectID":"/posts/js-2/:2:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"最大值最小值 无穷大: Infinity 无穷小: -Infinity ","date":"2021-03-28","objectID":"/posts/js-2/:3:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"隐式类型转化 没有主动的对值进行类型转换,但是因为某些操作,导致JS自动进行转换,这样的转换是在JS内部自动实现的 具体参考ECMAScripts官方文档 alert(1 + '10') //输出110---\u003e将1转换为'1',字符串拼接 alert(true + false) //输出为1---\u003e1+0 alert(null - 10) //输出为-10---\u003e0-10 ","date":"2021-03-28","objectID":"/posts/js-2/:4:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"switch语句 ","date":"2021-03-28","objectID":"/posts/js-2/:5:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"穿透 switch(value){ case 1: case 2: case 3: case 4: console.log(\"输入小于4\") case 5: case 6: console.log(\"输入大于4\") } ","date":"2021-03-28","objectID":"/posts/js-2/:5:1","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"范围分支 switch(true){ case score \u003e= 90: console.log(\"优秀\") case score \u003e= 60: console.log(\"良好\") case score \u003c 60: console.log(\"不及格\") default: console.log(\"输入有误\") } ","date":"2021-03-28","objectID":"/posts/js-2/:5:2","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"Function ","date":"2021-03-28","objectID":"/posts/js-2/:6:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"函数声明 function fn(){ alert(2) } ","date":"2021-03-28","objectID":"/posts/js-2/:6:1","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"函数表达式 var fn = function(){ alert(2) } ","date":"2021-03-28","objectID":"/posts/js-2/:6:2","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"函数调用 //事件调用函数 document.onclick = fn; //非事件调用函数 fn() ","date":"2021-03-28","objectID":"/posts/js-2/:6:3","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"不定参数 // 关键字 arguments function sum(){ for(var i=0; i\u003carguments.length; i++){ console.log(arguments[i]) } } sum(1,2,3,4,5) ","date":"2021-03-28","objectID":"/posts/js-2/:7:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"获取行间/非行间样式 var wid = document.querySelector('div'); //行间样式 /* getComputedStyle(obj)[attr] 非行间样式 */ var obj = document.querySelector('div'); var wid2 = getComputedStyle(obj)['width']; /* 兼容性问题 IE8 不支持 处理兼容性问题: obj.currentStyle.attr */ function getStyle(obj, attr){ if(obj.currentStyle){ return obj.currentStyle[attr] } else{ //非 IE 浏览器 return getConputedStyle(obj)[attr] } } /* 改为三目运算符 */ return obj.currentrStyle ? obj.currentStyle[attr] : getConputedStyle(obj)[attr] // return case ? true : false ","date":"2021-03-28","objectID":"/posts/js-2/:8:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"预解析 /* 声明变量 声明函数 */ var a; //undefined 变量声明 会放在最上面 console.log(a); a = 12; fn() //123 function fn(){ //函数声明提前 console.log(\"123\") } fn() // undefined var fn = function(){ //只将fn声明提前,函数体没有预编译 console.log(123) } ","date":"2021-03-28","objectID":"/posts/js-2/:9:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"变量定义 function fn(){ a = 5; } fn() console.log(a) //a为全局变量 //在函数中的变量,如果外层有定义,则指向定义 //如果外层没有定义,则默认作为window变量保存 ","date":"2021-03-28","objectID":"/posts/js-2/:10:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"闭包 /* 一个函数内嵌套子函数,子函数可以调用父函数的局部作用域 */ function fn(){ var a = 1; function fn2(){ a++; console.log(a) } fn2() } fn() /* 一个函数调用另一个函数的局部变量 */ var list = document.querySelectorAll('li'); for(var i=0; i\u003clist.length; i++){ (function(index){ console.log(index) lis[index].onclick = function(){ alert(index); } })(i) //闭包函数调用 } ","date":"2021-03-28","objectID":"/posts/js-2/:11:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"函数下的this指向 function fn(){ console.log(this) //window } document.onclick = function(){ console.log(this) //#document } //改变函数下的this指向 /* call 可以改变this指向 call(obj,传递的值) obj: 要指向的对象 传递的值: 传参 */ fn.call(document.body, 12) /* apply(指向的位置, 传参数组) */ fn.apply(document, [1,2,3]) ","date":"2021-03-28","objectID":"/posts/js-2/:12:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"bind /* bind 本身不会执行函数,会返回一个新的函数体 */ var newfn = fn.bind(document); newfn() //直接执行newfn,就是在执行绑定的函数 /* call和apply的区别 - bind 是一个方法,执行完毕,会返回一个函数 - call/apply 会立即调用函数本身 - bind 返回的是一个新的函数,改变的是新函数下的this指向 */ newfn(1,2,3) //传递参数 ","date":"2021-03-28","objectID":"/posts/js-2/:13:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"定时器 //每隔一段时间或延迟一段时间,执行一段指定的代码 /* 延迟定时器: setTimeout 间隔定时器: setInterval */ /* setTimeout(code, time, ) - code: 延迟一段时间后 需要执行的代码 - function - 字符串(不建议) - time: 延迟的事件(单位ms 1s=1000ms) - parma1...parmaN 作为参数传入code中(IE9存在兼容问题) */ setTimeout(function(){ console.log(123) }, 1000) setTimeout(\"alert(123)\", 1000) setTimeout(function(x,y){ console.log(x+y) }, 1000, 1, 2) //x=1, y=2 ","date":"2021-03-28","objectID":"/posts/js-2/:14:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"消除延迟代码 /* 每个定时器都会有一个返回值,这个返回值就是id(正整数) */ var time1 = 0; var time2 = 0; time1 = setTimeout(function(){ console.log(123) }, 1000) time2 = setTimeout(function(){ console.log(456) }, 1000) console.log(time1) //1 console.log(time2) //2 clearTimeout(time1) //清除定时器 参数为id ","date":"2021-03-28","objectID":"/posts/js-2/:14:1","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"间隔定时器 /* setInterval 参数和setTimeout相同 移动的div */ var btn = document.querySelectorAll('button'); var div = document.querySelectorAll('div'); var timer = null; var num = 0; btn[0].onlcick = function(){ div.style.background = 'url(img/download.gif)'; // 设定初始位置 num = parseInt(getStyle(div).left) timer = setInterval(function(){ num++; div.style.left = num+'px'; }, 16) } // 行间样式 兼容性 function getStyle(obj){ if(obj.currentStyle){ return currentStyle } else{ return getComputedStyle(obj) } } //清除间隔定时器 clearInterval(timer) ","date":"2021-03-28","objectID":"/posts/js-2/:15:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"this指向性问题 /* 定时器是js本身定义好的函数,因此this指向的是window 因为定时器都是通过window调用的 */ var div = document.querySelectorAll('div'); var _this = null; div.onclick = function(){ _this = this; window.setTimeout(function(){ _this.style.cssText = 'width:300px; height:300px'; }) } ","date":"2021-03-28","objectID":"/posts/js-2/:15:1","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"作用域 for(var i=0; i\u003c5; i++){ setTimeout(function(){ console.log(i) // 5 5 5 5 5 }) } /* 在局部作用域中没有找到i,因此到全局作用域中寻找,此时for循环结束,i=5 setTimeout函数执行会比for循环慢 */ ","date":"2021-03-28","objectID":"/posts/js-2/:15:2","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"延迟定时器中函数调用 ","date":"2021-03-28","objectID":"/posts/js-2/:16:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"存在问题 setTimeout(fn(\"hello\"), 1000) function fn(txt){ console.log(txt) } /* 此时没有产生延迟效果,因为函数直接激活 */ ","date":"2021-03-28","objectID":"/posts/js-2/:16:1","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"解决方案1-匿名函数 /* 解决方案1: 使用匿名函数包装 */ setTimeout(function(){ fn(\"hello\") }, 1000) ","date":"2021-03-28","objectID":"/posts/js-2/:16:2","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"bind改变作用域指向 bind方法 小于IE9不能使用 /* 解决方案2: bind*/ var obj = { age: 18, getAge: function(){ console.log(this.age) } } obj.getAge() //18 var getNewAge = obj.getAge; getNewAge() //undefined 因为函数中的this指向的是window var getNewAge = obj.getAge.bind(obj); getNewAge() //18 bind改变this指向 /* bind传递参数 */ bind(obj, auguments...) ","date":"2021-03-28","objectID":"/posts/js-2/:16:3","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"解决方案2-bind setTimeout(fn.bind(null, \"hello\"), 1000) ","date":"2021-03-28","objectID":"/posts/js-2/:16:4","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"导航栏实现 var nav = document.querySelector('#nav'); //一级导航 var aLi = nav.querySelectorAll('li'); //二级导航 var subNav = nav.querySelectorAll('.float_layer'); var timer = null; for(var i=0; i\u003caLi.length; i++){ aLi[i].onmouseover = function(){ //console.log(this.index) clearTimeout(timer) for(var j=0; j\u003csubNav.length; j++){ subNav[j].style.display = 'none'; } subNav[this.index].style.display = 'block'; } aLi[i].onmouseout = function(){ var _this = this; //定义指向 timer = setTimeout(function(){ subNav[_this.index].style.display = 'none'; }, 1000) } } ","date":"2021-03-28","objectID":"/posts/js-2/:17:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-2","uri":"/posts/js-2/"},{"categories":["Javascript"],"content":"JS模块化打包 全局变量的约束 因为在js中如果需要使用全局变量,则需要将变量命名为window.varible 而在引入的包中,全局变量会失控,因此引入了webpack的概念 只将特定的变量进行暴露 \u003cscript src=\"a.js\"\u003e\u003c/script\u003e \u003cscript src=\"b.js\"\u003e\u003c/script\u003e ","date":"2021-03-26","objectID":"/posts/nodejs-1/:0:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"model.js-作为一个模块 //node写法 var msg = \"yo\"; module.exports = {msg: msg}; //变量暴露 //es6写法 var msg = \"yo\"; export {msg}; ","date":"2021-03-26","objectID":"/posts/nodejs-1/:1:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"entry.js-入口文件 //node写法 var msg = require('./model.js').msg; console.log(msg); //输出 yo //es6写法 import {msg} from './model'; console.log(msg); ","date":"2021-03-26","objectID":"/posts/nodejs-1/:2:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"webpack打包 webpack b.js bundle.js //只需要输入 入口文件和出口文件名称即可 //然后在html文件中只需要引入bundle.js ","date":"2021-03-26","objectID":"/posts/nodejs-1/:3:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"npm ","date":"2021-03-26","objectID":"/posts/nodejs-1/:4:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"自定义命令 \"scripts\" :{ \"dev\": \"webpack-dev-server\", \"build\": \"eslint ./src \u0026\u0026 webpack\" } ","date":"2021-03-26","objectID":"/posts/nodejs-1/:4:1","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"安装包 npm install xxx --save-dev # --save 保存到package.json文件中 # -dev 作为开发环境的依赖 npm install --only=dev # 只安装dev环境下的依赖 npm install # 默认安装生产环境下的依赖 ","date":"2021-03-26","objectID":"/posts/nodejs-1/:4:2","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"卸载重装 rm -rf node_modules \u0026\u0026 npm install webpack基本构成 webpack作为模块化最关键的一环,可以将所有文件都模块化处理 ","date":"2021-03-26","objectID":"/posts/nodejs-1/:4:3","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"全局安装 npm install webpack-cli -g # 全局安装 ","date":"2021-03-26","objectID":"/posts/nodejs-1/:5:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"文件组成 ","date":"2021-03-26","objectID":"/posts/nodejs-1/:6:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"index.html \u003cscript src='./dist/bundle.js'\u003e\u003c/script\u003e ","date":"2021-03-26","objectID":"/posts/nodejs-1/:6:1","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"app.js import moduleLog from './moduleLog' document.write('入口文件') moduleLog() ","date":"2021-03-26","objectID":"/posts/nodejs-1/:6:2","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"webpack.config.js const path = require('path') const UglifyJSPlugin = require('uglifyjs-webpack-plugin') module.exports = { entry = 'app.js' #入口文件 output = { path : path.join(__dirname, 'dist'), # 输出文件路径 filename: 'bundle.js' # 输出文件名称 }, devServer: { port: 3000, # dev模式下的端口 publicPath: './dist' # 缓存文件存储路径 }, module: { rules: [ { test: /\\.css$/, use: [ # 有先后顺序 'style-loader' # 加载到页面中 'css-loader' # 读取css文件 ] } ] }, plugins: [ new UglifyJSPlugin() ] } ","date":"2021-03-26","objectID":"/posts/nodejs-1/:6:3","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"加载css文件 使用css-loader来实现,并且独立于webpack存在,需要安装 npm install css-loader --save -dev npm install style-loader --save -dev ","date":"2021-03-26","objectID":"/posts/nodejs-1/:7:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"style.css body{ color: 'red' } ","date":"2021-03-26","objectID":"/posts/nodejs-1/:7:1","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"app.js import './style.css' ","date":"2021-03-26","objectID":"/posts/nodejs-1/:7:2","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"plugin 压缩js文件体积uglyfyjs插件 npm install uglify-webpack-plugin ","date":"2021-03-26","objectID":"/posts/nodejs-1/:8:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"调试 webpack-dev-server 不会生成bundle.js,只存在于缓存中 动态实现重新打包,可全局安装,也可以直接执行文件 ./node_modules/.bin/webpack-dev-server webpack构建工程 ","date":"2021-03-26","objectID":"/posts/nodejs-1/:9:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"初始化项目 npm init -y # -y默认配置 ","date":"2021-03-26","objectID":"/posts/nodejs-1/:10:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"安装react npm install react react-dom ","date":"2021-03-26","objectID":"/posts/nodejs-1/:11:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"安装webpack npm install webpack webpack-cli -g ","date":"2021-03-26","objectID":"/posts/nodejs-1/:12:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"创建文件 ","date":"2021-03-26","objectID":"/posts/nodejs-1/:13:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"src/App.jsx import React from 'react' import ReactDom from 'react-dom' //ES6 箭头函数 const App = () =\u003e { return ( \u003cdiv\u003e \u003ch1\u003e我没学过React\u003c/h1\u003e \u003c/div\u003e ) } export default App React.render(\u003cApp/\u003e, document.getElementById('app')) ","date":"2021-03-26","objectID":"/posts/nodejs-1/:13:1","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"index.html \u003cbody\u003e \u003cdiv id=\"app\"\u003e\u003c/div\u003e \u003c/body\u003e ","date":"2021-03-26","objectID":"/posts/nodejs-1/:13:2","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"安装babel 将ES6变为版本较低的代码 cd .. mkdir babel-demo cd babel-demo npm init -y ## 使用场景: babel代码编译=\u003e编译为低版本代码 npm install @babel/core @babel/cli -g ","date":"2021-03-26","objectID":"/posts/nodejs-1/:14:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"创建ES6测试代码 //test.js [1,2,3].map((item)=\u003e{ console.log(item) }) ","date":"2021-03-26","objectID":"/posts/nodejs-1/:14:1","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"安装转换规则 npm install @babel/preset-env #集成包 ","date":"2021-03-26","objectID":"/posts/nodejs-1/:14:2","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"指定规则编译 babel test.js --preset=@babel/preset-env ","date":"2021-03-26","objectID":"/posts/nodejs-1/:14:3","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"配置文件(package.json) # package.json文件中 \"babel\": { \"presets\": [\"@babel/preset-env\"] } # babel test.js ","date":"2021-03-26","objectID":"/posts/nodejs-1/:14:4","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"配置文件(.babellrc) # .babellrc文件 { \"preset\": [\"@babel/preset-env\"] } ","date":"2021-03-26","objectID":"/posts/nodejs-1/:14:5","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"webpack.config.js const HtmlWebPackPlugin = require('html-webpack-plugin') const path = require('path') const webpack = require('webpack') module.exports = { resolve: { # 设置文件后缀 extension: ['.wasm', '.jsx','js','json'] }, # 设置入口文件 entry: path.resolve(__dirname, 'src/index.jsx') module: { # 利用正则不去解析npm库中的Jquery(省时间) noParse: /node_module\\/(jquery\\.js)/, rules: [ { test: /\\.jsx?/, #正则 exclude: /node_modules/, #排除文件,文件过大 include: xxx # 指定目录 use: { loader: 'babel-loader' option: { babelrc: false preset:[ # 转译react require.resolve('@babel/preset-react'), # 转译ES6 [require.resolve('@babel/preset',{module:false})] ], # 使用缓存 cacheDirectory: true, } } } ] }, plugins: [ new HtmlWebPackPlugin({ template: path.resolve(__dirname, 'src/index.html'), filenameL 'index.html' }), # HMR热更新 new webpack.HotReplacementPlugin() ], devServer: { hot: true } } ","date":"2021-03-26","objectID":"/posts/nodejs-1/:15:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"安装转译规则 npm install @babel/preset-env @babel/preset-react ","date":"2021-03-26","objectID":"/posts/nodejs-1/:15:1","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"安装html-plugin npm install html-webpack-plugin ","date":"2021-03-26","objectID":"/posts/nodejs-1/:15:2","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"index.jsx import App from './App' if(module.hot){ module.hot.accept(error =\u003e{ if(error){ console.log(\"热更新出错\") } }) } 性能调优 打包结果的优化 构建过程的优化 Tree-shaking ","date":"2021-03-26","objectID":"/posts/nodejs-1/:16:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"压缩 tenser 在webpack.config.js中添加 const TenserPlugin = require('tenser-webpack-plugin') # 是uglyfy的分支 module.exports={ optimization: { minimizer: [new TenserPlugin({ cache: true #使用缓存加快构建速度 paralle: true, #开启多线程压缩 tensorOptions: { compress: { unused: true, #去除没有用过的代码 drop_debugger: true, #删除调试代码 drop_console: true, #删除控制台显示代码 dead_code: true #删除无用代码 } } })] } } ","date":"2021-03-26","objectID":"/posts/nodejs-1/:17:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"压缩结果分析器 webpack bundle analyzer–可视化查看文件大小 npm install webpack bundle analyzer 在webpack.config.js中添加 const BundleAnalyzerPlugin = require('webpack bundle analyzer').BundleAnalyzerPlugin plugin: [ new BundleAnalyzerPlugin() ] ","date":"2021-03-26","objectID":"/posts/nodejs-1/:18:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"多线程处理 webpack是单线程处理,使用HappyPack或thread-loader来实现多线程 ","date":"2021-03-26","objectID":"/posts/nodejs-1/:19:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"thread-loader 在webpack.config.js中添加 # 放在所有loader之前 module: { rules: [ test: /\\/js$/, include: path.resolve('src'), use: [ 'thread-loader' ] ] } ","date":"2021-03-26","objectID":"/posts/nodejs-1/:19:1","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"HappyPack const HappyPack = require('happypack') # 根据cpu的数量来创建一个线程池 const happyThreadPool.ThreadPool({size: OscillatorNode.cpus().length}) # 在plugins中添加 plugins: [ new HappyPack({ id: 'jsx', threads: happyThreadPool, # 要查看loader是否支持happypack loaders: ['babel-loader', '...'] }) ] ","date":"2021-03-26","objectID":"/posts/nodejs-1/:19:2","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Javascript"],"content":"Tree-shaking 消除无用的JS代码 ","date":"2021-03-26","objectID":"/posts/nodejs-1/:20:0","tags":["Node.js"],"title":"Webpack基础概念","uri":"/posts/nodejs-1/"},{"categories":["Radis"],"content":"搭建Radis cluster预备知识 架构分类 单机模式 主从复制 哨兵模式 集群模式 单机模式 安装一个Redis的模式 ","date":"2021-03-25","objectID":"/posts/docker-5/:0:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"优点 部署简单 成本低,无备用结点 高性能,单机不需要同步数据,数据天然一致性 ","date":"2021-03-25","objectID":"/posts/docker-5/:1:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"缺点 不能保证可靠性,单机有宕机危险 单机性能受限于CPU性能,Redis为单线程 单机Redis能够承载QPS(每秒查询速率)大概在几万左右,取决于业务操作的复杂性,Lua脚本复杂性就极高 假设QPS达到10w,那么单机Redis就会直接挂掉,此时可以通过主从复制来解决该问题,实现系统的高并发 主从复制 Redis的复制(Replication)功能允许用户根据一个Redis服务器来创建任意多个该服务器的复制品,其中被复制的主机为主服务器(Master),通过复制创建出来的服务器为Slave 只要主从服务器之间的网络连接正常,主服务器就会将写入自己的数据同步到给从服务器,从而保证主从服务器的数据相同 数据的复制是单向的,只能从主节点到从节点,简单理解就是从节点支持读操作,不允许写操作 因此在以读操作的高并发场景下用主从架构,主从模式需要考虑的是:当Master结点宕机,需要选举出来一个新的Master结点,从而保证服务器的高可用性 ","date":"2021-03-25","objectID":"/posts/docker-5/:2:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"优点 Master/Slave 角色方便水平扩展，QPS 增加，增加 Slave 即可 降低 Master 读压力，转交给 Slave 节点 主节点宕机，从节点作为主节点的备份可以随时顶上继续提供服务 ","date":"2021-03-25","objectID":"/posts/docker-5/:3:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"缺点 可靠性保证不是很好，主节点故障便无法提供写入服务； 没有解决主节点写的压力； 数据冗余（为了高并发、高可用和高性能，一般是允许有冗余存在的）； 一旦主节点宕机，从节点晋升成主节点，需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预； 主节点的写能力受到单机的限制；主节点的存储能力受到单机的限制。 哨兵模式 在主从模式中，当主节点宕机之后，从节点是可以作为主节点顶上来继续提供服务，但是需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。 于是，在 Redis 2.8 版本开始，引入了哨兵（Sentinel）这个概念，在主从复制的基础上，哨兵实现了自动化故障恢复。 哨兵模式由两部分组成，哨兵节点和数据节点： 哨兵节点：哨兵节点是特殊的 Redis 节点，不存储数据； 数据节点：主节点和从节点都是数据节点。 Redis Sentinel 是分布式系统中监控 Redis 主从服务器，并提供主服务器下线时自动故障转移功能的模式。其中三个特性为： 监控(Monitoring)：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常 提醒(Notification)：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知 自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作 ","date":"2021-03-25","objectID":"/posts/docker-5/:4:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"定时任务 Sentinel 内部有 3 个定时任务 ","date":"2021-03-25","objectID":"/posts/docker-5/:5:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"每1秒 Sentinel 对其他 Sentinel 和 Redis 节点执行 PING 操作（监控），这是一个心跳检测，是失败判定的依据 ","date":"2021-03-25","objectID":"/posts/docker-5/:5:1","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"每2秒 每个 Sentinel 通过 Master 节点的 channel 交换信息（Publish/Subscribe） ","date":"2021-03-25","objectID":"/posts/docker-5/:5:2","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"每10秒 每个 Sentinel 会对 Master 和 Slave 执行 INFO 命令，这个任务主要达到两个目的 发现 Slave 节点 确认主从关系 ","date":"2021-03-25","objectID":"/posts/docker-5/:5:3","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"主观下线 所谓主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断，即单个 Sentinel 认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因） 　主观下线就是说如果服务器在给定的毫秒数之内， 没有返回 Sentinel 发送的 PING 命令的回复， 或者返回一个错误， 那么 Sentinel 会将这个服务器标记为主观下线（SDOWN） ","date":"2021-03-25","objectID":"/posts/docker-5/:6:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"客观下线 客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断，并且通过命令互相交流之后，得出的服务器下线判断，然后开启 failover 只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线（ODOWN）。只有当 Master 被认定为客观下线时，才会发生故障迁移 ","date":"2021-03-25","objectID":"/posts/docker-5/:7:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"仲裁 仲裁指的是配置文件中的 quorum 选项。某个 Sentinel 先将 Master 节点标记为主观下线，然后会将这个判定通过 sentinel is-master-down-by-addr 命令询问其他 Sentinel 节点是否也同样认为该 addr 的 Master 节点要做主观下线。最后当达成这一共识的 Sentinel 个数达到前面说的 quorum 设置的值时，该 Master 节点会被认定为客观下线并进行故障转移 quorum 的值一般设置为 Sentinel 个数的二分之一加 1，例如 3 个 Sentinel 就设置为 2 ","date":"2021-03-25","objectID":"/posts/docker-5/:8:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"哨兵模式工作原理 每个 Sentinel 以每秒一次的频率向它所知的 Master，Slave 以及其他 Sentinel 节点发送一个 PING 命令 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过配置文件 own-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel 标记为主观下线 如果一个 Master 被标记为主观下线，那么正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 是否真的进入主观下线状态； 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态，则 Master 会被标记为客观下线 如果 Master 处于 ODOWN 状态，则投票自动选出新的主节点。将剩余的从节点指向新的主节点继续进行数据复制 在正常情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令；当 Master 被 Sentinel 标记为客观下线时，Sentinel 向已下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除。若 Master 重新向 Sentinel 的 PING 命令返回有效回复，Master 的主观下线状态就会被移除 ","date":"2021-03-25","objectID":"/posts/docker-5/:9:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"优点 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都有 主从可以自动切换，系统更健壮，可用性更高 Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知 ","date":"2021-03-25","objectID":"/posts/docker-5/:10:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"缺点 主从切换需要时间，会丢失数据 没有解决主节点写的压力 主节点的写能力，存储能力受到单机的限制 动态扩容困难复杂，对于集群，容量达到上限时在线扩容会变得很复杂 集群模式 假设上千万、上亿用户同时访问 Redis，QPS 达到 10 万+。这些请求过来，单机 Redis 直接就挂了。系统的瓶颈就出现在 Redis 单机问题上，此时我们可以通过主从复制解决该问题，实现系统的高并发。 主从模式中，当主节点宕机之后，从节点是可以作为主节点顶上来继续提供服务，但是需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。于是，在 Redis 2.8 版本开始，引入了哨兵（Sentinel）这个概念，在主从复制的基础上，哨兵实现了自动化故障恢复。 哨兵模式中，单个节点的写能力，存储能力受到单机的限制，动态扩容困难复杂。 于是，Redis 3.0 版本正式推出 Redis Cluster 集群模式，有效地解决了 Redis 分布式方面的需求。Redis Cluster 集群模式具有高可用、可扩展性、分布式、容错等特性。 Redis Cluster 采用无中心结构，每个节点都可以保存数据和整个集群状态，每个节点都和其他所有节点连接。Cluster 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群，其中三个为主节点，三个为从节点。三个主节点会分配槽，处理客户端的命令请求，而从节点可用在主节点故障后，顶替主节点。 如上图所示，该集群中包含 6 个 Redis 节点，3 主 3 从，分别为 M1，M2，M3，S1，S2，S3。除了主从 Redis 节点之间进行数据复制外，所有 Redis 节点之间采用 Gossip 协议进行通信，交换维护节点元数据信息。 总结下来就是：读请求分配给 Slave 节点，写请求分配给 Master，数据同步从 Master 到 Slave 节点。 ","date":"2021-03-25","objectID":"/posts/docker-5/:11:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"分片 单机、主从、哨兵的模式数据都是存储在一个节点上，其他节点进行数据的复制。而单个节点存储是存在上限的，集群模式就是把数据进行分片存储，当一个分片数据达到上限的时候，还可以分成多个分片。 Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：HASH_SLOT = CRC16(key) % 16384。每一个节点负责维护一部分槽以及槽所映射的键值数据。 Redis Cluster 提供了灵活的节点扩容和缩容方案。在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容。可以说，槽是 Redis Cluster 管理数据的基本单位，集群伸缩就是槽和数据在节点之间的移动。 简单的理解就是：扩容或缩容以后，槽需要重新分配，数据也需要重新迁移，但是服务不需要下线。 假如，这里有 3 个节点的集群环境如下： 节点 A 哈希槽范围为 0 ~ 5500； 节点 B 哈希槽范围为 5501 ~ 11000； 节点 C 哈希槽范围为 11001 ~ 16383。 此时，我们如果要存储数据，按照 Redis Cluster 哈希槽的算法，假设结果是： CRC16(key) % 16384 = 6782。 那么就会把这个 key 的存储分配到 B 节点。此时连接 A、B、C 任何一个节点获取 key，都会这样计算，最终通过 B 节点获取数据。 假如这时我们新增一个节点 D，Redis Cluster 会从各个节点中拿取一部分 Slot 到 D 上，比如会变成这样： 节点 A 哈希槽范围为 1266 ~ 5500； 节点 B 哈希槽范围为 6827 ~ 11000； 节点 C 哈希槽范围为 12288 ~ 16383； 节点 D 哈希槽范围为 0 ~ 1265，5501 ~ 6826，11001 ~ 12287 这种特性允许在集群中轻松地添加和删除节点。同样的如果我想删除节点 D，只需要将节点 D 的哈希槽移动到其他节点，当节点是空时，便可完全将它从集群中移除。 ","date":"2021-03-25","objectID":"/posts/docker-5/:12:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"主从模式 Redis Cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点复制主节点数据备份，当这个主节点挂掉后，就会通过这个主节点的从节点选取一个来充当主节点，从而保证集群的高可用。 回到刚才的例子中，集群有 A、B、C 三个主节点，如果这 3 个节点都没有对应的从节点，如果 B 挂掉了，则集群将无法继续，因为我们不再有办法为 5501 ~ 11000 范围内的哈希槽提供服务。 所以我们在创建集群的时候，一定要为每个主节点都添加对应的从节点。比如，集群包含主节点 A、B、C，以及从节点 A1、B1、C1，那么即使 B 挂掉系统也可以继续正确工作。 因为 B1 节点属于 B 节点的子节点，所以 Redis 集群将会选择 B1 节点作为新的主节点，集群将会继续正确地提供服务。当 B 重新开启后，它就会变成 B1 的从节点。但是请注意，如果节点 B 和 B1 同时挂掉，Redis Cluster 就无法继续正确地提供服务了。 ","date":"2021-03-25","objectID":"/posts/docker-5/:13:0","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"优点 无中心架构； 可扩展性，数据按照 Slot 存储分布在多个节点，节点间数据共享，节点可动态添加或删除，可动态调整数据分布； 高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本。 实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升。 ","date":"2021-03-25","objectID":"/posts/docker-5/:13:1","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["Radis"],"content":"缺点 数据通过异步复制，无法保证数据强一致性； 集群环境搭建复杂，不过基于 Docker 的搭建方案会相对简单。 　","date":"2021-03-25","objectID":"/posts/docker-5/:13:2","tags":["Radis基础"],"title":"Radis架构模式","uri":"/posts/docker-5/"},{"categories":["VMware"],"content":"VMware安装Centos集群 设置虚拟机网络模式为桥接模式 查看宿主机(当前主机)的网络信息 ipconfig ","date":"2021-03-25","objectID":"/posts/docker-4/:0:0","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"配置虚拟机网络 ","date":"2021-03-25","objectID":"/posts/docker-4/:1:0","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"配置网关地址 首先查看/etc/sysconfig/network-scripts下的文件 ls /etc/sysconfig/network-scripts 然后编辑ifcfg-xxx文件 sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=Ethernet BOOTPROTO=static #修改成static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no NAME=eno16777736 UUID=bf5337ab-c044-4af7-9143-12da0d493b89 DEVICE=eno16777736 ONBOOT=yes #修改成yes PEERDNS=yes PEERROUTES=yes IPV6_PEERDNS=yes IPV6_PEERROUTES=yes IPADDR=192.168.1.130 # 自定义虚拟机的ip地址 NETMASK=255.255.255.0 #设置子网掩码 GATEWAY=192.168.1.1 #默认网关 DNS1=192.168.1.1 #DNS # 与宿主机相同 添加网关地址 sudo vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=xxxx #随便一个名字 GATEWAY=192.168.1.1 #默认网关和宿主机相同 ","date":"2021-03-25","objectID":"/posts/docker-4/:1:1","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"重启network sudo service network restart ","date":"2021-03-25","objectID":"/posts/docker-4/:1:2","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"测试网络 ping 192.168.1.130 ping baidu.com ","date":"2021-03-25","objectID":"/posts/docker-4/:1:3","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"安装bash补全功能 由于我安装的是Minimal版本的centos因此bash没有路径不全功能 sudo yum -y install bash-completion ","date":"2021-03-25","objectID":"/posts/docker-4/:2:0","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"开启SSH服务 ","date":"2021-03-25","objectID":"/posts/docker-4/:3:0","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"安装 openssh-server sudo yum install openssh-server ","date":"2021-03-25","objectID":"/posts/docker-4/:3:1","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"配置SSH文件 sudo vi /etc/ssh/sshd_config # 去除注释 Port 22 # 开启监听端口 PermitRootLogin yes # 开启远程登录 PasswordAuthentication yes #开启账号密码登录 ","date":"2021-03-25","objectID":"/posts/docker-4/:3:2","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"开启服务 sudo service sshd start ","date":"2021-03-25","objectID":"/posts/docker-4/:3:3","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"验证服务开启 ps -e | grep sshd ","date":"2021-03-25","objectID":"/posts/docker-4/:3:4","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"设置SSH开机自启动 sudo systemctl enable sshd.service systemctl list-unit-files | grep sshd ","date":"2021-03-25","objectID":"/posts/docker-4/:3:5","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"克隆虚拟机 ","date":"2021-03-25","objectID":"/posts/docker-4/:4:0","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"VMware克隆 ","date":"2021-03-25","objectID":"/posts/docker-4/:4:1","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"选择创建完整克隆 ","date":"2021-03-25","objectID":"/posts/docker-4/:4:2","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"更改主机hostname sudo vi /etc/hostname ","date":"2021-03-25","objectID":"/posts/docker-4/:4:3","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"更改ip地址 vi /etc/sysconfig/network-scripts/ifcfg-ens33 IPADDR= new_value # 192.168.1.131 ","date":"2021-03-25","objectID":"/posts/docker-4/:4:4","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"重启网络 sudo systemctl restart network ","date":"2021-03-25","objectID":"/posts/docker-4/:4:5","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["VMware"],"content":"配置hosts vi /etc/hosts 192.168.1.130 node-1 192.168.1.131 node-2 ","date":"2021-03-25","objectID":"/posts/docker-4/:4:6","tags":["VMware集群"],"title":"VMware安装Centos","uri":"/posts/docker-4/"},{"categories":["Docker"],"content":"Docker网络模式 容器之间的通信-根据服务/容器名称通信 三种网络模式 安装 Docker 以后，会默认创建三种网络，可以通过 docker network ls 查看。 [root@localhost ~]# docker network ls NETWORK ID NAME DRIVER SCOPE 688d1970f72e bridge bridge local 885da101da7d host host local f4f1b3cf1b7f none null local 网络模式 简介 bridge 为每一个容器分配、设置 IP 等，并将容器连接到一个 docker0 虚拟网桥，默认为该模式。 host 容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。 none 容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，IP 等。 container 新创建的容器不会创建自己的网卡和配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。 ","date":"2021-03-24","objectID":"/posts/docker-3/:0:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"bridge网路模式 在该模式中，Docker 守护进程创建了一个虚拟以太网桥 docker0，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。 　默认情况下，守护进程会创建一对对等虚拟设备接口 veth pair，将其中一个接口设置为容器的 eth0 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名，从而将宿主机上的所有容器都连接到这个内部网络上。 比如运行一个基于 busybox 镜像构建的容器 bbox01，查看 ip addr： busybox 被称为嵌入式 Linux 的瑞士军刀，整合了很多小的 unix 下的通用功能到一个小的可执行文件中。 ","date":"2021-03-24","objectID":"/posts/docker-3/:1:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"查看网络信息 ip addr ​ 守护进程会创建一对 对等虚拟设备接口veth pair，将其中一个接口设置为容器的 eth0 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名。 ​ 同时，守护进程还会从网桥 docker0 的私有地址空间中分配一个 IP 地址和子网给该容器，并设置 docker0 的 IP 地址为容器的默认网关。 ","date":"2021-03-24","objectID":"/posts/docker-3/:1:1","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"查看网桥信息 sudo yum install -y bridge-utils brctl show ","date":"2021-03-24","objectID":"/posts/docker-3/:1:2","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"查看每个容器的 IP 和 Gateway docker inspect 容器名称|ID 进行查看，在 NetworkSettings 节点中可以看到详细信息。 ","date":"2021-03-24","objectID":"/posts/docker-3/:1:3","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"查看所有 bridge 网络模式下的容器 docker network inspect bridge 在 Containers 节点中可以看到容器名称 ","date":"2021-03-24","objectID":"/posts/docker-3/:1:4","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"container指定bridge模式 关于 bridge 网络模式的使用，只需要在创建容器时通过参数 --net bridge 或者 --network bridge 指定即可(创建容器默认使用的网络模式，这个参数可以省略\"\u003e ","date":"2021-03-24","objectID":"/posts/docker-3/:1:5","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"host 网络模式 host 网络模式需要在创建容器时通过参数 --net host 或者 --network host 指定； 采用 host 网络模式的 Docker Container，可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换； host 网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。 ","date":"2021-03-24","objectID":"/posts/docker-3/:2:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"创建host容器 基于 host 网络模式创建了一个基于 busybox 镜像构建的容器 bbox02，查看 ip addr docker run -it --name bbox2 --net host busybox /# ip addr 然后宿主机通过 ip addr 查看信息 ","date":"2021-03-24","objectID":"/posts/docker-3/:2:1","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"查看docker网络信息 查看所有 host 网络模式下的容器，在 Containers 节点中可以看到容器名称 docker network inspect host ","date":"2021-03-24","objectID":"/posts/docker-3/:2:2","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"none 网络模式 none 网络模式是指禁用网络功能，只有 lo 接口 local 的简写，代表 127.0.0.1，即 localhost 本地环回接口。在创建容器时通过参数 --net none 或者 --network none 指定； none 网络模式即不为 Docker Container 创建任何的网络环境，容器内部就只能使用 loopback 网络设备，不会再有其他的网络资源。可以说 none 模式为 Docke Container 做了极少的网络设定，但是俗话说得好“少即是多”，在没有网络配置的情况下，作为 Docker 开发者，才能在这基础做其他无限多可能的网络定制开发。这也恰巧体现了 Docker 设计理念的开放。 ","date":"2021-03-24","objectID":"/posts/docker-3/:3:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"创建none容器 基于 none 网络模式创建了一个基于 busybox 镜像构建的容器 bbox03，查看 ip addr ","date":"2021-03-24","objectID":"/posts/docker-3/:3:1","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"查看docker网络信息 查看所有 none 网络模式下的容器，在 Containers 节点中可以看到容器名称 docker network inspect none ","date":"2021-03-24","objectID":"/posts/docker-3/:3:2","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"container 网络模式 Container 网络模式是 Docker 中一种较为特别的网络的模式。在创建容器时通过参数 --net container:已运行的容器名称|ID 或者 --network container:已运行的容器名称|ID 指定； 处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信 Container 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等 同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的 ","date":"2021-03-24","objectID":"/posts/docker-3/:4:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"创建container容器 基于容器 bbox01 创建了 container 网络模式的容器 bbox04，查看 ip addr ","date":"2021-03-24","objectID":"/posts/docker-3/:4:1","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"查看docker网络信息 容器 bbox01 的 ip addr 信息如下 宿主机的 ip addr 信息如下 Docker 守护进程只创建了一对对等虚拟设备接口用于连接 bbox01 容器和宿主机，而 bbox04 容器则直接使用了 bbox01 容器的网卡信息 这个时候如果将 bbox01 容器停止，会发现 bbox04 容器就只剩下 lo 接口了 当bbox01 容器重启以后，bbox04 容器也重启一下，就又可以获取到网卡信息了 自定义网络模式 虽然 Docker 提供的默认网络使用比较简单，但是为了保证各容器中应用的安全性，在实际开发中更推荐使用自定义的网络进行容器管理，以及启用容器名称到 IP 地址的自动 DNS 解析。 　从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过容器名称进行通信。方法很简单，只要在创建容器时使用 --name 为容器命名即可。 　但是使用 Docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的，所以我们就需要自定义网络。 ","date":"2021-03-24","objectID":"/posts/docker-3/:4:2","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"创建网络 docker network create network_name#创建自定义网络模式 创建一个基于 bridge 网络模式的自定义网络模式 custom_network docker network create custom_network # 默认模式为bridge ","date":"2021-03-24","objectID":"/posts/docker-3/:5:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"查看网络模式 docker network ls ","date":"2021-03-24","objectID":"/posts/docker-3/:5:1","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"创建容器 通过自定义网络模式 custom_network 创建容器： docker run -di --name bbox05 --net custom_network busybox ","date":"2021-03-24","objectID":"/posts/docker-3/:5:2","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"查看容器网络信息 在 NetworkSettings 节点中可以看到详细信息 docker inspect 容器名称|ID ","date":"2021-03-24","objectID":"/posts/docker-3/:5:3","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"连接新的网络 通过 docker network connect 网络名称 容器名称 为容器连接新的网络模式 docker network connect bridge bbox05 通过 docker inspect 容器名称|ID 再次查看容器的网络信息，多增加了默认的 bridge ","date":"2021-03-24","objectID":"/posts/docker-3/:6:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"断开网络 可以通过 docker network rm 网络名称 命令移除自定义网络模式，网络模式移除成功会返回网络模式名称 docker network rm custom_network 注意：如果通过某个自定义网络模式创建了容器，则该网络模式无法删除 容器间网络通信 接下来我们通过所学的知识实现容器间的网络通信。首先明确一点，容器之间要互相通信，必须要有属于同一个网络的网卡 ","date":"2021-03-24","objectID":"/posts/docker-3/:7:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"创建容器 先创建两个基于默认的 bridge 网络模式的容器 docker run -di --name default_bbox01 busybox docker run -di --name default_bbox02 busybox ","date":"2021-03-24","objectID":"/posts/docker-3/:8:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"查看IP信息 docker network inspect bridge ","date":"2021-03-24","objectID":"/posts/docker-3/:9:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"测试通信-IP 测试两容器间是否可以进行网络通信 ","date":"2021-03-24","objectID":"/posts/docker-3/:10:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"通过容器名称 docker daemon 实现了一个内嵌的DNS server ，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 --name 为容器命名即可 但是使用 Docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的，所以我们就需要自定义网络 　我们先基于 bridge 网络模式创建自定义网络 custom_network，然后创建两个基于自定义网络模式的容器 docker run -di --name custom_bbox01 --net custom_network busybox docker run -di --name custom_bbox02 --net custom_network busybox 通过 docker network inspect custom_network 查看两容器的具体 IP 信息 ","date":"2021-03-24","objectID":"/posts/docker-3/:11:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"测试通信-容器名称 两个属于同一个自定义网络的容器是可以进行网络通信的，并且可以使用容器名称进行网络通信 ","date":"2021-03-24","objectID":"/posts/docker-3/:12:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"bridge和 custom_network 通信 让 bridge 网络下的容器连接至新的 custom_network 网络即可 docker network connect custom_network default_bbox01 ","date":"2021-03-24","objectID":"/posts/docker-3/:13:0","tags":["Docker基础"],"title":"Docker网络模式","uri":"/posts/docker-3/"},{"categories":["Docker"],"content":"Dockerfile 构建过程 　我们可以通过公共仓库拉取镜像使用，但是，有些时候公共仓库拉取的镜像并不符合我们的需求。尽管已经从繁琐的部署工作中解放出来，但是实际开发时，我们可能希望镜像包含整个项目的完整环境，在其他机器上拉取打包完整的镜像，直接运行即可。 Docker 支持自己构建镜像，还支持将自己构建的镜像上传至公共仓库，镜像构建可以通过以下两种方式来实现： docker commit：从容器创建一个新的镜像 docker build：配合 Dockerfile 文件创建镜像 下面我们先通过 docker commit 来实现镜像的构建 目标：我们通过基础镜像 centos:7，在该镜像中安装 jdk 和 tomcat 以后将其制作为一个新的镜像 mycentos:7 ","date":"2021-03-22","objectID":"/posts/docker-2/:0:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"创建镜像 # 拉取镜像 docker pull centos:7 # 创建容器 docker run -di --name centos7 centos:7 ","date":"2021-03-22","objectID":"/posts/docker-2/:1:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"拷贝资源 # 将宿主机的 jdk 和 tomcat 拷贝至容器 docker cp jdk-11.0.6_linux-x64_bin.tar.gz centos7:/root docker cp apache-tomcat-9.0.37.tar.gz centos7:/root ","date":"2021-03-22","objectID":"/posts/docker-2/:2:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"安装资源 # 进入容器 docker exec -it centos7 /bin/bash ----------------------以下操作都在容器内部执行---------------------- # 切换至 /root 目录 cd root/ # 创建 java 和 tomcat 目录 mkdir -p /usr/local/java mkdir -p /usr/local/tomcat # 将 jdk 和 tomcat 解压至容器 /usr/local/java 和 /usr/local/tomcat 目录中 tar -zxvf jdk-11.0.6_linux-x64_bin.tar.gz -C /usr/local/java/ tar -zxvf apache-tomcat-9.0.37.tar.gz -C /usr/local/tomcat/ # 配置 jdk 环境变量 vi /etc/profile # 在环境变量文件中添加以下内容 export JAVA_HOME=/usr/local/java/jdk-11.0.6/ export PATH=$PATH:$JAVA_HOME/bin # 重新加载环境变量文件 source /etc/profile # 测试环境变量是否配置成功 [root@f7787f6fcbb6 ~]# java -version java version \"11.0.6\" 2020-01-14 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.6+8-LTS) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.6+8-LTS, mixed mode) # 删除容器内 jdk 和 tomcat rm jdk-11.0.6_linux-x64_bin.tar.gz apache-tomcat-9.0.37.tar.gz -rf ","date":"2021-03-22","objectID":"/posts/docker-2/:3:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"构建镜像 docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] docker commit -a=\"mrhelloworld\" -m=\"jdk11 and tomcat9\" centos7 mycentos:7 参数 作用 -a 提交的镜像作者 -c 使用 Dockerfile 指令来创建镜像 -m 提交时的说明文字 -p 在 commit 时，将容器暂停 ","date":"2021-03-22","objectID":"/posts/docker-2/:4:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"使用构建的镜像创建容器 # 创建容器 docker run -di --name mycentos7 -p 8080:8080 mycentos:7 # 进入容器 docker exec -it mycentos7 /bin/bash # 重新加载配置文件 source /etc/profile # 测试 java 环境变量 [root@dcae87df010b /]# java -version java version \"11.0.6\" 2020-01-14 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.6+8-LTS) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.6+8-LTS, mixed mode) # 启动 tomcat /usr/local/apache-tomcat-9.0.37/bin/startup.sh # 访问 http://localhost:8080/ 看到页面说明环境 OK! Dockerfile命令解析 ","date":"2021-03-22","objectID":"/posts/docker-2/:5:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"FROM 语法：FROM \u003cimage\u003e:\u003ctag\u003e 指明构建的新镜像是来自于哪个基础镜像，如果没有选择 tag，那么默认值为 latest FROM centos:7 如果不以任何镜像为基础，那么写法为：FROM scratch。官方说明：scratch 镜像是一个空镜像，可以用于构建 busybox 等超小镜像，可以说是真正的从零开始构建属于自己的镜像 ","date":"2021-03-22","objectID":"/posts/docker-2/:6:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"LABEL 语法：LABEL \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e ... 功能是为镜像指定标签。也可以使用 LABEL 来指定镜像作者 LABEL maintainer=\"mrhelloworld.com\" ","date":"2021-03-22","objectID":"/posts/docker-2/:7:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"RUN 语法：RUN \u003ccommand\u003e 构建镜像时运行的 Shell 命令，比如构建的新镜像中我们想在 /usr/local 目录下创建一个 java 目录 RUN mkdir -p /usr/local/java ","date":"2021-03-22","objectID":"/posts/docker-2/:8:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"ADD 语法：ADD \u003csrc\u003e... \u003cdest\u003e 拷贝文件或目录到镜像中。src 可以是一个本地文件或者是一个本地压缩文件，压缩文件会自动解压。还可以是一个 url，如果把 src 写成一个 url，那么 ADD 就类似于 wget 命令，然后自动下载和解压 ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java ","date":"2021-03-22","objectID":"/posts/docker-2/:9:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"COPY 语法：COPY \u003csrc\u003e... \u003cdest\u003e 拷贝文件或目录到镜像中。用法同 ADD，只是不支持自动下载和解压 COPY jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java ","date":"2021-03-22","objectID":"/posts/docker-2/:10:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"EXPOSE 语法：EXPOSE \u003cport\u003e [\u003cport\u003e/\u003cprotocol\u003e...] 暴露容器运行时的监听端口给外部，可以指定端口是监听 TCP 还是 UDP，如果未指定协议，则默认为 TCP EXPOSE 80 443 8080/tcp 如果想使得容器与宿主机的端口有映射关系，必须在容器启动的时候加上 -P 参数。 ","date":"2021-03-22","objectID":"/posts/docker-2/:11:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"ENV 语法：ENV \u003ckey\u003e \u003cvalue\u003e 添加单个，ENV \u003ckey\u003e=\u003cvalue\u003e ... 添加多个 设置容器内环境变量 ENV JAVA_HOME /usr/local/java/jdk-11.0.6/ ","date":"2021-03-22","objectID":"/posts/docker-2/:12:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"CMD 语法： CMD [\"executable\",\"param1\",\"param2\"]，比如：CMD [\"/usr/local/tomcat/bin/catalina.sh\", \"start\"] CMD [\"param1\",\"param2\"] ，比如：CMD [ \"echo\", \"$JAVA_HOME\" ] CMD command param1 param2，比如：CMD echo $JAVA_HOME 启动容器时执行的 Shell 命令。在 Dockerfile 中只能有一条 CMD 指令。如果设置了多条 CMD，只有最后一条 CMD 会生效 CMD ehco $JAVA_HOME 如果创建容器的时候指定了命令，则 CMD 命令会被替代。假如镜像叫 centos:7，创建容器时命令是：docker run -it --name centos7 centos:7 echo \"helloworld\" 或者 docker run -it --name centos7 centos:7 /bin/bash，就不会输出 $JAVA_HOME 的环境变量信息了，因为 CMD 命令被 echo \"helloworld\"、/bin/bash 覆盖了 ","date":"2021-03-22","objectID":"/posts/docker-2/:13:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"ENTRYPOINT 语法： ENTRYPOINT [\"executable\", \"param1\", \"param2\"]，比如：ENTRYPOINT [\"/usr/local/tomcat/bin/catalina.sh\", \"start\"] ENTRYPOINT command param1 param2，比如：ENTRYPOINT ehco $JAVA_HOME 启动容器时执行的 Shell 命令，同 CMD 类似，不会被 docker run 命令行指定的参数所覆盖。在 Dockerfile 中只能有一条 ENTRYPOINT 指令。如果设置了多条 ENTRYPOINT，只有最后一条 ENTRYPOINT 会生效 ENTRYPOINT ehco $JAVA_HOME 如果在 Dockerfile 中同时写了 ENTRYPOINT 和 CMD CMD 指令不是一个完整的可执行命令，那么 CMD 指定的内容将会作为 ENTRYPOINT 的参数； CMD 是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效 ","date":"2021-03-22","objectID":"/posts/docker-2/:14:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"WORKDIR 语法：WORKDIR /path/to/workdir 为 RUN、CMD、ENTRYPOINT 以及 COPY 和 AND 设置工作目录 WORKDIR /usr/local ","date":"2021-03-22","objectID":"/posts/docker-2/:15:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"VOLUME 指定容器挂载点到宿主机自动生成的目录或其他容器。一般的使用场景为需要持久化存储数据时 # 容器的 /var/lib/mysql 目录会在运行时自动挂载为匿名卷，匿名卷在宿主机的 /var/lib/docker/volumes 目录下 VOLUME [\"/var/lib/mysql\"] 一般不会在 Dockerfile 中用到，更常见的还是在 docker run 的时候通过 -v 指定数据卷。 ","date":"2021-03-22","objectID":"/posts/docker-2/:16:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"构建镜像 Dockerfile 文件编写好以后，真正构建镜像时需要通过 docker build 命令。 docker build 命令用于使用 Dockerfile 创建镜像。 -f：指定要使用的 Dockerfile 路径； –tag, -t：镜像的名字及标签，可以在一次构建中为一个镜像设置多个标签。 ","date":"2021-03-22","objectID":"/posts/docker-2/:17:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"构建路径 ‘.’ Docker 在运行时分为 Docker 引擎（服务端守护进程） 和 客户端工具，我们日常使用各种 docker 命令，其实就是在使用 客户端工具 与 Docker 引擎 进行交互。 当我们使用 docker build 命令来构建镜像时，这个构建过程其实是在 Docker 引擎 中完成的，而不是在本机环境。如果在 Dockerfile 中使用了一些 ADD 等指令来操作文件，如何让 Docker 引擎 获取到这些文件呢？ 这里就有了一个 镜像构建上下文 的概念，当构建的时候，由用户指定构建镜像时的上下文路径，而 docker build 会将这个路径下所有的文件都打包上传给 Docker 引擎，引擎内将这些内容展开后，就能获取到上下文中的文件了。 举个栗子：我的宿主机 jdk 文件在 /root 目录下，Dockerfile 文件在 /usr/local/dockerfile 目录下，文件内容如下： ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java 那么构建镜像时的命令就该这样写： docker build -f /usr/local/dockerfile/Dockerfile -t mycentos:7 /root 再举个栗子：我的宿主机 jdk 文件和 Dockerfile 文件都在 /usr/local/dockerfile 目录下，文件内容如下： ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java 那么构建镜像时的命令则这样写： docker build -f /usr/local/dockerfile/Dockerfile -t mycentos:7 . ","date":"2021-03-22","objectID":"/posts/docker-2/:18:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"Dockerfile 实践 接下来我们通过基础镜像 centos:7，在该镜像中安装 jdk 和 tomcat 以后将其制作为一个新的镜像 mycentos:7 ","date":"2021-03-22","objectID":"/posts/docker-2/:19:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"创建目录 mkdir -p /usr/local/dockerfile ","date":"2021-03-22","objectID":"/posts/docker-2/:19:1","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"编写dockerfile vi Dockerfile ","date":"2021-03-22","objectID":"/posts/docker-2/:20:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"Dockerfile文件如下 # 指明构建的新镜像是来自于 centos:7 基础镜像 FROM centos:7 # 通过镜像标签声明了作者信息 LABEL maintainer=\"mrhelloworld.com\" # 设置工作目录 WORKDIR /usr/local # 新镜像构建成功以后创建指定目录 RUN mkdir -p /usr/local/java \u0026\u0026 mkdir -p /usr/local/tomcat # 拷贝文件到镜像中并解压 ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java ADD apache-tomcat-9.0.37.tar.gz /usr/local/tomcat # 暴露容器运行时的 8080 监听端口给外部 EXPOSE 8080 # 设置容器内 JAVA_HOME 环境变量 ENV JAVA_HOME /usr/local/java/jdk-11.0.6/ ENV PATH $PATH:$JAVA_HOME/bin # 启动容器时启动 tomcat CMD [\"/usr/local/tomcat/apache-tomcat-9.0.37/bin/catalina.sh\", \"run\"] ","date":"2021-03-22","objectID":"/posts/docker-2/:21:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"构建镜像 [root@localhost ~]# docker build -f /usr/local/dockerfile/Dockerfile -t mycentos:7 /root/ Sending build context to Docker daemon 191.4MB Step 1/10 : FROM centos:7 ---\u003e 7e6257c9f8d8 Step 2/10 : LABEL maintainer=\"mrhelloworld.com\" ---\u003e Running in 3f18aa4f3fb2 Removing intermediate container 3f18aa4f3fb2 ---\u003e 7364f68ca4ab Step 3/10 : WORKDIR /usr/local ---\u003e Running in d9889152cfc4 Removing intermediate container d9889152cfc4 ---\u003e d05bd2e09fa4 Step 4/10 : RUN mkdir -p /usr/local/java \u0026\u0026 mkdir -p /usr/local/tomcat ---\u003e Running in 3bcd6ef78350 Removing intermediate container 3bcd6ef78350 ---\u003e 4832abf9d769 Step 5/10 : ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java ---\u003e e61474bf7a76 Step 6/10 : ADD apache-tomcat-9.0.37.tar.gz /usr/local/tomcat ---\u003e 7110cdff7438 Step 7/10 : EXPOSE 8080 ---\u003e Running in a4731c1cf77d Removing intermediate container a4731c1cf77d ---\u003e f893cefee00c Step 8/10 : ENV JAVA_HOME /usr/local/java/jdk-11.0.6/ ---\u003e Running in f0cb08f390db Removing intermediate container f0cb08f390db ---\u003e ff9f6acf6844 Step 9/10 : ENV PATH $PATH:$JAVA_HOME/bin ---\u003e Running in eae88cf841d0 Removing intermediate container eae88cf841d0 ---\u003e 4b9226a23b10 Step 10/10 : CMD [\"/usr/local/tomcat/apache-tomcat-9.0.37/bin/catalina.sh\", \"run\"] ---\u003e Running in ccf481045906 Removing intermediate container ccf481045906 ---\u003e 9ef76a16441b Successfully built 9ef76a16441b Successfully tagged mycentos:7 ","date":"2021-03-22","objectID":"/posts/docker-2/:22:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"查看镜像构建历史 docker history 镜像名称:标签|ID docker history mycentos:7 ","date":"2021-03-22","objectID":"/posts/docker-2/:23:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"使用构建的镜像创建容器 # 创建容器 docker run -di --name mycentos7 -p 8080:8080 mycentos:7 # 进入容器 docker exec -it mycentos7 /bin/bash # 测试 java 环境变量 [root@dcae87df010b /]# java -version java version \"11.0.6\" 2020-01-14 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.6+8-LTS) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.6+8-LTS, mixed mode) # 访问 http://localhost:8080/ 看到页面说明环境 OK! ","date":"2021-03-22","objectID":"/posts/docker-2/:24:0","tags":["Docker基础"],"title":"Dockerfile构建镜像","uri":"/posts/docker-2/"},{"categories":["Docker"],"content":"Docker常用命令 Docker的组成 Docker 在运行时分为 Docker 引擎（服务端守护进程） 和 客户端工具，我们日常使用各种 docker 命令，其实就是在使用 客户端工具 与 Docker 引擎 进行交互。 ","date":"2021-03-22","objectID":"/posts/docker-1/:0:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"Docker客户端 Docker 是一个客户端-服务器（C/S）架构程序。Docker 客户端只需要向 Docker 服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具 Docker 以及一整套 RESTful API。你可以在同一台宿主机上运行 Docker 守护进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程。 ","date":"2021-03-22","objectID":"/posts/docker-1/:1:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"Host主机(Docker引擎) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器 ","date":"2021-03-22","objectID":"/posts/docker-1/:2:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"Image镜像 什么是 Docker 镜像？简单的理解，Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运行在 Linux 内核的程序以及相应的数据。 通过镜像启动一个容器，一个镜像就是一个可执行的包，其中包括运行应用程序所需要的所有内容：包含代码，运行时间，库，环境变量和配置文件等。 Docker 把 App 文件打包成为一个镜像，并且采用类似多次快照的存储技术，可以实现： 多个 App 可以共用相同的底层镜像（初始的操作系统镜像）； App 运行时的 IO 操作和镜像文件隔离； 通过挂载包含不同配置/数据文件的目录或者卷（Volume），单个 App 镜像可以用来运行无数个不同业务的容器。 ","date":"2021-03-22","objectID":"/posts/docker-1/:3:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"Container容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 Docker 面向对象 容器 对象 镜像 类 ","date":"2021-03-22","objectID":"/posts/docker-1/:4:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"Volume数据卷 实际上我们的容器就好像是一个简易版的操作系统，只不过系统中只安装了我们的程序运行所需要的环境，前边说到我们的容器是可以删除的，那如果删除了，容器中的程序产生的需要持久化的数据怎么办呢？容器运行的时候我们可以进容器去查看，容器一旦删除就什么都没有了。 所以数据卷就是来解决这个问题的，是用来将数据持久化到我们宿主机上，与容器间实现数据共享，简单的说就是将宿主机的目录映射到容器中的目录，应用程序在容器中的目录读写数据会同步到宿主机上，这样容器产生的数据就可以持久化了，比如我们的数据库容器，就可以把数据存储到我们宿主机上的真实磁盘中。 ","date":"2021-03-22","objectID":"/posts/docker-1/:5:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"Registry镜像存储中心 可以将镜像上传到Docker Hub作为公共镜像 也可以在本地搭建局域网Docker Hub,搭建权限分级 Centos安装Docker引擎 # 安装 yum-utils sudo yum install -y yum-utils # 设置 yum 源为阿里云方便下载 Docker Engine sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo ","date":"2021-03-22","objectID":"/posts/docker-1/:6:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"Docker常用命令 # 启动 docker sudo systemctl start docker # 停止 docker sudo systemctl stop docker # 重启 docker sudo systemctl restart docker # 设置开机启动 sudo systemctl enable docker # 查看 docker 状态 sudo systemctl status docker # 查看 docker 内容器的运行状态 sudo docker stats # 查看 docker 概要信息 sudo docker info # 查看 docker 帮助文档 sudo docker --help ","date":"2021-03-22","objectID":"/posts/docker-1/:7:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"Docker版本查看 docker -v docker version ","date":"2021-03-22","objectID":"/posts/docker-1/:8:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"配置镜像源 vi /etc/docker/daemon.json # 编辑配置文件 在文件中输入以下内容 { \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\", \"http://hub-mirror.c.163.com\"] } 重新加载配置 # 重新加载某个服务的配置文件 sudo systemctl daemon-reload # 重新启动 docker sudo systemctl restart docker 镜像命令 ","date":"2021-03-22","objectID":"/posts/docker-1/:9:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"查看镜像 docker images 名称 作用 REPOSITORY 镜像在仓库中的名称，本文中以后都简称镜像名称 TAG 镜像标签 IMAGE ID 镜像 ID CREATED 镜像的创建日期（不是获取该镜像的日期） SIZE 镜像大小 这些镜像都是存储在 Docker 宿主机的 /var/lib/docker 目录下。 ","date":"2021-03-22","objectID":"/posts/docker-1/:10:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"搜索镜像 docker search image_name 名称 作用 NAME 镜像名称 DESCRIPTION 镜像描述 STARS 用户评价，反映一个镜像的受欢迎程度 OFFICIAL 是否为官方构建 AUTOMATED 自动构建，表示该镜像由 Docker Hub 自动构建流程创建的 ","date":"2021-03-22","objectID":"/posts/docker-1/:11:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"拉取镜像 docker pull docker_name ","date":"2021-03-22","objectID":"/posts/docker-1/:12:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"删除镜像 # 按照ID删除 docker rmi docker_id # 删除多个镜像 docker rmi docker_id1 docker_id2 docker_id3 # 查询所有镜像并删除 docker rmi 'docker images -q' 容器命令 ","date":"2021-03-22","objectID":"/posts/docker-1/:13:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"查看容器 docker ps 名称 作用 CONTAINER ID 容器 ID IMAGE 所属镜像 COMMAND CREATED 创建时间 STATUS 容器状态 PORTS 端口 NAMES 容器名称 ","date":"2021-03-22","objectID":"/posts/docker-1/:14:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"查看停止的容器 docker ps if status=exited ","date":"2021-03-22","objectID":"/posts/docker-1/:15:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"查看所有容器 docker ps -a ","date":"2021-03-22","objectID":"/posts/docker-1/:16:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"查看最后一次运行的容器 docker ps -l ","date":"2021-03-22","objectID":"/posts/docker-1/:17:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"列出最近创建的 n 个容器 docker ps -n 5 ","date":"2021-03-22","objectID":"/posts/docker-1/:18:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"创建与启动容器 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 名称 作用 -i 表示运行容器 -t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端 –name 为创建的容器命名 -v 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个 -v 做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上 -d 在 run 后面加上 -d 参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加 -i -t 两个参数，创建容器后就会自动进容器里） -p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个 -p 做多个端口映射 -P 随机使用宿主机的可用端口与容器内暴露的端口映射 ","date":"2021-03-22","objectID":"/posts/docker-1/:19:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"创建并进入容器 通过镜像 AA 创建一个容器 BB，运行容器并进入容器的 /bin/bash docker run -it --name 容器名称 镜像名称:标签 /bin/bash 注意：Docker 容器运行必须有一个前台进程， 如果没有前台进程执行，容器认为是空闲状态，就会自动退出 ","date":"2021-03-22","objectID":"/posts/docker-1/:20:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"退出当前容器 exit ","date":"2021-03-22","objectID":"/posts/docker-1/:21:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"守护式方式创建容器 docker run -di --name 容器名称 镜像名称:标签 ","date":"2021-03-22","objectID":"/posts/docker-1/:22:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"登录守护式容器方式 docker exec -it 容器名称|容器ID /bin/bash ","date":"2021-03-22","objectID":"/posts/docker-1/:23:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"停止与启动容器 # 停止容器 docker stop 容器名称|容器ID # 启动容器 docker start 容器名称|容器ID ","date":"2021-03-22","objectID":"/posts/docker-1/:24:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"文件拷贝 docker cp 容器名称:容器目录 需要拷贝的文件或目录 目录挂载(容器数据卷操作) 我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器，而且这个操作是双向绑定的，也就是说容器内的操作也会影响到宿主机，实现备份功能。 但是容器被删除的时候，宿主机的内容并不会被删除。如果多个容器挂载同一个目录，其中一个容器被删除，其他容器的内容也不会受到影响。 容器与宿主机之间的数据卷属于引用的关系，数据卷是从外界挂载到容器内部中的，所以可以脱离容器的生命周期而独立存在，正是由于数据卷的生命周期并不等同于容器的生命周期，在容器退出或者删除以后，数据卷仍然不会受到影响，数据卷的生命周期会一直持续到没有容器使用它为止。 创建容器添加 -v 参数，格式为宿主机目录:容器目录 docker run -di -v /mydata/docker_centos/data:/usr/local/data --name centos7-01 centos:7 # 多目录挂载 docker run -di -v /宿主机目录:/容器目录 -v /宿主机目录2:/容器目录2 镜像名 目录挂载操作可能会出现权限不足的提示。这是因为 CentOS7 中的安全模块 SELinux 把权限禁掉了，在 docker run 时通过 --privileged=true 给该容器加权限来解决挂载的目录没有权限的问题。 ","date":"2021-03-22","objectID":"/posts/docker-1/:25:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"匿名挂载 匿名挂载只需要写容器目录即可，容器外对应的目录会在 /var/lib/docker/volume 中生成 # 匿名挂载 docker run -di -v /usr/local/data --name centos7-02 centos:7 # 查看 volume 数据卷信息 docker volume ls ","date":"2021-03-22","objectID":"/posts/docker-1/:26:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"具名挂载 具名挂载就是给数据卷起了个名字，容器外对应的目录会在 /var/lib/docker/volume 中生成 # 匿名挂载 docker run -di -v docker_centos_data:/usr/local/data --name centos7-03 centos:7 # 查看 volume 数据卷信息 docker volume ls ","date":"2021-03-22","objectID":"/posts/docker-1/:27:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"指定目录挂载 一开始给大家讲解的方式就属于指定目录挂载，这种方式的挂载不会在 /var/lib/docker/volume 目录生成内容 docker run -di -v /mydata/docker_centos/data:/usr/local/data --name centos7-01 centos:7 # 多目录挂载 docker run -di -v /宿主机目录:/容器目录 -v /宿主机目录2:/容器目录2 镜像名 ","date":"2021-03-22","objectID":"/posts/docker-1/:28:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"查看目录挂载关系 通过 docker volume inspect 数据卷名称 可以查看该数据卷对应宿主机的目录地址 [root@localhost ~]# docker volume inspect docker_centos_data [ { \"CreatedAt\": \"2020-08-13T20:19:51+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/docker_centos_data/_data\", \"Name\": \"docker_centos_data\", \"Options\": null, \"Scope\": \"local\" } ] 通过 docker inspect 容器ID或名称 ，在返回的 JSON 节点中找到 Mounts，可以查看详细的数据挂载信息 ","date":"2021-03-22","objectID":"/posts/docker-1/:29:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"设置只读/只写 # 只读。只能通过修改宿主机内容实现对容器的数据管理。 docker run -it -v /宿主机目录:/容器目录:ro 镜像名 # 读写，默认。宿主机和容器可以双向操作数据。 docker run -it -v /宿主机目录:/容器目录:rw 镜像名 ","date":"2021-03-22","objectID":"/posts/docker-1/:30:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"volumes-from（继承） # 容器 centos7-01 指定目录挂载 docker run -di -v /mydata/docker_centos/data:/usr/local/data --name centos7-01 centos:7 # 容器 centos7-04 和 centos7-05 相当于继承 centos7-01 容器的挂载目录 docker run -di --volumes-from centos7-01:ro --name centos7-04 centos:7 docker run -di --volumes-from centos7-01:rw --name centos7-05 centos:7 ","date":"2021-03-22","objectID":"/posts/docker-1/:31:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"查看容器详细信息 docker inspect 容器名称|容器ID ","date":"2021-03-22","objectID":"/posts/docker-1/:32:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Docker"],"content":"删除容器 # 删除指定容器 docker rm 容器名称|容器ID # 删除多个容器 docker rm 容器名称|容器ID 容器名称|容器ID ","date":"2021-03-22","objectID":"/posts/docker-1/:33:0","tags":["Docker基础"],"title":"Docker基本概念","uri":"/posts/docker-1/"},{"categories":["Javascript"],"content":"常用命令 ","date":"2021-03-22","objectID":"/posts/js-1/:0:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"script标签 //建议放在\u003c/body\u003e之前,即页面的最后面 \u003cscript type=\"text/javascript\"\u003e\u003c/script\u003e 其中type=“text/javascript\"为html5的新标准,可以省略为了 向下兼容,应该加上 ","date":"2021-03-22","objectID":"/posts/js-1/:1:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"获取元素 ","date":"2021-03-22","objectID":"/posts/js-1/:2:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"第一种方式 //getElementById document.getElementById('btn') /* 通过id获取元素,只有document下有 遇到第一个元素就返回 */ ","date":"2021-03-22","objectID":"/posts/js-1/:2:1","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"第二种方式 选择器querySelector: IE8以下不能用 ducument.querySelector('btn') /* 通过元素选择器,选择器可以通过class,id来选择 #box 表示通过 id 选择 .box 表示通过 class 选择 遇到第一个元素就返回 */ ","date":"2021-03-22","objectID":"/posts/js-1/:2:2","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"寻找父级元素 \u003cdiv class=\"wrap\"\u003e \u003cdiv\u003e父级元素下的子元素\u003c/div\u003e \u003c/div\u003e \u003cscript\u003e document.querySelector('.wrap').querySelector('div')//第一种方式 ducument.querySelector('.wrap div')//第二种方式,包含选择器 \u003c/script\u003e ","date":"2021-03-22","objectID":"/posts/js-1/:3:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"script放置的位置 //等待页面加载完成再执行script脚本(不推荐这样的方法) windows.onload = function(){ console.log(\"窗口加载完成\") } ","date":"2021-03-22","objectID":"/posts/js-1/:4:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"给元素绑定点击事件 \u003cbutton id=\"btn\"\u003e按钮\u003c/script\u003e \u003cscript\u003e document.getElementById('btn').onclick = function(){ ducument.getElementById('btn').style.background = 'red'; } \u003c/script\u003e ","date":"2021-03-22","objectID":"/posts/js-1/:5:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"变量存储 var btn = ducument.getElementById(\"btn\"); btn.onclick = function(){ //do something } ","date":"2021-03-22","objectID":"/posts/js-1/:6:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"cssText box.onclick = function(){ box.style.cssText = 'width:300px; height:300px; background:green;' } ","date":"2021-03-22","objectID":"/posts/js-1/:7:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"display属性 属性 作用 none 此元素不会被显示 block 此元素将显示为块级元素，此元素前后会带有换行符 inline 默认-此元素会被显示为内联元素，元素前后没有换行符 inline-block 行内块元素 ","date":"2021-03-22","objectID":"/posts/js-1/:8:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"innerHTML 替换掉标签内的全部内容 var list = document.getElementById('list'); list.innerHTML = '\u003cli\u003e' + 'hello' + '\u003cli\u003e' ","date":"2021-03-22","objectID":"/posts/js-1/:9:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"控制标签样式 var shit = document.getElementById('list'); shit.style.display = 'block'; ","date":"2021-03-22","objectID":"/posts/js-1/:10:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"js-a标签不执行跳转 \u003ca id = 'next' href=\"javascript:;\"\u003e ","date":"2021-03-22","objectID":"/posts/js-1/:11:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"获取全部div var divs = document.querySelectorAll('div') //返回值为数组 ","date":"2021-03-22","objectID":"/posts/js-1/:12:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"多选框开关切换 var btns = document.querySelectorAll('.option a'); //为所有选项增加事件 for(var i=0; i\u003cbtns.length; i++){ btns[i].abc = false //自定义属性 btns[i].onclick = function(){ if(this.abc){ //判断当前组件 this.className = ''; } else{ this.className = 'checked'; } this.abc = !this.abc; } } ","date":"2021-03-22","objectID":"/posts/js-1/:13:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"单选框实现 var btns = document.querySelectAll('.option a'); for(var i=0; i\u003cbtns.length; i++){ btns[i].onclick = function(){ for(var j=0; j\u003cbtns.length; j++){ btns[j].className = ''; } this.className = 'checked'; } } ","date":"2021-03-22","objectID":"/posts/js-1/:14:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"this指向 在全局情况下调用this,为window 在函数下为调用这个函数的元素或对象 ","date":"2021-03-22","objectID":"/posts/js-1/:15:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"classList ","date":"2021-03-22","objectID":"/posts/js-1/:16:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"原有class基础上增加 var div = document.querySelector('div'); div.onclick = function(){ div.classList.add('now'); } ","date":"2021-03-22","objectID":"/posts/js-1/:16:1","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"删除 classList.remove('now'); ","date":"2021-03-22","objectID":"/posts/js-1/:16:2","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"判断是否存在某种class this.classList.contains('abc'); //返回true/false ","date":"2021-03-22","objectID":"/posts/js-1/:16:3","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"切换class var div = document.querySelector('div'); div.onclick = function(){ div.classList.toggle('now'); } // 点一下有now的样式,再点一下样式消除 ","date":"2021-03-22","objectID":"/posts/js-1/:16:4","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"js中的正则表达式 正则的三个模式: i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配 字符串replace正则替换 var txt = str.replace(/microsoft/g,\"Runoob\"); ","date":"2021-03-22","objectID":"/posts/js-1/:17:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"判断数组或对象中key是否存在 ary.hasOwnProperty(key); obj.hasOwnProperty(key); ","date":"2021-03-22","objectID":"/posts/js-1/:18:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"在开发环境中添加npm包 cnpm i electron --save-dev ","date":"2021-03-22","objectID":"/posts/js-1/:19:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"生成9*9乘法表 var box = document,getElementById('box'); var colors = ['red', 'blue', 'yellow', 'green',...]; var str = ''; for(var i=1; i\u003c5; i++){ for(var j=1; j\u003c=i; j++){ str+= '\u003cdiv style=\"background:'+ colors[i-1]+'\u003e'+j+'*'+i+'='+j*i+'\u003c/div\u003e'\"; } str += '\u003cbr/\u003e'; } box.innerHTML = str; ","date":"2021-03-22","objectID":"/posts/js-1/:20:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"背景图移动鼠标显示 var wrap = document,querySelector(.wrap) for(var i=0; i\u003c10; i++){ for(var j=0; j\u003c10; j++){ wrap.innerHTML += '\u003cdiv style=\"left:'+60*i+'px; top:'+60*j+'px; background-position:-'50*i'px -'50*j+'px\"\u003c/div\u003e' } } var divs = wrap.querySelectAll('div'); for(var i=0; i\u003cdivs.length; i++){ divs[i].onmouseover = function(){ this.style.backgroundImage = 'url(img.jpg)'; } } ","date":"2021-03-22","objectID":"/posts/js-1/:21:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Javascript"],"content":"选项卡实现 \u003cdiv class='wrap'\u003e \u003cnav id='nav'\u003e \u003ca href=\"javascript:;\" class=\"active\"\u003e我的行程\u003c/a\u003e \u003ca href=\"javascript:;\"\u003e消息中心\u003c/a\u003e \u003ca href=\"javascript:;\"\u003e角色管理\u003c/a\u003e \u003ca href=\"javascript:;\"\u003e定时任务补偿\u003c/a\u003e \u003c/nav\u003e \u003cdiv class=\"boards\"\u003e \u003cdiv class=\"active\"\u003e我的行程\u003c/div\u003e \u003cdiv\u003e消息中心\u003c/div\u003e \u003cdiv\u003e角色管理\u003c/div\u003e \u003cdiv\u003e定时任务补偿\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript\u003e var btns = document.querySelectorAll('#nav a'); var divs = document.querySelectorAll('.board div'); for(var i=0; i\u003cbtns.length; i++){ btns[i].index = i; btns[i].onclick = function(){ for(var j=0; j\u003cbtns.length; j++){ btns[j].className = ''; } this.className = 'active'; for(var k=0; k\u003cbtns.length; k++){ divs[k].className = ''; } div[this.index].className = 'active'; } } \u003c/script\u003e ","date":"2021-03-22","objectID":"/posts/js-1/:22:0","tags":["Javascript基础语法"],"title":"Javascript基础 Part-1","uri":"/posts/js-1/"},{"categories":["Flask"],"content":"Apache部署Flask过程 环境准备工作 ","date":"2021-03-16","objectID":"/posts/flask/:0:0","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"下载apache v14版本 说明：为了对应mod_wsgi模块的要求，我们选择apacheVC14版本 下载地址 选择版本：httpd-2.4.33-win64-VC14.zip ","date":"2021-03-16","objectID":"/posts/flask/:1:0","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"安装vc_redist_x64 在通过httpd -k install -n Apache 命令，把Apache添加到了Windows的本地服务中 当启动这个服务时，提示：1053 错误 - “错误 1053: 服务没有及时响应启动或控制请求”。 表示没有安装:vc_redist_x64 在apache下载页面可以下载安装 ","date":"2021-03-16","objectID":"/posts/flask/:2:0","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"下载python3.6 安装flask等项目依赖库 pip install flask ","date":"2021-03-16","objectID":"/posts/flask/:3:0","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"mod_wsgi模块 ","date":"2021-03-16","objectID":"/posts/flask/:4:0","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"下载 说明：参考链接的大神使用的.so模块是需要通过翻墙得到，所以我们需要使用whl文件，mod_wsgi的版本选择是非常有讲究的，它需要对应apache对应的vc编译版本（ap24vc14）与python的对应版本（cp36‑cp36m）以及window的架构（amd64） 下载地址 选择的版本：mod_wsgi‑4.6.4+ap24vc14‑cp36‑cp36m‑win_amd64.whl ","date":"2021-03-16","objectID":"/posts/flask/:4:1","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"安装 pip install \u003cmod_wsgi文件绝对路径\u003e ","date":"2021-03-16","objectID":"/posts/flask/:4:2","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"验证安装 mod_wsgi-express module-config 显示文件路径,表示成功 C:\\Users\\Administrator\u003emod_wsgi-express module-config LoadFile #文件路径 LoadModule wsgi_module #文件路径 WSGIPythonHome #文件路径 将整体添加到配置文件http.conf模块加载部分 修改文件配置 ","date":"2021-03-16","objectID":"/posts/flask/:4:3","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"http.conf ServerRoot \"c:/Apache24\" #修改成自己的目录地址 Listen 8080 #端口号配置 ServerName localhost:8090 #配置servername # 服务器请求配置 \u003cDirectory \"c:/Apache24/cgi-bin\"\u003e AllowOverride None Options None Require all granted \u003c/Directory\u003e # 项目文件配置 \u003cVirtualHost *:8090 \u003e #ServerAdmin example@xx.com DocumentRoot D:\\Book_Spider \u003cDirectory \"D:\\Book_Spider\"\u003e Require all granted Require host ip \u003c/Directory\u003e WSGIScriptAlias / D:\\Book_Spider\\wsgi.wsgi \u003c/VirtualHost\u003e 启动Apache服务 启动管理员模式的cmd进入到Apache24的bin文件路径下： ","date":"2021-03-16","objectID":"/posts/flask/:5:0","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"安装apache作为系统服务： httpd -k install ","date":"2021-03-16","objectID":"/posts/flask/:6:0","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"启动apache： httpd -k start ","date":"2021-03-16","objectID":"/posts/flask/:7:0","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"停止apache服务： httpd -k stop ","date":"2021-03-16","objectID":"/posts/flask/:8:0","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Flask"],"content":"重启apache服务： httpd -k restart ","date":"2021-03-16","objectID":"/posts/flask/:9:0","tags":["Flask服务器部署"],"title":"Apache部署Flask","uri":"/posts/flask/"},{"categories":["Python"],"content":"二级Python ","date":"2021-03-01","objectID":"/posts/python-1/:0:0","tags":null,"title":"Python(NCRE)","uri":"/posts/python-1/"},{"categories":["Python"],"content":"输出格式 ","date":"2021-03-01","objectID":"/posts/python-1/:1:0","tags":null,"title":"Python(NCRE)","uri":"/posts/python-1/"},{"categories":["Python"],"content":"格式要求:宽度为20,超过20则显示本来的字符串 n = eval(input(\"请输入正整数:\")) print(\"{:-\u003e20,}\".format(n)) ","date":"2021-03-01","objectID":"/posts/python-1/:1:1","tags":null,"title":"Python(NCRE)","uri":"/posts/python-1/"},{"categories":["Python"],"content":"“:“表示填充,其后面的字符为所要填充的字符 impor random random.seed(123) #随机数种子 for i in range(4): print(random.randint(1,1000),end=\",\") #random.randint()生成随机数 ","date":"2021-03-01","objectID":"/posts/python-1/:1:2","tags":null,"title":"Python(NCRE)","uri":"/posts/python-1/"},{"categories":["Python"],"content":"turtle库的使用 import turtle turtle.right(-30) #right顺时针旋转角度 turtle.fd(200) #绘画线 turtle.right(60) turtle.fd(200) turtle.right(120) turtle.fd(200) turtle.right(60) turtle.fd(200) turtle.right(120) left()、right() 使用时，角度以当前所在位置方向为参照，是相对角度 seth()使用时，角度以坐标系原点为参照，是绝对角度 ","date":"2021-03-01","objectID":"/posts/python-1/:2:0","tags":null,"title":"Python(NCRE)","uri":"/posts/python-1/"},{"categories":["Python"],"content":"字符串处理题 txt=open(\"命运.txt\",\"r\").read() #读取文件 for ch in\"，。？：\": #去除特殊符号 txt=txt.replace(ch,\"\") d = {} for ch in txt: d[ch]=d.get(ch,0)+1 #字符串计数 ls=list(d.items()) #转换为元组 ls.sort(key=lambda x:x[1], reverse=True) # a,b=ls[0] print(\"{}:{}\".format(a,b)) ","date":"2021-03-01","objectID":"/posts/python-1/:3:0","tags":null,"title":"Python(NCRE)","uri":"/posts/python-1/"},{"categories":["Python"],"content":"Python字典转换为元组 dict.items() # Python 字典(Dictionary) items() 函数以列表返回可遍历的(键, 值) 元组数组。 ","date":"2021-03-01","objectID":"/posts/python-1/:4:0","tags":null,"title":"Python(NCRE)","uri":"/posts/python-1/"},{"categories":["Python"],"content":"Python元组排序 如果是对于key排序,直接可以 sorted(d.keys(), reverse=True) # reverse表示逆序排序 对于键值value排序,需要用到d.items()实际上是将d转换为可迭代对象 例如: 迭代对象的元素为(‘lilee’,25),(‘wangyan’,21),(‘liqun’,32),(‘lidaming’,19); items()方法将字典的元素转化为了元组，而这里key参数对应的lambda表达式的意思则是选取元组中的第二个元素作为比较参数（如果写作key=lambda item:item[0]的话则是选取第一个元素作为比较对象，也就是key值作为比较对象。lambda x:y中x表示输出参数，y表示lambda函数的返回值） 所以采用这种方法可以对字典的value进行排序。注意排序后的返回值是一个list，而原字典中的名值对被转换为了list中的元组。 sorted(d.items(), key=lambda item:item[0], reverse=True) ","date":"2021-03-01","objectID":"/posts/python-1/:5:0","tags":null,"title":"Python(NCRE)","uri":"/posts/python-1/"},{"categories":["神经网络与深度学习"],"content":"循环神经网络(Andrew Ng) 为什么选择序列模型 数学符号 循环神经网络 Recurrent Neural Network Model 通过时间的反向传播 Backpropagation through time 不同类型的循环神经网络 Different types of RNNs 语言模型和序列生成 Language model and sequence generation 对新序列采样 Sampling noval sequences 循环神经网络的梯度消失 Vanishing grdients with RNNs GRU单元 Gated Recurrent Unit(GRU) 长短期记忆 LSTM(long short-term memory) unit ","date":"2021-02-25","objectID":"/posts/nndl-22/:0:0","tags":["Andrew NNDL"],"title":"NNDL-序列模型","uri":"/posts/nndl-22/"},{"categories":["Shell"],"content":"正则表达式 我吐辣…正则和shell真是折磨王了 从昨晚折磨我到今天上午 还好写出来了,要是再搞不出来真要自闭了 $ for x in *;do var=$(echo $x|egrep -o '[^img_.png]');var=$((1+$var)).png; mv $x $var; done 正则表达式 表示筛选除去这些字符以外的字符,即想要提取的数字 [^img_.png] egrep命令 $x|egrep -o '[^img_.png\\]' 返回的是匹配数量,并且打印出来匹配的字符 如果想要赋值给变量var,需要使用 $(echo) 在shell中进行数值运算需要用到 $((表达式)) 并且在shell中进行赋值时,’=‘两侧不可以加空格 ","date":"2021-02-23","objectID":"/posts/shell-2/:0:0","tags":["Shell语法基础"],"title":"Shell-字符串正则提取","uri":"/posts/shell-2/"},{"categories":["Matplotlib"],"content":"Python数据可视化 Subplot多图合一 ```python import matplotlib.pyplot as plt plt.figure() plt.subplot(2, 1, 1) plt.plot([0, 1], [0, 1]) plt.subplot(2, 2, 3) plt.plot([0, 1], [0, 2]) plt.subplot(2, 2, 4) plt.plot([0, 1], [0, 3]) plt.show() # 展示 使用plt.subplot来创建小图 plt.subplot(2,2,1)表示将整个图像窗口分为2行1列, 当前位置为1. 使用plt.plot([0,1],[0,1])在第1个位置创建一个小图. plt.subplot(2,2,3)表示将整个图像窗口分为2行2列, 当前位置为3. 因为在第一行中占了两个位置 使用plt.plot([0,1],[0,2])在第3个位置创建一个小图. plt.subplot(2,2,4)表示将整个图像窗口分为2行2列,当前位置为4. plt.subplot(2,2,4)可以简写成plt.subplot(224), matplotlib同样可以识别. 使用plt.plot([0,1],[0,3])在第3个位置创建一个小图 ## subplot2grid \u003cimg loading=\"lazy\" src=\"https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/Matplotlib/2/1_.png\"\u003e 将画布分为表格形式,分格排列 ```python import matplotlib.pyplot as plt plt.figure() ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3) ax1.plot([1, 2], [1, 2]) # 画小图 ax1.set_title('ax1_title') # 设置小图的标题 ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3) ax1.plot([1, 2], [1, 2]) # 画小图 ax1.set_title('ax1_title') # 设置小图的标题 ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2) ax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2) ax4 = plt.subplot2grid((3, 3), (2, 0)) ax5 = plt.subplot2grid((3, 3), (2, 1)) ax4.scatter([1, 2], [2, 2]) ax4.set_xlabel('ax4_x') ax4.set_ylabel('ax4_y') ","date":"2021-02-22","objectID":"/posts/matplotlib-2/:0:0","tags":["Matplotlib"],"title":"Matplotlib 进阶","uri":"/posts/matplotlib-2/"},{"categories":["Matplotlib"],"content":"第一个小图 使用plt.subplot2grid来创建第1个小图 ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3) ax1.plot([1, 2], [1, 2]) # 画小图 ax1.set_title('ax1_title') # 设置小图的标题 参数 作用 (3,3) 表示将整个图像窗口分成3行3列 (0,0) 表示从第0行第0列开始作图 colspan=3 表示列的跨度为3 rowspan=1 表示行的跨度为1 colspan和rowspan缺省 默认跨度为1 ","date":"2021-02-22","objectID":"/posts/matplotlib-2/:0:1","tags":["Matplotlib"],"title":"Matplotlib 进阶","uri":"/posts/matplotlib-2/"},{"categories":["Matplotlib"],"content":"第二个小图 使用plt.subplot2grid来创建第2个小图 ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2) 参数 作用 (3,3) 表示将整个图像窗口分成3行3列 (1,0) 表示从第1行第0列开始作图 colspan=2 表示列的跨度为2 (1,2) 表示从第1行第2列开始作图 rowspan=2 表示行的跨度为2 ","date":"2021-02-22","objectID":"/posts/matplotlib-2/:0:2","tags":["Matplotlib"],"title":"Matplotlib 进阶","uri":"/posts/matplotlib-2/"},{"categories":["Matplotlib"],"content":"第三个小图 ax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2) ","date":"2021-02-22","objectID":"/posts/matplotlib-2/:0:3","tags":["Matplotlib"],"title":"Matplotlib 进阶","uri":"/posts/matplotlib-2/"},{"categories":["Matplotlib"],"content":"第四和第五小图 ax4 = plt.subplot2grid((3, 3), (2, 0)) ax4.scatter([1, 2], [2, 2]) ax4.set_xlabel('ax4_x') ax4.set_ylabel('ax4_y') ax5 = plt.subplot2grid((3, 3), (2, 1)) ","date":"2021-02-22","objectID":"/posts/matplotlib-2/:0:4","tags":["Matplotlib"],"title":"Matplotlib 进阶","uri":"/posts/matplotlib-2/"},{"categories":["Matplotlib"],"content":"gridspec ```python import matplotlib.pyplot as plt import matplotlib.gridspec as gridspec plt.figure() gs = gridspec.GridSpec(3, 3) ax6 = plt.subplot(gs[0, :]) ax7 = plt.subplot(gs[1, :2]) ax8 = plt.subplot(gs[1:, 2]) ax9 = plt.subplot(gs[-1, 0]) ax10 = plt.subplot(gs[-1, -2]) 使用plt.figure()创建一个图像窗口 **使用gridspec.GridSpec将整个图像窗口分成3行3列** **使用plt.subplot来作图** - gs[0, :]表示这个图占第0行和所有列 - gs[1, :2]表示这个图占第1行和第2列前的所有列 - gs[1:, 2]表示这个图占第1行后的所有行和第2列 - gs[-1, 0]表示这个图占倒数第1行和第0列 - gs[-1, -2]表示这个图占倒数第1行和倒数第2列 # 绘制途中图 \u003cimg loading=\"lazy\" src=\"https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/Matplotlib/2/3_.png\"\u003e ```python import matplotlib.pyplot as plt fig = plt.figure() x = [1, 2, 3, 4, 5, 6, 7] y = [1, 3, 4, 2, 5, 8, 6] # 确定大图左下角的位置以及宽高 left, bottom, width, height = 0.1, 0.1, 0.8, 0.8 # 添加大图的坐标系 ax1 = fig.add_axes([left, bottom, width, height]) ax1.plot(x, y, 'r') ax1.set_xlabel('x') ax1.set_ylabel('y') ax1.set_title('title') # 绘制第一个小图 left, bottom, width, height = 0.2, 0.6, 0.25, 0.25 ax2 = fig.add_axes([left, bottom, width, height]) ax2.plot(y, x, 'b') ax2.set_xlabel('x') ax2.set_ylabel('y') ax2.set_title('title inside 1') # 绘制第二个小图 plt.axes([0.6, 0.2, 0.25, 0.25]) plt.plot(y[::-1], x, 'g') # 注意对y进行了逆序处理 plt.xlabel('x') plt.ylabel('y') plt.title('title inside 2') ","date":"2021-02-22","objectID":"/posts/matplotlib-2/:1:0","tags":["Matplotlib"],"title":"Matplotlib 进阶","uri":"/posts/matplotlib-2/"},{"categories":["Matplotlib"],"content":"left,bottom,width,height left, bottom, width, height = 0.1, 0.1, 0.8, 0.8 这四个值都是占整个figure坐标系的百分比 假设figure的大小是10x10，那么大图就被包含在由(1, 1)开始，宽8，高8的坐标系内 建立次要坐标轴 ```python fig = plt.figure() x = np.arange(0, 10, 0.1) y1 = 0.05 * x**2 y2 = -1 * y1 fig, ax1 = plt.subplots() ax2 = ax1.twinx() # 生成镜面效果后的坐标轴 ax1.plot(x, y1, 'g-') # green, solid line ax1.set_xlabel('X data') ax1.set_ylabel('Y1 data', color='g') ax2.plot(x, y2, 'b-') # blue ax2.set_ylabel('Y2 data', color='b') subplots返回的值的类型为元组，其中包含两个元素：第一个为一个画布，第二个是子图 # code ```python import matplotlib.pyplot as plt import matplotlib.gridspec as gridspec import numpy as np plt.figure() plt.subplot(2, 1, 1) plt.plot([0, 1], [0, 1]) plt.subplot(2, 2, 3) plt.plot([0, 1], [0, 2]) plt.subplot(2, 2, 4) plt.plot([0, 1], [0, 3]) plt.figure() ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3) ax1.plot([1, 2], [1, 2]) # 画小图 ax1.set_title('ax1_title') # 设置小图的标题 ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3) ax1.plot([1, 2], [1, 2]) # 画小图 ax1.set_title('ax1_title') # 设置小图的标题 ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2) ax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2) ax4 = plt.subplot2grid((3, 3), (2, 0)) ax5 = plt.subplot2grid((3, 3), (2, 1)) ax4.scatter([1, 2], [2, 2]) ax4.set_xlabel('ax4_x') ax4.set_ylabel('ax4_y') plt.figure() gs = gridspec.GridSpec(3, 3) ax6 = plt.subplot(gs[0, :]) ax7 = plt.subplot(gs[1, :2]) ax8 = plt.subplot(gs[1:, 2]) ax9 = plt.subplot(gs[-1, 0]) ax10 = plt.subplot(gs[-1, -2]) fig = plt.figure() x = [1, 2, 3, 4, 5, 6, 7] y = [1, 3, 4, 2, 5, 8, 6] # 确定大图左下角的位置以及宽高 left, bottom, width, height = 0.1, 0.1, 0.8, 0.8 # 添加大图的坐标系 ax1 = fig.add_axes([left, bottom, width, height]) ax1.plot(x, y, 'r') ax1.set_xlabel('x') ax1.set_ylabel('y') ax1.set_title('title') # 绘制第一个小图 left, bottom, width, height = 0.2, 0.6, 0.25, 0.25 ax2 = fig.add_axes([left, bottom, width, height]) ax2.plot(y, x, 'b') ax2.set_xlabel('x') ax2.set_ylabel('y') ax2.set_title('title inside 1') # 绘制第二个小图 plt.axes([0.6, 0.2, 0.25, 0.25]) plt.plot(y[::-1], x, 'g') # 注意对y进行了逆序处理 plt.xlabel('x') plt.ylabel('y') plt.title('title inside 2') x = np.arange(0, 10, 0.1) y1 = 0.05 * x**2 y2 = -1 * y1 fig, ax1 = plt.subplots() ax2 = ax1.twinx() # 生成镜面效果后的坐标轴 ax1.plot(x, y1, 'g-') # green, solid line ax1.set_xlabel('X data') ax1.set_ylabel('Y1 data', color='g') ax2.plot(x, y2, 'b-') # blue ax2.set_ylabel('Y2 data', color='b') plt.show() # 展示 ","date":"2021-02-22","objectID":"/posts/matplotlib-2/:2:0","tags":["Matplotlib"],"title":"Matplotlib 进阶","uri":"/posts/matplotlib-2/"},{"categories":["Matplotlib"],"content":"Python数据可视化 这两天杂事有点多…学的东西也比较杂,所以最后笔记几天都没更新 这两天慢慢把笔记补全,今天来补一下matplotlib笔记 一开始是在看tensorflow,后来看上了pytorch,再后来发现数据可视化表示很重要 因此想了想还是先学一下最基本的matplotlib吧 其实没有想象中的那么难,他本身已经封装的很傻瓜了,因此只要有数据,几步就能把数据图画出来 笔记的内容不是很系统,都是东拼西凑学来的 基本概念 ```python import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D x = np.linspace(-1, 3, 50) y1 = 2*x + 1 y2 = x**2 plt.figure() plt.plot(x, y1, label=“line-1”) plt.plot(x, y2, color=‘red’, linewidth=1.0, linestyle=’:’, label=“line-2”) plt.xlim((-1, 3)) # 设定X轴的坐标范围 plt.ylim((-2, 7)) # 设定Y轴的坐标范围 创建坐标轴刻度数据 x_ticks = np.linspace(-1, 3, 5) y_ticks = np.linspace(-2, 7, 10) plt.xticks(x_ticks) plt.yticks(y_ticks) ’’' 设定Y坐标轴为特定符号 plt.yticks([-1, 0, 1, 2], [r’$\\alpha$’, r’$\\beta$’, r’$c$’, r’$d$’]) ’'' 获取当前的坐标系 ax = plt.gca() 设置刻度线显示位置 ax.xaxis.set_ticks_position(’top') 设定坐标轴的文字 plt.xlabel(‘I am x’) # X轴的名称 plt.ylabel(‘I am y’) # Y轴的名称 设定坐标轴为指定颜色 ax.spines[‘right’].set_color(‘red’) ax.spines[’top’].set_color(‘red’) 设定坐标轴位置 ax.spines[‘bottom’].set_position((‘data’, -2)) 垂直坐标轴指示点-虚线 x0 = 1 y0 = 2*x0 + 1 plt.plot([x0, x0, ], [-2, y0, ], ‘k–’, linewidth=2.5) 垂直坐标轴指示点-绘制点 plt.scatter([x0, ], [y0, ], s=50, color=‘b’) 曲线注释 plt.annotate(r’$2x+1=%s$’ % y0, xy=(x0, y0), xycoords=‘data’, xytext=(+30, -30), textcoords=‘offset points’, fontsize=16, arrowprops=dict(arrowstyle=’-\u003e’, connectionstyle=“arc3,rad=.2”)) 标注文字 plt.text(-1, 5, r’$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$’, fontdict={‘size’: 16, ‘color’: ‘r’}) 显示指示框 plt.legend(loc=“best”) plt.show() ## numpy.linspace numpy.linspace(1,20,20)\"表示-\u003e 在[1,20]范围内选取20个点 ```python test_trick = np.linspace(1, 20, 20) print(test_trick) # [ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18.19. 20.] ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:0:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"plt.figure 表示创建一个画布,图表中的元素都是向画布中添加 参数 用处 num 表示图形的编号或名称，数字代表编号，字符串表示名称 figsize 用于设置画布的尺寸，宽度、高度以英寸为单位 dpi 用于设置图形的分辨率 facecolor 用于设置画板的背景颜色 edgecolor 用于显示边框的颜色 frameon 表示是否显示边框 FigureClass 派生自matplotlib.figure.Figure的类，可以选择用自定义的图形对象 clear 若设为True且改图形已经存在，则它会被清除 参考文献 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:1:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"plt.plot 绘制曲线 参数 用处 alpha 曲线透明度 color 曲线颜色 label 曲线的命名 linestyle 曲线的样式 linewidth 曲线粗细 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:2:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"linestyle: 符号 样式 : 点线 -. 点画线 – 短划线 - 实线 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:2:1","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"color 符号 颜色 c cyan青色 r red红色 g green绿色 b blue蓝色 w white白色 k black黑色 y yellow黄色 m magenta洋红色 参考文献 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:2:2","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"设置刻度 刻度的尺度 x_tricks = np.linspace(-1, 3, 5) plt.xtricks(x_tricks) 将x轴设定为数组\"linspace(-1,3,5)\" 设定刻度为指定显示 plt.yticks([60,70,80,90], [r'$及格$', r'$良好$', r'$不错$', r'$优秀$']) 其中在’$$‘中,支持,mathjax符号 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:3:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"边框(坐标轴)颜色 ax = plt.gca() # 获取当前的坐标轴 ax.spines['right'].set_color('red') # 设置右侧坐标轴为红色 ax.spines['top'].set_color('red') # 设置顶部坐标轴为红色 # ax.spines['top'].set_color('none') ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:4:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"设置刻度显示的位置 ax.xaxis.set_ticks_position('bottom') 参数: bottom, top, both, default, none ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:5:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"设置坐标轴的位置 ax.spines['bottom'].set_position(('data', 0)) # 设置底部的坐标轴(X轴)位置为刻度0点处 ax.spines['left'].set_position(('data', 0)) # 设置左侧的坐标轴(Y轴)位置为刻度0点处 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:6:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"Legend图例解释 plt.legend(loc='upper right') loc参数: best upper right right upper left lower left center left lower right right center right lower center upper center center ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:7:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"标注点的直线 画出一条垂直于x轴的虚线 # 绘制虚线 x0 = 1 y0 = 2*x0 + 1 plt.plot([x0, x0,], [0, y0,], 'k--', linewidth=2.5) # 绘制点 plt.scatter([x0, ], [y0, ], s=50, color='b') ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:8:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"添加曲线的注释 plt.annotate(r'$2x+1=%s$' % y0, xy=(x0, y0), xycoords='data', xytext=(+30, -30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle='-\u003e', connectionstyle=\"arc3,rad=.2\")) 参数 作用 xycoords=‘data’ 基于数据的值来选位置 xytext=(+30, -30) 标注位置 textcoords=‘offset points’ xy偏差值 arrowprops 图中箭头类型的一些设置 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:9:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"标注文字 plt.text(-1, 5, r'$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$', fontdict={'size': 16, 'color': 'r'}) 其中\"-1,5\"表示text显示的位置 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:10:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"刻度透明度 如果坐标轴的刻度被曲线遮盖,可以通过调整透明度来显示 for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) # 在 plt 2.0.2 或更高的版本中, 设置 zorder 给 plot 在 z 轴方向排序 label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.7, zorder=2)) 参数 作用 label.set_fontsize(12) 重新调节字体大小 set_bbox 设置目的内容的透明度相关参数 facecolor 调节box前景色 edgecolor 设置边框( 本处设置边框为无) alpha 设置透明度 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:11:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"numpy.arange 函数返回一个有终点和起点的固定步长的排列 如[1,2,3,4,5]，起点是1，终点是6，步长为1。 参数个数情况： np.arange()函数分为一个参数，两个参数，三个参数三种情况 一个参数时:参数值为终点，起点取默认值0，步长取默认值1。 两个参数时:第一个参数为起点，第二个参数为终点，步长取默认值1。 三个参数时:第一个参数为起点，第二个参数为终点，第三个参数为步长。其中步长支持小数 图表类型 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:12:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"散点图 ```python import matplotlib.pyplot as plt import numpy as np n = 1024 # data size X = np.random.normal(0, 1, n) # 每一个点的X值 Y = np.random.normal(0, 1, n) # 每一个点的Y值 T = np.arctan2(Y, X) # for color value plt.scatter(X, Y, s=75, c=T, alpha=.5) plt.xlim(-1.5, 1.5) x_ticks = np.linspace(-1.5, 1.5, 10) plt.xticks(x_ticks) y_ticks = np.linspace(-1.5, 1.5, 10) plt.ylim(-1.5, 1.5) plt.yticks(y_ticks) plt.show() | 参数 | 作用 | | :-----------: | :------------------------------------: | | random.normal | 生成服从标准正态分布的数据(EX=0, DX=1) | | s=75 | size尺寸 | | c=T | color map颜色状态 | | alpha | 透明度 | ## 柱状图 \u003cimg loading=\"lazy\" src=\"https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/Matplotlib/1/2_.png\"\u003e ```python n = 12 X = np.arange(n) # X为数组 # 均匀分布 Y1 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) Y2 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white') plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white') # facecolor为柱条颜色 plt.xlim(-.5, n) plt.xticks(()) plt.ylim(-1.25, 1.25) plt.yticks(()) # 添加数值标识 for x, y in zip(X, Y1): # ha: horizontal alignment # va: vertical alignment plt.text(x + 0.4, y + 0.05, '%.2f' % y, ha='center', va='bottom') for x, y in zip(X, Y2): # ha: horizontal alignment # va: vertical alignment plt.text(x + 0.4, -y - 0.05, '%.2f' % y, ha='center', va='top') plt.show() plt.text 分别在柱体上方和下方添加数值 %.2f 保留两位小数 ha=‘center’ 横向居中对齐 va=‘bottom’ 纵向底部（顶部）对齐 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:13:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"Contours 等高线图 数据集即三维点 (x,y) 和对应的高度值，共有256个点。高度值使用一个 height function f(x,y) 生成。 x, y 分别是在区间 [-3,3] 中均匀分布的256个值，并用meshgrid在二维平面中将每一个x和每一个y分别对应起来，编织成栅格: ```python def f(x, y): # the height function return (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 - y**2) n = 256 x3 = np.linspace(-3, 3, n) y3 = np.linspace(-3, 3, n) X3, Y3 = np.meshgrid(x3, y3) # use plt.contourf to filling contours # X, Y and value for (X,Y) point plt.contourf(X3, Y3, f(X3, Y3), 8, alpha=.75, cmap=plt.cm.hot) # use plt.contour to add contour lines C = plt.contour(X3, Y3, f(X3, Y3), 8, colors='black') plt.clabel(C, inline=True, fontsize=10) plt.xticks(()) plt.yticks(()) ``` 颜色填充函数 plt.contourf 位置参数分别为：X, Y, f(X,Y) 透明度0.75 将 f(X,Y) 的值对应到color map的暖色组中寻找对应颜色 等高线画线函数 plt.contour 位置参数为：X, Y, f(X,Y) 颜色为黑色 线条宽度为0.5 添加高度数字函数 plt.clabel inline控制是否将Label画在线里面 字体大小为10 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:14:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"colorbar 显示数值参考颜色条 # shrink:透明度 plt.colorbar(shrink=.92) 参考文献-1 参考文献-2 ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:15:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["Matplotlib"],"content":"3D函数图像 ```python fig = plt.figure() ax = Axes3D(fig) # X, Y value X = np.arange(-4, 4, 0.25) Y = np.arange(-4, 4, 0.25) X, Y = np.meshgrid(X, Y) # x-y 平面的网格 R = np.sqrt(X ** 2 + Y ** 2) # height value Z = np.sin(R) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap('rainbow')) ax.contourf(X, Y, Z, zdir='y', offset=-4, cmap=plt.get_cmap('rainbow')) ``` 参数 作用 plot_surface 绘制表面 rstride 表面纵向稀疏度 cstride 表面横向稀疏度 cmap 颜色样式 contourf 投影 zdir 投影面选择 offset 投影坐标 numpy.meshgrid 函数解释 code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D x = np.linspace(-1, 3, 50) y1 = 2*x + 1 y2 = x**2 plt.figure() plt.plot(x, y1, label=\"line-1\") plt.plot(x, y2, color='red', linewidth=1.0, linestyle=':', label=\"line-2\") # plt.xlim((-1, 3)) # 设定X轴的坐标范围 # plt.ylim((-2, 7)) # 设定Y轴的坐标范围 # 创建坐标轴刻度数据 x_ticks = np.linspace(-1, 3, 5) y_ticks = np.linspace(-2, 7, 10) plt.xticks(x_ticks) plt.yticks(y_ticks) ''' # 设定Y坐标轴为特定符号 plt.yticks([-1, 0, 1, 2], [r'$\\alpha$', r'$\\beta$', r'$c$', r'$d$']) ''' # 获取当前的坐标系 ax = plt.gca() # 设置刻度线显示位置 ax.xaxis.set_ticks_position('top') # 设定坐标轴的文字 plt.xlabel('I am x') # X轴的名称 plt.ylabel('I am y') # Y轴的名称 # 设定坐标轴为指定颜色 ax.spines['right'].set_color('red') ax.spines['top'].set_color('red') # 设定坐标轴位置 ax.spines['bottom'].set_position(('data', -2)) # 垂直坐标轴指示点-虚线 x0 = 1 y0 = 2*x0 + 1 plt.plot([x0, x0, ], [-2, y0, ], 'k--', linewidth=2.5) # 垂直坐标轴指示点-绘制点 plt.scatter([x0, ], [y0, ], s=50, color='b') # 曲线注释 plt.annotate(r'$2x+1=%s$' % y0, xy=(x0, y0), xycoords='data', xytext=(+30, -30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle='-\u003e', connectionstyle=\"arc3,rad=.2\")) # 标注文字 plt.text(-1, 5, r'$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$', fontdict={'size': 16, 'color': 'r'}) # 显示指示框 plt.legend(loc=\"best\") # 创建散点图 plt.figure() n = 1024 # data size X = np.random.normal(0, 1, n) # 每一个点的X值 Y = np.random.normal(0, 1, n) # 每一个点的Y值 T = np.arctan2(Y, X) # for color value plt.scatter(X, Y, s=75, c=T, alpha=.5) plt.xlim(-1.5, 1.5) x_ticks = np.linspace(-1.5, 1.5, 10) plt.xticks(x_ticks) y_ticks = np.linspace(-1.5, 1.5, 10) plt.ylim(-1.5, 1.5) plt.yticks(y_ticks) # 创建柱状图 plt.figure() n = 12 X = np.arange(n) # X为数组 # 均匀分布 Y1 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) Y2 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white') plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white') # facecolor为柱条颜色 plt.xlim(-.5, n) plt.xticks(()) plt.ylim(-1.25, 1.25) plt.yticks(()) # 添加数值标识 for x, y in zip(X, Y1): # ha: horizontal alignment # va: vertical alignment plt.text(x + 0.4, y + 0.05, '%.2f' % y, ha='center', va='bottom') for x, y in zip(X, Y2): # ha: horizontal alignment # va: vertical alignment plt.text(x + 0.4, -y - 0.05, '%.2f' % y, ha='center', va='top') # 绘制等高线 plt.figure() def f(x, y): # the height function return (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 - y**2) n = 256 x3 = np.linspace(-3, 3, n) y3 = np.linspace(-3, 3, n) X3, Y3 = np.meshgrid(x3, y3) # use plt.contourf to filling contours # X, Y and value for (X,Y) point plt.contourf(X3, Y3, f(X3, Y3), 8, alpha=.75, cmap=plt.cm.hot) plt.colorbar(shrink=.92) # use plt.contour to add contour lines C = plt.contour(X3, Y3, f(X3, Y3), 8, colors='black') plt.clabel(C, inline=True, fontsize=10) plt.xticks(()) plt.yticks(()) # 绘制3D图像 fig = plt.figure() ax = Axes3D(fig) # X, Y value X = np.arange(-4, 4, 0.25) Y = np.arange(-4, 4, 0.25) X, Y = np.meshgrid(X, Y) # x-y 平面的网格 R = np.sqrt(X ** 2 + Y ** 2) # height value Z = np.sin(R) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap('rainbow')) ax.contourf(X, Y, Z, zdir='y', offset=-4, cmap=plt.get_cmap('rainbow')) plt.show() ","date":"2021-02-21","objectID":"/posts/matplotlib-1/:16:0","tags":["Matplotlib"],"title":"Matplotlib 绘制基本图表","uri":"/posts/matplotlib-1/"},{"categories":["神经网络与深度学习"],"content":"循环神经网络 看了吴老师的视频感觉讲的很快,而且似乎什么都没有听懂… 所以就去网上找各种大佬总结的博客学了好几天…感觉就像拼拼图,把RNN的知识点慢慢拼出来了 最后发现李宏毅老师的深度学习讲的很棒!!!种草了嘻嘻 概念 RNN对具有序列特性的数据非常有效，它能挖掘数据中的时序信息以及语义信息，利用了RNN的这种能力，使深度学习模型在解决语音识别、语言模型、机器翻译以及时序分析等NLP领域的问题时有所突破。 序列特性:符合时间顺序，逻辑顺序，或者其他顺序就叫序列特性 为什么要发明循环神经网路 我们先来看一个NLP很常见的问题，命名实体识别，举个例子，现在有两句话： 第一句话：I like eating apple！（我喜欢吃苹果！） 第二句话：The Apple is a great company！（苹果真是一家很棒的公司！） 现在的任务是要给apple打Label，我们都知道第一个apple是一种水果，第二个apple是苹果公司，假设我们现在有大量的已经标记好的数据以供训练模型，当我们使用全连接的神经网络时，我们做法是把apple这个单词的特征向量输入到我们的模型中（如下图），在输出结果时，让我们的label里，正确的label概率最大，来训练模型，但我们的语料库中，有的apple的label是水果，有的label是公司，这将导致，模型在训练的过程中，预测的准确程度，取决于训练集中哪个label多一些，这样的模型对于我们来说完全没有作用。 问题就出在了我们没有结合上下文去训练模型，而是单独的在训练apple这个单词的label，这也是全连接神经网络模型所不能做到的，于是就有了我们的循环神经网络。 循环神经网络的结构及原理 上图就是RNN的结构，我第一次看到这图的第一反应是，不是说好的循环神经网络么，起码得是神经网络啊，神经网络不是有很多球球么，也就是神经元，这RNN咋就这几个球球，不科学啊，看不懂啊！！！！随着慢慢的了解RNN，才发现这图看着是真的清楚，因为RNN的特殊性,如果展开画成那种很多神经元的神经网络，会很麻烦 我们先来讲解一下上面这幅图，首先不要管右边的W，只看X,U,S,V,O，这幅图就变成了之前的全连接神经网络 其中X是一个向量，也就是某个字或词的特征向量，作为输入层，如上图也就是3维向量 U是输入层到隐藏层的参数矩阵，在上图中其维度就是3X4，S是隐藏层的向量，如上图维度就是4 V是隐藏层到输出层的参数矩阵，在上图中就是4X2，O是输出层的向量，在上图中维度为2。 弄懂了RNN结构的左边，那么右边这个W到底是什么啊？把上面那幅图打开之后，是这样的： 举个例子，有一句话是，I love you，那么在利用RNN做一些事情时，比如命名实体识别，上图中的$X_t-1$代表的就是I这个单词的向量，X代表的是love这个单词的向量，$X_t+1$代表的是you这个单词的向量，以此类推，我们注意到，上图展开后，W一直没有变，W其实是每个时间点之间的权重矩阵，我们注意到，RNN之所以可以解决序列问题，是因为它可以记住每一时刻的信息，每一时刻的隐藏层不仅由该时刻的输入层决定，还由上一时刻的隐藏层决定，公式如下，其中$O_t$代表t时刻的输出, $S_t$代表t时刻的隐藏层的值： $O_t = g(V\\cdot S_t)$ $S_t = f(U\\cdot S_t + W\\cdot S_t-1)$ 值得注意的一点是，在整个训练过程中，每一时刻所用的都是同样的W RNN实例 首先对于语义识别中,传统的神经网络缺少记忆 因此加上了两个存储单元$a_1$和$a_2$ 假设每个单词的特征向量是二维的，也就是输入层的维度是二维，且隐藏层也假设是二维，输出也假设是二维，所有权重的值都为1且没有偏差且所有激活函数都是线性函数，现在输入一个序列，到该模型中，我们来一步步求解出输出序列 我们可以想象上一时刻的隐藏层的值是被存起来，等下一时刻的隐藏层进来时，上一时刻的隐藏层的值通过与权重相乘，两者相加便得到了下一时刻真正的隐藏层，如图$a_1$, $a_2$可以看做每一时刻存下来的值，当然初始时$a_1$,$a_2$是没有存值的，因此初始值为0 通过公式$S_t = f(U\\cdot S_t + W\\cdot S_t-1)$ 可以计算出来 $1\\cdot 1+1\\cdot 1+1\\cdot 0+1\\cdot 0 = 2$ 因此绿色的神经元的值为2 再通过公式$O_t = g(V\\cdot S_t)$ 可以计算出来$2\\cdot 1+2\\cdot1 = 4$ 因此输出值为4 随后绿色神经元将值传给记忆单元,通过相同步骤计算得到 至此，一个完整的RNN结构我们已经经历了一遍，我们注意到，每一时刻的输出结果都与上一时刻的输入有着非常大的关系，如果我们将输入序列换个顺序，那么我们得到的结果也将是截然不同，这就是RNN的特性，可以处理序列数据，同时对序列也很敏感 这样在进行语义识别时,可以根据前句传递下来的\"记忆\"来判断当前词的含义 注意：上图为同一个RNN在三个不同时间点被分别使用了三次，并非是三个不同的NN LSTM Long short-term memory(长短期记忆) 如今RNN中大多都会用LSTM来构建模型 因为在基础版本的RNN中，每一时刻的隐藏状态都不仅由该时刻的输入决定，还取决于上一时刻的隐藏层的值，如果一个句子很长，到句子末尾时，它将记不住这个句子的开头的内容详细内容,这就是梯度弥散 LSTM是RNN的一种变体，更高级的RNN，那么它的本质还是一样的，还记得RNN的特点吗，可以有效的处理序列数据，当然LSTM也可以，还记得RNN是如何处理有效数据的吗，是不是每个时刻都会把隐藏层的值存下来，到下一时刻的时候再拿出来用，这样就保证了，每一时刻含有上一时刻的信息，如图，我们把存每一时刻信息的地方叫做Memory_Cell，中文就是记忆细胞，可以这么理解。 打个比喻吧，普通RNN就像一个乞丐，路边捡的，别人丢的，什么东西他都想要，什么东西他都不嫌弃，LSTM就像一个贵族，没有身份的东西他不要，他会精心挑选符合自己身份的物品。这是为什么呢？有没有思考过，原因很简单，乞丐没有选择权，他的能力注定他只能当一个乞丐，因此他没有挑选的权利，而贵族不一样，贵族能力比较强，经过自己的打拼，终于有了地位和身份，所以可以选择舍弃一些低档的东西，这也是能力的凸显。 LSTM和普通RNN正是贵族和乞丐，RNN什么信息它都存下来，因为它没有挑选的能力，而LSTM不一样，它会选择性的存储信息，因为它能力强，它有门控装置，它可以尽情的选择。如下图，普通RNN只有中间的Memory_Cell用来存所有的信息，而从下图我们可以看到，LSTM多了三个Gate，也就是三个门，什么意思呢？在现实生活中，门就是用来控制进出的，门关上了，你就进不去房子了，门打开你就能进去，同理，这里的门是用来控制每一时刻信息记忆与遗忘的。 三个门的解释 Input_Gate：中文是输入门，在每一时刻从输入层输入的信息会首先经过输入门，输入门的开关会决定这一时刻是否会有信息输入到Memory_Cell Output_Gate：中文是输出门，每一时刻是否有信息从Memory_Cell输出取决于这一道门 Forget_Gate：中文是遗忘门，每一时刻Memory_Cell里的值都会经历一个是否被遗忘的过程，就是由该门控制的，如果打卡，那么将会把Memory_Cell里的值清除，也就是遗忘掉 传递顺序: 先经过输入门，看是否有信息输入，再判断遗忘门是否选择遗忘Memory_Cell里的信息，最后再经过输出门，判断是否将这一时刻的信息进行输出。 LSTM的结构图，是一个时间点上的内部结构，就是整个工作流程中的其中一个时间点 首先看图中最中间的地方，Cell，我们上面也讲到了Memory_Cell，也就是一个记忆存储的地方，这里就类似于普通RNN的$S_t$，都是用来存储信息的，这里面的信息都会保存到下一时刻，其实标准的叫法应该是$h_t$，因为这里对应神经网络里的隐藏层，所以是hidden的缩写，无论普通RNN还是LSTM其实t时刻的记忆细胞里存的信息，都应该被称为$O_t$。再看最上面的$a$，是这一时刻的输出，也就是类似于普通RNN里的$Z,Z_i,Z_f, Z_o$。最后，我们再来看这四个，这四个相辅相成，才造就了中间的Memory_Cell里的值，你肯恩要问普通RNN里有个$X_t$作为输入，那LSTM的输入在哪？别着急，其实这四个$Z, Z_i,Z_f,Z_o$都有输入向量X_t的参与 其中的运算单元都是激活函数 tanh和sigmoid $Z = \\tanh(W[x_t, h_{t-1}])$ $Z_i = \\sigma(W_i [x_t,h_{t-1}])$ $Z_f = \\sigma(W_f [x_t, h_{t-1}])$ $Z_o = \\sigma(W_o [x_t, h_{t-1}])$ 其中$Z$是最为普通的输入，可以从上图中看到，$Z$是通过该时刻的输入$Z$和上一时刻存在Memory_Cell里的隐藏层信息$h_{t-1}$向量拼接，再与权重参数向量$W$点积，得到的值经过激活函数tanh最终会得到一个数值，也就是$Z$，注意只有$Z$的激活函数是tanh，因为$Z$是真正作为输入的，其他三个都是门控装置 再来看$Z_i$，input gate的缩写i，所以也就是输入门的门控装置，Z_i同样也是通过该时刻的输入$X_t$和上一时刻隐藏状态，也就是上一时刻存下来的信息$h_{t-1}$向量拼接，在与权重参数","date":"2021-02-16","objectID":"/posts/nndl-21/:0:0","tags":["Andrew NNDL"],"title":"NNDL-RNN","uri":"/posts/nndl-21/"},{"categories":["Git"],"content":"因为前段时间的BLM运动,Github就把master改名成了main,因为master有奴隶主的意思… 这就导致本地分支和main不统一,无法push 所以只能通过合并分支来解决 git checkout -b main # Switched to a new branch 'main' git branch # * main # master git merge master # 将master分支合并到main上 # Already up to date. git pull origin main --allow-unrelated-histories # git pull origin main会报错：refusing to merge unrelated histories git push origin main ","date":"2021-02-08","objectID":"/posts/github-5/:0:0","tags":["Github"],"title":"Git master转为main","uri":"/posts/github-5/"},{"categories":["win"],"content":"加快BT文件下载速度 BT文件下载原理 参考文章 参考文章2 BT 下载速度取决于其他下载同一资源的用户上传速度 也就是做种的人越多，你的下载速度越快！如果一个资源没人上传，你就完全没有下载速度 做种：指上传文件数据给其他 BT 用户的行为 但是迅雷是把下载过的资源缓存到自己服务器上来实现“加速”的BT软件 而其他的BT软件都是单纯靠其他用户给你提供下载速度 因此在使用BT软件下载资源会出现速率不稳定(尤其是非热门资源) 在BT下载器下载时,会花费大量时间去检索当前的用户,因此速率一直很低,因为无法在短时间内找到优质的下载用户 Tracker是什么? BT下载的文件都是其他用户上传给你的。 BT下载速度就等于其他用户的上传速度。 做种上传的用户越多，你的下载速度就越快，而用户通过Peer、DHT、Tracker获得。 name function Peer 在获得一个有效用户后才会起作用，该用户会把它知道的其他用户信息告诉你 DHT Peer 威力加强版，分布式储存用户信息，因此获得用户的效率更高，但需要养（下载热门资源） Tracker 记录下载同一个资源的用户信息并提供给你，帮助你与其他用户建立连接，简单粗暴 以上三者的优缺点是互补的，不存在谁替代谁，一起用效果最好！ 使用这些Tracker的人越多，用户数量就越多，大家的下载速度就越快 对于tracker文件,需要在bt软件进行相应的设置,一般只填写一个订阅网址即可,列表进行时间间隔更新 但是在实际使用中,虽然设定了trackers列表,但下载速度很不稳定 因此还是建议使用迅雷下载,虽然最高速度很低,但下载速率稳定 ","date":"2021-02-08","objectID":"/posts/win-10/:0:0","tags":["win"],"title":"BT文件下载","uri":"/posts/win-10/"},{"categories":["Qt-Python"],"content":"Pyinstaller实现程序打包 这个打包程序,足足耗费了我两天的时间 以为一行命令就行,但是打包之后的程序,要么缺少东西,要么在新环境下缺少qt库,快给我搞自闭了,添加各种plugin和platform下的文件都不好使 直到昨天晚上,我才在博客的海洋中,找到有人提了一下Anaconda环境下打包会出问题,需要额外配置一下虚拟环境 我这才去试了一下,但是在windows terminal中一直调用的还是base环境下的包,就在最后放弃的关头! 看到有大佬在pycharm的terminal中调用出了虚拟环境,最后终于打包成功! Pyinstaller命令 命令 解释 -F 打包为一个文件(exe) –workpath 指定了制作过程中临时文件的存放目录 –distpath 指定了最终的可执行文件目录所在的父目录 –runtime-hook=“runtimehook.py” 库文件存在一个文件夹中 –noconsole(-w) 运行时没有terminal黑框 –icon=“star.ico” 程序图标 –hidden-import PySide2.QtXml 导入动态库 demo打包命令 pyinstaller main_run.py -w --icon=\"star.ico\" --hidden-import PySide2.QtXml 其中 –hidden-import PySide2.QtXml 必要参数 ","date":"2021-02-08","objectID":"/posts/qt-2/:0:0","tags":["Pyside"],"title":"Pyside2程序打包","uri":"/posts/qt-2/"},{"categories":["Qt-Python"],"content":"解决缺少\"shiboken2.abi3.dll\"文件 -p D:/Anaconda/envs/py37_env/Lib/site-packages/shiboken2 ","date":"2021-02-08","objectID":"/posts/qt-2/:1:0","tags":["Pyside"],"title":"Pyside2程序打包","uri":"/posts/qt-2/"},{"categories":["Qt-Python"],"content":"指定生成文件路径 --distpath E:/dist --workpath E:/building_file 配置Python虚拟环境 在Anaconda中配置一个python3.7的环境 ","date":"2021-02-08","objectID":"/posts/qt-2/:2:0","tags":["Pyside"],"title":"Pyside2程序打包","uri":"/posts/qt-2/"},{"categories":["Qt-Python"],"content":"conda常用命令 conda list #查看安装了哪些包。 conda env list 或 conda info -e #查看当前存在哪些虚拟环境 conda update conda #检查更新当前conda ","date":"2021-02-08","objectID":"/posts/qt-2/:3:0","tags":["Pyside"],"title":"Pyside2程序打包","uri":"/posts/qt-2/"},{"categories":["Qt-Python"],"content":"创建虚拟环境 conda create -n xxx python=3.7 xxx为虚拟环境的名字,该文件可在Anaconda安装目录 envs文件下找到 ","date":"2021-02-08","objectID":"/posts/qt-2/:3:1","tags":["Pyside"],"title":"Pyside2程序打包","uri":"/posts/qt-2/"},{"categories":["Qt-Python"],"content":"激活虚拟环境 activate your_env_name # Windows source activate your_env_nam # Linux ","date":"2021-02-08","objectID":"/posts/qt-2/:3:2","tags":["Pyside"],"title":"Pyside2程序打包","uri":"/posts/qt-2/"},{"categories":["Qt-Python"],"content":"关闭虚拟环境 deactivate env_name # Windows source deactivate #Linux ","date":"2021-02-08","objectID":"/posts/qt-2/:3:3","tags":["Pyside"],"title":"Pyside2程序打包","uri":"/posts/qt-2/"},{"categories":["Qt-Python"],"content":"指定环境管理包 conda install --name $your_env_name $package_name conda remove --name $your_env_name $package_name ","date":"2021-02-08","objectID":"/posts/qt-2/:3:4","tags":["Pyside"],"title":"Pyside2程序打包","uri":"/posts/qt-2/"},{"categories":["Qt-Python"],"content":"删除虚拟环境 conda remove -n your_env_name --all 最后切换到虚拟环境安装pyside2等库,实现打包 打包完成的程序结构 最后打包文件dist中应该有 界面ui文件 主程序exe文件 程序图标ico文件 ","date":"2021-02-08","objectID":"/posts/qt-2/:3:5","tags":["Pyside"],"title":"Pyside2程序打包","uri":"/posts/qt-2/"},{"categories":["Qt-Python"],"content":"monitor_control 起源 Demo灵感来源 『又来瞎鼓捣』外接显示器不能自动调亮度？我花 10 块钱做了个自动光感调节器 - 少数派 Demo项目地址 GitHub 调节外接显示器的亮度以及对比度 当时正在重温Python,正愁没啥代码可写,正好借着这个机会学学GUI开发,岂不美哉! 然后正好一直很眼馋跨平台开发,发现Qt这个好东西😄! 最后断断续续用了五天的时间,把这个程序写了出来,并且实现程序打包,可以在非开发(无python)环境下的电脑正常运行…嚯嚯嚯非常的开心了 开发环境 ","date":"2021-02-08","objectID":"/posts/qt-1/:0:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"依赖库版本 name version Python 3.8.5 pyside2 5.15.2 monitorcontrol 2.3.0 一开始本来使用pyqt5去做,后来发现pyside2以及现在刚出的pyside6是官方支持的,以后兼容性以及生态会更好,因此这次直接选择用pyside2去搭建这个程序 ","date":"2021-02-08","objectID":"/posts/qt-1/:1:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"开发工具 pycharm qt-designer ","date":"2021-02-08","objectID":"/posts/qt-1/:2:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"配置pycharm 参考博客 配置成功后,在External tools中会有三个工具,依次为打开designer,ui文件转换为py文件,以及资源转换工具 在开发的第一个程序中,我们直接使用ui文件并且没有额外的资源调用,因此只会用到designer 界面设计 qt-designer步骤 直接创建widget即可 然后多选控件,进行布局(套娃)操作 通过选择工具栏的信号/槽选项,然后拖拽控件,可以实现自带信号/槽函数的响应实现 保存文件,放入程序的根目录下 在本程序中,信号/槽函数都在程序的脚本文件中定义,没有在ui文件中指定 程序脚本框架 import部分 from PySide2.QtWidgets import QApplication, QSystemTrayIcon, QMenu, QAction from PySide2.QtUiTools import QUiLoader from PySide2.QtCore import Signal, QObject, Qt from PySide2.QtGui import QIcon from threading import Thread from monitorcontrol import get_monitors import time 对于import部分,要使用 from ... import ... 这样可以减少程序生成时,所依赖的包,大幅度减少程序打包后的大小 窗口类 参考B站视频 在脚本中,可以将一个窗口看作是一个类 通过类中的构造函数,初始化窗口中的参数以及绑定事件(信号/槽函数) 引入ui文件 初始化ui中参数 绑定ui界面的事件(信号/槽函数) 槽函数定义 ","date":"2021-02-08","objectID":"/posts/qt-1/:3:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"引入ui/绑定事件 class Stats(): def __init__(self): # 引入ui文件 self.ui = QUiLoader().load('main_ui.ui') # 获得当前屏幕亮度以及对比度 with global_monitor[0]: s_contrast = global_monitor[0].get_contrast() s_luminance = global_monitor[0].get_luminance() # 初始化划轴位置 self.ui.horizontalSlider.setValue(s_luminance) self.ui.horizontalSlider_2.setValue(s_contrast) # 初始化显示 self.ui.lcdNumber.display(s_luminance) self.ui.lcdNumber_2.display(s_contrast) # 建立信号量实例(子线程改变主界面,防止画面阻塞) self.global_ms = MySignals() # 绑定事件 self.ui.pushButton.clicked.connect(self.minimize_totray) self.ui.horizontalSlider.valueChanged.connect(lambda: self.update_shit(1)) self.ui.horizontalSlider_2.valueChanged.connect(lambda: self.update_shit(2)) self.global_ms.main_signal.connect(self.main_thread) ","date":"2021-02-08","objectID":"/posts/qt-1/:4:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"槽函数定义 其实就是事件的响应函数,需要注意的是,在信号的绑定中,如果需要传递参数,那么需要添加\"lambda\"关键字,具体原理还不知道,先暂时这样记吧 self.ui.horizontalSlider_2.valueChanged.connect(lambda: self.update_shit(2)) 函数完整定义 def main_thread(self, index, value): global last_time now_time = time.time() global global_monitor if now_time-last_time \u003e 0.1: if index == 0: self.ui.lcdNumber.display(value) with global_monitor[0]: global_monitor[0].set_luminance(value) last_time = now_time else: self.ui.lcdNumber_2.display(value) with global_monitor[0]: global_monitor[0].set_contrast(value) last_time = now_time else: pass ","date":"2021-02-08","objectID":"/posts/qt-1/:5:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"画面阻塞处理(子线程) 参考博客 如果在脚本中,需要进行函数操作,之后更新到ui上,但是函数操作需要较长的时间,那么就会出现画面阻塞的情况,即此时画面卡死,去等待函数操作完成,这个情况在gui开发中,会经常出现,最好的解决方式就是调用子线程,而在子线程中更新ui,需要用到python的signal机制 首先需要创建一个signal类 class MySignals(QObject): main_signal = Signal(int, int) 然后再主窗口类实例化,并绑定 self.global_ms = MySignals() self.global_ms.main_signal.connect(self.main_thread) 定义处理函数 def main_thread(self, index, value): # command... 将ui上的动作与信号绑定 def update_shit(self, shit): def threadFunc(): if shit == 1: new_data = self.ui.horizontalSlider.value() self.global_ms.main_signal.emit(0, new_data) else: new_data = self.ui.horizontalSlider_2.value() self.global_ms.main_signal.emit(1, new_data) thread = Thread(target=threadFunc) thread.start() 其中emit,就是发送信号值 emit信号发送到\"global_ms\"实例对象,然后\"global_ms\"去调用绑定的\"main_thread\"函数,最后完成了子线程调用主线程函数,从而不会发生主线程等待 托盘实现 ","date":"2021-02-08","objectID":"/posts/qt-1/:6:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"构造函数 如果想将程序隐藏至托盘,那么需要新定义一个托盘类 class TrayIcon(QSystemTrayIcon): def __init__(self, MainWindow, parent=None): super(TrayIcon, self).__init__(parent) self.ui = MainWindow self.createMenu() 构造函数传参为主窗口类的实例化对象 ","date":"2021-02-08","objectID":"/posts/qt-1/:7:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"创建托盘右键菜单 def createMenu(self): self.menu = QMenu() self.showAction1 = QAction(\"打开\", self, triggered=self.show_window) self.showAction2 = QAction(\"夜晚模式\", self, triggered=self.open_night) self.showAction3 = QAction(\"白天模式\", self, triggered=self.open_light) self.quitAction = QAction(\"退出\", self, triggered=self.quitapp) # 托盘增加选项 self.menu.addAction(self.showAction1) self.menu.addAction(self.showAction2) self.menu.addAction(self.showAction3) self.menu.addAction(self.quitAction) self.setContextMenu(self.menu) # 设置图标 self.setIcon(QIcon(\"star.png\")) self.icon = self.MessageIcon() # 把鼠标点击图标的信号和槽连接 self.activated.connect(self.onIconClicked) ","date":"2021-02-08","objectID":"/posts/qt-1/:8:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"定义菜单绑定事件 def open_night(self): # 系统提示弹窗 self.showMessage(\"Message\", \"已开启夜晚模式\", self.icon) # 实现过程(调节亮度,更新ui界面数值) global global_monitor with global_monitor[0]: global_monitor[0].set_contrast(50) global_monitor[0].set_luminance(35) self.ui.horizontalSlider.setValue(35) self.ui.horizontalSlider_2.setValue(50) self.ui.lcdNumber.display(35) self.ui.lcdNumber_2.display(50) ","date":"2021-02-08","objectID":"/posts/qt-1/:9:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"隐藏至托盘 在主窗口函数的事件中定义 def minimize_totray(self): self.ui.setWindowFlags(Qt.SplashScreen | Qt.FramelessWindowHint) self.ui.showMinimized() ","date":"2021-02-08","objectID":"/posts/qt-1/:10:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"点击托盘显示窗口/退出程序 def show_window(self): # 若是最小化，则先正常显示窗口，再变为活动窗口（暂时显示在最前面） self.ui.showNormal() self.ui.activateWindow() self.ui.setWindowFlags(Qt.Window) self.ui.show() def quitapp(self): QApplication.quit() ","date":"2021-02-08","objectID":"/posts/qt-1/:11:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["Qt-Python"],"content":"定义点击托盘图标事件 鼠标点击icon传递的信号会带有一个整形的值 表示单击右键 双击 单击左键 用鼠标中键点击 def onIconClicked(self, reason): if reason == 2 or reason == 3: # self.showMessage(\"Message\", \"skr at here\", self.icon) if self.ui.isMinimized() or not self.ui.isVisible(): # 若是最小化，则先正常显示窗口，再变为活动窗口（暂时显示在最前面） self.ui.showNormal() self.ui.activateWindow() self.ui.setWindowFlags(Qt.Window) self.ui.show() else: # 若不是最小化，则最小化 self.ui.showMinimized() self.ui.setWindowFlags(Qt.SplashScreen) self.ui.show() 测试当前窗口 适合于测试当前窗口程序,在完成测试之后应该删去或注释 if __name__ == \"__main__\": # 用于当前窗体测试 app = QApplication([]) app.setWindowIcon(QIcon('star.png')) #实例化主程序 stats = Stats() stats.ui.show() # 实例化托盘程序 ti = TrayIcon(stats.ui) ti.show() app.exec_() 窗口与运行的分离 新创建一个\"main_run.py\"文件,将所有窗口类在该文件中import 然后控制窗口调用,而不是将所有窗口写在一个文件中 (由于Demo只有一个窗口吗,所以看起来没啥区别… from PySide2.QtGui import QIcon from PySide2.QtWidgets import QApplication from main_script import Stats, TrayIcon app = QApplication([]) app.setWindowIcon(QIcon('star.png')) # 实例化主程序 stats = Stats() stats.ui.show() # 实例化托盘程序 ti = TrayIcon(stats.ui) ti.show() app.exec_() 这样第一个Demo就完成啦 Python太强啦,没想到开发GUI这么简单!!!好快乐 ","date":"2021-02-08","objectID":"/posts/qt-1/:12:0","tags":["Pyside"],"title":"Pyside2开发第一个GUI程序","uri":"/posts/qt-1/"},{"categories":["win"],"content":"Firefox/Chrome利用WebDav同步书签 之前一直用火狐,今天发现突然访问网站好慢好慢,后来排查发现不是家里网络的问题,是浏览器自身的问题…但是这河狸吗,这不合理呀!edge就一点问题都没有 在设置里逛了好久,发现火狐有一个选项\"启用基于Https的DNS\",然后关掉…就好了(抓狂…我的大半天没了) 但是后来发现edge也蛮好用的,Chromium插件会更全一点,所以想转到edge呆一阵,然后发现如果同时用火狐和edge的话,书签同步是不互通的,但这能难倒我吗?当然不能! 所以花了好几个小时,终于搞明白啦 所需工具 ","date":"2021-01-31","objectID":"/posts/win-9/:0:0","tags":["Chrome"],"title":"跨平台同步书签","uri":"/posts/win-9/"},{"categories":["win"],"content":"浏览器插件 插件 Floccus ","date":"2021-01-31","objectID":"/posts/win-9/:1:0","tags":["Chrome"],"title":"跨平台同步书签","uri":"/posts/win-9/"},{"categories":["win"],"content":"webdav 本来想用onedrive,但是查了好久也没查明白怎么调出来 最后只好用了坚果云的webdav,发现同步速度还挺快的!那就这样吧 创建应用 保存好密码 配置插件 https://dav.jianguoyun.com/dav/我的坚果云 修改更新时间为5min 注意两个浏览器的同步文件夹部分,因为火狐和edge的书签文件构成是不同的,如果直接同步根目录会发生错误 ","date":"2021-01-31","objectID":"/posts/win-9/:2:0","tags":["Chrome"],"title":"跨平台同步书签","uri":"/posts/win-9/"},{"categories":["数据库"],"content":"SQL大礼包 group by 将查询结果按某一列或多列的值分组,值相等的分为一组 对查询结果分组的目的时为了细化聚集函数的作用对象,如果未对查询结果分组,聚集函数将作用域整个查询结果,分组后的聚集函数将作用于每一个组,每一个组都有一个函数值 求各个课程号以及相应的选课人数 selectcno,count(sno)fromscgroupbycno; 查询选修了三门以上课程的学生学号 selectsnofromscgroupbysnohavingcount(*)\u003e3; where和having短语的区别在于作用的对象不同,where子句作用于基本表或视图,从中选择满足条件的元组,having短语作用于组,从中选择满足条件的组 查询平均成绩大于等于90分的学生学号和平均成绩 selectsno,avg(grade)fromscgroupbysnohavingavg(grade)\u003e=90; 连接查询 查询每个学生及其选修课程的情况 selectstudent.*,sc.*fromstuden,scwherestudent.sno=sc.sno;/*如果属性列在两个表中是唯一的,则可以去掉表名前缀*/selectstudent.sno,sname,ssex,sage,sdept,cno,gradefromstudent,scwherestudent.sno=sc.sno; 查询选修2号课程且成绩在90分以上的所有学生的学号和姓名 selectstudent.sno,snamefromstudent,scwherestudent.sno=sc.snoandsc.cno='2'andsc.grade\u003e90; 自身连接 一个表和其自己连接 查询每一门课的间接先修课(先修课的先修课) selectfirst.cno,second.cpnofromcoursefirst,coursesecondwherefirst.cpno=second.cno; 外连接 selectstudent.sno,sname,ssex,sage,sdept,cno,gradefromstudentleftouterjoinscon(student.sno=sc.sno)/*左外连接*/ 多表连接 selectstudent.sno,sname,cname,gradefromstudent,sc,coursewherestudent.sno=sc.snoandsc.cno=course.cno; 嵌套查询 在sql中,一个select-from-where语句为一个查询块 将一个查询块嵌套在另一个查询块的where子句或having短语的条件的查询称为嵌套查询 selectsnamefromstudentwheresnoin(selectsnofromscwherecno='2'); ","date":"2021-01-30","objectID":"/posts/DB-8/:0:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-2","uri":"/posts/DB-8/"},{"categories":["数据库"],"content":"带有in的子查询 查询与\"刘晨\"在同一个系学习的学生 selectsno,sname,sdeptfromstudentwheresdeptin(selectsdeptfromstudentwheresname='刘晨'); 查询选修了课程为\"信息系统\"的学生的学号和姓名 selectsno,snamefromstudentwheresnoin(selectsnofromscwherecnoin(selectcnofromcoursewherecname='信息系统')); ","date":"2021-01-30","objectID":"/posts/DB-8/:1:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-2","uri":"/posts/DB-8/"},{"categories":["数据库"],"content":"带有比较运算符的子查询 查询每个学生超过他自己选修课程的平均成绩的课程号 selectsno,cnofromscxwheregrade\u003e=(selectavg(grade)fromscywherey.sno=x.sno); 如果子查询的条件依赖于父查询,那么这类查询称为相关子查询(上例中子查询中有夫查询元素) 整个查询语句称为相关嵌套查询 ","date":"2021-01-30","objectID":"/posts/DB-8/:2:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-2","uri":"/posts/DB-8/"},{"categories":["数据库"],"content":"带有any(some)或all谓词的子查询 查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄 selectsname,sagefromstudentwheresage\u003cany(selectsagefromstudentwheresdept='cs')andsdept!='cs'; “\u003eany\"表示至少大于一个值(大于最小值) “\u003eall\"表示大于每一个值(大于最大值) 也可以用聚集函数表示 selectsname,sagefromstudentwheresage\u003c(selectmax(sage)fromstudentwheresdept='cs')andsdept!='cs'; 查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名及年龄 selectsname,sagefromstudentwheresage\u003call(selectsagefromstudentwheresdept='cs')andsdept!='cs'; 也可以用聚集函数表示 selectsname,sagefromstudentwheresage\u003c(selectmin(sage)fromstudentwheresdept='cs')andsdept!='cs'; 带有exist谓词的子查询 带有exist谓词的子查询不返回任何数据,只产生逻辑真\"true\"或逻辑假值\"false” 查询所有选修了1号课程的学生姓名 selectsnamefromstudentwhereexists(select*fromscwheresno=student.snoandcno='1'); 查询选修了全部课程的学生姓名 即没有一门课不是他不选修的 selectsnamefromstudentwherenotexists(select*fromcoursewherenotexists(select*fromscwheresno=student.snoandcno=course.cno)); 查询至少选修了学生20121512选修的全部课程的学生号码 selectdistinctsnofromscscxwherenotexists(select*fromscscywherescy.sno='20121512'andnotexists(select*fromscsczwherescz.sno=scx.snoandscz.cno=scy.cno)); ","date":"2021-01-30","objectID":"/posts/DB-8/:3:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-2","uri":"/posts/DB-8/"},{"categories":["神经网络与深度学习"],"content":"Style Transfer What is neural style transfer 什么是神经网络迁移 What are deep ConvNets learning? CNN特征可视化 Cost function 代价函数 Content cost function 内容代价函数 Style cost function 风格代价函数 1D and 3D generalizations of models 一维到三维的推广 ","date":"2021-01-29","objectID":"/posts/nndl-20/:0:0","tags":["Andrew NNDL"],"title":"NNDL-神经风格迁移","uri":"/posts/nndl-20/"},{"categories":["数据库"],"content":"SQL大礼包 schema(模式) ","date":"2021-01-29","objectID":"/posts/DB-7/:0:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["数据库"],"content":"定义模式 createschema\u003c模式名\u003eauthorization\u003c用户名\u003e 为用户wang定义一个学生-课程模式\"s-t\" createschema\"s-t\"authorizationwang; 在定义模式的同时,定义表 createschematestauthorizationweicreatetabletab1(col1SMALLINT,col2INT,col3CHAR(20),col4NUMBER(10,3),col5DECIMAL(5,2)); ","date":"2021-01-29","objectID":"/posts/DB-7/:1:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["数据库"],"content":"删除模式 dropschema\u003c模式名\u003e\u003ccascade|restrict\u003e;/* cascade级联删除,模式下的所有对象都删除 restrict限制删除,如果模式下有对象,则拒绝执行删除 */ table(表) ","date":"2021-01-29","objectID":"/posts/DB-7/:2:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["数据库"],"content":"定义表 createtable\u003c表名\u003e(\u003c列名\u003e\u003c数据类型\u003e[列级完整性约束条件],...); 建立一个\"学生\"表student createtablestudent(snoCHAR(9)PRIMARYKEY,snameCHAR(20)UNIQUE,sexCHAR(2),sageSMALLINT,sdeptCHAR(20)); 建立一个\"课程\"表course createtablecourse(cnoCHAR(4)PRIMARYKEY,cnameCHAR(40)NOTNULL,cpnoCHAR(4),ccreditSMALLINT,FOREIGNKEY(cpno)REFERENCEScourse(cno)); 建立学生选课表sc createtablesc(snoCHAR(9),cnoCHAR(4),gradeSMALLINT,PRIMARYKEY(sno,cno),FOREIGNKEY(sno)REFERENCESstudent(sno),FOREIGNKEY(cno)REFERENCESstudent(cno)); ","date":"2021-01-29","objectID":"/posts/DB-7/:3:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["数据库"],"content":"修改基本表 altertable\u003c表名\u003e[add[column]\u003c新列名\u003e\u003c数据类型\u003e[完整性约束]][add\u003c表级完整性约束\u003e][drop[column]\u003c列名\u003e[cascade|restrict]][dropconstraint\u003c完整性约束\u003e[restrict|cascade]][altercolumn\u003c列名\u003e\u003c数据类型\u003e]; 向student表中增加\"入学时间\"列,其数据类型为日期型 altertablestudentadds_intimeDATE; 将年龄数据类型由字符型改为整数 altertablestudentaltercolumnsageINT; 增加课程名称必须取唯一值的约束条件 altertablecourseaddUNIQUE(cname); ","date":"2021-01-29","objectID":"/posts/DB-7/:4:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["数据库"],"content":"删除基本表 droptable\u003c表名\u003e[restrict|cascade];/*默认为restrict*/ 删除学生表 droptablestudentcascade; 如果表上建有视图,选择restrict时表不能被删除,需要选择cascade 索引(index) ","date":"2021-01-29","objectID":"/posts/DB-7/:5:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["数据库"],"content":"建立索引 create[UNIQUE][CLUSTER]index\u003c索引名\u003eon\u003c表名\u003e(\u003c列名\u003e[\u003c次序\u003e],...) ASC(升序) DESC(降序) UNIQUE 表名此索引的每一个索引值只能对应唯一的数据记录 CLUSTER 表示要建立的索引时聚簇索引 为学生-课程数据库中的student,course,sc三个表建立索引 createUNIQUEindexonstudent(sno);createUNIQUEindexoncourse(cno);createUNIQUEindexscnoonsc(snoASC,cnoDESC); ","date":"2021-01-29","objectID":"/posts/DB-7/:6:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["数据库"],"content":"修改索引 alterindex\u003c旧索引名\u003erenameto\u003c新索引名\u003e ","date":"2021-01-29","objectID":"/posts/DB-7/:7:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["数据库"],"content":"删除索引 dropindex\u003c索引名\u003e 查询 select[distinct|all]\u003c目标列表达式\u003e,...from\u003c表名或视图名\u003e,...[where\u003c条件表达式\u003e][groupby\u003c列名1\u003e[having\u003c条件表达式\u003e]][orderby\u003c列名2\u003e[ASC|DESC]]; ","date":"2021-01-29","objectID":"/posts/DB-7/:8:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["数据库"],"content":"表查询 涉及一个表的查询 查询指定列 selectsno,snamefromstudent;selectsname,sno,sdeptfromstudent; 查询所有列 select*fromstudent; 查询经过计算的值 selectsname-sagefromstudent; 查询全体学生的名字,出生日期,所在院系,要求小写字母表示院系 selectsname,'year of birth',2014-sage,lower(sdept)fromstudent; 指定查询结果的列名 selectsnamename,'year of birth:'birth,2014-sagebirthday,lower(sdept)departmentfromstudent; 其中name,birth,department为查询结果的列名 消除重复行 selectDISTINCTsnofromsc 查询满足条件的元组 比较大小 selectsnamefromstudentwheresdept='cs'; 确定范围 selectsname,sdept,sagefromstudentwheresagebetween20and23; 确定集合 selectsname,ssexfromstudentwheresdeptin('cs','ma','is');/*where sdept not in ('cs','ma','is')*/ 字符串匹配 [NOT]LIKE'\u003c匹配串\u003e'[ESCAPE'\u003c换码字符\u003e'] % 代表任意长度的字符串 _ 代表任意单个字符 select*fromstudentwheresnolike'20121512'/*等价于 where sno ='20121512'*/ 如果like后面的匹配串中不含有通配符,则可以用=运算符取代like 查询所有姓刘的学生的名字,学号,性别 selectsname,sno,ssexfromstudentwheresnamelike'欧阳_'; 查询姓\"欧阳\"且全名为三个汉字的学生的姓名 selectsnamefromstudentwheresnamelike'欧阳_' 查询名字中第二个字为\"阳\"的学生的姓名和学号 selectsname,sno,ssexfromstudentwheresnamenotlike'_阳%'; 查询所有不姓刘的学生的名字,学号,性别 selectsname,sno,ssxfromstudentwheresnamenotlike'刘%'; 查询db_design课程的课程号和学分 selectcno,ccreditfromcoursewherecnamelike'db\\_design'escape'\\'; escape’' 表示 ‘'为转码字符,这样匹配串中紧跟在’'后面的字符’_‘不再具有通配符的含义,而只是单纯的字符 查询以’db_‘开头,且倒数第三个字符为i的课程的详细信息 select*fromcoursewherecnamelike'db\\_%i__'escape'\\'; 这里第一个’_‘前面有换码字符’',而后面的两个 _ 没有换码字符,因此都仍作为通配符 涉及空值的查询 某些同学没有参加选修课的考试,因此成绩为空 selectsno,snamefromdcwheregradeisnull 多重查询条件 逻辑运算符and和or可用来连接多个查询条件,and的优先级高于or,但用户可以使用括号改变优先级 查询计算机科学系中年龄在20以下的学生姓名 selectsnamefromstudentwheresdpt='cs'andsage\u003c20; 在查询条件中’in’的作用等价于or selectsnamessexfromstudentwheresdept='cs'orsdpt='ma'orsdpt='is'; ","date":"2021-01-29","objectID":"/posts/DB-7/:9:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["数据库"],"content":"order by子句 用户可以用order by子句对查询结果按照一个或多个属性的升序(ASC)或降序(DESC)排列,默认为升序 查询选修了课程3的学生的学号及成绩,查询结果按照分数的降序排列 selectsno,gradefromscwherecno='3'orderbygradedesc; 查询全体学生的情况,查询结果按照所在系的系号升序排列,同一系中的学生按照年龄的降序排列 select*fromstudentorderbysdept,sagedesc 聚集函数 为了进一步方便用户,增强检索功能,sql提供了许多聚集函数 函数名 含义 count(*) 统计元组的个数 count([distinc|all]\u003c列名\u003e) 统计一列中值的个数 sum(distinct|all)\u003c列名\u003e 计算一列值的总和 avg(distinct|all)\u003c列名\u003e 计算一列值的平均值 max(distinct|all)\u003c列名\u003e 计算一列值的最大值 min(distinct|all)\u003c列名\u003e 计算一列值的最小值 如果指定distinct短语,则表示在计算时要取消指定列中的重复值(all为默认值) 查询学生总人数 selectcount(*)fromstudent; 查询选修了课程的学生人数 selectcount(distinctsno)fromsc; 计算选修1号课程的学生平均成绩 selectavg(grade)fromscwherecno='1'; 查询选修1号课程的学生的最高分数 selectmax(grade)fromscwherecno='1'; 查询学生20125012选修课程的总学分数 selectsum(credit)fromsc,coursewheresno='20125012'andsc.cno=course.cno; ","date":"2021-01-29","objectID":"/posts/DB-7/:10:0","tags":["数据库系统概论-课程"],"title":"数据库系统概论 SQL-1","uri":"/posts/DB-7/"},{"categories":["win"],"content":"编辑 PAC.txt 代理规则 通配符支持 .example.com/ 实际书写时可省略*如 .example.com/ 意即 *.example.com/ 正则表达式支持 以\\开始和结束， 如 [\\w]+://example.com\\ 例外规则 @@ @@.example.com/ 满足@@后规则的地址不使用代理 即所有example .com域名下的网址都不走代理 匹配地址开始和结尾 | |http://example.com example.com| # 分别表示以http://example.com开始和以example.com结束的地址 # 意思是以http://example.com开始和以example.com结束的地址都走代理 标记|| ||example.com # http://example.com、https://example.com、ftp://example.com等地址均满足条件，只用于匹配地址开头 注释 ! ! Comment 分隔符^ 表示除了字母、数字或者 _ - . % 之外的任何字符。如 http://example.com^ # http://example.com/和http://example.com:8000/均满足条件，而http://example.com.ar/不满足条件 ","date":"2021-01-29","objectID":"/posts/win-8/:0:0","tags":["SSR"],"title":"PAC代理规则","uri":"/posts/win-8/"},{"categories":["神经网络与深度学习"],"content":"Object Detection What is face recognition? 什么是人脸识别 One-shot learning One-Shot学习 Siamese network Siamese 网络 Triplet lose Triplet 损失 Face verification and binary classification 人脸验证与二分类 ","date":"2021-01-28","objectID":"/posts/nndl-19/:0:0","tags":["Andrew NNDL"],"title":"NNDL-人脸识别","uri":"/posts/nndl-19/"},{"categories":["Shell"],"content":"Shell教程 碎碎的知识点 ","date":"2021-01-27","objectID":"/posts/shell-1/:0:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"批量重命名 之前在ubuntu的时候,能用bash直接批量处理图片命名 (因为每次查资料截图都会产生大量的图片,之前手动一个个命名真是太顶了 因为wsl的出现,所以现在还是回到了win的怀抱 但是在cmd下,使用之前的Linux下的bash命令,会产生奇怪的错误,在Linux下,图片命名是按照时间产生的顺序排序,正好符合我的意思 但是在windows下没有按照时间顺序命名,每次都是奇奇怪怪的顺序,导致命名后的文件都没有办法使用 懒得每次都调用py文件之类的,想直接在控制台中写好,所以只好乖乖去学shell啦 $ for x in *; do mv $x ${x:4}; done 其中 ${x:4} #从x变量中的第4号位置开始截取字符串(第一个位置为0号) ","date":"2021-01-27","objectID":"/posts/shell-1/:1:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"数据写入文件 echo \"hello\"\u003e\u003etext.txt #将hello写入text.txt文件中 ","date":"2021-01-27","objectID":"/posts/shell-1/:2:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"tree命令 tree /f video #/f命令为查看所有文件名字(video为文件名) ","date":"2021-01-27","objectID":"/posts/shell-1/:3:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"打开Windows terminal wt -d . # 当前目录打开Windows terminal ","date":"2021-01-27","objectID":"/posts/shell-1/:4:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"seq关键字 时间倒计时.sh echo -n \"Time: \" for i in `seq 9 -2 1` do echo -n -e \"\\b$i\" sleep 1 done echo seq基本用法 seq … 尾数(一个变量) seq … 首数 尾数(两个变量) seq … 首数 增量 尾数(三个变量) 以指定增量从首数开始打印数字到尾数 Shell教程 ","date":"2021-01-27","objectID":"/posts/shell-1/:5:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"脚本编写规范 一般在第一行填写基本信息 #！/bin/bash # Date：16:29 2018-10-20 # Author: Create by xiaoxie # Description: This script function is …… # Version： 1.1 ","date":"2021-01-27","objectID":"/posts/shell-1/:6:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"变量 交互式读取 read -p \"提示信息\" 变量名 赋值时使用引号的作用 双引号：允许通过$符号引用其他变量值 单引号：禁止引用其他变量值，$视为普通字符 反撇号：命令替换，提取命令执行后的输出结果 全局变量的定义方法 export 变量名 预定义变量 预定义变量和环境变量相类似，也是在Shell一开始就定义的变量，不同的是，用户只能根据shell的定义来使用这些变量，所有预定义变量都是由符号“$”和另一个符号组成。 常见的Shell预定义变量有以下几种。 $# ：位置参数的数量 $* ：所有位置参数的内容 $? ：命令执行后返回的状态，0表示没有错误，非0表示有错误 $$ ：当前进程的进程号 $! ：后台运行的最后一个进程号 $0 ：当前执行的进程名 例如 example.sh 文件 echo $1 echo ${2}+${3} # 执行bash example.sh 10 11 12 #输出两个参数 #10 #23 ","date":"2021-01-27","objectID":"/posts/shell-1/:7:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"常见运算符 ","date":"2021-01-27","objectID":"/posts/shell-1/:8:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"(()) 用于整数运算的常见运算符,效率很高 ((i= i+1)) #i增加1 i= $(($a+5)) #i = a变量+5 ","date":"2021-01-27","objectID":"/posts/shell-1/:8:1","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"let 用于整数运算 let i = i+8 ","date":"2021-01-27","objectID":"/posts/shell-1/:8:2","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"expr expr直接可计算出结果 配合变量计算 i = `expr $i+5` #将i变量+5 赋值给i ","date":"2021-01-27","objectID":"/posts/shell-1/:8:3","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"[] 可用于整数的运算 echo $[2-5] #得到-3 ","date":"2021-01-27","objectID":"/posts/shell-1/:8:4","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"逻辑语句 ","date":"2021-01-27","objectID":"/posts/shell-1/:9:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"if-then if condition then commands else commands fi ","date":"2021-01-27","objectID":"/posts/shell-1/:9:1","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"if-elseif if conditon then commands elseif condition then commands else commands fi ","date":"2021-01-27","objectID":"/posts/shell-1/:9:2","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"case case variable in v1) commands ;; v2) commands ;; v3) commands ;; *) commands esac 举例 read -p \"please input a num or str:\" i case $i in [1-9]) echo \"this is a number\" [a-z]) echo \"this is a letter\" *) echo \"this is shit\" esac ","date":"2021-01-27","objectID":"/posts/shell-1/:9:3","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"for for conditon do commands done ","date":"2021-01-27","objectID":"/posts/shell-1/:9:4","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"while while condition do commands done ","date":"2021-01-27","objectID":"/posts/shell-1/:9:5","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"函数 function_name(){ commands return N } 函数调用直接使用名字即可(不需要加双括号) Linux三剑客 grep擅长查找功能 sed擅长取行和替换 awk擅长取列 ","date":"2021-01-27","objectID":"/posts/shell-1/:10:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"正则表达式 参考博客 ","date":"2021-01-27","objectID":"/posts/shell-1/:11:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"元字符 . 匹配任意单个字符 [] 匹配指定范围内的任意单个字符 [^] 匹配指定范围外的任意单个字符 ","date":"2021-01-27","objectID":"/posts/shell-1/:11:1","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"字符集合 [[:digit:]] 匹配单个数字 [[:lower:]] 匹配单个小写字母 [[:upper:]] 匹配单个大写字母 [[:punct:]] 匹配单个标点字符 [[:space:]] 匹配单个空白字符 [[:alpha:]] 匹配单个字母 [[:alnum:]] 匹配单个字母或数字 ","date":"2021-01-27","objectID":"/posts/shell-1/:11:2","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"匹配次数（贪婪模式） * 匹配其前面的字符任意次 ? 匹配其前面的字符0次或者1次 + 匹配其前面的字符至少1次 .* 任意长度的任意字符 ","date":"2021-01-27","objectID":"/posts/shell-1/:11:3","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"位置锚定 ^ 锚定行首，此字符后面的任意内容必须出现在行首 $ 锚定行尾，此字符前面的任意内容必须出现在行尾 ^$ 空白行 ","date":"2021-01-27","objectID":"/posts/shell-1/:11:4","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"实际使用 由于linux系统shell解释器的特殊处理，某些元字符在linux下具有展开式等特殊含义，在实际的使用过程中我们需要添加 \\ 进行转义 \\? 匹配其前面的字符1次或0次 \\+ 匹配至少一次 \\{m,n\\} 匹配其前面的字符至少m次，至多n次 \\{1,\\} 匹配前面的字符至少1次 \\{0,3\\} 匹配前面的字符0次至3次均可 备注：至少0次，必须要显式的写出来； \\\u003c 锚定词首，其后面的任意字符必须作为单词首部出现 \\\u003e 锚定词尾，其前面的任意字符必须作为单词的尾部出现 ","date":"2021-01-27","objectID":"/posts/shell-1/:11:5","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"分组与后向引用 \\(\\) \\(ab\\)* \\1：引用第1个左括号以及与之对应的括号所包括的所有内容 \\2：引用第2个左括号以及与之对应的括号所包括的所有内容，以此类推 ","date":"2021-01-27","objectID":"/posts/shell-1/:11:6","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"拓展正则表达式 可以看到标准正则表达的使用过程中，许多符号都需要转义，这在工作中带来了一定的不便，因此扩展的正则表达式便出现了。 ","date":"2021-01-27","objectID":"/posts/shell-1/:12:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"字符匹配： . 匹配单个字符 [abc] 包含abc任意一个字符 [^abc] 不包含abc任意一个字符 ","date":"2021-01-27","objectID":"/posts/shell-1/:12:1","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"次数匹配（不用再转义）： * 匹配前一个字符任意次 ? 匹配其前面的字符1次或0次 + 匹配其前面的字符至少1次 {m,n} 匹配其前面的字符至少m次，至多n次 ","date":"2021-01-27","objectID":"/posts/shell-1/:12:2","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"位置锚定： 对比使用方式：^ 和 $ 这里要注意的是对于词首定位和词尾定位，分别是 \\\u003c 和 \\\u003e ，依然需要加上反斜杠； ","date":"2021-01-27","objectID":"/posts/shell-1/:12:3","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"分组（不用再转义）： ()：分组 \\1, \\2, \\3：分别对应第n个括号所匹配的内容 或运算 | 可以同时取并集 注意：C|cat表示的是C或cat（表示的是整个部分） 可以看到，使用扩展的正则表达式可以省略很多的转义符号，这尤其在写sed语句时极大的提高了代码的可读性。建议优先使用扩展的正则表达式 grep命令家族 grep命令家族由grep, egrep, fgrep 三个子命令组成，适用于不同的场景。具体如下： grep 原生的grep命令，使用“标准正则表达式”作为匹配标准。 egrep 扩展的grep命令，相当于$(grep -E)，使用“扩展正则表达式”作为匹配标准。 fgrep 简化版的grep命令，不支持正则表达式，但搜索速度快，系统资源使用率低。 ","date":"2021-01-27","objectID":"/posts/shell-1/:12:4","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"语法 grep [options] PATTERN [FILE...] ","date":"2021-01-27","objectID":"/posts/shell-1/:13:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"options部分 -i 忽略大小写 –color 高亮匹配上的字符串 -v 显示没有被模式匹配到的行 -o 只显示被模式匹配到的字符串 -E 使用扩展的正则表达式，egrep=grep -E ","date":"2021-01-27","objectID":"/posts/shell-1/:13:1","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"PATTERN部分 以字符串的方式给定匹配模板，可以使用普通字符串以及正则表达式(标准\u0026扩展) ","date":"2021-01-27","objectID":"/posts/shell-1/:13:2","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"FILE部分 需要查找内容的文件 sed命令 sed全称为Stream EDitor，sed是一个流编辑器，在处理行内容时功能十分强大 ","date":"2021-01-27","objectID":"/posts/shell-1/:13:3","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"基本语法 sed [option] 'script' [input file]... ","date":"2021-01-27","objectID":"/posts/shell-1/:14:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"option部分 -n：不输出模式空间中未匹配上的内容stdout，详情可以看4.3高级用法； -e：可以在sed命令中指定多个script脚本，多点编辑功能； -f：输入sed脚本，脚本中写着编辑命令； -r：支持使用扩展的正则； -i：直接编辑源文件； ","date":"2021-01-27","objectID":"/posts/shell-1/:14:1","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"script部分 script部分包含两个内容，其一是定界，即确定我们要操作的范围。另一个内容是操作，比如替换、插入当前行或在后面插入等操作。 定界-空地址 即全文编辑； 定界-单地址： n：指定第n行，对特定行进行编辑；举例：sed -n ‘1p’ passwd 仅输出第一行； /pattern/：指定模式匹配到的那一行，注意这里的pattern不是扩展正则表达式，如果要用扩展的正则表达式，需要在option需要使用-r；举例：sed -n ‘/sbin/p’ passwd 输出能够匹配上sbin的内容行； 定界-范围： n,m：定位从第n行开始至第m行(都是闭区间)； n,+k：定位从第n行开始，包括往后的k行； n,/pattern/：定位从第n行开始，至指定模式匹配到的那一行； /pattern1/,/pattern2/：定位从pattern1模式匹配开始，直到pattern2模式匹配之间的范围； 定界-步进方式： 1~2：以1为起始行，然后步进2行向下匹配，即所有的奇数行； 2~2：以2为起始行，然后步进2行向下匹配，即所有的偶数行； 编辑操作： d 删除整行，d放在定界后面。举例： sed '/sbin/d' passwd； p 显示模式空间中的内容, p放在定界后面。一般来说，p操作和-n选项配合使用，筛选出我们匹配的行。若不加-n的话，由于模式空间中未匹配上的行也会输出，我们会发现所有内容都输出并且匹配行会输出2次； a 在匹配的行后面增加文本，使用\\n支持多行追加，a放在定界后面。举例： sed '1a first_line\\nsecond_line' passwd 在第1行后面插入两行内容(first_line 和 second_line)； i 在匹配的行前面增加文本，i放在定界后面。举例： sed '3i hello' passwd； c 替换匹配行为指定的文本。举例： sed '/root/c text' passwd 把匹配到的行替换成text； w 保存模式空间中匹配的内容到指定位置。举例： sed -n '/^[^#]/w /tmp/demo' /etc/fstab 即将/etc/fstab中非#开头的行输出保存到/tmpdemo中。 r 读取指定文件的内容添加到当前文件匹配到的行后面，进行文件合并。举例： sed '2r /etc/passwd' 1.txt 即将/etc/passwd文件的内容读取，并插入到1.txt文件的第二行处。 ! 条件取反 用法：地址定界!编辑命令。 s/// 条件替换 这里的/可以用其他特殊符号，其替换分隔符的判定标准是s字符后的第一个特殊符号。这在替换文本中涉及特殊符号时特别好使，我们避开需要替换的特殊符号即可。即 sed 's@root@me@g' /etc/passwd 等同于 sed 's/root/me/g' /etc/passwd。 替换标记备注：g(全局替换)，p(显示替换成功的行) 替换举例：根据输入查找目录，下面输出的是/var/log/ echo \"/var/log/messages\" | sed 's@[^/]\\+$/\\?@@' ","date":"2021-01-27","objectID":"/posts/shell-1/:14:2","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"sed高级用法 在模式空间中，完成匹配的操作。当没有匹配上的时候，文本行内容会默认输出stdout；当匹配上文本行的时候，会执行编辑命令，执行结果输出到stdout中 保持空间可以理解为一个暂存区，只是用于完成额外的动作 ","date":"2021-01-27","objectID":"/posts/shell-1/:15:0","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"相关参数 h：把模式空间中的内容覆盖至保持空间中； H：把模式空间中的内容追加至保持空间中； g：把保持空间中的内容覆盖至模式空间中； G：把保持空间中的内容追加至模式空间中； x：把模式空间中的内容与保持空间中的内容互换； n：覆盖读取匹配到的行的下一行(改变指向)至模式空间中； N：追加读取匹配到的行的下一行(改变指向)至模式空间中； d：删除模式空间中的行； D：删除多行模式空间中的所有行； ","date":"2021-01-27","objectID":"/posts/shell-1/:15:1","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"举例 sed -n ’n;p’ FILE：显示偶数行； sed ‘1!G;h;$!d’ FILE：逆序显示文件的内容； sed ‘$!d’ FILE：取出最后一行； sed ‘$!N;$!D’ FILE：取出文件后两行； sed ‘/^$/d;G’ FILE：删除原有的所有空白行，而后为所有的非空白行后添加一个空白行； sed ’n;d’ FILE：显示奇数行； sed ‘G’ FILE：在原有的每行后方添加一个空白行； ","date":"2021-01-27","objectID":"/posts/shell-1/:15:2","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["Shell"],"content":"基础面试题举例 面试题1：提取字符串中的指定字符串 /bin/bash info=\"hellozimskyshenzhen\" echo $info | sed 's/hello\\(\\w\\+\\)shenzhen/\\1/g' 注意事项： sed中不支持\\d，如果要用数字用[0-9]，但是支持\\w。 在一般正则表达式中，sed中的()要转义，+要转义，\u003c\u003e要使用\\转义。如果不想这么麻烦，那就加上-r选项使用扩展正则表达式吧！ 面试题2：判断输入是否为整数 #!/bin/bash if [ -n \"$(echo $1 | sed -n '/^[0-9]\\+$/p')\" ] ; then echo 'yes' else echo 'no' fi awk命令 awk是发明该工具三个作者姓名的首字母简称，awk是一个报表生成器，主要用于格式化输出,格式化文本输出器 参考文献 [1]Linux三剑客及使用介绍 [2]Linux三剑客(grep、sed、awk) [3]linux中grep命令的用法 [4]linux 命令之seq ","date":"2021-01-27","objectID":"/posts/shell-1/:15:3","tags":["Shell语法基础"],"title":"Shell语法","uri":"/posts/shell-1/"},{"categories":["神经网络与深度学习"],"content":"Object Detection Object localization 目标定位 Landmark detection 特征点检测 Object detection 目标检测 Convolution implementation of sliding windows 滑动窗口的卷积实现 Bounding box predictions Bounding Box 预测 Intersection over union 交并比 Non-max suppression 非极大值抑制 Anchor Boxes YOLO Algorithm YOLO算法 Region proposals 候选区域 ","date":"2021-01-25","objectID":"/posts/nndl-18/:0:0","tags":["Andrew NNDL"],"title":"NNDL-目标检测","uri":"/posts/nndl-18/"},{"categories":["神经网络与深度学习"],"content":"Convolution 小辣鸡很懒,所以直接截图划重点了 卷积的理解 ","date":"2021-01-25","objectID":"/posts/nndl-17/:0:0","tags":["Andrew NNDL"],"title":"卷积的理解","uri":"/posts/nndl-17/"},{"categories":["神经网络与深度学习"],"content":"信号分析 ","date":"2021-01-25","objectID":"/posts/nndl-17/:1:0","tags":["Andrew NNDL"],"title":"卷积的理解","uri":"/posts/nndl-17/"},{"categories":["神经网络与深度学习"],"content":"丢骰子 ","date":"2021-01-25","objectID":"/posts/nndl-17/:2:0","tags":["Andrew NNDL"],"title":"卷积的理解","uri":"/posts/nndl-17/"},{"categories":["神经网络与深度学习"],"content":"图像处理-1 ","date":"2021-01-25","objectID":"/posts/nndl-17/:3:0","tags":["Andrew NNDL"],"title":"卷积的理解","uri":"/posts/nndl-17/"},{"categories":["神经网络与深度学习"],"content":"图像处理-2 ","date":"2021-01-25","objectID":"/posts/nndl-17/:4:0","tags":["Andrew NNDL"],"title":"卷积的理解","uri":"/posts/nndl-17/"},{"categories":["神经网络与深度学习"],"content":"ResNet–Face Recognation 项目Github地址 安装踩坑 ","date":"2021-01-24","objectID":"/posts/nndl-16/:0:0","tags":["Andrew NNDL"],"title":"ResNet--人脸识别Demo","uri":"/posts/nndl-16/"},{"categories":["神经网络与深度学习"],"content":"安装dlib pip3 install opencv-python pip3 install scikit-image pip3 install dlib 在安装dlib时报错,提示安装visual studio c++运行库 解决方式 下载对应python3.7的whl文件(注意python版本对应) 在目录下执行 pip3 install dlib-19.17.99-cp37-cp37m-win_amd64.whl ","date":"2021-01-24","objectID":"/posts/nndl-16/:1:0","tags":["Andrew NNDL"],"title":"ResNet--人脸识别Demo","uri":"/posts/nndl-16/"},{"categories":["神经网络与深度学习"],"content":"使用国内镜像 ","date":"2021-01-24","objectID":"/posts/nndl-16/:2:0","tags":["Andrew NNDL"],"title":"ResNet--人脸识别Demo","uri":"/posts/nndl-16/"},{"categories":["神经网络与深度学习"],"content":"单次安装 使用 -i 指定镜像源 pip3 install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2021-01-24","objectID":"/posts/nndl-16/:2:1","tags":["Andrew NNDL"],"title":"ResNet--人脸识别Demo","uri":"/posts/nndl-16/"},{"categories":["神经网络与深度学习"],"content":"Windows文件配置 Windows下，你需要在当前对用户目录下（C:\\Users\\xx\\pip，xx 表示当前使用对用户，比如张三）创建一个 pip.ini在pip.ini文件中输入以下内容： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host = pypi.tuna.tsinghua.edu.cn ","date":"2021-01-24","objectID":"/posts/nndl-16/:2:2","tags":["Andrew NNDL"],"title":"ResNet--人脸识别Demo","uri":"/posts/nndl-16/"},{"categories":["神经网络与深度学习"],"content":"vscode中的pylint对cv2提示报错 参考blog 在vscode的setting中找到参数 Pylint Args 之后添加两项即可 --errors-only --generated-members=numpy.* ,torch.* ,cv2.* , cv.* 参数解释 ","date":"2021-01-24","objectID":"/posts/nndl-16/:3:0","tags":["Andrew NNDL"],"title":"ResNet--人脸识别Demo","uri":"/posts/nndl-16/"},{"categories":["神经网络与深度学习"],"content":"VideoCapture() cap = cv2.VideoCapture(1) #参数为1代表调用外置摄像头,0代表调用本机摄像头(笔记本情况) 参考blog ","date":"2021-01-24","objectID":"/posts/nndl-16/:4:0","tags":["Andrew NNDL"],"title":"ResNet--人脸识别Demo","uri":"/posts/nndl-16/"},{"categories":["神经网络与深度学习"],"content":"Case Studies Why look at case studies? 为什么要进行实力探究 Classic networks 经典网络 LeNet-5 AlexNet VGGNet Residual Networks (ResNets) 残差网络 Why ResNets work? 为什么残差网络有用 Network in Network and 1×1 convolutions 网络中的网络以及1×1卷积 Inception network motivation 谷歌Inception网络简介 Inception network Inception网络 Using open-source implementations 使用开源的实现方案 Transform Learning 迁移学习 Data augmentation 数据增强 The state of computer vision 计算机视觉现状 ","date":"2021-01-21","objectID":"/posts/nndl-15/:0:0","tags":["Andrew NNDL"],"title":"NNDL-神经网络模型实例","uri":"/posts/nndl-15/"},{"categories":["神经网络与深度学习"],"content":"CNN Example One layer of a convolutional network 单层卷积网络 A simple convolution network example 简单卷积网络示例 Pooling layers 池化层 Convolutional neural network example 卷积神经网络示例 Why convolutions? 为什么使用卷积 ","date":"2021-01-20","objectID":"/posts/nndl-14/:0:0","tags":["Andrew NNDL"],"title":"NNDL-CNN实例","uri":"/posts/nndl-14/"},{"categories":["神经网络与深度学习"],"content":"Convolutional Neural Networks Computer vision 计算机视觉 Edge detection example 边缘检测示例 More edge detection 更多边缘检测内容 Padding 图像边界拓展 Strided convolutions 卷积步长 Convolutions over volumes 三维卷积 ","date":"2021-01-19","objectID":"/posts/nndl-13/:0:0","tags":["Andrew NNDL"],"title":"NNDL-卷积神经网络","uri":"/posts/nndl-13/"},{"categories":["神经网络与深度学习"],"content":"Optimization algorithms Mini-batch gradient descent Mini-batch 梯度下降 Understanding mini-batch gradient descent 理解mini-batch梯度下降法 Exponentially weighted averages 指数加权平均数 Understanding exponentially weighted averages 理解指数加权平均数 Bias correction in exponentially weighted averages 指数加权平均的偏差修正 Gradient descent with Momentum 动量梯度下降法 RMSprop Adam optimization algorithm Adam 优化算法 Learning rate decay 学习率衰减 The problem of local optima 局部最优的问题 ","date":"2021-01-18","objectID":"/posts/nndl-12/:0:0","tags":["Andrew NNDL"],"title":"NNDL-梯度下降的优化算法","uri":"/posts/nndl-12/"},{"categories":["人工智能"],"content":"吴恩达老师 - “What is AI” ","date":"2021-01-18","objectID":"/posts/ai-6/:0:0","tags":["Andrew What is AI"],"title":"What is AI","uri":"/posts/ai-6/"},{"categories":["win"],"content":"无法打开注册表项 UNKNOWN\\Components\\… 今天安装MySQL的时候一直提示c++2019运行库安装失败 提示注册表权限不足,之前一直没有遇到这样的问题,google了好久也没有找到解决方法,在心态崩溃的边缘,最后终于找到了一篇博客(呜呜呜) 参考blog 方法一 使用命令提示符解决 win+r打开运行对话框，输入cmd，管理员身份进入命令提示符 执行以下命令 secedit /configure /cfg %windir%\\inf\\defltbase.inf /db defltbase.sdb /verbose 运行完成重新安装 此方法只可解决部分人的问题，当出现下来情况时，表示此方法不起作用，使用第二个方法 任务已结束.在此操作期间,一些属性出现警告,可以忽略此警告 方法二 修改注册表权限 使用组合键 Win+R 打开\"运行\"对话框，输入 regedit 并回车（需管理员权限） 找到这个键值 ： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData 右击\"UserData\" 选择\"权限(P)…\" 点击\"高级(V)“按钮 选定\"Administrators……\"，勾选使用此对象继承的权限项目替换所有子对象的权限项目 点击\"应用(A)\"；将所有者更改为Administrators，注意不是Administrstor。 ","date":"2021-01-17","objectID":"/posts/win-7/:0:0","tags":["win"],"title":"C++运行库安装报错(权限不足)","uri":"/posts/win-7/"},{"categories":["win"],"content":"报错 如果在第5步：勾选-“使用此对象继承的权限项目替换所有子对象的权限项目”-点击应用 出现错误注册表编辑器无法在当前所选的项及其部分子项上设置安全性的弹窗 解决方式 在以下链接中下载psexec 下载好后解压 使用管理员权限打开命令提示符(cmd)，定位到解压的文件夹执行以下命令进入注册表 psexec -i -d -s regedit 然后按照之前操作重复一遍即可 如何定位到解压文件夹： 如解压文件夹为D:\\xxx 在cmd窗口输入 “d:” 切换至D盘（注意要输入冒号） 输入cd 解压文件夹路径，即可 ","date":"2021-01-17","objectID":"/posts/win-7/:1:0","tags":["win"],"title":"C++运行库安装报错(权限不足)","uri":"/posts/win-7/"},{"categories":["神经网络与深度学习"],"content":"Gradients Vanishing/Exploding gradients 梯度消失/梯度爆炸 Weight Initialization for Deep NetworksVanishing / Exploding gradients 神经网络的权重初始化 Numerical approximation of gradients 梯度的数值逼近 Gradient Checking 梯度检验 Gradient Checking Implementation Notes 梯度检验应用的注意事项 ","date":"2021-01-15","objectID":"/posts/nndl-11/:0:0","tags":["Andrew NNDL"],"title":"NNDL-梯度计算","uri":"/posts/nndl-11/"},{"categories":["神经网络与深度学习"],"content":"Regularization 基本概念 Why regularization reduces overfitting? 为什么正则化有利于预防过拟合 Dropout Regularization dropout正则化 Understanding Dropout 理解dropout Other regularization methods 其他正则化方法 Normalizing inputs 归一化输入 ","date":"2021-01-15","objectID":"/posts/nndl-10/:0:0","tags":["Andrew NNDL"],"title":"NNDL-正则化","uri":"/posts/nndl-10/"},{"categories":["神经网络与深度学习"],"content":"Bias/Variance Train / Dev / Test sets 训练，验证，测试集 Bias /Variance 偏差，方差 Basic Recipe for Machine Learning 机器学习基础 ","date":"2021-01-13","objectID":"/posts/nndl-9/:0:0","tags":["Andrew NNDL"],"title":"NNDL-偏差/方差","uri":"/posts/nndl-9/"},{"categories":["神经网络与深度学习"],"content":"Deep Neural Networks Deep L-layer neural network 深层神经网络 Forward and backward propagation 前向传播和反向传播 Forward propagation in a Deep Network 深层网络中的前向传播 Why deep representations? 为什么使用深层表示 Building blocks of deep neural networks 搭建神经网络块 Parameters vs Hyperparameters 参数VS超参数 What does this have to do with the brain? 深度学习和大脑的关联性 ","date":"2021-01-09","objectID":"/posts/nndl-8/:0:0","tags":["Andrew NNDL"],"title":"NNDL-深层神经网络","uri":"/posts/nndl-8/"},{"categories":["神经网络与深度学习"],"content":"BackPropagation Algorithm BackPropagation(反向传播) ","date":"2021-01-09","objectID":"/posts/nndl-2/:0:0","tags":["Andrew NNDL"],"title":"NNDL-反向传播","uri":"/posts/nndl-2/"},{"categories":["神经网络与深度学习"],"content":"视频来源 3Blue1Brown 计算过程 典型的三层神经网络的基本构成 Layer L1是输入层 Layer L2是隐含层 Layer L3是隐含层 我们现在手里有一堆数据{x1,x2,x3,…,xn},输出也是一堆数据{y1,y2,y3,…,yn},现在要他们在隐含层做某种变换，让你把数据灌进去后得到你期望的输出 ","date":"2021-01-09","objectID":"/posts/nndl-2/:1:0","tags":["Andrew NNDL"],"title":"NNDL-反向传播","uri":"/posts/nndl-2/"},{"categories":["神经网络与深度学习"],"content":"神经网络BP算法详解 BP详解 总结 资料参考Blog ","date":"2021-01-09","objectID":"/posts/nndl-2/:2:0","tags":["Andrew NNDL"],"title":"NNDL-反向传播","uri":"/posts/nndl-2/"},{"categories":["神经网络与深度学习"],"content":"Gradient Descent 懒狗小辣鸡继续搬运 运用梯度下降并配合反向传播可以取到模型的最优解,实现神经网络参数的确定 浅层神经网络梯度下降 ","date":"2021-01-09","objectID":"/posts/nndl-6/:0:0","tags":["Andrew NNDL"],"title":"NNDL-梯度下降","uri":"/posts/nndl-6/"},{"categories":["神经网络与深度学习"],"content":"Shallow neural networks Neural Network Overview 正向传播计算损失函数,反向传播计算偏导调整参数 Neural Network Representation Computing a Neural Network’s output Computing a Neural Network’s output Vectorizing across multiple examples 多样本向量化 Justification for vectorized implementation 向量化实现的解释 Activation functions 激活函数 ","date":"2021-01-08","objectID":"/posts/nndl-7/:0:0","tags":["Andrew NNDL"],"title":"NNDL-浅层神经网络","uri":"/posts/nndl-7/"},{"categories":["神经网络与深度学习"],"content":"Derivatives of activation functions 激活函数的导数 ","date":"2021-01-08","objectID":"/posts/nndl-7/:1:0","tags":["Andrew NNDL"],"title":"NNDL-浅层神经网络","uri":"/posts/nndl-7/"},{"categories":["HEXO"],"content":"Hexo Mathjax大括号公式渲染问题 双斜杠\"\\“换行失败 ","date":"2021-01-07","objectID":"/posts/hexo-6/:0:0","tags":["HEXO-NEXT"],"title":"Hexo-Mathjax渲染Bug","uri":"/posts/hexo-6/"},{"categories":["HEXO"],"content":"解决方式 更换渲染引擎 npm uninstall --save hexo-renderer-marked npm install --save hexo-renderer-kramed 多行公式需要使用两个”$$\" $$\\left \\lbrace\\begin{matrix} h_\\Theta(X)\u003e0.5, set h_\\Theta(X) = 1\\\\ h_\\Theta(X)\u003c0.5, set h_\\Theta(X) = 0 \\end{matrix} \\right.$$ $$\\left \\lbrace\\begin{matrix} h_\\Theta(X)\u003e0.5, set h_\\Theta(X) = 1\\ h_\\Theta(X)\u003c0.5, set h_\\Theta(X) = 0 \\end{matrix} \\right.$$ 左括号渲染失败 $U=\\{ A_1,A_2,\\cdots,A_n \\} $ #渲染失败 ","date":"2021-01-07","objectID":"/posts/hexo-6/:1:0","tags":["HEXO-NEXT"],"title":"Hexo-Mathjax渲染Bug","uri":"/posts/hexo-6/"},{"categories":["HEXO"],"content":"解决方案 不要使用 \\{ \\} 使用 \\lbrace \\rbrace ","date":"2021-01-07","objectID":"/posts/hexo-6/:2:0","tags":["HEXO-NEXT"],"title":"Hexo-Mathjax渲染Bug","uri":"/posts/hexo-6/"},{"categories":["神经网络与深度学习"],"content":"Explanation of logistic regression cost function 我懒得抄了,直接搬运了嘿嘿(我是懒狗 原文 笔记 ","date":"2021-01-07","objectID":"/posts/nndl-5/:0:0","tags":["Andrew NNDL"],"title":"NNDL-逻辑回归函数的推导","uri":"/posts/nndl-5/"},{"categories":["人工智能"],"content":"Constraint Satisfaction Problems 搜索问题，是一种规划问题(planning problem)的最优解 约束满足问题（constraint satisfaction problems）(CSPSs).与搜索问题不同，CSP是一种识别问题（identification problem），对这种问题，我们只需要识别一个状态是否是目标状态，不用管我们如何到达那个目标。CSPs由三个要素定义： 变量Variables：CSP拥有一个集合，其中有N个变量$X_1,X_2,…X_N$，每一个都可以从定义的一组值中取一个值。 域Domain：一个CSP变量所有可能取值的集合${x_1,x_2…x_d}$ 约束Constrains：约束定义了变量取值的限制条件，这可能与其他变量有关。 ","date":"2021-01-05","objectID":"/posts/ai-5/:0:0","tags":["Berkeley CS-188"],"title":"AI-CSP","uri":"/posts/ai-5/"},{"categories":["人工智能"],"content":"heuristic algorithm 启发式算法的概念 启发式算法（heuristic algorithm)是相对于最优化算法提出的。一个问题的最优算法求得该问题每个实例的最优解。启发式算法可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。现阶段，启发式算法以仿自然体算法为主，主要有蚁群算法、模拟退火法、神经网络等。 百度百科 启发式算法概念 启发式函数的使用 启发式函数h(n)告诉A*从任意结点n到目标点的最小代价评估值 因此，选择一个好的启发式函数是重要的 情况 函数 结果 h(n) = 0 A*演变为Dijkstra算法 保证能找到最短路径(但是运算时间长) h(n)\u003c=实际代价 h(n)越小,A*扩展的结点越多,运算减慢 能找到一条最短路径,运算速度更快 h(n)=实际代价 仅仅寻找最佳路径而不扩展其他结点 保证能找到一条最短路径,运算时间最短 h(n)\u003e实际代价 寻找最短路径且扩展别的结点 不能保证找到一条最短路径,但运算更快 h(n)»g(n) A*演变为BFS算法 不能保证找到一条最短路径,但运算非常快 所以得到一个很有趣的情况，那就是可以决定想要从A* 中获得什么 理想情况下，想最快地得到最短路径 如果目标太低，仍会得到最短路径，不过速度变慢了 如果目标太高，那就放弃了最短路径，但A 运行得更快* A*的这个特性非常有用，例如 在某些情况下，希望得到一条好的路径-“good”path,而不是一条完美的路径-“perfect” path 为了权衡g(n)和h(n)，可以修改任意一个的权重 在学术上，如果启发式函数值是对实际代价的低估，A算法被称为简单的A算法（simply A） 然而，继续称之为A，因为在实现上是一样的，并且在编程领域并不区别A和A* 权衡代价函数 A* 改变它自己行为的能力基于启发式代价函数 在速度和精确度之间取得折衷将会让搜索运行得更快 在搜索中，并不真正需要得到最好的路径，仅需要近似的就足够了 而需要什么则取决于路径搜索中发生着什么，或者运行路径搜索的机器有多快 假设路径搜索的地图中有两种地形：平原和山地 有可能有一条沿着平原到山地的路径 在平原中的移动代价是1，而在山地则是3 把两个邻接点之间的评估距离设为1.5可以加速A* 的搜索过程 然后A* 会将3和1.5比较，这并不比把3和1比较差 速度和精确度之间的选择前不是静态的 可以基于CPU的速度、用于路径搜索的时间片数、地图上物体的数量、物体的重要性、组（group）的大小、难度或者其他任何因素来进行动态的选择 取得动态的折衷的一个方法是： 建立一个启发式函数用于假定通过一个网格空间的最小代价是1 然后建立一个代价函数（cost function）用于测量（scales）： g′(n) = 1 + alpha∗(g (n)–1) 改变最短路径搜索算法的代价 如果alpha是0，则改进后的代价函数的值总是1，地形代价被完全忽略，简单地判断一个网格可否通过 如果alpha是1，则最初的最短路径搜索算法代价函数将起作用，然后得到了A*的所有优点 也可以考虑对启发式函数的返回值做选择：绝对最小代价或者期望最小代价.例如，如果地图大部分地形是代价为2的草地，其它一些地方是代价为1的道路.那么可以考虑让启发式函数不考虑道路，而只返回2*距离 当然，速度和精确度之间的选择并不是全局的 衡量单位 A* 计算f(n)=g(n)+h(n) 为了对这两个值进行相加，这两个值必须使用相同的衡量单位 如果g(n)用小时来衡量而h(n)用米来衡量，那么A* 将会认为g或者h太大或者太小 因而将不能得到正确的路径，同时A* 算法将运行得更慢 因此优化启发式算法的过程就是找到一个合适的f(n)函数,而在寻找的过程也需要进行大量计算 精确的启发式函数 如果启发式函数精确地等于实际最佳路径（optimal path） 此时A*扩展的结点将非常少 A* 算法内部发生的事情是： 在每一结点它都计算f(n)=g(n)+h(n) 当h(n)精确地和g(n)匹配时，f(n)的值在沿着该路径时将不会改变 不在最短路径上，所有结点的f(n)值均大于最短路径上的f(n)值 如果已经有较低f(n)值的结点，A* 将不考虑f(n)值较高的结点 因此它肯定不会偏离最短路径 ","date":"2021-01-05","objectID":"/posts/ai-4/:0:0","tags":["Berkeley CS-188"],"title":"AI-Heuristic Algorithm","uri":"/posts/ai-4/"},{"categories":["人工智能"],"content":"预计算的精确启发式函数 构造精确启发函数的一种方法： 预先计算任意一对结点之间最短路径的长度 然后添加一个启发函数 h ′ h’ h′用于评估从任意位置n到达邻近导航点（waypoints）的代价 最终的启发式函数：h(n)=h′(n,w1)+distance(w1,w2)+h′(w2,goal) 或者如果希望一个更好但更昂贵的启发式函数 则分别用靠近结点和目标的 所有的w1，w2对 对上式进行求值 ","date":"2021-01-05","objectID":"/posts/ai-4/:1:0","tags":["Berkeley CS-188"],"title":"AI-Heuristic Algorithm","uri":"/posts/ai-4/"},{"categories":["人工智能"],"content":"线性精确启发式算法 在特殊情况下，可以不通过预计算而让启发式函数很精确 如果有一个不存在障碍物和平缓地形 那么从初始点到目标的最短路径应该是一条直线 如果正使用简单的启发式函数（不知道地图上的障碍物） 则它应该和精确的启发式函数相符合 如果不是这样，则会遇到衡量单位的问题，或者所选择的启发函数类型的问题 参考博客-1 参考博客-2 ","date":"2021-01-05","objectID":"/posts/ai-4/:2:0","tags":["Berkeley CS-188"],"title":"AI-Heuristic Algorithm","uri":"/posts/ai-4/"},{"categories":["人工智能"],"content":"Berkeley CS-188 A算法 A*(A-Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法 A算法公式表示为：f(n)=g(n)+h(n)其中 f(n) 是从初始点经由节点n到目标点的估价函 g(n) 是在状态空间中从初始节点到n节点的实际代价 h(n) 是从n到目标节点最佳路径的估计代价 启发信息给得越多（估价函数值越大），则A算法需要搜索处理的状态数就越少，效率就越高。但并不是估计值越大越好，有时估价函数值太大会使A算法不一定搜索到最优解。(局部最优解) A*算法 A* 算法公式：f*(n) = g* (n) + h* (n) g* (n)是从初始结点到n结点的最短路径代价 h* (n)是从n结点到目的结点的最佳路径代价 当我们要求估价函数f(n)中的**h(n)都小于等于h*(n)*即： h(n) \u003c= h(n)时 A搜索算法就成为A*搜索算法，所得路径为最优路径。 大佬的讲解 实例 问题分析：从节点A开始搜索至#节点，该节点对应的h* (n)即为该城市到目标城市的直线距离（即最佳路径代价），从A点到#节点走过的实际距离（即最短路径代价）则为g* (n)。 每次搜索节点查找最小的g* (n) + h* (n) #include\u003cstdio.h\u003e#include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cstring\u003eint city_num=0;//城市数目 int g[100][100];//存储城市间实际距离的邻接矩阵 int closeNum=0;//close表大小 int track[100];//行驶路径 int tra_num=0;//途径城市的数目 typedef struct node//代表城市的结构体 { int data; //城市名 int num;//估价函数值 struct node *next; //存储下一个结点的地址 int fa;//上一个城市 }LinkList; typedef struct distance { char city; int dist; }dis;//存储实际距离和数字与城市名的对应关系 dis h[100]; LinkList *head,*p,*q; void INITLIST(LinkList *L){ // L=(LinkList*)malloc(sizeof(LinkList)); //判断是否申请成功 if(!L){ printf(\"无内存空间可分配\");exit(0);} L-\u003enext=NULL; } //INITLIST LinkList close[100];//close表 void Init()//初始化，主要是将文件中的内容读入 { FILE *stream=fopen(\"text.txt\",\"r\"); int initNum=0;//城市数目 if(stream==NULL) printf(\"The file fscanf.out was not opened\\n\"); else { while(fscanf(stream,\"%d%c\",\u0026h[initNum].dist,\u0026h[initNum].city) !=EOF){//h数组存储各城市到达目标城市的直线距离 initNum++; } city_num=initNum; fclose(stream); } FILE *stream2=fopen(\"map.txt\",\"r\"); //int initNum=0; if(stream2==NULL) printf(\"The file fscanf.out was not opened\\n\"); else { for(int i=0;i\u003cinitNum;i++){ for(int j=0;j\u003cinitNum;j++){ if(fscanf(stream,\"%d\",\u0026g[i][j]) !=EOF) //initNum++; continue; } } fclose(stream); } } int Initend()//仅仅是为了找到目标城市而已 { for(int i=0;i\u003ccity_num;i++){ if(h[i].dist==0) return i; } return -1; } int find(char c){ for(int i=0;i\u003ccity_num;i++){ if(h[i].city==c) return i; } return -1; } void addOpen(LinkList *p,int a,int dis,int f)//将走过的节点加入到open表 { LinkList *q; //p =(LinkList *)malloc(sizeof(LinkList)); //q =(LinkList *)malloc(sizeof(LinkList)); q=head; p-\u003edata=a; p-\u003efa=f; p-\u003enum=dis+h[a].dist; while(1){ if(q-\u003enext==NULL||q-\u003enext-\u003enum\u003ep-\u003enum){ p-\u003enext=q-\u003enext; q-\u003enext=p; return; } q=q-\u003enext; } } void deleteOpen(int n)//将重新找到更短的路径从open表替换 { LinkList *r; r=head; while(r-\u003enext!=NULL){ if(r-\u003enext-\u003edata==n){ r-\u003enext=r-\u003enext-\u003enext; return; } else { r=r-\u003enext; } } return; } int findClose(int a)//查找某城市是否在close表中 { for(int i=0;i\u003ccity_num;i++){ if(close[i].data==a) return i; } return -1; } void deleteclose(int n)//在需要时从close表中转移出来 { for(int i=0;i\u003ccloseNum;i++){ if(close[i].data==n){ close[i].data=close[closeNum-1].data; close[i].num=close[closeNum-1].num; closeNum--; return; } } return; } int findOpen(int n,int dis)//查找某节点是否在open表中 { LinkList *r; r=head; int i=0; while(r-\u003enext!=NULL){ if(r-\u003enext-\u003edata==n){ if(r-\u003enext-\u003enum\u003edis+h[n].dist) return 1; else return 0; } else { r=r-\u003enext; i++; } } return -1; } void Track()//形成track表 { int a,b; track[tra_num++]=head-\u003enext-\u003edata; b=head-\u003enext-\u003efa; track[tra_num++]=b; while(1){ for(int i=0;i\u003ccloseNum;i++){ if(close[i].data==b){ if(close[i].fa==-1) return; b=close[i].fa; track[tra_num++]=b; break; } } } } int main(){ Init(); char name; int end; printf(\"输入初始城市:\"); scanf(\"%c\",\u0026name); end=Initend();//找到目标城市 head =(LinkList *)malloc(sizeof(LinkList)); INITLIST(head);//初始化open表 p =(LinkList *)malloc(sizeof(LinkList));//... p-\u003enext=head-\u003enext; head-\u003enext=p; p-\u003enum=h[find(name)].dist; p-\u003edata=find(name); p-\u003efa=-1;//...起点城市入open表 LinkList *t; while(head-\u003enext-\u003edata!=end){ t=head-\u003enext; //addTrack(t); head-\u003enext=t-\u003enext;//open表头入close表 close[closeNum].data=t-\u003edata; close[closeNum].num=t-\u003enum; close[closeNum++].fa=t-\u003efa; //printf(\"%d\\n\",t-\u003edata); for(int i=0;i\u003ccity_num;i++){ if(g[t-\u003edata][i]!=0){//如果找到与此城市相连的城市\u0026\u0026不在close表中 p =(LinkList *)malloc(sizeof(LinkList)); if(findClose(i)==-1\u0026\u0026findOpen(i,t-\u003enum-h[t-\u003edata].dist+g[t-\u003edata][i])==-1){ addOpen(p,i,t-\u003enum-h[t-\u003edata].dist+g[t-\u003edata][i],t-\u003edata);//添加到open表中（城市序号，到此城市要走的路） } if(findOpen(i,t-\u003enu","date":"2021-01-05","objectID":"/posts/ai-3/:0:0","tags":["Berkeley CS-188"],"title":"AI-A* Algorithm","uri":"/posts/ai-3/"},{"categories":["人工智能"],"content":"Berkeley CS-188 Informed Search(有信息搜索) 一致代价搜索很棒，因为它兼顾了完备性和最优性。但它也可能会相当的慢，因为它在搜索一个目标时向所有方向扩展。如果我们对于我们应该搜索的方向有一定的了解，我们就能显著提高性能并更快地达到目标。这就是有信息搜索。 Heuristics 启发式搜索 启发式搜索是允许估计到目标状态距离的驱动力——它们是将状态作为输入并输出相应估计的函数。由这样一个函数执行的计算是专门针对所解决的搜索问题的。由于一些我们将在A*搜索中见到的原因，下面，我们一般希望启发函数是到达目标剩余距离的下界，因此启发式搜索通常是松弛问题（relaxed problems）（其中原问题的一些限制被移除了）的解决办法。回到我们的吃豆人例子，我们来考虑一下前面描述的路径规划问题。用来解决这个问题的一个通用方法是曼哈顿距离法（Manhattan Distance），对于两个点$(x_1,y_1)$和$(x_2,y_2)$的定义为： ","date":"2021-01-04","objectID":"/posts/ai-2/:0:0","tags":["Berkeley CS-188"],"title":"AI-Informed Search","uri":"/posts/ai-2/"},{"categories":["人工智能"],"content":"Manhattan Distance 曼哈顿距离的命名原因是从规划为方型建筑区块的城市（如曼哈顿）间，最短的行车路径而来（忽略曼哈顿的单向车道以及只存在于3、14大道的斜向车道）。任何往东三区块、往北六区块的的路径一定最少要走九区块，没有其他捷径。 $dis(x_1,y_1,x_2,y_2) = |x_1-x_2|+|y_1-y_2|$ 欧氏距离: $dis = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$ ","date":"2021-01-04","objectID":"/posts/ai-2/:1:0","tags":["Berkeley CS-188"],"title":"AI-Informed Search","uri":"/posts/ai-2/"},{"categories":["人工智能"],"content":"偏好性 上图表示了曼哈顿距离帮助解决的松弛问题——假设吃豆人想到达迷宫的左下角，它在计算了假设没有墙的情况下从吃豆人现在的位置到目标位置的距离。这个距离是松弛搜索问题中的精确（exact）距离，而相应的在实际的搜索问题中的是估计（estimated）目标距离。有了启发式搜索，在我们的agent中实现逻辑变得很简单，这使它们在决定执行哪个操作时能“偏好”在估计中离目标状态比较近的扩展状态。这个偏好的概念非常有用，并且在以下两种搜索算法中都有利用到它：贪婪搜索和A*搜索。 Greedy Search 描述：贪婪搜索总是选择有最小启发值（lowest heuristic value）的节点来扩展，这些节点对应的是它认为最接近目标的状态。 边缘描述：贪婪搜索的操作和UCS相同，具有优先队列边缘表示。不同之处在于，贪婪搜索使用估计前进代价（estimated forward cost），而不是计算后退代价（computed backward cost）（通往状态的路径上各边的权重之和）。 完备性和最优性：如果存在一个目标状态，贪婪搜索无法保证能找到它，它也不是最优的，尤其是在选择了非常糟糕的启发函数的情况下。在不同场景中。它的行为通常是不可预测的，有可能一路直奔目标状态，也有可能像一个被错误引导的DFS一样并遍历所有的错误区域。 A* Search 描述：A*搜索总是选择有最低估计总代价（lowest estimated total cost）的边缘节点来扩展，其中总代价是指从起始节点到目标节点的全部代价。 边缘表示：和贪婪搜索及UCS一样，A* 搜索也用一个优先队列来表示它的边缘。和之前一样，唯一的区别在于优先权选择的方法。A*搜索将UCS使用的全部后退代价（到达状态的路径上各边权重之和）和贪婪搜索使用的估计前进代价（启发值）通过相加联合起来，有效地得到了从起始到目标的估计总代价（estimated total value）。由于我们想将从起始到目标的总代价最小化，这是一个很好的选择。 完备性和最优性：在给定一个合适的启发函数（我们很快就能得到）时，A*搜索既是完备的又是最优的。它结合了目前我们发现的所有其他搜索策略的优点，兼备贪婪搜索的高搜索速度以及UCS的完备性和最优性。 Admissibility and Consistency 可纳性和一致性 现在我们已经讨论了启发式搜索以及它在贪婪和A* 搜索中应用的，接下来我们来花些时间讨论一下一个好的启发式是由什么构成的。为此，我们首先重新定义UCS、贪婪搜索和A* 中用于确定优先级队列顺序的方法，定义如下： g(n)：UCS计算的总后退代价函数。 h(n)：贪婪搜索使用的启发值函数，或者说估计前进代价函数。 f(n)：A*搜索使用的估计总代价函数。 F(n) = g(n)+h(n) 在回答一个“好的”启发式由什么构成这个问题之前，我们必须先抛开我们使用的启发式函数，思考一下A是否保持了它的完备性和最优性的特点。的确，很容易就能找到失去了这两个黄金特点的启发式。举个例子，考虑一下启发函数$h(n) = 1-g(n)$。先不谈搜索问题，用这个启发式能得到 $f(n) = g(n)+h(n)$ $ = g(n)+(1-g(n))$ $ = 1$ 于是，这样的一个启发式将A退化为了BFS，所有代价都相等了。我们之前已经说明了，BFS在边的权重不恒定的通常情况下不能保证是最优的。 ","date":"2021-01-04","objectID":"/posts/ai-2/:2:0","tags":["Berkeley CS-188"],"title":"AI-Informed Search","uri":"/posts/ai-2/"},{"categories":["人工智能"],"content":"admissibility 使用A* 树搜索时，最优性所需的条件称为可纳性（admissibility）。可纳性约束表明，用一个可纳的启发式估算的值既不是负的，也不会被高估。定义 $h^(n)$ 为从一个给定节点n到达目标状态的真正的最佳前进代价，我们能将可纳性约束数学表示为： $\\forall n, 0\\leq h(n)\\leq h^(n)$ 定理: 对于一个给定的搜索问题，如果一个启发式函数h满足可纳性约束，使用含有h的A*树搜索能得到最优解。 证明: 假设两个可以到达的目标状态，最优目标A和次优目标B在一个给定的搜索问题的搜索树中。因为可以从初始状态到达A，A的某个祖先节点n（有可能是A本身）现在一定在边缘上。用以下三个陈述，我们可以断定n会在B之前被选来扩展 $g(A)\u003cg(B)$ 因为A是最优而B是次优，我们能得出A到达起始状态的后退代价低于B。 $h(A) = h(B) = 0$ 因为已知我们的启发式满足可纳性约束。因为A和B都是目标状态，从A或B到达目标状态的真实最优代价就是$h^*(n) = 0$。因此$0\\leq h(n)\\leq0$。 $f(n)\\leq f(A)$，虽然h有可纳性,$f(n) = g(n)+h(n)\\leq g(n)+h*(n) = g(A) = f(A)$。穿过节点n的总代价最大是A的真实后退代价，也就是A的总代价。 我们通过陈述1和2得到$f(A)\u003cf(B) = f(A)+h(A)\u003cf(B)+h(B)$ 由此，我们知道n在B之前被扩展。因为我们已经证明了对任意n均有这个结论，我们能得出结论：A所有的祖先（包括A自己）都在B之前扩展。 我们在上面发现树搜索有一个问题，那就是有些情况下它可能会找不到解，在状态空间图中陷入同一个环中无限地搜索下去。即使是在我们的搜索技术不涉及这样一个无限循环的情况下，因为有多个路径能到达同一个点，我们经常会多次访问同一个节点。这导致工作量指数上升，而自然地解决方案只是简单地跟踪哪些状态已经扩展过，并且永远不再扩展它们。更明确地讲，在使用你选择的方法的同时维持一个**“封闭”的扩展节点集**。然后，确保每一个节点在扩展前不在这个集合中，并且在扩展后将其加入集合里。经过这种优化的树搜索称为**图搜索（graph search）**伪代码为: 注意在实现时，很重要的一点是将封闭集存储为一个不相交集合而不是一个队列。将它存储为队列需要花费O(n)个操作来检查资格（membership），这会抵消图搜索本来的优势。关于图搜索，另一个需要注意的是即使是在可纳的启发式下，它也会破坏A*的最优性。思考一下下面这个简单的状态空间图和相应的搜索树，启发值和权重都已标出： ","date":"2021-01-04","objectID":"/posts/ai-2/:3:0","tags":["Berkeley CS-188"],"title":"AI-Informed Search","uri":"/posts/ai-2/"},{"categories":["人工智能"],"content":"consistency 在上面这个例子中，最佳路径显然是S→A→C→G，得到总路径代价为1+1+3=5.仅有的另一条到达目标的路径，S→B→C→G的代价为1+2+3=6.然而，因为节点A的启发值比B大得多，节点C首先作为节点B的孩子沿着次优路径扩展。然后它才被放入“封闭”集，所以A* 在把它当做A的孩子访问它时无法重新扩展它，导致它永远无法找到最优解。于是，为了维持A*搜索下的完备性和最优性，我们需要一个比可纳性更强的性质，一致性（consistency）知乎:一致性的解释。一致性的核心思想在于，我们不仅仅强制让启发式算法低估从任意给定节点到目标的总距离，还低估了图中每一条边的代价/权重。由启发式函数度量的边的代价只是两个连接的节点的启发值的差异。一致性约束的数学表示如下： $\\forall A,C h(A)-h(C)\\leq cost(A,C)$ 定理. 对于一个给定的搜索问题，如果启发式函数h满足一致性约束，对这个搜索问题使用有h的A*图搜索能得到一个最优解。 证明详解 Dominance 优势 现在我们已经建立了可纳性和一致性的性质以及它们在保持A*搜索的最优性中扮演的角色，我们能够回到我们最初的问题，创建“好”的启发式以及如何比较启发式之间的优劣。衡量这个的标准就是优势（dominance）。如果启发式a相对于启发式b而言有优势，那么对状态空间图中的所有节点，a的估计目标距离都比b要好。数学表示为: $\\forall n:h_a(n)\\geq h_b(n)$ 优势能非常直观地表示一个启发式比另一个好的概念——如果一个可纳/一致的启发式对另一个有优势，它肯定更好，因为它总是能更准确地估计从任何给定状态到目标的距离。除此之外，微启发式（trivial heuristic）被定义为$h(n) = 0$，使用它会将A*搜索退化为UCS。所有可纳启发式都比这个微启发式有优势。对于一个搜索问题，在搜索问题中通常在的基础上加入微启发式，在半网格基础上又加入了一个优势等级序列。下面是一个结合了不同启发式$h_a$，$h_b$ 和 $h_c$的半网格，它们的范围是从最底下的微启发式到最顶端的精确目标距离。 image:5.png 一般地，应用于多个可纳启发式的最大函数同样总是可纳的。这只是启发式算法为任意给定的由可纳条件约束的状态输出的所有值中的一种结果，$0\\leq h(n) \\leq h^*(n)$。在这个范围内的最大数也必须落在同样的范围内。对于多个一致启发式，同样的情况也很容易被证明。为任何给定的搜索问题生成多个可纳/一致启发式，并且计算由它们输出的最大值来生成一个相比较它们中的任何一个都有优势（也更好）的启发式，这是一个惯例。 BFS宽度优先搜索 DFS深度优先搜索 UCS一致代价搜索 贪婪搜索 A*搜索 前三种搜索技术都属于无信息搜索（uninformed search），而后两种都是通过启发式（heuristics）来估计目标距离并完善性能的有信息搜索（informed search）。 ","date":"2021-01-04","objectID":"/posts/ai-2/:4:0","tags":["Berkeley CS-188"],"title":"AI-Informed Search","uri":"/posts/ai-2/"},{"categories":["神经网络与深度学习"],"content":"数据的向量化处理以及Python Broadcasting 向量化处理的原因 为什么向量化会更快 摘自一个回答: Numpy运算是向量化的，进行是CPU指令集层面的并行运算，for循环是串行运算，效率肯定差多了。想象一下，一个大矩阵做运算，for循环是一次提取两个值，放入内存运算后返回结果，再提取2个再运算返回结果，如果循环。Numpy是一次性把所有值都提入内存同时运算同时返回结果，效率肯定不一样。向量化的优势是快，劣势是费内存，矩阵太大就放不进去了。for循环一次2个值多大都能算，就是太慢没法实用。科学计算都是向量化的，for循环只用于工业界软件开发等数据不大但对运行环境有资源限制的地方。 向量化(Vectorization) 向量化是非常基础的去除代码中for循环的艺术，在深度学习安全领域、深度学习实践中，你会经常发现自己训练大数据集，因为深度学习算法处理大数据集效果很棒，所以你的代码运行速度非常重要，否则如果在大数据集上，你的代码可能花费很长时间去运行，你将要等待非常长的时间去得到结果。所以在深度学习领域，运行向量化是一个关键的技巧，让我们举个栗子说明什么是向量化。 在逻辑回归中你需要去计算$z = s^Tx+b, w,x$都是列向量,如果你有很多的特征那么就会有一个非常大的向量,所以如果你想使用非向量化去计算$w^Tx$你需要用python ​x z=0 for i in range(n_x) z+=w[i]*x[i] z+=b 这是一个非向量化的实现，你会发现这真的很慢，作为一个对比，向量化实现将会非常直接计算w^Tx，代码如下： z=np.dot(w,x)+b import numpy as np #导入numpy库 a = np.array([1,2,3,4]) #创建一个数据a print(a) # [1 2 3 4] import time #导入时间库 a = np.random.rand(1000000) b = np.random.rand(1000000) #通过round随机得到两个一百万维度的数组 tic = time.time() #现在测量一下当前时间 #向量化的版本 c = np.dot(a,b) toc = time.time() print(“Vectorized version:” + str(1000*(toc-tic)) +”ms”) #打印一下向量化的版本的时间 #继续增加非向量化的版本 c = 0 tic = time.time() for i in range(1000000): c += a[i]*b[i] toc = time.time() print(c) print(“For loop:” + str(1000*(toc-tic)) + “ms”)#打印for循环的版本的时间 在两个方法中，向量化和非向量化计算了相同的值，如你所见，向量化版本花费了1.5毫秒，非向量化版本的for循环花费了大约几乎500毫秒，非向量化版本多花费了300倍时间。所以在这个例子中，仅仅是向量化你的代码，就会运行300倍快。这意味着如果向量化方法需要花费一分钟去运行的数据，for循环将会花费5个小时去运行。 一句话总结，以上都是再说和for循环相比，向量化可以快速得到结果。 你可能听过很多类似如下的话，“大规模的深度学习使用了GPU或者图像处理单元实现”，但是我做的所有的案例都是在jupyter notebook上面实现，这里只有CPU，CPU和GPU都有并行化的指令，他们有时候会叫做SIMD指令，这个代表了一个单独指令多维数据，这个的基础意义是，如果你使用了built-in函数,像np.function或者并不要求你实现循环的函数，它可以让python的充分利用并行化计算，这是事实在GPU和CPU上面计算，GPU更加擅长SIMD计算，但是CPU事实上也不是太差，可能没有GPU那么擅长吧。接下来的视频中，你将看到向量化怎么能够加速你的代码，经验法则是，无论什么时候，避免使用明确的for循环。 向量乘法 ","date":"2021-01-04","objectID":"/posts/nndl-4/:0:0","tags":["Andrew NNDL"],"title":"NNDL-向量化","uri":"/posts/nndl-4/"},{"categories":["神经网络与深度学习"],"content":"向量的内积(点乘) ","date":"2021-01-04","objectID":"/posts/nndl-4/:1:0","tags":["Andrew NNDL"],"title":"NNDL-向量化","uri":"/posts/nndl-4/"},{"categories":["神经网络与深度学习"],"content":"定义 概括地说，向量的内积（点乘/数量积）。对两个向量执行点乘运算，就是对这两个向量对应位一一相乘之后求和的操作，如下所示，对于向量a和向量b： $a = [a_1,a_2,a_3…a_n] b = [b_1,b_2,b_3…b_n]$ 因此a和b的点积为 $a·b = a_1b_1+a_2b_2+a_3b_3…+a_nb_n$ 这里要求一维向量a和向量b的行列数相同。注意：点乘的结果是一个标量(数量而不是向量) 定义：两个向量a与b的内积为 a·b = |a||b|cos∠(a, b)，特别地，0·a =a·0 = 0；若a，b是非零向量，则a与b****正交的充要条件是a·b = 0。 ","date":"2021-01-04","objectID":"/posts/nndl-4/:1:1","tags":["Andrew NNDL"],"title":"NNDL-向量化","uri":"/posts/nndl-4/"},{"categories":["神经网络与深度学习"],"content":"向量内积的性质： a^2 ≥ 0；当a^2 = 0时，必有a = 0. （正定性） a·b = b·a. （对称性） (λa + μb)·c = λa·c + μb·c，对任意实数λ, μ成立. （线性） cos∠(a,b) =a·b/(|a||b|). |a·b| ≤ |a||b|，等号只在a与b共线时成立. ","date":"2021-01-04","objectID":"/posts/nndl-4/:1:2","tags":["Andrew NNDL"],"title":"NNDL-向量化","uri":"/posts/nndl-4/"},{"categories":["神经网络与深度学习"],"content":"向量内积的几何意义 内积（点乘）的几何意义包括： 表征或计算两个向量之间的夹角 b向量在a向量方向上的投影 ","date":"2021-01-04","objectID":"/posts/nndl-4/:1:3","tags":["Andrew NNDL"],"title":"NNDL-向量化","uri":"/posts/nndl-4/"},{"categories":["神经网络与深度学习"],"content":"外积（叉乘） 概括地说，两个向量的外积，又叫叉乘、叉积向量积，其运算结果是一个向量而不是一个标量。并且两个向量的外积与这两个向量组成的坐标平面垂直。 ","date":"2021-01-04","objectID":"/posts/nndl-4/:2:0","tags":["Andrew NNDL"],"title":"NNDL-向量化","uri":"/posts/nndl-4/"},{"categories":["神经网络与深度学习"],"content":"定义 向量a与b的外积a×b是一个向量，其长度等于|a×b| = |a||b|sin∠(a,b)，其方向正交于a与b。并且，(a,b,a×b)构成右手系。 特别地，0×a = a×0 = 0.此外，对任意向量a，a×a=0。 $a = (x_1,y_1,z_1)$ $b = (x_2,y_2,z_2)$ a和b的外积公式为 $a\\times b = \\left| \\begin{matrix} i \u0026 j \u0026 k \\ x_1 \u0026 y_1 \u0026 z_1 \\ x_2 \u0026 y_2 \u0026 z_2 \\end{matrix} \\right|$ 其中i = (1,0,0) j = (0,1,0) k= (0,0,1) 根据i,j,k之间的关系可以得出 $a\\times b = (y_1z_2-y_2z_1, -(x_1z_2-x_2z_1), x_1y_2-x_2y_1)$ ","date":"2021-01-04","objectID":"/posts/nndl-4/:2:1","tags":["Andrew NNDL"],"title":"NNDL-向量化","uri":"/posts/nndl-4/"},{"categories":["神经网络与深度学习"],"content":"向量外积的性质 a × b = -b × a. （反称性） (λa + μb) × c = λ(a ×c) + μ(b ×c). （线性） ","date":"2021-01-04","objectID":"/posts/nndl-4/:2:2","tags":["Andrew NNDL"],"title":"NNDL-向量化","uri":"/posts/nndl-4/"},{"categories":["神经网络与深度学习"],"content":"向量外积的几何意义 在三维几何中，向量a和向量b的外积结果是一个向量，有个更通俗易懂的叫法是法向量，该向量垂直于a和b向量构成的平面。 向量化逻辑回归 向量化 logistic 回归的梯度输出 Broadcasting in Python Python中的矩阵计算便捷方法 ","date":"2021-01-04","objectID":"/posts/nndl-4/:2:3","tags":["Andrew NNDL"],"title":"NNDL-向量化","uri":"/posts/nndl-4/"},{"categories":["神经网络与深度学习"],"content":"线性回归\u0026逻辑回归 线性回归–Linear Regression 线性回归模型可应用与监督学习(supervised learning)预测问题，如房价预测，疾病预测……. 对线性回归的直观解释: 找到一个线性函数能尽可能拟合已给出的点 理论解释: ","date":"2021-01-04","objectID":"/posts/nndl-3/:0:0","tags":["Andrew NNDL"],"title":"NNDL-回归模型","uri":"/posts/nndl-3/"},{"categories":["神经网络与深度学习"],"content":"影响因素 $$X=[x_1,x_2,x_3,…….,x_m]T$$ $x_i$代表影响结果的一个特征(feature), y ∈ R 当X与结果y属于线性关系时，即可得到线性回归假设(hypotheses)： $$h_θ(X)=θ_1x_1+θ_2x_2+…….+θ_mx_m+b$$ 写成向量形式即为： $$h_Θ(X)=Θ^TX+b$$ ","date":"2021-01-04","objectID":"/posts/nndl-3/:1:0","tags":["Andrew NNDL"],"title":"NNDL-回归模型","uri":"/posts/nndl-3/"},{"categories":["神经网络与深度学习"],"content":"损失函数 构造损失函数（损失函数就是用来表现预测与实际数据的差距程度）: cost function（损失函数）: $$J(\\Theta)={1\\over2}\\sum_i^{smaples}[h_\\Theta(X)-y]$$ 利用梯度下降方法找到一组 $$\\Theta=[θ_1,θ_2,….,θ_m]$$ 最小化J(Θ) 在得到Θ向量后，将 $$X_predict$$ 代入 $$h_Θ(X)=Θ^TX$$ 中即可得到 $$y_predict $$ ","date":"2021-01-04","objectID":"/posts/nndl-3/:2:0","tags":["Andrew NNDL"],"title":"NNDL-回归模型","uri":"/posts/nndl-3/"},{"categories":["神经网络与深度学习"],"content":"最小二乘法 CSDN解释 标准定义: 用一个具体的例子来说明: 小明是跑运输的，跑1公里需要6块，跑2公里需要5块（那段时间刚好油价跌了），跑3公里需要7块，跑4公里需要10块，请问跑5公里需要多少块？ 如果我们有初中数学基础，应该会自然而然地想到用线性方程组来做，对吧。 $y = \\beta_1+\\beta_2x$ 这里假定x是公里数，y是运输成本（β1和β2是要求的系数）。我们把上面的一组数据代入得到这么几个方程： $\\beta_1+1\\beta_2 = 6$ $\\beta_1+2\\beta_2 = 5$ $\\beta_1+3\\beta_2 = 7$ $\\beta_1+4\\beta_2 = 10$ 如果存在这样的β1和β2，让所有的数据（x，y）=（1,6），（2,5），（3,7），（4，10）都能满足的话，那么解答就很简单了，β1+5β2就是5公里的成本，对吧。 但遗憾的是，这样的β1和β2是不存在的，上面的方程组很容易，你可以把前面两个解出来得到一组β1和β2，后面两个也解出来同样得到一组β1和β2。这两组β1和β2是不一样的。 形象地说，就是你找不到一条直线，穿过所有的点，因为他们不在一条直线上。如下图： 可是现实生活中，我们就希望能找到一条直线，虽然不能满足所有条件，但能近似地表示这个趋势，或者说，能近似地知道5公里的运输成本，这也是有意义的。 现实生活当中，有很多这样的例子，想起以前在某公司上班的时候，CEO说我们研发部做事有个问题：一个研发任务，要求三个月做完，因为周期太短，完成不了，就干脆不做，这显然是不对的，要尽全力，哪怕三个月完成了80%，或者最终4个月完成，总比不作为的好。 其实最小二乘法也是这样，要尽全力让这条直线最接近这些点，那么问题来了，怎么才叫做最接近呢？直觉告诉我们，这条直线在所有数据点中间穿过，让这些点到这条直线的误差之和越小越好。这里我们用方差来算更客观。也就是说，把每个点到直线的误差平方加起来： $$S( \\beta_1, \\beta_2) = [6-(\\beta_1+1\\beta_2)]^{2} +[5-(\\beta_1+2\\beta_2)]^{2}+ [7-(\\beta_1+3\\beta_2)]^{2} + $$ $$[10-(\\beta_1+4\\beta_2)]^{2}$$ （如果上面的四个方程都能满足，那么S的值显然为0，这是最完美的，但如果做不到完美，我们就让这个S越小越好） 接下来的问题就是，如何让这个S变得最小。这里有一个概念，就是求偏导数。这里我想提一下，在培训的过程中，我发现机器学习的数学基础课程当中，微积分是大家印象最深刻的，而且也最容易理解：比如导数就是求变化率，而偏导数则是当变量超过一个的时候，对其中一个变量求变化率。如果这个概念也忘了，可以参考我在深度学习回答里那个王小二卖猪的例子。这里就不细讲了： 要让S取得最小值（或最大值，但显然这个函数没有最大值，自己琢磨一下），那么S对于β1和β2分别求偏导结果为0，用一个直观的图来表示： 我们看到这条曲线，前半部分是呈下降的趋势，也就是变化率（导数）为负的，后半部分呈上升的趋势，也就是变化率（导数）为正，那么分界点的导数为0，也就是取得最小值的地方。这是一个变量的情况，对于多个变量的情况，要让S取得最小值，那最好是对β1和β2分别求导（对β1求导的时候，把β2当常量所以叫求偏导），值为0： $$\\frac{\\partial S}{\\partial\\beta_1} = 0 = 8\\beta_1+20\\beta_2-56$$ $$\\frac{\\partial S}{\\partial\\beta_2} = 0 = 20\\beta_1+60\\beta_2-154$$ 看到这个我们就熟悉了，两个变量，刚好有两个方程式，初中学过，那么很容易得出： $\\beta_1 = 3.5 \\beta_2 = 1.4$ 其实也就意味着 $y = 3.5+1.4x$ 这个函数也就是我们要的直线，这条直线虽然不能把那些点串起来，但它能最大程度上接近这些点。也就是说5公里的时候，成本为3.5+1.4x5=10.5块，虽然不完美，但是很接近实际情况。 逻辑回归–Logistic Regression 逻辑回归模型应用于监督学习分类问题，暂且考虑二分类(如0,1分类)问题 直观解释：得到一条函数将不同类别的分开，如图: 假设 $X=[x_1,x_2,x_3,…….,x_m]$ $Θ=[θ_1,θ_2,θ_3,…….θ_m]$ 定义hypotheses(也就是预测预测结果 $\\check{y}$) $hΘ(X)=\\frac{1}{1+exp(−Θ^TX)}$ $$\\left \\lbrace\\begin{matrix} h_\\Theta(X)\u003e0.5, set h_\\Theta(X) = 1\\ h_\\Theta(X)\u003c0.5, set h_\\Theta(X) = 0 \\end{matrix} \\right.$$ cost functions: $$J(\\Theta) = \\left{\\begin{matrix} -log(h_\\Theta(x^i)), if y^i = 1\\ -log(1-h_\\Theta(x^i)), if y^i = 0 \\end{matrix}\\right.$$ 统一起来即为: $$J(\\theta) = \\sum_{i}{samples}[y^{i}log(h_\\Theta)(x^i)+((1-y^i)log(1-h_\\Theta(x^i))]$$ 同样是用到梯度下降优化参数,得到优化后的参数$$\\Theta = [\\Theta_1,\\Theta_2,…\\Theta_m]$$后,将$$X_predict$$ 代入 $$h_\\Theta(X)$$ 即可得到对该X对应的分类 参考博客 ","date":"2021-01-04","objectID":"/posts/nndl-3/:2:1","tags":["Andrew NNDL"],"title":"NNDL-回归模型","uri":"/posts/nndl-3/"},{"categories":["人工智能"],"content":"Berkeley CS-188 AI发展历史 Definition of agent(智能体) 人工智能只会在基于当前数据下做出合理的决策,而没有创造力,但是没有记忆的衰减性 Ⅰ.Note官方笔记 PDF笔记 Ⅱ.Translation ","date":"2021-01-03","objectID":"/posts/ai-1/:0:0","tags":["Berkeley CS-188"],"title":"AI-Uninformed Search","uri":"/posts/ai-1/"},{"categories":["人工智能"],"content":"Agents 在人工智能中，目前的主要问题是创建一个理性（rational） agent，一个有特定目标或偏好并会针对这些目标试图执行一系列操作（actions）来得到最优解的实体。理性agent存在于为给定的agent示例而量身定制的特定环境中。举一个简单的例子，一个西洋棋agent的环境就是它用来与对手对弈的虚拟棋盘，而对应的操作就是棋子的移动。一个环境和其中的agents一起创造了一个世界。 反射（reflex）agent不会考虑它的操作的后果，而只是根据世界的当前状态而选择一个操作。而计划（planning）agent则有一个世界模型并用这个模型来模拟执行不同的操作，远远胜过了反射agent。于是，agent就能确定操作的假想结果并选择最佳操作。这样的模拟“智能”在这个意义上符合人类在任何情况下尝试决定最佳动作的行为——预测。 ","date":"2021-01-03","objectID":"/posts/ai-1/:1:0","tags":["Berkeley CS-188"],"title":"AI-Uninformed Search","uri":"/posts/ai-1/"},{"categories":["人工智能"],"content":"State Spaces and Search Problems 状态空间和搜索问题 为了创建一个理性计划agent，我们需要一种方法来对agent存在的环境进行数学表达。为此，我们必须正式表达一个搜索问题（search problem）——给定agent的当前状态（state）（它在环境中的配置），我们如何尽可能最好地达到一个满足目标的新状态？讲一个问题公式化需要四个前提： 状态空间state space：在给定世界中所有可能的状态 后继函数successor function：包含一个状态和一个操作，并计算执行该操作的代价（cost）和执行操作后世界的后继状态 起始状态start state：agent最初存在时当前世界的状态 目标测试函数goal test：一个函数，输入一个状态并决定它是否是一个目标状态 要解决一个搜索问题，首先要考虑它的起始状态，然后用后继函数探索它的状态空间，反复计算不同状态的后继直到得到一个目标状态，这时我们就能确定一条连接起始状态和目标状态的路径（一般称为计划路径（plan））。由一个既定的策略（strategy）来决定我们考虑不同状态的顺序。很快我们将介绍策略的种类及其性能。 在我们继续讨论如何解决搜索问题之前，有必要强调一下世界状态（world state）和搜索状态（search state）的区别。世界状态包含一个给定状态的所有信息，而搜索状态仅包含对计划（主要是为了空间效率）必要的信息。我们将介绍本课程的一大亮点——吃豆人Pacman来解释这些概念。这个游戏很简单：吃豆人必须探索一个迷宫，吃掉所有的的小豆子并且不被游荡的恶灵吃掉。如果它吃了大豆子，它将在一段时间内无敌并且能吃掉恶灵赚取分 我们来考虑这个游戏的一个变式，迷宫中只有吃豆人和豆子。在这种情况下我们能给出两种不同的搜索问题：路径规划和光盘行动（pathing and eat-all-dots）。路径规划需要找出从位置(x1,y1)到(x2,y2)的最佳方案，而光盘行动要求用尽可能短的时间吃掉迷宫中所有的豆子。下面分别列出了两个问题的状态、操作、后继函数和目标测试函数： 问题 路径规划 光盘行动 状态 (x,y)坐标 (x,y)坐标,豆子的bool量 操作 东南西北 东南西北 后继函数 仅更新位置信息 更新位置和bool 目标测试函数 (x,y) == end 所有的豆子bool是否都等于0 路径规划的状态包含的信息比光盘行动要少，因为在光盘行动中我们必须保存一大批布尔值用来表示在给定状态中每个豆子有没有被吃掉。一个世界状态还有可能包含更多的信息，比如吃豆人走过的总距离，或者吃豆人在它的当前位置（x，y）和豆子布尔值上到达过的所有地方这些潜在的编码信息。 ","date":"2021-01-03","objectID":"/posts/ai-1/:2:0","tags":["Berkeley CS-188"],"title":"AI-Uninformed Search","uri":"/posts/ai-1/"},{"categories":["人工智能"],"content":"State Space Size 状态空间大小 在估算搜索问题的计算运行时间时，状态空间的大小是一个很重要的问题。这个问题几乎只能用基础计数原理（fundamental counting principle）解决：如果在一个给定的世界里有n个变量分别有x1,x2,x3…xn种不同的取值，那么状态的总数为n 。我们用吃豆人来举例说明这个概念： 我们定义变量和它们分别的取值种数如下： 吃豆人位置：吃豆人可以在120个不同的（x，y）坐标，而只有一个吃豆人 吃豆人前进方向：共有东南西北四种可能 恶灵位置：有两个恶灵，每一个都有可能在12个不同的（x，y）坐标 豆子分布：共30个豆子，每个都要么被吃要么没有被吃 根据基础计数原理，吃豆人有120个位置，可以朝着4个方向，恶灵分布有12$\\times$12种（每个恶灵12种），豆子分布有230种。由此可得总状态空间大小为 $120\\times4\\times12^2\\times2^{30}$ ","date":"2021-01-03","objectID":"/posts/ai-1/:3:0","tags":["Berkeley CS-188"],"title":"AI-Uninformed Search","uri":"/posts/ai-1/"},{"categories":["人工智能"],"content":"State Space Graphs and Search Trees 状态空间图和搜索树 现在我们已经构建了状态空间的概念并用了四个部件来完整地定义了一个状态空间，我们马上就可以开始着手解决搜索问题了。现在我们缺少的最后一块拼图就是状态空间图和搜索树。 图是由一些结点和连接结点的边构成的。这些边也会有与之相关的权重。状态空间图（state space graph）是由代表状态的结点以及从一个状态指向其后继的有向边构成的。这些边表示操作（action），而任何相关联的权重表示对应操作的代价。通常，状态空间图太大，无法存储在内存中（就算是吃豆人这样的简单例子也有大约$10^{13}$种不同状态）。不过在解决问题时从概念上记住它们就好。另一点需要注意的是，在一个状态空间图中，每一个状态仅表示一次——没必要多次表示一个状态，这一点在尝试推理搜索问题时非常有用。 与状态空间图不同，我们要讲的下一个结构，搜索树（search trees）对于一个状态出现的次数没有限制。这是因为虽然搜索树也是一类用结点表示状态、用边表示状态之间操作的图，每个结点/状态并不仅仅代表它本身，同时也代表了状态空间图中连通起始状态和给定状态的整个路径（或计划）。观察下面的状态空间图和与其对应的搜索树： 状态空间图中标红的路径(S → d → e → r → f → G)在对应的搜索树中表示为从起始状态S到标红状态G的路径。同理，状态空间图中从起始节点到其他任意节点的每条路径在搜索树中都表示为从根节点S到另一节点对应的子孙节点的路径。由于从一个状态到另一个状态通常会有多种方案，搜索树中状态会出现多次。由此，搜索树的规模大于等于对应的状态空间图。 我们已经确定了即使是简单问题的状态空间图也有相当大的规模，于是问题来了——如果这些结构大到无法再内存中表示，我们如何对它们进行有效计算呢？答案就在后继函数中——我们只保存即刻处理的状态，并用相应的后继函数根据需求来计算新的状态。通常，搜索问题是用搜索树来解决的。在树中，我们每次观察那几个非常小心地存储选择的节点，反复地用其后继来替换节点，直到我们到达一个目标状态。有许多种方法可以用来决定在搜索树中迭代替换节点的顺序，现在我们将介绍这些方法。 ","date":"2021-01-03","objectID":"/posts/ai-1/:4:0","tags":["Berkeley CS-188"],"title":"AI-Uninformed Search","uri":"/posts/ai-1/"},{"categories":["人工智能"],"content":"Uninformed Search 未知搜索 寻找从起始状态到目标状态的计划的标准协议（standard protocol）是保持来自于搜索树的部分计划的边缘（outer fringe）。通过移除一个与部分计划对应的节点（用给定的策略来选择）并用它所有的子节点代替它，我们不断地扩展（expand）我们的边缘。用子节点代替边缘上的元素,相当于丢弃一个长度为n的计划并考虑所有源于它的长度为（n+1）的计划。我们继续这一操作，直到最终将目标从边缘移除为止。此时我们得出结论，与移除的目标状态相对应的部分计划其实就是从起始状态到目标状态的一条路径。实际上，这类算法的大多数实现都对父节点、到节点的距离和节点内部的信息进行编码。我们刚刚介绍的这一过程就是树搜索（tree search） 当我们不知道目标状态在搜索树中的的位置时，我们只能从属于未知搜索（uninformed search）的技术中选择用于树搜索的策略。我们将依次介绍三种策略：深度优先搜索DFS、广度优先搜索BFS和一致代价搜索UCS。同时，我们还会介绍它们的一些基本性质，内容如下： 每种策略的完备性（completeness）：如果此搜索问题有解，在拥有无限计算资源的情况下，是否可以保证找到这个解？ 每种策略的最优性（optimality）：这个策略是否能保证找到通往目标状态代价最低的路径？ 分支因数b：每次将边缘节点移除并用其子节点替换时，边缘节点增加的数量为O(b)。在搜索树深度为k的一层存在$O(b^k)$个节点。 最大深度m 最浅解的深度s ","date":"2021-01-03","objectID":"/posts/ai-1/:5:0","tags":["Berkeley CS-188"],"title":"AI-Uninformed Search","uri":"/posts/ai-1/"},{"categories":["人工智能"],"content":"Depth-First Search 描述：深度优先搜索DFS总是选择距离起始节点最深的边缘节点来进行扩展。 边缘表示：在边缘移除最深的节点并用它的孩子节点替换，这当然意味着现在孩子节点就成为了最深的节点——它们的深度比之前的最深节点要多1。这意味着要实现DFS，我们需要一种结构来让最近添加的对象总是有最高优先级。后进先出（LIFO）堆栈正是这样，而且它在实现DFS时通常用来表示边缘。 完备性：深度优先搜索并不具有完备性。如果在状态空间图中存在回路，这必然意味着相应搜索树的深度将是无限的。因此，存在这样一种可能性，即DFS老实地在无限大的搜索树中搜索最深的节点而不幸地陷入僵局，注定无法找到解。 最优性：深度优先搜索只是在搜索树中找到“最左边”的解，而没有考虑路径的代价，因此不是最优的。 时间复杂度：在最坏情况下，深度优先搜索最终可能会搜遍整个搜索树。因此，给定一棵最大深度为m的树，DFS的时间复杂度$O(b^k)$。 空间复杂度：在最坏情况下，DFS在边缘上m个深度级别上都有b个节点。这是一个简单的结果，因为一旦某个父节点的b个子节点进入队列，DFS的本性在任意时间点都只允许研究任意一个子节点的一棵子树。因此，DFS的空间复杂度是$O(bm)$。 ","date":"2021-01-03","objectID":"/posts/ai-1/:5:1","tags":["Berkeley CS-188"],"title":"AI-Uninformed Search","uri":"/posts/ai-1/"},{"categories":["人工智能"],"content":"Breadth-First Search 描述：宽度优先搜索总是选择距离起始节点最浅（近）的边缘节点来扩展。 边缘表示：如果我们想在较深的节点之前访问较浅的节点，我们必须按照节点的插入顺序来访问它们。因此，我们希望有一种能输出最早进入队列的对象的结构来表示我们的边缘。为此，BFS使用了一种先进先出（FIFO）队列。 完备性：如果存在一个解，那么最浅节点s的深度一定是有限的，所以BFS最终一定会搜索这个深度。所以它是完备的。 最优性：BFS一般不是最优的，因为它在选择边缘上被替换的节点时不会考虑代价问题。在所有边的代价都相等的特殊情况下BFS可以保证是最优的，因为这会让BFS退化为一致代价搜索，我们将会在下面讨论这个特殊情况。 时间复杂度：在最坏情况下我们必须搜索 $1+b+b^2+ … b^s$ 个节点，因为我们得在从1到s每一个深度下都遍历所有节点。因此，时间复杂度是$O(b^s)$。 空间复杂度：在最坏情况下，边缘所有节点都在对应最浅解的那一层。由于最浅解位于深度s处，在这一深度有$O(b^s)$个节点。 ","date":"2021-01-03","objectID":"/posts/ai-1/:5:2","tags":["Berkeley CS-188"],"title":"AI-Uninformed Search","uri":"/posts/ai-1/"},{"categories":["人工智能"],"content":"Uniform Cost Search(一致代价搜索) 描述：一致代价搜索（UCS），我们的最后一种方案，总是选择距离起始节点代价最小的边缘节点来扩展。 边缘表示：为了表示UCS的边缘，通常选择基于堆的优先队列，其中给定排队节点v的权重就是从起始节点到v的路径代价，或是v的后退代价（backward cost）。直观来讲，以这种方式构建的优先队列只需重新自我洗牌就能维持我们希望得到的按照路径代价排序的顺序，因为我们移除当前代价最小的路径并用它的子路径代替了它。 完备性：一致代价搜索是完备的。如果存在一个目标状态，它一定有一些有限长度最短路径；因此，UCS最终一定能找到这条长度最短路径。 最优性：如果我们假设所有的边都是非负的，那么UCS也是最优的。通过构造，由于我们按照路径代价递增的顺序来搜索节点，我们肯定能找到到达一个目标状态的最低代价路径。一致代价搜索的策略与Dijkstra算法相同，主要区别在于UCS在找到一个解状态时终止，而不是找到通往所有状态的最短路径。要注意的是，如果在我们的图中有边的代价为负会导致路径上的节点长度减少，从而破坏了最优性的保证。（有关应对这种可能性的较慢的算法请参阅Bellman-Ford算法） 时间复杂度：我们定义最优路径代价为$C*$，状态空间图内两节点之间最小代价为$\\varepsilon$。那么，我们得简单粗暴地遍历深度为从1到$C*\\over\\varepsilon$范围内的所有节点，导致运行时间为$O(b^{C*/\\varepsilon})$。 空间复杂度：又是简单粗暴地，边缘会包括代价最低解所在层的所有节点，所以UCS空间复杂度大约为$O(b^{C*/\\varepsilon})$。 作为对一致代价搜索的最后说明，必须注意上面列出的三种策略本质上是相同的——只是在扩展策略上有所区别，上面给出的树搜索伪代码捕捉到了它们的相似之处。 ","date":"2021-01-03","objectID":"/posts/ai-1/:5:3","tags":["Berkeley CS-188"],"title":"AI-Uninformed Search","uri":"/posts/ai-1/"},{"categories":["神经网络与深度学习"],"content":"今天学习了吴恩达大佬的《neutral network and deep learning》的开头一点点 感觉真是收获颇丰，首先算是真正意义上稍微理解了神经网络的基本原理，以及深度学习其中蕴含的数学 如果说硬件进步以及大数据的积累是人工智能进步的直接动力，那么数学就是根本动力 例如微积分导数来实现实现梯度下降法（Gradient Descent） 下面开始搬运别人写的笔记,并且加上一些自己的见解 Welcome 深度学习改变了传统互联网业务，例如如网络搜索和广告。但是深度学习同时也使得许多新产品和企业以很多方式帮助人们，从获得更好的健康关注。 深度学习做的非常好的一个方面就是读取X光图像，到生活中的个性化教育，到精准化农业，甚至到驾驶汽车以及其它一些方面。如果你想要学习深度学习的这些工具，并应用它们来做这些令人窒息的操作，本课程将帮助你做到这一点。当你完成cousera上面的这一系列专项课程，你将能更加自信的继续深度学习之路。在接下来的十年中，我认为我们所有人都有机会创造一个惊人的世界和社会，这就是AI（人工智能）的力量。我希望你们能在创建AI（人工智能）社会的过程中发挥重要作用。 我认为AI是最新的电力，大约在一百年前，我们社会的电气化改变了每个主要行业，从交通运输行业到制造业、医疗保健、通讯等方面，我认为如今我们见到了AI明显的令人惊讶的能量，带来了同样巨大的转变。显然，AI的各个分支中，发展的最为迅速的就是深度学习。因此现在，深度学习是在科技世界中广受欢迎的一种技巧。 What is a Neural Network 我们常常用深度学习这个术语来指训练神经网络的过程。有时它指的是特别大规模的神经网络训练。那么神经网络究竟是什么呢？在这个视频中，我会讲解一些直观的基础知识。 让我们从一个房价预测的例子开始讲起。 假设你有一个数据集，它包含了六栋房子的信息。所以，你知道房屋的面积是多少平方英尺或者平方米，并且知道房屋价格。这时，你想要拟合一个根据房屋面积预测房价的函数。 如果你对线性回归很熟悉，你可能会说：“好吧，让我们用这些数据拟合一条直线。”于是你可能会得到这样一条直线。 但有点奇怪的是，你可能也发现了，我们知道价格永远不会是负数的。因此，为了替代一条可能会让价格为负的直线，我们把直线弯曲一点，让它最终在零结束。这条粗的蓝线最终就是你的函数，用于根据房屋面积预测价格。有部分是零，而直线的部分拟合的很好。你也许认为这个函数只拟合房屋价格。 作为一个神经网络，这几乎可能是最简单的神经网络。我们把房屋的面积作为神经网络的输入（我们称之为x），通过一个节点（一个小圆圈），最终输出了价格（我们用y表示）。其实这个小圆圈就是一个单独的神经元。接着你的网络实现了左边这个函数的功能。 在有关神经网络的文献中，你经常看得到这个函数。从趋近于零开始，然后变成一条直线。这个函数被称作ReLU激活函数，它的全称是Rectified Linear Unit。rectify（修正）可以理解成max(0,x)，这也是你得到一个这种形状的函数的原因。 你现在不用担心不理解ReLU函数，你将会在这门课的后面再次看到它。 如果这是一个单神经元网络，不管规模大小，它正是通过把这些单个神经元叠加在一起来形成。如果你把这些神经元想象成单独的乐高积木，你就通过搭积木来完成一个更大的神经网络。 让我们来看一个例子，我们不仅仅用房屋的面积来预测它的价格，现在你有了一些有关房屋的其它特征，比如卧室的数量，或许有一个很重要的因素，一家人的数量也会影响房屋价格，这个房屋能住下一家人或者是四五个人的家庭吗？而这确实是基于房屋大小，以及真正决定一栋房子是否能适合你们家庭人数的卧室数。 换个话题，你可能知道邮政编码或许能作为一个特征，告诉你步行化程度。比如这附近是不是高度步行化，你是否能步行去杂货店或者是学校，以及你是否需要驾驶汽车。有些人喜欢居住在以步行为主的区域，另外根据邮政编码还和富裕程度相关（在美国是这样的）。但在其它国家也可能体现出附近学校的水平有多好。 在图上每一个画的小圆圈都可以是ReLU的一部分，也就是指修正线性单元，或者其它稍微非线性的函数。基于房屋面积和卧室数量，可以估算家庭人口，基于邮编，可以估测步行化程度或者学校的质量。最后你可能会这样想，这些决定人们乐意花费多少钱。 对于一个房子来说，这些都是与它息息相关的事情。在这个情景里，家庭人口、步行化程度以及学校的质量都能帮助你预测房屋的价格。以此为例，x是所有的这四个输入，y是你尝试预测的价格，把这些单个的神经元叠加在一起，我们就有了一个稍微大一点的神经网络。这显示了神经网络的神奇之处，虽然我已经描述了一个神经网络，它可以需要你得到房屋面积、步行化程度和学校的质量，或者其它影响价格的因素。 即多影响因素同时作用,多个修正单元 网络的一部分神奇之处在于，当你实现它之后，你要做的只是输入x，就能得到输出y。因为它可以自己计算你训练集中样本的数目以及所有的中间过程。所以，你实际上要做的就是：这里有四个输入的神经网络，这输入的特征可能是房屋的大小、卧室的数量、邮政编码和区域的富裕程度。给出这些输入的特征之后，神经网络的工作就是预测对应的价格。同时也注意到这些被叫做隐藏单元圆圈，在一个神经网络中，它们每个都从输入的四个特征获得自身输入，比如说，第一个结点代表家庭人口，而家庭人口仅仅取决于x1和x2特征，换句话说，在神经网络中，你决定在这个结点中想要得到什么，然后用所有的四个输入来计算想要得到的。因此，我们说输入层和中间层被紧密的连接起来了。 值得注意的是神经网络给予了足够多的关于x和y的数据，给予了足够的训练样本有关x和y。神经网络非常擅长计算从x到y的精准映射函数。 这就是一个基础的神经网络。你可能发现你自己的神经网络在监督学习的环境下是如此的有效和强大，也就是说你只要尝试输入一个 x，即可把它映射成y，就好像我们在刚才房价预测的例子中看到的效果。 Supervised Learning with Neural Networks 关于神经网络也有很多的种类，考虑到它们的使用效果，有些使用起来恰到好处，但事实表明，到目前几乎所有由神经网络创造的经济价值，本质上都离不开一种叫做监督学习的机器学习类别，让我们举例看看。 在监督学习中你有一些输入x，你想学习到一个函数来映射到一些输出y，比如我们之前提到的房价预测的例子，你只要输入有关房屋的一些特征，试着去输出或者估计价格。我们举一些其它的例子，来说明神经网络已经被高效应用到其它地方。 如今应用深度学习获利最多的一个领域，就是在线广告。这也许不是最鼓舞人心的，但真的很赚钱。具体就是通过在网站上输入一个广告的相关信息，因为也输入了用户的信息，于是网站就会考虑是否向你展示广告。 神经网络已经非常擅长预测你是否会点开这个广告，通过向用户展示最有可能点开的广告，这就是神经网络在很多家公司难以置信地提高获利的一种应用。因为有了这种向你展示你最有可能点击的广告的能力，而这一点击的行为的改变会直接影响到一些大型的在线广告公司的收入。 计算机视觉在过去的几年里也取得了长足的进步，这也多亏了深度学习。你可以输入一个图像，然后想输出一个索引，范围从1到1000来试着告诉你这张照片，它可能是，比方说，1000个不同的图像中的任何一个，所以你可能会选择用它来给照片打标签。 深度学习最近在语音识别方面的进步也是非常令人兴奋的，你现在可以将音频片段输入神经网络，然后让它输出文本记录。得益于深度学习，机器翻译也有很大的发展。你可以利用神经网络输入英语句子，接着输出一个中文句子。 在自动驾驶技术中，你可以输入一幅图像，就好像一个信息雷达展示汽车前方有什么，据此，你可以训练一个神经网络，来告诉汽车在马路上面具体的位置，这就是神经网络在自动驾驶系统中的一个关键成分。 那么深度学习系统已经可以创造如此多的价值，通过智能的选择，哪些作为x,哪些作为y，来针对于你当前的问题，然后拟合监督学习部分，往往是一个更大的系统，比如自动驾驶。这表明神经网络类型的轻微不同，也可以产生不同的应用，比如说，应用到我们在上一个视频提到的房地产领域，我们不就使用了一个普遍标准神经网络架构吗？ 也许对于房地产和在线广告来说可能是相对的标准一些的神经网络，正如我们之前见到的。 对于图像应用，我们经常在神经网络上使用卷积（Convolutional Neural Network），通常缩写为CNN。 对于序列数据，例如音频，有一个时间组件，随着时间的推移，音频被播放出来，所以音频是最自然的表现。作为一维时间序列（两种英文说法one-dimensional time series / temporal sequence）.对于序列数据，经常使用RNN，一种递归神经网络（Recurrent Neural Network），语言，英语和汉语字母表或单词都是逐个出现的，所以语言也是最自然的序列数据，因此更复杂的RNNs版本经常用于这些应用。 对于更复杂的应用比如自动驾驶，你有一张图片，可能会显示更多的CNN卷积神经网络结构，其中的雷达信息是完全不同的，你可能会有一个更定制的，或者一些更复杂的混合的神经网络结构。所以为了更具体地说明什么是标准的CNN和RNN结构 标准神经网络 卷积网络(CNN)-图像数据 递归神经网络(RNN)-一维序列 你可能也听说过机器学习对于结构化数据和非结构化数据的应用，结构化数据意味着数据的基本数据库。例如在房价预测中，你可能有一个数据库，有专门的几列数据告诉你卧室的大小和数量，这就是结构化数据。或预测用户是否会点击广告，你可能会得到关于用户的信息","date":"2021-01-02","objectID":"/posts/nndl-1/:0:0","tags":["Andrew NNDL"],"title":"NNDL Overview","uri":"/posts/nndl-1/"},{"categories":["NCEPU"],"content":"数据结构 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:0:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"请简述数据结构的定义和组成: 数据结构是相互之间存在的一种或多种特定关系的数据元素的集合,数据结构包括三个方面:逻辑结构,存储结构,数据的运算 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:1:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"请简述算法的五个重要的特性 有穷性: 一个算法必须总是在执行有穷步后结束,并且每一步都可在有穷时间内完成 确定性: 算法中的每一趟都必须有确切的含义,即相同的输出只能得到相同的结果 可行性: 一个算法是可行的 输入: 一个算法有0个或多个输出 输入: 一个算法有0个或多个输入 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:2:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"简述好的一个算法应该达到那些目标 正确性: 算法应当能够正确解决所求问题 可读性: 算法应当具有良好的可读性 健壮性: 当输入非法数据时,算法也能及时的做出反应或处理,不会产生莫名其妙的输出结果 效率和低存储需求: 效率是算法执行的时间,存储量需求是算法执行过程中所需要的最大存储空间 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:3:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"请简述线性表和顺序表的区别 线性表是逻辑结构,表示元素之间的一对一关系,顺序表是存储结构,指的是所有的数据在存储空间上顺序排序列,而跟具体的操作方式无关 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:4:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"头结点和头指针的区分 头指针是指链表中指向第一个结点的指针,若链表有头结点,则是指向头结点的指针 头结点是为了操作的统一和方便设立的,放在第一个元素的结点之前,一般数据域无意义 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:5:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"简述链表引入头结点带来的优点 第一个位置的插入和删除更加方便 同意了空表和非空表的处理,若使用头结点,无论表是否为空,头指针都指向头结点 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:6:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"简述头插法和尾插法的区别 头插法:不断将新节点插入表头后面,头插法会改变数据的输入顺序 尾插法:新来的节点插入链表的末尾处,数据的顺序不改变 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:7:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"简述顺序表和链表存储的优缺点 顺序表存储: 优点: 存取速度更快,可以实现随机存取,数据存取密度较高. 缺点: 删除和插入较慢,不可以增加长度 链表存储: 优点: 插入和删除的速度快,并且不会发生存储溢出的问题. 缺点: 查找速度过慢,不能实现随机存取 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:8:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"字符串和字符数组的区别 字符串指针变量本身是一个变量,用于存放存放字符串的首地址,而字符串本身是存在以该首地址为首的一块连续内存空间并以’\\0’作为串的结束,字符数组是由于若干个数组元素组成的,它可以用来存放整个字符串 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:9:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"数组和线性表的关系 数组是线性表的推广,一维数组可以看作是一个线性表,二维数组可以看作是元素是线性表的线性表,数组一旦被定义,他的维数和维界就不会发生改变,因此除了结构初始化和销毁之外,数组只会有存取元素和修改元素的操作 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:10:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"请叙述完全二叉树的定义 对于深度为K的,有n个结点的二叉树,当且仅当其每一个结点都与深度为K的满二叉树中编号从1到n的结点一一对应,则称之为完全二叉树 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:11:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"简述极大连通子图和极小连通子图 极大连通子图是无向图的连通分量,极大即要求连通子图中包含其所有的边,极小连通子图既保持图连通又要使得边数最小的子图 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:12:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"算法的稳定性 假定在待排序的记录序列中,存在多个具有相同关键字的记录,若经过排序后这些记录的相对次序保持不变,则称算法是稳定的 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:13:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么是抽象数据类型 ADT是指一个数学模型及定义在该模型上的一组操作,抽象数据类型的定义仅取决于他的逻辑特性,而与其在计算机内部如何表示和实现无关 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:14:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"数据的基本单位和最小单位分别是什么 基本单位: 数据元素 最小单位: 数据项 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:15:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么是数据结构,包含哪些方面的内容 数据结构是相互之间有一种或多种特定关系的数据元素的集合 数据结构包括三个方面的内容: 逻辑结构,存储结构,数据的运算 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:16:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"数据的逻辑结构 集合 线性结构 树形结构 图状结构或网状结构 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:17:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"数据的存储结构 顺序存储 链式存储 索引存储 散列存储 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:18:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"算法的特性有哪些 有穷性 确定性 输入 输出 可行性 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:19:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"好的算法的要求 健壮性 正确性 可读性 效率和低存储要求 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:20:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"顺序表的定义及主要特点 线性表的顺序存储成为顺序表,他用一组地址连续的存储单元依次存储线性表中的数据元素,从而使得在逻辑上相邻的两个元素在物理位置上也相邻 主要特点: 随机存储 存储密度高,每个节点只存储数据元素 顺序表逻辑上相邻的元素在物理地址上也相邻,所以插入和删除需要删除大量元素 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:21:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么是头结点 在单链表的第一个结点之前附加的一个结点称之为头结点 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:22:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"头结点和头指针的区分 无论带不带头结点,头指针始终指向链表的第一个结点,而头结点是带头结点的单链表的第一个结点,结点内通常不带存储信息 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:23:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"引入头结点的好处 由于开始结点的位置被存放在头结点的指针域中,所以在链表的第一个位置的操作和其他位置上的操作一致,无需进行特殊处理 无论链表是否为空,其头指针都指向头结点的非空指针,因此空表和非空表的操作也得到了统一 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:24:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"单链表的优缺点 存取方式: 链表只能从表头开始顺序存取元素 逻辑结构和物理结构: 在逻辑结构上相邻的元素,其物理存储位置不一定相邻 查找删除操作: 链表的插入删除操作,只需要改变相关结点的指针域即可,由于每一个结点都带有指针域,因此在存储空间上要比顺序存储付出的代价大,存储密度不高 顺序存储在静态和动态存储分配下,都十分麻烦,容易内存溢出或浪费大量空闲存储空间,链式存储的结点空间只有在需要时才会分配,操作灵活,高效 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:25:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"头插法和尾插法有什么区别 头插法建立单链表时,读入的数据和生成链表中的元素的顺序是相反的,尾插法得到的链表中元素的顺序和输入顺序相同 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:26:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"循环队列公式 队满条件: (q.rear+1)%maxsize == q.front; 队空条件: q.rear == q.front 队列中元素的数量: (q.rear-front+maxsize)%maxsize ","date":"2020-12-11","objectID":"/posts/ncepu-10/:27:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么叫做递归 在一个函数,过程或数据结构的定义中又应用了自身,则这个函数,过程或数据结构称为是递归定义的 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:28:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"数组和线性表的关系 数组是由n个相同类型的数据元素构成的有限序列,每个元素成为一个数组元素 数组是线性表的推广,一维数组可视为一个线性表,二维数组可视为元素是线性表的线性表 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:29:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"二叉树和度为2的有序树的区别 度为2的有序树,至少有三个节点,二叉树可以为空 度为2的有序树的孩子结点的左右次序是相对于另一个孩子结点而言的,若某个结点的孩子只有一个孩子结点,那么这个孩子结点就无需分为左右,而二叉树中无论孩子结点是否为二,其左右次序都是固定的 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:30:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"满二叉树 一棵高度为h,且含有2h-1个结点的二叉树称为满二叉树 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:31:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"完全二叉树 高度为h,有n个结点的二叉树,当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时,称为完全二叉树 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:32:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"二叉排序树 一棵二叉树,如果是空二叉树,或者是具有如下性质的二叉树,左子树上所有结点的关键字都小于根节点的关键字,右子树的关键字都大于根节点的关键字,并且左右子树又各是一棵二叉排序树 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:33:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"平衡二叉树 树上任意节点的左子树和右子树的深度之差不超过一 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:34:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"二叉树的遍历 二叉树的遍历是指按某条搜索路径访问树中的每个结点,使得每个结点均被访问一次 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:35:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"树的存储结构-双亲表示法 采用连续空间存储每个节点,同时在每个结点中增设一个伪指针,指示其双亲结点在数组中的位置 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:36:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"孩子表示法 将每个结点的孩子结点都用单链表链接起来,形成一个线性结构,此时n个结点就有n个孩子链表 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:37:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"孩子兄弟表示法 孩子兄弟表示法又称为二叉树表示法,即以二叉链表为存储结构,孩子兄弟表示法使得每个结点包括三个部分的内容:结点值,指向结点第一个孩子结点的指针,以及指向结点下一个兄弟节点的指针 最大的优点是方便实现树转换为二叉树的操作,易于查找结点的孩子节点,缺点是从当前节点查找其双亲结点比较麻烦 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:38:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"哈夫曼树及哈夫曼编码 在含有n个带权叶子结点的二叉树中,其中带权路径长度最小的二叉树称为哈夫曼树,即最优二叉树 哈夫曼编码是一种广泛应用并且非常有效的数据压缩编码 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:39:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"空表空树 在数据结构中,线性表可以没有数据元素,称为空表 树中没有结点,称为空树 图中不能没有结点 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:40:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"完全图 在无向图中,任意两个顶点之间都存在边,称该图为完全图,含有n个顶点的完全图有n(n-1)/2条边 在有向图中,任意两个顶点之间都存在方向相反的两条弧,则称为有向完全图,含有n个顶点的有向完全图有n(n-1)条有向边 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:41:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"生成树 生成森林 连通图的生成树是包含图中全部顶点的一个极小连通子图 在非连通图中,连通分量的生成树构成了非连通图的生成森林 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:42:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"结点的度 入度出度 图中每个顶点的度定义为以该顶点为一个端点的边的边的数目 入度: 在有向图中,顶点v的入度为以v为终点的有向边的数目 出度: 在有向图中,顶点v的出度为以v为起点的有向边的数目 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:43:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"图的遍历 图的遍历是指从图中的某一个顶点出发,按照某种搜索方法沿着图中的边对图中所有的顶点访问一次 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:44:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"最短路径 图为带权图时,把一个顶点v0到图中其余任意一个顶点vi的一条路径所经过的权值之和,定义为该路径的带权路径长度,将带权路径长度最短的那条路径称为最短路径 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:45:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"有向无环图 若一个有向图中不存在环,则称为有向无环图DAG ","date":"2020-12-11","objectID":"/posts/ncepu-10/:46:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"AOV 若用DAG表示一个工程,其顶点表示活动,有向边(vi,vj)表示活动vi必须先于vj进行的关系,则称这种有向图是顶点表示活动的网络,称为AOV网 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:47:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"AOE网 在带权有向图中,顶点表示事件,有向边表示活动,边上的权值表示完成该活动需要的开销,则称这种有向图为用边表示活动的网络,简称为AOE网 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:48:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"关键路径 在AOE网中,从源点到汇点的所有路径中,具有最大路径长度的路径称为关键路径,关键路径上的活动称为关键活动 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:49:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"顺序查找的优缺点 缺点: 顺序查找的缺点是当n较大时,平均查找长度较大,效率低 优点: 对数据的存储没有要求,顺序存储或链式存储都可以 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:50:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么是折半查找 又称为二分查找,将给定的key值与表中间位置的关键字比较,若相等则查找成功,若不相等,则所需查找的元素只能在中间元素的前半侧或后半侧 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:51:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么是分块查找 又称为索引顺序查找,将查找表划分为多个块,块内元素可以无序,但块之间必须有序,即第i个块中的最大关键字必须小于第i+1个块中的最大关键字,因此建立一个索引表,索引表中的每个元素含有各块中最大关键字和各块中第一个元素的地址,查找过程分为两步,首先在索引表中确定待查元素所在的块,第二步在块内进行查找 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:52:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么叫B树 b树为所有结点的平衡因子都等于0的多路平衡查找树 b树中所有结点的孩子结点数的最大值称为B树的阶,通常用m来表示 树中每个结点至多有一个m棵子树(即至多有m-1个关键字) 除根节点外的所有非叶子结点,都至少有m/2(向上取整)棵子树 所有的叶子结点都在同一层次上,并且不带信息,可以看作是查找失败结点 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:53:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么叫B+树 每个分支结点最多有m个子树 非叶根结点至少有两个子树,其他每个分支结点至少有m/2(向上取整)棵子树 结点的子树数量与结点关键字相等 所有叶结点包含所有关键字及指向相应记录的指针 所有分支节点中仅包含他的各个子节点中关键字的最大值,及指向子节点的指针 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:54:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"B+树和B树的差异 在B+树中具有n个关键字的结点含有n棵子树,即每个关键字对应一棵子树,而在B树中,具有n个关键字的结点有n+1棵子树 在B+树中,每个结点(非根内部结点)的关键字数n范围为 m/2(向上取整)\u003c= n \u003c=m 在B树中,每个结点(非根内部结点)的关键字数n范围为 m/2(向上取整)-1 \u003c= n \u003c= m-1 在B+树中,叶节点包含信息,非叶节点起索引作用,而在B树中,叶节点包含的关键字和其他结点的关键字是不重复的 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:55:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么散列表的填充因子 表中记录数n/散列表长度m ","date":"2020-12-11","objectID":"/posts/ncepu-10/:56:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么是算法的稳定性 若待排序表中有两个元素Ri和Rj,其对应的关键字keyi == keyj,若使用某一排序算法后,两个元素的相对位置没有发生改变,则称为这个算法是稳定的 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:57:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么是内部排序,什么是外部排序 内部排序: 排序期间元素全部存放在内存中排序 外部排序: 排序期间元素无法全部同时存放在内存中,必须在排序过程中,根据要求不断在内外存之间移动的排序 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:58:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"简述快速排序的思想 快速排序基于分治思想,在待排序列[1…n]中任取一个元素pivot作为基准,通过一趟排序将待排序表划分为两个单独部分[1…k-1]和[k+1…n],pivot放在了最终的位置,这个过程称为一趟快速排序,之后递归的对两个子表重复上述过程,直到所有元素都有序 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:59:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"什么是基数排序 基数排序是一种特殊的排序方法,它不基于比较进行排序,而采用多关键字排序思想(基于关键字的各位的大小进行排序)借助\"分配\"和\"收集\"两种操作对单逻辑关键字进行排序 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:60:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"各种排序算法的平均时间复杂度,稳定性 算法 最好情况 平均情况 最坏情况 空间复杂度 稳定 直接插入排序 O(n) O(n2) O(n2) O(1) 是 冒泡排序 O(n) O(n2) O(n2) O(1) 是 简单选择排序 O(n2) O(n2) O(n2) O(1) 否 希尔排序 O(1) 否 快速排序 O(nlog2n) O(nlog2n) O(n2) O(nlog2n) 否 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 否 2路归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 是 基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(r) 是 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:61:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"排序趟数和初始状态无关的排序方法是 直接插入 简单选择排序 基数排序 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:62:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"内部排序中,哪几种排序每一趟排序结束都至少能确定一个元素的最终位置 简单选择 快速排序 堆排序 ","date":"2020-12-11","objectID":"/posts/ncepu-10/:63:0","tags":["数据结构与算法"],"title":"NCEPU 数据结构简答题","uri":"/posts/ncepu-10/"},{"categories":["NCEPU"],"content":"操作系统 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:0:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"进程和线程的主要区别是什么,引入线程的好处 在有进程和线程的系统中,进程是系统分配资源的独立单位,而线程是可调度的独立的单位,线程是进程的一个组成部分 以线程作为系统调度的基本单位,减少了系统的时空开销 引入线程提高了系统的并行能力 同一进程的线程,分享进程的用户地址空间,所以同一进程的线程间的通信更容易实现 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:1:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是原语,原语的主要特点是什么 原语是指由若干条机器指令构成,并用以完成特定功能的一段程序,这段程序在执行期间是不可分割的,主要特点是运行期间不可分割 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:2:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"同步机制应该遵循什么准则 空闲让进,忙则等待,让权等待,有限等待 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:3:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"三级调度 高级调度(作业调度) 中级调度 低级调度(进程调度) ","date":"2020-12-10","objectID":"/posts/ncepu-11/:4:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"死锁是什么,产生死锁的原因和必要条件是什么 死锁是指多个进程因竞争资源而造成一种僵持状态,若无外力作用,这些进程就会永远处于阻塞状态,无法运作下去 产生死锁的原因: 资源不足,进程推进次序不当 产生死锁的必要条件: 互斥条件,请求保持条件,不剥夺条件,环路等待保持 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:5:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"覆盖技术和虚拟存储的区别是什么 交换技术主要在不同进程(或作业)中进行,而覆盖技术则用于同一进程或者进程中 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:6:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"I/O控制方式有几种 程序I/O方式, 终端控制I/O方式, DMA控制方式 通道方式 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:7:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"说明进程和程序的区别 每个进程实体中包括程序段和数据段以及PCB三部分 进程是程序的一次执行过程,由创建而产生,由调度而执行,由撤销而消亡,因此是动态的,而程序只是一组指令的集合,是静态的 多个进程可以在内存中并发运行,而程序没有并发性 进程是一个可以独立运行,独立分配资源的,和独立接受调度的基本单位,程序中没有PCB,因此不可能在多道程序环境独立运行 程序和进程不一一对应,一个程序可以多次运行,形成多个进程,同一个程序的一次执行也可以产生多个进程,而一个进程在执行过程也可以执行多个程序 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:8:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"操作系统的定义 操作系统是计算机系统的一种系统软件,统一管理计算机系统的资源和控制程序的执行 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:9:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"简述预防死锁的三种方法 死锁的预防,死锁的避免,死锁的检测 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:10:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"死锁和饥饿的区别 相同点: 两者都是由于竞争资源引起的,与资源的分配策略有关 不同点: 从进程状态考虑,死锁进程都处于等待状态,但是饿死进程属于忙等状态 死锁进程等待永远不会释放的资源,饿死进程等待会被释放但是不会分配给自己的资源 死锁一定会发生循环等待,但是饿死进程则不会,根据资源分配图可以检测死锁,但不能检测饿死 死锁一定涉及多个进程,但是饥饿或饿死可能只有一个 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:11:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是设备独立性 应用程序独立于具体使用的物理设备 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:12:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是颠簸,以及产生的原因 在虚拟内存中,页面在内存和外存中循环调试,系统效率急剧下降,称为颠簸,颠簸是由于缺页率高引起的 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:13:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"虚拟存储技术的理论基础(局部性原理)是什么 时间局部性: 是指若一条指令被执行,则在不久之后可能被再次执行 空间局部性: 一旦一个存储单元被访问,那么其附近的单元也很快被访问 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:14:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"操作系统的概念 管理协调硬件软件等计算机资源 为上层用户,应用程序提供简单易用的服务 一种系统软件 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:15:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"操作系统的特征 并发 共享 异步 虚拟 其中并发和共享是最基本的特征 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:16:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"并发并行 并发: 指两个或多个事件在同一时间间隔内发生,宏观上同时发生,微观上交替发生 并行: 指两个或多个事件同一时刻同时发生 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:17:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"并发共享之间的联系 两者互为存在的条件 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:18:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"操作系统的功能 作为计算机系统资源的管理者 作为用户与计算机硬件系统之间的接口 用作扩充机器 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:19:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"操作系统发展阶段 手工操作阶段 单道批处理阶段 多道批处理阶段 分时操作系统 实时操作系统 网络操作系统,分布式计算机系统 个人计算机操作系统 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:20:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"多道批处理的特点 优缺点 优点: 多道程序并发执行,共享计算机资源,资源利用率大幅提升,系统吞吐量增大 缺点: 没有人机交互,提交作业后只能等嗲计算机处理,无法对中间过程干预 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:21:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"分时系统和实时系统 分时: 计算机以时间片为单位轮流为每一个用户(作业)服务,各个用户能通过终端与计算机交互 实时: 计算机系统受到外部信号后及时处理,并且在严格的时限内处理完事件,具有及时性和可靠性 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:22:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"特权指令 特权指令是指有特殊权限的指令,由于这类指令的权限最大,使用不当将导致整个系统崩溃 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:23:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"中断和异常的概念和区别 中断: 也称为外中断,指来自CPU执行指令之外的事件的发生,如设备发出的I/O结束中断,时钟中断 异常: 内中断,源自于CPU执行指令内部的事件,例如程序的非法操作码,地址越界,算术溢出,虚存系统的缺页等 区别: 广义的中断包括中断和异常,狭义的中断和异常的区别在于,是否和正在执行的指令相关,中断是可以被屏蔽的,异常不能被屏蔽,一旦出现应立即处理 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:24:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"访管指令和访管中断 访管指令是一条可以在用户态执行的指令 产生一个中断事件,将操作系统转换为核心态,称为访管中断,访管中断由访管指令产生,程序员使用访管指令向操作系统请求服务 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:25:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"进程的概念 进程是进程实体的运行过程,是系统进行资源分配和调度的基本单位 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:26:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"进程的组成部分 PCB, 程序段, 数据段 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:27:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"进程的特征 动态性 并发性 独立性 异步性 结构性 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:28:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"进程状态的切换 就绪态-\u003e运行态 进程被调度 运行态-\u003e就绪态 时间片用完 处理机被占用 运行态-\u003e阻塞态 等待系统资源分配 等待某事件发生 阻塞态-\u003e就绪态 资源分配到位 等待的事件发生 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:29:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"进程创建的事件 用户登录 作业调度 提供服务 应用请求 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:30:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"PCB的概念和作用 概念: 保存进程运行期间的相关数据,是进程存在的唯一标识 作用: 利用PCB来描述进程的基本状况和运行态,从而控制和管理进程 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:31:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"进程通信的方式 共享存储 消息传递 管道通信 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:32:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"处理机调度的三个层次 高级调度(作业调度) 中级调度(内存调度) 低级调度(进程调度) ","date":"2020-12-10","objectID":"/posts/ncepu-11/:33:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"处理机调度的基本准则 CPU利用率 系统吞吐量 周转时间 等待时间 响应时间 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:34:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是饥饿现象 死锁现象 饥饿: 等待时间已经影响到进程运行,此时称为饥饿现象,如果等待时间过长,导致进程使命已经没有意义的时候,称为\"饿死\" 死锁现象: 两个或多个进程相互竞争系统资源,导致进程永久阻塞 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:35:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是临界资源 临界区 临界资源: 一次仅允许一个进程使用的资源称为临界资源 临界区: 在每个进程中,访问临界资源的那段代码称为临界区 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:36:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"临界资源访问的四个过程 进入区 临界区 退出区 剩余区 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:37:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"同步机制应遵循的准则 空闲让进 忙则等待 有限等待 让权等待 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:38:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"死锁产生的原因 系统资源的竞争 进程推进顺序非法 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:39:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"死锁产生的四个必要条件 互斥条件 不剥夺条件 请求保持条件 循环等待 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:40:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"死锁的处理策略 死锁预防 死锁避免 死锁检测和解除 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:41:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"死锁预防的策略 破坏互斥条件 破坏不剥夺条件 破坏循环等待条件 破坏请求保持条件 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:42:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"系统不安全状态和死锁的关系 并非所有的不安全状态都是死锁状态,但系统进入不安全状态后,便可能进入死锁状态,只要系统处去安全状态,就不会进入死锁状态 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:43:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"安全状态的概念 系统能按照某种进程推进顺序,为每个进程分配其所需要的资源,直至满足每个进程的需求,使每个进程都能顺序完成 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:44:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"银行家算法的基本思想 将操作系统视为银行家,操作系统管理的资源相当于银行家的资金,进程向操作系统请求分配资源相当于用户向银行家贷款 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:45:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是死锁定理 通过简化资源分配图,可检测系统状态是否为死锁状态 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:46:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"进程同步互斥的关系 进程同步: 直接制约关系,为了完成某个任务而建立的两个或多个进程,因为需要而协调他们的工作次序而等待,传递信息所产生的制约关系 进程互斥: 间接制约关系,当一个进程进入临界区,另一个进程必须等待,当占用临界资源的进程退出临界区后,另一个进程才允许去访问临界资源 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:47:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"程序变为进程的步骤 为进程申请唯一的进程标识号,并申请一个空白PCB 为进程分配资源 初始化PCB 进程进入就绪队列,等待被调度运行 编译-\u003e链接-\u003e装入 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:48:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"链接的三个方式 静态链接 装入时动态链接 运行时动态链接 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:49:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"装入的三个方式 绝对装入 可重定位装入 动态运行时装入 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:50:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"逻辑地址和绝对地址 逻辑地址: 编译后每个目标模块都从0号单元开始编址,这成为该目标模块的逻辑地址 物理地址: 内存中物理单元的集合,是地址转换的最终地址,进程在运行时执行指令和访问数据,都要通过物理地址从主存中提取 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:51:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"地址重定位 当装入程序将可执行程序装入内存时,必须通过地址转换将逻辑地址转换为物理地址,这个过程称为地址重定位 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:52:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是覆盖技术 交换技术 两者之间的区别 覆盖技术和交换技术是多道程序环境下用来扩充内存的方法 覆盖技术: 在程序运行过程中并非需要任何时候都要访问程序及数据的各个部分,因此可将用户空间分为一个固定区和若干个覆盖区,将活跃部分放入固定区,将即将访问的段放入覆盖区,其他段放在外存,在需要调用前,系统将其调入覆盖区,替换覆盖区原有的段 交换技术: 将等待状态的程序从内存移入辅存,换出,将内存空间腾出,将准备好运行的程序从辅存移入内存,换入 交换技术通常用于不同的进程(作业)之间,覆盖技术通常用于同一个程序或进程中 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:53:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"连续分配管理方式 单一连续分配 固定分区分配 动态分区分配 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:54:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"非连续分配 基本分页存储管理方式 基本分段存储管理方式 段页式存储管理方式 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:55:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"内存碎片 外部碎片 外部碎片如何消除 内部碎片: 当程序小于固定分区大小时,也占用一个完整的内存分区空间,这样内存空间内部就存在内存浪费,这种现象称为内部碎片 外部碎片: 在动态分配中,会导致内存中产生很多小的内存块,并且无法使用,这些小的内存块成为外部碎片 外部碎片可通过紧凑技术来解决,即操作系统对进程进行移动和整理,进行磁盘整理 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:56:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"内存分配算法 首次适应: 将空闲分区按照地址递增次序链接,分配内存时顺序查找,找到大小满足要求的第一个空闲分区 最佳适应: 将空闲分区按照容量大小递增次序链接,分配内存时顺序查找,找到第一个能满足要求的空闲分区 最坏适应: 将空闲分区按照容量大小递减次序链接,找到第一个能满足要求的空闲分区 邻近适应(循环首次适应): 由首次适应演变而来,分配内存从上次查找结束的位置开始继续查找 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:57:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"为什么页式管理是一维的,分段是二维的 页式管理中,只需要提供一个整数就能确定对应物理地址,因为页面大小L是固定的,因此页式管理中地址是一维的 分段管理中,由于每段长度不同,因此无法同各国整数除法得到短号,无法通过求余得到段内偏移,所以段号和段内偏移需要显式给出,因此分段管理是二维的 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:58:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"页面为什么过大或者过小 页面过小会使进程的页面数增多,导致页表过长,占用大量内存,也会增加硬件地址转换的开销,降低页面换入换出效率,页面过大会使页内碎片增多,降低内存利用率 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:59:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是可重入代码 程序中不能修改的代码称为可重入代码,这种代码可以进行共享 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:60:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"多级页表解决了什么问题,带来了什么问题 多级页表解决了当逻辑地址空间过大时,页表长度会大大增加的问题 采用多级页表后,一次访盘需要多次访问内存甚至磁盘,大大增加了一次访存事件 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:61:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"局部性原理 时间局部性原理: 程序中的某条指令一旦执行,不久后该指令可能再次执行 空间局部性: 一旦程序访问了某个存储单元,不久后其附近的存储单元也会被访问 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:62:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"虚拟内存技术实现的三种技术 请求分页存储管理 请求分段存储管理 请求段页式存储管理 一定的内存和外村 页表(段表)机制 中断机构 地址变换机构 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:63:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"Belady异常 出现在哪里 分配的物理块增多,但是页故障不减反增的异常现象 只有FIFO可能会出现Belady异常 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:64:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是驻留集 给一个进程分配的物理页框的集合就是该进程的驻留集 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:65:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"驻留集分配的三种策略 固定分配局部置换 可变分配全局置换 可变分配局部置换 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:66:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是\"抖动\"现象 刚换出的页面又要马上换入主存,刚换入的页面又要马上换出主存,这种频繁的页面调度行为称为\"抖动\" ","date":"2020-12-10","objectID":"/posts/ncepu-11/:67:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是文件 什么是文件系统 文件是以计算机硬盘为载体的存储在计算机上的信息集合,文件可以是文本文档,图片,程序等 在用户输入输出时,以文件为基本单位 文件系统是为了实现用户对于文件的访问,修改,保存等维护管理 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:68:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"文件的逻辑结构都有哪些 无结构文件(流式文件) 有结构文件(记录式文件) ","date":"2020-12-10","objectID":"/posts/ncepu-11/:69:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"记录式文件分为哪几种 顺序文件 索引文件 索引顺序文件 散列文件 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:70:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是FCB 文件控制块是用来存放控制文件需要的各种信息的数据结构,以实现\"按名存取\" FCB的有序集合称为文件目录,一个FCB是一个文件目录项,为了创建一个新文件,系统将分配一个FCB并存放在文件目录中,成为目录项 基本信息 存取控制信息 使用信息 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:71:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"单级目录机构存在什么问题 两级目录存在什么问题,解决了什么问题 单级目录实现了\"按名存取\"但是存在查找速度慢,文件不允许重名,不便于文件共享等缺点,不适合多用户操作系统 二级目录解决了不同用户文件的\"重名\"问题,又在一定程度上保证了文件的安全 但二级目录结构缺乏灵活性,不能对文件分类 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:72:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是相对路径 绝对路径 从根目录出发的路径称为绝对路径 从当前目录出发的路径称为相对路径 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:73:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"文件共享的两种方式 基于索引节点的共享方式(硬链接) 利用符号链实现文件文件共享(软链接) ","date":"2020-12-10","objectID":"/posts/ncepu-11/:74:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"文件保护的手段 口令保护 加密保护 访问控制 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:75:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"文件系统的层次结构 0级: 用户调用接口 1级: 文件目录系统 2级: 存取控制验证 3级: 逻辑文件系统与文件信息缓冲区 4级: 物理文件系统 5级: 辅助分配模块 设备管理程序模块 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:76:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"文件的物理结构(文件的分配方式)都有哪几种 连续分配 链接分配 索引分配 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:77:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"文件存储空间管理方式 对空闲块的管理方式 空闲表法 空闲链表法 位示图法 成组链接法 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:78:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是磁盘的柱面 具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:79:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"磁盘读写操作时间由哪几个部分组成 哪部分的时间最长 寻找时间 旋转延迟时间 传输时间 其中寻找(寻道)时间最长,因此要用算法去优化 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:80:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"I/O的控制方式有什么 程序直接控制 中断驱动方式 DMA方式 通道方式 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:81:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"I/O子系统的层次结构 用户层I/O软件 设备独立性软件 设备驱动程序 中断处理程序 硬件 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:82:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"缓冲池的三个队列是什么 空缓冲队列 输入队列 输出队列 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:83:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是SPOOLING技术 特点是什么 SPOOLING技术是低速输入输出设备与主机交换的一种技术\"假脱机真联机\",以联机的方式得到脱机的效果 提高了I/O的速度 将独占设备改造为共享设备 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:84:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"设备分配的数据结构 设备控制表(DCT) 控制器控制表(COCT) 通道控制表(CHCT) 系统设备表(SDT) ","date":"2020-12-10","objectID":"/posts/ncepu-11/:85:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"什么是设备的独立性 用户在编写程序时使用的设备与实际设备无关 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:86:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"SPOOLING系统的组成部分 输入井 输出井 输入缓冲区 输出缓冲区 输入进程 输出进程(模拟外围控制机) ","date":"2020-12-10","objectID":"/posts/ncepu-11/:87:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"DMA与中断控制的区别 在中断驱动方式中,I/O设备与内存之间的数据交换.必须要经过CPU中的寄存器,所以速度还是受限 而DMA方式的基本思想是在I/O设备和内存之间开辟直接的交换通路 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:88:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"DMA与通道方式的区别 通道方式是DMA的发展,进一步减少CPU的干预,即把对一个数据块的为单位的干预,减少为对一组数据块的干预 同时实现CPU,通道,I/O设备三者的并行操作 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:89:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"磁盘冗余阵列有哪几个分级 各自的特点是什么 一共7级 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:90:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"磁盘冗余阵列(RAID)的优点 可靠性高: 除了0级以外,其余各级都采用了容错技术 I/O速度高: 采取了并行交叉存取方式 性价比高 ","date":"2020-12-10","objectID":"/posts/ncepu-11/:91:0","tags":["数据结构与算法"],"title":"NCEPU 操作系统简答题","uri":"/posts/ncepu-11/"},{"categories":["NCEPU"],"content":"图 课后习题 头文件 #include\u003ciostream\u003e#include\u003ccstdlib\u003e#include\u003cstack\u003e#include\u003cqueue\u003e#include\u003cset\u003eusing namespace std; #define maxsize 1000 typedef struct{ int vexnum, arcnum; int edge[maxsize][maxsize]; int vex[maxsize]; }MGraph; typedef struct arcnode{ struct arcnode *next; int adjvex; int weight; }Arcnode; typedef struct { arcnode *first; int val; }vnode, adjlist[maxsize]; typedef struct{ adjlist vertices; int arcnum; int vexnum; }ALGraph; 题号 1 /* 已知一具有n个顶点的无向图G采用邻接表存储,写一个算法,删除图中数据信息为item的结点 */ void delete_node(ALGraph \u0026g, int x){ //循环删除结点数组 int k = -1; for(int i=0; i\u003cg.vexnum; i++){ //找到删除节点位置 if(g.vertices[i].val == x){ k = i; } } if(k == -1){ return; } arcnode *p = g.vertices[k].first, *q; for(int i=k; i\u003cg.vexnum-1; i++){ //移动 vertices 中的元素 g.vertices[i].val = g.vertices[i+1].val; g.vertices[i].first = g.vertices[i+1].first; } g.vexnum -= 1; while(p){ //删除结点对应的链队 q = p; p = p-\u003enext; delete(q); } arcnode *r; for(int i=0; i\u003cg.vexnum; i++){ p = g.vertices[i].first; if(p-\u003eadjvex == k){ if(g.vertices[i].first == p){ g.vertices[i].first = p-\u003enext; } else{ q-\u003enext = p-\u003enext; } //统一删除 r = p; p = p-\u003enext; delete(r); } else{ q = p; if(p-\u003eadjvex \u003e k){ //只移动 k 之后的结点 p-\u003eadjvex -= 1; } p = p-\u003enext; } } } 题号 2 /* 设图采用邻接矩阵,写出图的深度优先和广度优先 */ void dfs_mgraph(MGraph g, int v, int visited[]){ visited[v] = 1; printf(\"%d\",g.vex[v]); for(int i=0; i\u003cg.vexnum; i++){ if(g.edge[v][i] != 0 \u0026\u0026 visited[i] == 0){ dfs_mgraph(g, i, visited); } } } void dfs_mgraph_non(MGraph g, int v, int visited[]){ stack\u003cint\u003e s; s.push(v); int tmp; while(!s.empty()){ tmp = s.top(); printf(\"%d\", g.vex[tmp]); visited[tmp] = 1; for(int i=0; i\u003cg.vexnum; i++){ if(g.edge[tmp][i] != 0 \u0026\u0026 visited[i] == 0){ s.push(i); break; } if(i == g.vexnum-1){ s.pop(); } } } } void dfs_main(MGraph g){ int visited[g.vexnum] = {0}; for(int i=0; i\u003cg.vexnum; i++){ if(visited[i] == 0){ dfs_mgraph(g, i, visited); } } } void bfs_mgraph(MGraph g, int v, int visited[]){ queue\u003cint\u003e q; q.push(v); int tmp; while(!q.empty()){ tmp = q.front(); printf(\"%d\", g.vex[tmp]); visited[tmp] = 1; q.pop(); for(int i=0; i\u003cg.vexnum; i++){ if(g.edge[tmp][i] != 0 \u0026\u0026 visited[i] == 0){ q.push(i); } } } } 题号 3 /* 编写一个算法,找出在邻接表方式存储的图G中,顶点i到顶点j的不含回路的长度为m的路径数,并输出各个路径 */ vector\u003cint\u003e path; int sum = 0; void find_path(ALGraph g, int v, int j, int m, int visited[]){ path.push_back(v); visited[v] = 1; if(v == j \u0026\u0026 path.size() == m){ ++sum; for(int i=0; i\u003cpath.size(); i++){ printf(\"%d\", path[i]); } } else if(path.size() \u003c m){ arcnode *p = g.vertices[v].first; while(p){ if(visited[p-\u003eadjvex] == 0){ find_path(g, v, j, m, visited); } else{ p = p-\u003enext; } } } path.pop_back(); visited[v] = 0; } 题号 4 /* 以邻接表为存储结构,实现从源点vo到其余各点的最短距离 */ void dijkstra_algraph(ALGraph g, int v0){ int visited[g.vexnum] = {0}; int lowcost[g.vexnum]; for(int i=0; i\u003cg.vexnum; i++){ lowcost[i] = INT_MAX; } arcnode *p = g.vertices[v0].first; visited[v0] = 1; while(p){ lowcost[p-\u003eadjvex] = p-\u003eweight; p = p-\u003enext; } int k; int maxl; for(int i=0; i\u003cg.vexnum; i++){ //n次迭代 k = -1; maxl = INT_MAX; for(int i=0; i\u003cg.vexnum; i++){ if(lowcost[i] \u003c maxl \u0026\u0026 visited[i] == 0){ maxl = i; k = lowcost[i]; } } if(k == -1){ return; } visited[k] = 1; p = g.vertices[k].first; int tmp; while(p){ tmp = p-\u003eweight + lowcost[k]; if(lowcost[p-\u003eadjvex] \u003c tmp){ lowcost[p-\u003eadjvex] = tmp; } p = p-\u003enext; } } } ","date":"2020-11-23","objectID":"/posts/ncepu-9/:0:0","tags":["数据结构与算法"],"title":"NCEPU 图-2(习题)","uri":"/posts/ncepu-9/"},{"categories":["NCEPU"],"content":"图 课后习题 头文件 #include\u003ciostream\u003e#include\u003ccstdlib\u003e#include\u003cstack\u003e#include\u003cqueue\u003e#include\u003cset\u003eusing namespace std; 题号 1.1 /* 对于一个使用邻接表存储的带权有向图G,试用dfs对所有顶点进行拓扑排序 如果拓扑排序成功,返回1,如果图中存在环,则返回0 这个题好像有点问题,他只能判定是否成环,而不能输出拓扑排序序列 拓扑排序序列是 深度优先遍历的 逆后序 */ #define maxsize 1000 typedef struct arcnode{ struct arcnode *next; int vertex; }Arcnode; typedef struct { int val; Arcnode *first; }vnode, adjlist[maxsize]; typedef struct{ adjlist vertices; int vexnum, arcnum; }ALGraph; void dfs_t(ALGraph g, int flag, int v, int visited[], int finished[]){ Arcnode *p = g.vertices[v].first; printf(\"%d\", g.vertices[v].val); finished[v] = 0; visited[v] = 1; while(p){ if(visited[p-\u003evertex] == 1 \u0026\u0026 finished[p-\u003evertex] == 0){ flag = 0; //阻断(成环)标志 } else if(visited[p-\u003evertex] == 0){ dfs_t(g, flag, p-\u003evertex, visited, finished); finished[p-\u003evertex] = 1; } p = p-\u003enext; } } int dfs_t_main(ALGraph g){ int flag = 1; int visited[g.vexnum] = {0}; int finished[g.vexnum] = {1}; int i = 0; while(flag == 1 \u0026\u0026 i \u003c g.vexnum){ if(visited[i] == 0){ dfs_t(g, flag, i, visited, finished); } else{ i++; } finished[i] = 1; } return flag; } 题号 1.2 /* 设计一个算法,求出无向图G的连通分量个数,假设题中顶点标号为 1-g.vexnum-1 */ typedef struct{ int arcnum, vexnum; int edge[maxsize][maxsize]; }MGraph; int count_num(MGraph g){ int visited[g.vexnum] = {0}; int num = 0; for(int i=0; i\u003cg.vexnum; i++){ if(visited[i] == 0){ dfs_mgraph(g, i, visited); num++; } } return num; } void dfs_mgraph(MGraph g, int v, int visited[]){ visited[v] = 1; for(int i=0; i\u003cg.vexnum; i++){ if(g.edge[v][i] != 0 \u0026\u0026 visited[i] == 0){ dfs_mgraph(g, i, visited); } } } 题号 1.4 /* 设计一个算法,从入口\"0\"到出口\"6\"必须经过食品和财宝的地方,不得经过强盗的点 */ bool verify_valid(vector\u003cint\u003e v, int a, int b){ bool v1 = false, v2 = false; for(int i=0; i\u003cv.size(); i++){ if(v[i] == a){ v1 = true; } if(v[i] == b){ v2 = true; } } if(v1 \u0026\u0026 v2){ return true; } return false; } void print_path(ALGraph g, int i, int vj, int visited[], vector\u003cint\u003e v, int a, int b, int c){ if(i == c){ return; } else if(i == vj){ v.push_back(vj); if(verify_valid(v, a, b)){ for(int i=0; i\u003cv.size(); i++){ printf(\"%d \", v[i]); } } } else{ v.push_back(i); visited[i] = true; Arcnode *p = g.vertices[i].first; while(p){ if(visited[p-\u003evertex] = 0){ print_path(g, p-\u003evertex, vj, visited, v, a, b, c); } } v.pop_back(); visited[i] = 0; } } void print_path_main(ALGraph g, int vi, int vj, int a, int b, int c){ int visited[g.vexnum] = {0}; vector\u003cint\u003e path; print_path(g, vi, vj, visited, path, a, b, c); } 题号 1.5 /* 设计一个算法,输出图G中经过某个顶点vi,长度为L的所有环 */ void print_cycle(ALGraph g, int i, int vi, int l, int visited[], vector\u003cint\u003e v){ if(i == vi \u0026\u0026 v.size() == l){ v.push_back(vi); for(int i=0; i\u003cv.size(); i++){ printf(\"%d\", v[i]); } } else{ visited[i] = 1; v.push_back(i); Arcnode *p = g.vertices[i].first; while(p){ if(v.size() \u003e l){ return; } if(visited[p-\u003evertex] == 0 || p-\u003evertex == vi){ print_cycle(g, p-\u003evertex, vi, l, visited, v); } p = p-\u003enext; } v.pop_back(); visited[i] = 0; } } void cycle(ALGraph g, int vi, int vj, int l){ int visited[g.vexnum] = {0}; vector\u003cint\u003e v; print_cycle(g, vi, vj, l, visited, v); } 题号 1.6 /* 假设图采用邻接表存储,编写一个算法,利用深度优先求出无向图中通过给定结点v的所有简单回路 */ /* 和上一题相同,只是不需要路径长度判定 */ 题号1.7 /* 设计一个算法创建一个带权的无向图,要求被创建的图由用户输入 输出从v0到其他各点的最短路径长度和路径 */ MGraph *create_graph(){ int n; cout \u003c\u003c \"输入节点个数\"; cin \u003e\u003e n; MGraph *g = new MGraph(); if(g == nullptr){ return nullptr; } g-\u003evexnum = n; int a, b, weight; for(int i=0; i\u003cg-\u003evexnum; i++){ cout \u003c\u003c \"输入边\"; cin \u003e\u003e a \u003e\u003e b \u003e\u003e weight; g-\u003eedge[a][b] = g-\u003eedge[b][a] = weight; } return g; } void dji(MGraph g, int vi, int visited[], int pre[]){ int lowcost[g.vexnum] = {0}; for(int i=0; i\u003cg.vexnum; i++){ //初始化lowcost if(g.edge[vi][i] != 0){ lowcost[i] = g.edge[vi][i]; pre[i] = vi; } } for(int i=0; i\u003cg.vexnum; i++){ int min = INT_MAX; int index; for(int j=0; j\u003cg.vexnum; j++){ if(visited[j] == 0 \u0026\u0026 lowcost[j] \u003c min){ index = j; min = lowcost[j]; } } visited[index] = 1; for(int i=0; i\u003cg.vexnum; i++){ int dis = lowcost[index] + g.edge[index][i]; if(dis \u003c lowcost[i]){ pre[i] = index; } } } } void dji_main(int vi)","date":"2020-11-17","objectID":"/posts/ncepu-8/:0:0","tags":["数据结构与算法"],"title":"NCEPU 图(习题)","uri":"/posts/ncepu-8/"},{"categories":["NCEPU"],"content":"二叉树\u0026\u0026图 课后习题 头文件 #include\u003ciostream\u003e#include\u003ccstdlib\u003e#include\u003cstack\u003e#include\u003cqueue\u003e#include\u003cset\u003eusing namespace std; 二叉树 ","date":"2020-11-15","objectID":"/posts/ncepu-7/:0:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树\u0026图(习题)","uri":"/posts/ncepu-7/"},{"categories":["NCEPU"],"content":"题号 6.6 typedef struct tnode{ struct tnode *left, *right; int val; }TNode; /* 设二叉树采用链式存储结构,试设计一个算法计算一棵给定二叉树中单孩子结点的数量 */ int num = 0; int childnum(TNode *root){ if(root == nullptr){ return 0; } if(root-\u003eleft == nullptr \u0026\u0026 root-\u003eright){ num++; } else if(root-\u003eright == nullptr \u0026\u0026 root-\u003eleft){ num++; } childnum(root-\u003eleft); childnum(root-\u003eright); } ","date":"2020-11-15","objectID":"/posts/ncepu-7/:1:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树\u0026图(习题)","uri":"/posts/ncepu-7/"},{"categories":["NCEPU"],"content":"题号 6.7 /* 设t指向二叉树根节点的指针,试求二叉树中某节点p的双亲结点 */ TNode *get_father(TNode *root, TNode *p){ if(root == nullptr){ return nullptr; } if(root-\u003eleft == p || root-\u003eright == p){ return root; } else { TNode *r = get_father(root-\u003eright, p); TNode *l = get_father(root-\u003eleft, p); if(r){ return r; } if(l){ return l; } } return nullptr; } 图 ","date":"2020-11-15","objectID":"/posts/ncepu-7/:2:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树\u0026图(习题)","uri":"/posts/ncepu-7/"},{"categories":["NCEPU"],"content":"结构定义 #define maxsize 1000 //邻接矩阵 typedef struct { int edges[maxsize][maxsize]; int vertex[maxsize]; int vexnum, arcnum; }MGraph; //邻接表 typedef struct arcnode{ int vertex; struct arcnode *next; }Arcnode; typedef struct{ int val; Arcnode *first; }vnode, adjlist[maxsize]; typedef struct{ adjlist vertices; int arcnum, vexnum; }ALGraph; ","date":"2020-11-15","objectID":"/posts/ncepu-7/:3:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树\u0026图(习题)","uri":"/posts/ncepu-7/"},{"categories":["NCEPU"],"content":"题号 图-2.1 /* 编写一个算法,将一个无环图的邻接矩阵转换为邻接表 */ void convert_ma(MGraph g1, ALGraph \u0026g2){ for(int i=0; i\u003cg1.vexnum; i++){ g2.vertices[i].val = g1.vertex[i]; g2.vertices[i].first = nullptr; } for(int i=0; i\u003cg1.vexnum; i++){ for(int j=0; j\u003cg1.vexnum; j++){ if(g1.edges[i][j] != 0){ //存在边 if(g2.vertices[i].first == nullptr){ Arcnode *n = new Arcnode(); n-\u003evertex = j; n-\u003enext = nullptr; } else{ Arcnode *p = g2.vertices[i].first; while(p){ p = p-\u003enext; } Arcnode *n = new Arcnode(); n-\u003evertex = j; p-\u003enext = n; n-\u003enext = nullptr; } } } } g2.vexnum = g1.vexnum; g2.arcnum = g1.arcnum; } ","date":"2020-11-15","objectID":"/posts/ncepu-7/:4:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树\u0026图(习题)","uri":"/posts/ncepu-7/"},{"categories":["NCEPU"],"content":"题号 图-2.2 /* 设计一个算法,判断无向图G是否连通,若连同,则返回1,否则返回0,假设途中顶点标号从 0-g.vexnum-1 */ int bfs_mgraph(MGraph g){ int visited[g.vexnum] = {0}; queue\u003cint\u003e q; q.push(0); while(!q.empty()){ int tmp = q.front(); q.pop(); for(int i=0; i\u003cg.vexnum; i++){ if(g.edges[tmp][i] != 0){ if(visited[i] == 0){ visited[i] = 1; q.push(i); } } } } for(int i=0; i\u003cg.vexnum; i++){ if(visited[i] == 0){ return 0; } } return 1; } ","date":"2020-11-15","objectID":"/posts/ncepu-7/:5:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树\u0026图(习题)","uri":"/posts/ncepu-7/"},{"categories":["NCEPU"],"content":"题号 2.3 /* 设计一个算法,输出G中从顶点 vi 到 vj 的长度为L的所有路径 */ typedef struct{ vector\u003cint\u003e v; int sum; }path; void get_path(MGraph g, int vi, int vj, int L){ path *p = new path(); p-\u003esum = 0; int visited[g.vexnum] = {0}; for(int i=0; i\u003cg.vexnum; i++){ int tmp = g.edges[vi][i]; if(tmp != 0){ dfs_path(g, vj, L, vi, p, visited,tmp); } } } void dfs_path(MGraph g, int vj, int l, int k, path *p, int visited[], int sum){ visited[k] = 1; p-\u003ev.push_back(k); for(int i=0; i\u003cg.vexnum; i++){ if(g.edges[k][i] != 0 \u0026\u0026 visited[i] == 0){ sum += g.edges[k][i]; if(sum == l \u0026\u0026 i == vj){ for(int i=0; i\u003cp-\u003ev.size(); i++){ print(\"%d\", p-\u003ev[i]); } } else if(sum \u003c l){ dfs_path(g,vj,l,i,p,visited,sum); } } sum -= g.edges[k][i]; } p-\u003ev.pop_back(); visited[k] = 0; } ","date":"2020-11-15","objectID":"/posts/ncepu-7/:6:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树\u0026图(习题)","uri":"/posts/ncepu-7/"},{"categories":["NCEPU"],"content":"题号 2.4 /* 编写一个实现连通图G的深度优先搜索的非递归函数 */ //邻接矩阵 void dfs_main(MGraph g){ int visited[g.vexnum] = {0}; for(int i=0; i\u003cg.vexnum; i++){ dfs_non(g, i, visited); } } void dfs_non(MGraph g, int i, int visited[]){ if(visited[i] == 1){ return; } stack\u003cint\u003e s; s.push(i); int tmp; while(!s.empty()){ tmp = s.top(); printf(\"%d\", g.vertex[tmp]); visited[tmp] = 1; s.pop(); for(int i=0; i\u003cg.vexnum; i++){ if(g.edges[tmp][i] != 0 \u0026\u0026 visited[i] == 0){ s.push(i); break; } if(i == g.vexnum-1){ s.pop(); } } } } //邻接表 void dfs_non_list(ALGraph g, int i, int visited[]){ stack\u003cint\u003e s; s.push(i); int tmp; while(!s.empty()){ tmp = s.top(); printf(\"%d\", g.vertices[tmp].val); visited[tmp] = 1; Arcnode *p = g.vertices[tmp].first; while(p){ if(visited[p-\u003evertex] == 0){ s.push(p-\u003evertex); break; } else{ p = p-\u003enext; } if(p == nullptr){ s.pop(); } } } } void dfs_main_list(ALGraph g){ int visited[g.vexnum] = {0}; for(int i=0; i\u003cg.vexnum; i++){ if(visited[i] == 0){ dfs_non_list(g, i, visited); } } } ","date":"2020-11-15","objectID":"/posts/ncepu-7/:7:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树\u0026图(习题)","uri":"/posts/ncepu-7/"},{"categories":["NCEPU"],"content":"查找 \u0026\u0026 排序基本算法 头文件 #include\u003ciostream\u003e#include\u003ccstdlib\u003e#include\u003cstack\u003e#include\u003cqueue\u003e#include\u003cset\u003e 顺序查找 typedef struct{ int *data; int length; }stable; int find(stable t, int x){ int len = t.length; for(int i=0; i\u003clen; i++){ if(t.data[i] == x){ return i; } } } 折半查找 int find(stable t, int x){ int len = t.length; int low = 0, high = len-1; int mid; while(low \u003c= high){ mid = (low+high)/2; if(t.data[mid] == x){ return mid; } else if(t.data[mid] \u003c x){ high = mid-1; } else{ low = mid+1; } } return -1; } 插入排序-直接插入排序 int insert_sort(stable t){ int i, j; int tmp; for(i=1; i\u003ct.length; i++){ if(t.data[i] \u003c t.data[i-1]){ tmp = t.data[i]; for(j = i-1; tmp \u003c t.data[j]; --j){ t.data[j+1] = t.data[j]; } t.data[j+1] = tmp; } } } 折半插入 void insert_sort_half(stable t){ int i, j, tmp; int low, high, mid; for(i=1; i\u003ct.length; i++){ tmp = t.data[i]; //其中 [0, i)为有序序列 low = 0; high = i-1; while(low \u003c= high){ mid = (high+low)/2; if(t.data[mid] \u003e tmp){ high = mid-1; } else{ low = mid+1; } } //折半查找到位置 low = high for(j=i-1; j \u003e= high+1; --j){ //统一后移 t.data[j+1] = t.data[j]; } t.data[j+1] = tmp; } } 希尔排序 void shell_sort(stable t){ int dk,i,j; int tmp; for(dk = t.length/2; dk \u003e= 1; dk = dk/2){ for(i=dk+1; i\u003ct.length; i++){ if(t.data[i] \u003c t.data[i-dk]){ tmp = t.data[i]; for(j=i-dk; j\u003e0 \u0026\u0026 tmp\u003ct.data[j]; j-=dk){ t.data[j+dk] = t.data[j]; } t.data[j+dk] = tmp; } } } } 快速排序 int partition(stable t, int low, int high){ int pivot = t.data[0]; while(low \u003c high){ while(low \u003c high \u0026\u0026 t.data[high] \u003e= pivot){ --high; } t.data[low] = t.data[high]; while(low \u003c high \u0026\u0026 t.data[low] \u003c= pivot){ ++low; } t.data[high] = t.data[low]; } t.data[low] = pivot; return low; } void quick_sort(stable t, int low, int high){ if(low \u003c high){ int pivot = partition(t, low, high); quick_sort(t, low, pivot-1); quick_sort(t, pivot+1, high); } } 简单选择排序 void swap(stable t, int i, int j){ int tmp = t.data[i]; t.data[i] = t.data[j]; t.data[j] = tmp; } void selectsort(stable t){ for(int i=0; i\u003ct.length-1; i++){ int min = i; for(int j = i+1; j\u003ct.length; j++){ if(t.data[j] \u003c t.data[min]){ min = j; } } if(min != i){ swap(t, t.data[min], t.data[i]); } } } 堆排序 ","date":"2020-11-14","objectID":"/posts/ncepu-6/:0:0","tags":["数据结构与算法"],"title":"NCEPU 排序","uri":"/posts/ncepu-6/"},{"categories":["NCEPU"],"content":"建堆 void adjust_heap_down(int a[], int index, int len){ int tmp = a[index]; for(int i=2*index; i\u003c=len; i*=2){ if(i\u003clen \u0026\u0026 a[i] \u003c a[i+1]){ i++; } if(tmp \u003e a[i]){ break; } else{ a[index] = a[i]; index = i; } } a[index] = tmp; } void adjust_heap_up(int a[], int index, int len){ int tmp = a[index]; int i = index/2; while(i\u003e0 \u0026\u0026 a[i]\u003ca[index]){ a[index] = a[i]; index = i; i = i/2; } a[index] = tmp; } void build_heap_maxtree(stable t){ for(int i=t.length/2; i\u003e0; i--){ adjust_heap_down(t.data, i, t.length); } } ","date":"2020-11-14","objectID":"/posts/ncepu-6/:1:0","tags":["数据结构与算法"],"title":"NCEPU 排序","uri":"/posts/ncepu-6/"},{"categories":["NCEPU"],"content":"堆排序 void heap_sort(stable t){ build_heap_maxtree(t); //初始建堆 for(int i=t.length-1; i\u003e0; i--){ swap(t, i, 0); adjust_heap_down(t.data, i-1, i); } } 归并排序 stable *t = new stable(); int n = t-\u003elength; int *tmp = (int*)malloc(sizeof(int)*(n+1)); //申请辅助空间 void merge(stable t, int low, int mid, int high){ //两端各自有序,合并为一段有序 int i, j, k; for(k = low; k\u003c=high; k++){ tmp[k] = t.data[k]; } for(i=low, j=mid+1, k=i; i\u003c=mid \u0026\u0026 j\u003c=high; k++){ if(tmp[i] \u003c= tmp[j]){ t.data[k++] = tmp[i++]; } else{ t.data[k++] = tmp[j++]; } } while(i \u003c= mid){ t.data[k++] = tmp[i++]; } while(j \u003c= high){ t.data[k++] = tmp[j++]; } } void merge_sort(stable t, int low, int high){ if(low \u003c high){ int mid = (low+high)/2; merge_sort(t, low, mid-1); merge_sort(t, mid+1, high); merge(t, low, mid, high); } } 数据结构的基本算法算是完事啦! ","date":"2020-11-14","objectID":"/posts/ncepu-6/:2:0","tags":["数据结构与算法"],"title":"NCEPU 排序","uri":"/posts/ncepu-6/"},{"categories":["NCEPU"],"content":"图基本算法 头文件 #include\u003ciostream\u003e#include\u003ccstdlib\u003e#include\u003cstack\u003e#include\u003cqueue\u003e#include\u003cset\u003eusing namespace std; #define Elemtype int #define maxsize 10000 邻接矩阵结构 typedef struct { int edge[maxsize][maxsize]; Elemtype vex[maxsize]; int vexnum,arcnum; }MGraph; 邻接表结构 typedef struct arcnode{ //边结点 int adjvex; //指向的邻接表中的编号 struct arcnode *next; }; typedef struct vnode{ //头结点 Elemtype val; //顶点的值 arcnode *first; }vnode, adjlist[maxsize]; typedef struct { int vexnum, arcnum; adjlist vertices; }ALGraph; 最短路径 ","date":"2020-10-28","objectID":"/posts/ncepu-5/:0:0","tags":["数据结构与算法"],"title":"NCEPU 图","uri":"/posts/ncepu-5/"},{"categories":["NCEPU"],"content":"Dijkstra单源最短 /* 单源最短路径,一个起始点,到剩余所有点的最短路径 */ void dijkstra(MGraph g, int p){ int k, maxs; int n = g.vexnum; bool visited[n]; int dis[n]; for(int i=0; i\u003cn; i++){ dis[i] = g.edge[p][i]; visited[i] = false; } for(int i=0; i\u003cn; i++){ // n次迭代 maxs = INT_MAX; for(int j=0; j\u003cn; j++){ //找到贪心点 if(!visited[j] \u0026\u0026 dis[j]\u003cmaxs){ maxs = dis[j]; k = j; } } visited[k] = true; for(int j=0; j\u003cn; j++){ //对贪心点作为中间节点,更新dis[] if(!visited[j] \u0026\u0026 g.edge[k][j] != INT_MAX){ dis[j] = (dis[k]+g.edge[k][j]) \u003c dis[j] ? (dis[k]+g.edge[k][j]) : dis[j]; } } } } ","date":"2020-10-28","objectID":"/posts/ncepu-5/:1:0","tags":["数据结构与算法"],"title":"NCEPU 图","uri":"/posts/ncepu-5/"},{"categories":["NCEPU"],"content":"Floyd多源最短 /* 多源最短路径 */ void floyd(MGraph g){ for(int k=0; k\u003cg.vexnum; k++){ for(int i=0; i\u003cg.vexnum; i++){ for(int j=0; j\u003cg.vexnum; j++){ if(g.edge[i][k] != INT_MAX \u0026\u0026 g.edge[j][k] != INT_MAX \u0026\u0026 g.edge[i][k]+g.edge[k][j] \u003c g.edge[i][j]){ g.edge[i][j] = g.edge[i][k]+g.edge[k][j]; } } } } } Prim最小生成树 typedef struct{ int weight; int vi; //前驱结点 int vj; //当前节点 }lowcost; void prim(MGraph g){ lowcost *lowest = new lowcost[g.vexnum]; for(int i=0; i\u003cg.vexnum; i++){ //初始化lowest数组 lowest[i].weight = g.edge[0][i]; lowest[i].vi = 0; lowest[i].vj = i; } lowest[0].weight = 0; int min; int k; for(int i=0; i\u003cg.vexnum; i++){ // num迭代 min = INT_MAX; for(int j=0; j\u003cg.vexnum; j++){ //找到贪心节点 if(lowest[j].weight != 0 \u0026\u0026 lowest[j].weight \u003c min){ min = lowest[j].weight; k = j; } } lowest[k].weight = 0; for(int j=0; j\u003cg.vexnum; j++){ //更新路径权值 if(lowest[j].weight \u003e g.edge[k][j]){ lowest[j].weight = g.edge[k][j]; lowest[j].vi = k; } } } } DFS-递归 ","date":"2020-10-28","objectID":"/posts/ncepu-5/:2:0","tags":["数据结构与算法"],"title":"NCEPU 图","uri":"/posts/ncepu-5/"},{"categories":["NCEPU"],"content":"邻接矩阵-递归 void dfs_matrix_traversal(MGraph g){ int visited[g.vexnum] = {0}; for(int i=0; i\u003cg.vexnum; i++){ dfs_matrix(g,i,visited); } } void dfs_matrix(MGraph g, int v, int visited[]){ printf(\"%d\", g.vex[v]); visited[v] = 1; for(int i=0; i\u003cg.vexnum; i++){ if(g.edge[v][i] != 0 \u0026\u0026 visited[i] == 0){ dfs_matrix(g,i,visited); } } } ","date":"2020-10-28","objectID":"/posts/ncepu-5/:3:0","tags":["数据结构与算法"],"title":"NCEPU 图","uri":"/posts/ncepu-5/"},{"categories":["NCEPU"],"content":"邻接表-递归 void dfs_list_traversal(ALGraph g){ int visited[g.vexnum] = {0}; for(int i=0; i\u003cg.vexnum; i++){ if(visited[i] == 0){ dfs_list(g, i, visited); } } } void dfs_list(ALGraph g, int v, int visited[]){ printf(\"%d\", g.vertices[v].val); visited[v] = 1; arcnode *p = g.vertices[v].first; while(p){ int i = p-\u003eadjvex; if(visited[i] == 0){ dfs_list(g, i, visited); } p = p-\u003enext; } } DFS-非递归 ","date":"2020-10-28","objectID":"/posts/ncepu-5/:4:0","tags":["数据结构与算法"],"title":"NCEPU 图","uri":"/posts/ncepu-5/"},{"categories":["NCEPU"],"content":"邻接矩阵-非递归 void nonrecursive_dfs_matrix(MGraph g, int v, int visited[]){ stack\u003cint\u003e s; printf(\"%d\", g.vex[v]); s.push(v); while(!s.empty()){ int t = s.top(); for(int i=0; i\u003cg.vexnum; i++){ if(g.edge[t][i] != 0 \u0026\u0026 visited[i] == 0){ printf(\"%d\", g.vex[i]); visited[i] = 1; s.push(i); break; } if(i == g.vexnum){ s.pop(); } } } } void nonrevursive_dfs_matrix_traversal(MGraph g){ int visited[g.vexnum] = {0}; for(int i=0; i\u003cg.vexnum; i++){ if(visited[i] == 0){ nonrecursive_dfs_matrix(g, i, visited); } } } ","date":"2020-10-28","objectID":"/posts/ncepu-5/:5:0","tags":["数据结构与算法"],"title":"NCEPU 图","uri":"/posts/ncepu-5/"},{"categories":["NCEPU"],"content":"邻接表-非递归 void nonrecursive_dfs_list(ALGraph g, int v, int visited[]){ printf(\"%d\", g.vertices[v].val); //访问初始节点 visited[v] = 1; stack\u003cint\u003e s; s.push(v); arcnode *p; while(!s.empty()){ p = g.vertices[s.top()].first; while(p){ if(visited[p-\u003eadjvex] == 0){ visited[p-\u003eadjvex] = 1; s.push(p-\u003eadjvex); printf(\"%d\", g.vertices[p-\u003eadjvex].val); p = g.vertices[p-\u003eadjvex].first; } else{ p = p-\u003enext; } if(p == nullptr){ s.pop(); } } } } void nonrecursive_dfs_list_traversal(ALGraph g){ int visited[g.vexnum] = {0}; for(int i=0; i\u003cg.vexnum; i++){ if(visited[i] == 0){ nonrecursive_dfs_list(g, i, visited); } } } BFS ","date":"2020-10-28","objectID":"/posts/ncepu-5/:6:0","tags":["数据结构与算法"],"title":"NCEPU 图","uri":"/posts/ncepu-5/"},{"categories":["NCEPU"],"content":"邻接矩阵 void bfs_matrix(MGraph g, int v, int visited[]){ queue\u003cint\u003e q; q.push(v); while(!q.empty()){ //层序遍历 int t = q.front(); q.pop(); visited[v] = 1; printf(\"%d\", g.vex[v]); for(int i=0; i\u003cg.vexnum; i++){ if(g.edge[t][i] != 0 \u0026\u0026 visited[i] == 0){ q.push(i); } } } } ","date":"2020-10-28","objectID":"/posts/ncepu-5/:7:0","tags":["数据结构与算法"],"title":"NCEPU 图","uri":"/posts/ncepu-5/"},{"categories":["NCEPU"],"content":"邻接表 void dfs_list(ALGraph g, int v, int visited[]){ queue\u003cint\u003e q; q.push(v); while(!q.empty()){ int t = q.front(); q.pop(); visited[t] = 1; printf(\"%d\", g.vertices[t].val); arcnode *p = g.vertices[t].first; while(p){ q.push(p-\u003eadjvex); p = p-\u003enext; } } } ","date":"2020-10-28","objectID":"/posts/ncepu-5/:8:0","tags":["数据结构与算法"],"title":"NCEPU 图","uri":"/posts/ncepu-5/"},{"categories":["NCEPU"],"content":"二叉树基本算法 #include\u003ciostream\u003e#include\u003ccstdlib\u003e#include\u003cstack\u003e#include\u003cqueue\u003e#include\u003cset\u003e using namespace std; #define Elemtype int #define maxsize 10000 树的结构 typedef struct tnode{ struct tnode *left; struct tnode *right; Elemtype val; }Treenode; 先序 ","date":"2020-10-25","objectID":"/posts/ncepu-4/:0:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"先序访问(递归) void preorder(Treenode *root){ if(!root){ return; } printf(\"%d\", root-\u003eval); preorder(root-\u003eleft); preorder(root-\u003eright); } ","date":"2020-10-25","objectID":"/posts/ncepu-4/:1:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"先序遍历非递归 void nonrecursive_preorder(Treenode *root){ stack\u003cTreenode*\u003e s; Treenode *tmp; while(!s.empty() || root){ while(root){ printf(\"%d\", root-\u003eval); //在节点左移过程中输出 s.push(root); root = root-\u003eleft; } tmp = s.top(); s.pop(); root = tmp-\u003eright; } } 中序 ","date":"2020-10-25","objectID":"/posts/ncepu-4/:2:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"中序递归 void inorder(Treenode *root){ if(!root){ return; } inorder(root-\u003eleft); printf(\"%d\", root-\u003eval); inorder(root-\u003eright); } ","date":"2020-10-25","objectID":"/posts/ncepu-4/:3:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"中序非递归 void nonrecursive_inorder(Treenode *root){ stack\u003cTreenode*\u003e s; Treenode *tmp; while(!s.empty() || root){ while(root){ s.push(root); root = root-\u003eleft; } tmp = s.top(); //while后输出 printf(\"%d\", tmp-\u003eval); s.pop(); root = tmp-\u003eright; } } 后序 ","date":"2020-10-25","objectID":"/posts/ncepu-4/:4:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"后序递归 void postorder(Treenode *root){ if(!root){ return; } postorder(root-\u003eleft); postorder(root-\u003eright); printf(\"%d\",root-\u003eval); } ","date":"2020-10-25","objectID":"/posts/ncepu-4/:5:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"后序非递归 void nonrecursive_postorder(Treenode *root){ Treenode *pre = root; stack\u003cTreenode*\u003e s; while(!s.empty() || root){ while(root){ s.push(root); root = root-\u003eleft; } root = s.top(); if(root-\u003eright == nullptr || root-\u003eright == pre){ printf(\"%d\", root-\u003eval); s.pop(); pre = root; root = nullptr; } else{ root = root-\u003eright; } } } 层序遍历 void levleorder(Treenode *root){ if(!root){ return; } queue\u003cTreenode*\u003e q; q.push(root); while(!q.empty()){ root = q.front(); printf(\"%d\", root-\u003eval); if(root-\u003eleft){ q.push(root-\u003eleft); } if(root-\u003eright){ q.push(root-\u003eright); } q.pop(); } } 交换子树 //设计一个算法,交换二叉树的所有节点的左右子树 //前序递归和后序递归不需要多考虑,但是中序递归需要注意 void swap_child(Treenode *root){ if(!root){ return; } swap_child(root-\u003eleft); Treenode *tmp = root-\u003eleft; root-\u003eleft = root-\u003eright; root-\u003eright = tmp; swap_child(root-\u003eright); } /* 交换二叉树的左右子树可采用先序遍历，中序遍历，后序遍历完成。先序与后序不需要考虑太多，简单交换即可。 中序遍历要考虑到，若左子树已经交换过了，那么左右一交换 原来的左变为右了，原来的右子树变为左子树，而新的左子树是没有进行交换过的。 */ 中序递归交换左右子树 Treenode* exchange_rootMiddle(Treenode* T) { if(!T){ return nullptr; } if(T-\u003eleft!=NULL||T-\u003eright!=NULL) { Treenode *p,*q; p = exchange_rootMiddle(T-\u003eleft); q = T-\u003eright; T-\u003eright = p; T-\u003eleft = q; q = exchange_rootMiddle(T-\u003eright); } return T; } 叶子节点路径 //二叉树采用三叉链表存储结构,设计一个算法输出二叉树从根节点到所有叶子节点的路径 typedef struct triple_tree{ struct triple_tree *parent; struct triple_tree *left; struct triple_tree *right; Elemtype val; }triple_tree; void print_road(triple_tree *root){ if(!root){ return; } printf(\"%d\", root-\u003eval); print_road(root-\u003eparent); } void dfs_road(triple_tree *root){ if(!root){ return; } if(root-\u003eleft == nullptr \u0026\u0026 root-\u003eright == nullptr){ print_road(root); } if(root-\u003eleft){ root-\u003eleft-\u003eparent = root; dfs_road(root-\u003eleft); } if(root-\u003eright){ root-\u003eright-\u003eparent = root; dfs_road(root-\u003eright); } } void recursive_road(triple_tree *root){ if(!root){ return; } root-\u003eparent = nullptr; dfs_road(root); } 三叉树链表打印路径 非递归 void dfs_nonrecursive(triple_tree *root){ stack\u003ctriple_tree*\u003e s; triple_tree *tmp; while(root || !s.empty()){ while(root){ s.push(root); if(root-\u003eleft == nullptr \u0026\u0026 root-\u003eright == nullptr){ print_road(root); } else if(root-\u003eleft){ root-\u003eleft-\u003eparent = root; } else if(root-\u003eright){ root-\u003eright-\u003eparent = root; } root == root-\u003eleft; } tmp = s.top(); s.pop(); root = tmp-\u003eright; } } 线索二叉树 typedef struct BTNode{ Elemtype val; struct BTNode *left, *right; int ltag, rtag; }BTNode, *BTTree; ","date":"2020-10-25","objectID":"/posts/ncepu-4/:6:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"线索二叉树前序线索化 BTTree pre = nullptr; void preorder_thread(BTTree t){ if(!t){ return; } if(pre \u0026\u0026 pre-\u003ertag == 1){ pre-\u003eleft = t; } if(!t-\u003eleft){ t-\u003eleft = pre; t-\u003eltag = 1; } else{ t-\u003eltag = 0; } if(!t-\u003eright){ t-\u003ertag = 1; } else{ t-\u003ertag = 0; } pre = t; preorder_thread(t-\u003eleft); preorder_thread(t-\u003eright); } ","date":"2020-10-25","objectID":"/posts/ncepu-4/:7:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"前序线索遍历-新版 void pre_thread_order(BTTree root){ if(!root){ return; } BTNode *p = root; while(p){ while(p-\u003eltag == 0){ printf(\"%d\", p-\u003eval); p = p-\u003eleft; } printf(\"%d\", p-\u003eval); p = p-\u003eright; } } ","date":"2020-10-25","objectID":"/posts/ncepu-4/:8:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"前序线索二叉树2 void bttree_preorder(BTTree t){ if(!t){ return; } BTNode *p = t; while(p){ printf(\"%d\", p-\u003eval); if(p-\u003ertag == 1){ p = p-\u003eright; } else{ if(p-\u003eltag == 0){ p = p-\u003eleft; } else{ p = p-\u003eright; } } } } ","date":"2020-10-25","objectID":"/posts/ncepu-4/:9:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"二叉树的中序线索化 BTNode *pre = nullptr; void inorder_thread(BTTree t){ if(!t){ return; } inorder_thread(t-\u003eleft); //前驱结点-线索 if(pre \u0026\u0026 pre-\u003ertag == 1){ pre-\u003eright = t; } //当前结点-线索 //左 if(!t-\u003eleft){ t-\u003eleft = pre; t-\u003eltag = 1; } else{ t-\u003eltag = 0; } //右 if(!t-\u003eright){ t-\u003ertag = 1; } else{ t-\u003ertag = 0; } pre = t; inorder_thread(t-\u003eright); } ","date":"2020-10-25","objectID":"/posts/ncepu-4/:10:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"中序线索二叉树的遍历-新版 void bttree_iorder(BTTree root){ BTNode *p = root; while(p){ while(p-\u003eltag == 0){ p = p-\u003eleft; } printf(\"%d\", p-\u003eval); while(p-\u003ertag == 1){ p = p-\u003eright; printf(\"%d\", p-\u003eval); } p = p-\u003eright; } } ","date":"2020-10-25","objectID":"/posts/ncepu-4/:11:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"中序线索二叉树的遍历-2 void bttree_inorder(BTTree t){ if(!t){ return; } BTNode *p = t; while(p-\u003eltag == 0){ p = p-\u003eleft; } while(p){ printf(\"%d\", p-\u003eval); if(p-\u003ertag == 1){ p = p-\u003eright; } else{ p = p-\u003eright; while(p-\u003eltag == 0){ p = p-\u003eleft; } } } } ","date":"2020-10-25","objectID":"/posts/ncepu-4/:12:0","tags":["数据结构与算法"],"title":"NCEPU 二叉树","uri":"/posts/ncepu-4/"},{"categories":["NCEPU"],"content":"课后习题-单链表 头文件 #include\u003ciostream\u003e#include\u003ccstdlib\u003e#include\u003cstack\u003e#include\u003cqueue\u003e#include\u003cset\u003e using namespace std; #define Elemtype int #define maxsize 10000 typedef struct listnode{ struct listnode *next; Elemtype val; }ListNode; 题号 3.1 /* 有一个带头结点的单链表(不同节点的值域可能相同)其头指针为head,编写一个函数来计算数据域为x的节点个数 (默认链表都带头结点) */ int list_count(ListNode *head, int x){ ListNode *p = head-\u003enext; int num = 0; while(p){ if(head-\u003eval == x){ num++; } p = p-\u003enext; } return num;; } 题号 3.2 /*IMPORTANT: 链表的原地逆置 有一个单链表l(至少有一个节点)的头指针为head,编写一个函数将l逆置 */ void reverse_list(ListNode *head){ ListNode *p = head, *q = head-\u003enext; while(q){ ListNode *r = p-\u003enext; q-\u003enext = p; p = q; q = r; } head-\u003enext = nullptr; head = p; } 题号 3.3 /* 已知一个带头结点的单链表中的元素按元素非递减有序排列,编写一个函数删除链表中多余的值相同的元素 */ void delete_same(ListNode* head){ ListNode *p = head-\u003enext, *q = p-\u003enext; if(!p){ return; } while(q){ if(p-\u003eval == q-\u003eval){ p-\u003enext = q-\u003enext; free(q); //注意释放空间 } else{ p = p-\u003enext; } q = p-\u003enext; } } 题号 3.4 /* 设计一个算法判断链表的元素是否递增有序 */ bool isbigger(ListNode *head){ ListNode *p = head-\u003enext, *q = p-\u003enext; if(!p){ return true; } while(q){ if(q-\u003eval \u003c= p-\u003eval){ return false; } p = p-\u003enext; q = p-\u003enext; } return true; } 题号 3.5 /* 已知两个不带头结点单链表A和B,其头指针分别为heada和headb 编写一个函数,从链表a自i起的len个节点,然后将他们插入到链表b第j个节点前 */ void switchnode(ListNode *heada, ListNode *headb, int i, int len, int j){ ListNode *a = new ListNode(); a-\u003enext = heada; ListNode *b = new ListNode(); b-\u003enext = headb; //查找a中第i个节点前驱 for(int k=0; k\u003ci-1; k++){ if(!a){ printf(\"i越界\"); return; } a = a-\u003enext; } ListNode *s = a-\u003enext; //查找b中第j个节点的前驱 for(int h=0; h\u003cj-1; h++){ if(!b){ printf(\"j越界\"); return; } b = b-\u003enext; } //移动节点 for(int m=0; m\u003clen; m++){ if(!s){ printf(\"a链表越界\"); return; } a-\u003enext = s-\u003enext; b-\u003enext = s; b = b-\u003enext; s = s-\u003enext; } b-\u003enext = nullptr; } 题号 3.6 /* 已知递增有序的两个链表a,b分别存储了一个集合,设计算法实现求两个集合交集,并且用a表示 */ void mergesame(ListNode *a, ListNode *b){ ListNode *p = a; ListNode *q = b; ListNode *tmp; while(p-\u003enext \u0026\u0026 q-\u003enext){ if(p-\u003enext-\u003eval \u003c q-\u003enext-\u003eval){ tmp = p-\u003enext; p-\u003enext = tmp-\u003enext; free(tmp); } else if(p-\u003enext-\u003eval \u003e q-\u003enext-\u003eval){ q = q-\u003enext; } else{ p = p-\u003enext; q = q-\u003enext; } } while(p-\u003enext){ tmp = p-\u003enext; p-\u003enext = tmp-\u003enext; free(tmp); } } /* int m[] = {1,2,3,4,5,6}; int n[] = {2,3,4}; ListNode *makelist(int a[], int n){ ListNode *p = new ListNode(); ListNode *pre = p; for(int i=0; i\u003cn; i++){ ListNode *shit = new ListNode(); shit-\u003eval = a[i]; pre-\u003enext = shit; pre = shit; } pre-\u003enext = nullptr; return p; } int main(){ ListNode *a = makelist(m,6); ListNode *b = makelist(n,3); mergesame(a, b); ListNode *s = a-\u003enext; while(s){ printf(\"%d\", s-\u003eval); s = s-\u003enext; } system(\"pause\"); } */ 题号 3.7 /* 有两个单循环链表,链表头指针分别为heada和headb,编写一个函数将链表a连接到headb后仍然保持循环状态 */ void link(ListNode *heada, ListNode *headb){ ListNode *p = heada; while(p-\u003enext != heada){ p = p-\u003enext; } ListNode *q = headb; while(q-\u003enext != headb){ q = q-\u003enext; } p-\u003enext = headb; q-\u003enext = heada; } 题号 3.8 /* 编写算法,将一个用循环链表表示的稀疏多项式分解为两个多项式 使这两个多项式中仅含有奇次项和偶数项,并要求利用原链表的空间构成这两个链表 */ typedef struct node{ double c; int exp; struct node *next; }*polynom; void splitpoly(polynom \u0026l, polynom \u0026l1, polynom \u0026l2){ polynom p = l-\u003enext; polynom q = l1; polynom r = l2; while(p){ if(p-\u003eexp %2 == 0){ q-\u003enext = p; q = p; } else{ r-\u003enext = p; r = p; } p = p-\u003enext; } q-\u003enext = nullptr; r-\u003enext = nullptr; } ","date":"2020-10-21","objectID":"/posts/ncepu-3/:0:0","tags":["数据结构与算法"],"title":"NCEPU 单链表(习题)","uri":"/posts/ncepu-3/"},{"categories":["NCEPU"],"content":"课后习题-线性表 测试代码 #include\u003ciostream\u003e#include\u003ccstdlib\u003e#include\u003cstack\u003e#include\u003cqueue\u003e#include\u003cset\u003e using namespace std; #define Elemtype int #define maxsize 10000 int max_val = 0, min_val = 1000; int a[] = {1,2,3,4,5}; int len = sizeof(a)/sizeof(a[0]); /* 测试数组的引用 */ void modify_list(int a[], int x){ a[x] = 99; for(int i=0; i\u003clen; i++){ printf(\"%d \",a[i]); } } /* int main(){ modify_list(a, 2); system(\"pause\"); } */ 题号 2.2 /* 线性表中的元素存在向量A中,元素是整型数,试写出递归算法求出A中的最大最小元素 */ void get_val(int A[], int n, int \u0026max_val, int \u0026min_val){ if(n == 1){ max_val = A[0]; min_val = A[0]; } else{ get_val(A, n-1, max_val, min_val); if(A[n] \u003e max_val){ max_val = A[n]; } if(A[n] \u003c min_val){ min_val = A[n]; } } } /* int main(){ get_val(a, len-1, max_val, min_val); printf(\"max=%d min=%d\", max_val, min_val); system(\"pause\"); } */ 题号 2.3 /* 删除线性表A中第i个元素开始的,连续K个元素 */ void delete_list(int *a[], int i, int k, int *n){ if(i\u003e(*n-1) || (i+k) \u003e (*n-1) || k\u003c0){ printf(\"没有元素可以删除\"); } for(int j=i; j\u003ci+k; ++j){ a[j] = a[j+k]; } *n -= k; } 题号 2.4 /* 将元素x插入到递增有序的表a中 */ void insert_list(int a[], int x, int \u0026n){ if(n \u003e= maxsize){ printf(\"空间不足\"); } for(int i=n; i\u003e=0; i--){ if(a[i-1] \u003e= x){ a[i] = a[i]; } else{ a[i] = x; break; } } /* 冗余方法 int k = 0; for(int i=0; i\u003c*n; i++){ if(x \u003e *a[i]){ k = i; break; } } for(int j=*n-1; j\u003e=k; j++){ *a[j+1] = *a[j]; } *a[k] = x; *n++; */ } 题号 2.5 /* IMPORTANT: 已知在一维数组A[1,..m+n]中依次存放着两个向量(a1,a2...am)和(b1,b2...bn) 编写一个函数将两个向量位置互换 */ // 思路: 三次逆置 void reverse_list(int a[], int f, int n){ int tmp; for(int i=f; i\u003c(n)/2; i++){ tmp = a[i]; a[i] = a[n-i-1]; a[n-i-1] = tmp; } } void reverse(int a[], int m, int n){ reverse_list(a, 0, m+n-1); reverse_list(a, 0, n-1); reverse_list(a, n, m+n-1); } /* int main(){ reverse_list(a,5); for(int i=0; i\u003c5; i++){ printf(\"%d \", a[i]); } system(\"pause\"); } */ 题号 2.6 /* 假定以\"I\"和\"O\"分别表示入栈和出栈,栈的初始态和终态均为空 判断所给序列是否合法,若合法返回1,若不合法返回0 */ int isvalid(char a[], int n){ int num = 0; for(int i=0; i\u003cn; i++){ if(a[i] == 'I'){ ++num; } else if(a[i] == 'O'){ --num; } if(num \u003c 0 || num\u003en-1){ return 0; } } if(num != 0){ return 0; } return 1; } int main(){ char test[] = {'I','O','I','I','O','O'}; int res = isvalid(test, 6); printf(\"%d\", res); system(\"pause\"); } 题号 2.7 /* 编写一个函数来求逆波兰表达式,其中逆波兰表达式是在该函数中输入的 */ void nibolan(char a[]){ stack\u003cfloat\u003e s; char data[maxsize]; int i=0; while(data[i] != '#' \u0026\u0026 i\u003cmaxsize){ //输入元素 scanf(\"%c\", \u0026data[i]); i++; } int n = i; char tmp; float m, n, res; for(int j=0; j\u003cn; j++){ tmp = data[i]; if('0' \u003c tmp \u0026\u0026 tmp \u003c '9'){ //数字 s.push(tmp-'0'); } else{ m = s.top(); s.pop(); n = s.top(); s.pop(); switch (tmp) { case '+': res = m+n; s.push(res); break; case '-': res = m-n; s.push(res); break; case '*': res = m*n; s.push(res); break; case '/': if(n == 0.0){ printf(\"当前除零错误\"); } else{ res = m/n; s.push(res); } break; } } } int ress = s.top(); printf(\"%f\", ress); } 题号 2.10 /* 假设循环队列中 rear,len 表示队尾元素的位置,和队中元素的个数 试着求出判别该循环队列队满的条件,并写出相应的入队和出队算法,要求出队时返回队头元素 */ typedef struct{ int rear; int len; Elemtype data[maxsize]; }xh_queue; bool isfull(xh_queue a){ if(a.len == maxsize){ return false; } else{ return true; } } void enqueue_xh(xh_queue \u0026a, int x){ if(isfull(a)){ printf(\"队列已经满啦\"); } else{ a.len++; a.rear = (a.rear+1)%maxsize; a.data[a.rear] = x; } } Elemtype dequeue_xh(xh_queue \u0026a){ int front; if(a.len == 0){ printf(\"队列中没有元素\"); return 0; } else{ a.len--; front = (maxsize + a.rear - a.len + 1)%maxsize; } return a.data[front]; } ","date":"2020-10-20","objectID":"/posts/ncepu-2/:0:0","tags":["数据结构与算法"],"title":"NCEPU 线性表(习题)","uri":"/posts/ncepu-2/"},{"categories":["Leetcode"],"content":"链表 142. 环形链表 II 查找环形链表中的第一个入环元素 首先对于这种环形链表,判定成环有两种方法 利用set或者hash,来判定遍历链表过程中是否存在相同的元素,如果存在相同元素,就代表成环 利用快慢指针,如果快慢指针相遇则代表成环 这道题我一开始想用快慢指针,但是快慢指针相遇的点是在环中,而不是题中要求的环首元素,后来看了题解,发现如果使用快慢指针的话,还需要一个数学推导,学到啦 ","date":"2020-10-19","objectID":"/posts/leetcode-30/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-30","uri":"/posts/leetcode-30/"},{"categories":["Leetcode"],"content":"使用set 这里需要注意的是,set 有count()方法,即计算元素出现 class Solution { public: ListNode *detectCycle(ListNode *head) { //使用set unordered_set\u003cListNode*\u003e s; while(head != NULL){ if(s.count(head)){ return head; } s.insert(head); head = head-\u003enext; } return NULL; } }; ","date":"2020-10-19","objectID":"/posts/leetcode-30/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-30","uri":"/posts/leetcode-30/"},{"categories":["Leetcode"],"content":"双指针 官方题解 class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (fast != nullptr) { slow = slow-\u003enext; //慢指针 if (fast-\u003enext == nullptr) { return nullptr; } fast = fast-\u003enext-\u003enext; //快指针 if (fast == slow) { //快慢指针相遇时刻,一个新的指针从head出发 ListNode *ptr = head; while (ptr != slow) { //新的指针与慢指针相遇,此时为环首 ptr = ptr-\u003enext; slow = slow-\u003enext; } return ptr; } } return nullptr; } }; 23. 合并K个升序链表 难点在于,k个链表组合成一个链表 这道题方法很多,这里只写上暴力方法,即与每个链表进行挨个合并 ","date":"2020-10-19","objectID":"/posts/leetcode-30/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-30","uri":"/posts/leetcode-30/"},{"categories":["Leetcode"],"content":"暴力组合 class Solution { public: ListNode* mergeTwoLists(ListNode *a, ListNode *b) { if ((!a) || (!b)) return a ? a : b; ListNode head, *tail = \u0026head, *aPtr = a, *bPtr = b; while (aPtr \u0026\u0026 bPtr) { if (aPtr-\u003eval \u003c bPtr-\u003eval) { tail-\u003enext = aPtr; aPtr = aPtr-\u003enext; } else { tail-\u003enext = bPtr; bPtr = bPtr-\u003enext; } tail = tail-\u003enext; } tail-\u003enext = (aPtr ? aPtr : bPtr); return head.next; } ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { ListNode *ans = nullptr; for (size_t i = 0; i \u003c lists.size(); ++i) { ans = mergeTwoLists(ans, lists[i]); //依次合并 } return ans; } }; ","date":"2020-10-19","objectID":"/posts/leetcode-30/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-30","uri":"/posts/leetcode-30/"},{"categories":["Leetcode"],"content":"分治合并 这个分治思想真的很重要鸭!!!很灵性的递归分治 与归并排序有异曲同工之妙 class Solution { public: ListNode* mergeTwoLists(ListNode *a, ListNode *b) { if ((!a) || (!b)) return a ? a : b; ListNode head, *tail = \u0026head, *aPtr = a, *bPtr = b; while (aPtr \u0026\u0026 bPtr) { if (aPtr-\u003eval \u003c bPtr-\u003eval) { tail-\u003enext = aPtr; aPtr = aPtr-\u003enext; } else { tail-\u003enext = bPtr; bPtr = bPtr-\u003enext; } tail = tail-\u003enext; } tail-\u003enext = (aPtr ? aPtr : bPtr); return head.next; } ListNode* merge(vector \u003cListNode*\u003e \u0026lists, int l, int r) { if (l == r) return lists[l]; if (l \u003e r) return nullptr; int mid = (l + r) \u003e\u003e 1; //左右递归,分治归并 return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r)); } ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { return merge(lists, 0, lists.size() - 1); } }; 61. 旋转链表 很开心!快慢指针无敌! ","date":"2020-10-19","objectID":"/posts/leetcode-30/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-30","uri":"/posts/leetcode-30/"},{"categories":["Leetcode"],"content":"快慢指针 class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if(!head || !head-\u003enext){ return head; } //暴力 int num = 0; ListNode *p = head; while(p){ ++num; p = p-\u003enext; } int shit = k % num; ListNode *res = new ListNode(); ListNode *m = head; ListNode *n = head; if(shit == 0){ return head; } while(shit--){ m = m-\u003enext; } while(m-\u003enext){ m = m-\u003enext; n = n-\u003enext; } ListNode *rr = n-\u003enext; n-\u003enext = NULL; m-\u003enext = head; return rr; } }; ","date":"2020-10-19","objectID":"/posts/leetcode-30/:5:0","tags":["Leetcode-C++"],"title":"Leetcode Part-30","uri":"/posts/leetcode-30/"},{"categories":["Leetcode"],"content":"题解 只是切法跟我不太一样哈,题解没用到双指针 class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if(!head || !head-\u003enext || k==0) return head; ListNode *pos = head; int size = 1; while(pos \u0026\u0026 pos-\u003enext) { pos = pos -\u003e next; size ++; } int move = k % size; if(move == 0) return head; ListNode *cut = head; for(int i=0; i\u003csize-move-1; ++i) cut = cut -\u003e next; ListNode *result = cut -\u003e next; cut -\u003e next = nullptr; pos -\u003e next = head; return result; } }; 92. 反转链表 II 链表的部分反转,菜鸡只会暴力…所以用的栈来做逆转,但是后来发现链表会在头节点处出现问题 所以以后在操作链表时 **一定要加上头节点!!!**这是链表算法的精髓 ","date":"2020-10-19","objectID":"/posts/leetcode-30/:6:0","tags":["Leetcode-C++"],"title":"Leetcode Part-30","uri":"/posts/leetcode-30/"},{"categories":["Leetcode"],"content":"栈逆置 class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { if(!head || m == n){ return head; } stack\u003cListNode*\u003e s; ListNode *first = new ListNode(); first-\u003enext = head; ListNode *a, *b, *p = first; for(int i=0; i\u003c=n; ++i){ if(i == m-1){ a = p; } if(i == n){ b = p-\u003enext; } if(i \u003e= m){ s.push(p); } p = p-\u003enext; } ListNode *tmp; while(!s.empty()){ tmp = s.top(); s.pop(); a-\u003enext = tmp; a = a-\u003enext; } a-\u003enext = b; return first-\u003enext; } }; ","date":"2020-10-19","objectID":"/posts/leetcode-30/:7:0","tags":["Leetcode-C++"],"title":"Leetcode Part-30","uri":"/posts/leetcode-30/"},{"categories":["Leetcode"],"content":"递归 在题解里发现了一个大佬的操作 感觉这个对于递归的解释不能更赞了! (但是这个方法的话,内存占用甚至比我还多,只能说这个题用递归的方法会很精妙) class Solution { public: ListNode *successor = NULL; // 后驱节点 // 反转以 head 为起点的 n 个节点，返回新的头结点 ListNode *reverseN(ListNode *head, int n) { if (n == 1) { // 记录第 n + 1 个节点 successor = head-\u003enext; return head; } // 以 head.next 为起点，需要反转前 n - 1 个节点 ListNode *last = reverseN(head-\u003enext, n - 1); head-\u003enext-\u003enext = head; // 让反转之后的 head 节点和后面的节点连起来 head-\u003enext = successor; return last; } ListNode *reverseBetween(ListNode *head, int m, int n) { if (m == 1) { return reverseN(head, n); } // 前进到反转的起点触发 base case head-\u003enext = reverseBetween(head-\u003enext, m - 1, n - 1); return head; } }; ","date":"2020-10-19","objectID":"/posts/leetcode-30/:8:0","tags":["Leetcode-C++"],"title":"Leetcode Part-30","uri":"/posts/leetcode-30/"},{"categories":["Leetcode"],"content":"DP-64.最小路径和 好久没做动态规划了!好经典动态规划题 class Solution { public: int minPathSum(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { if(grid.size() == 0 || grid[0].size() == 0){ return 0; } int row = grid.size(); int colume = grid[0].size(); auto dp = vector\u003cvector\u003cint\u003e \u003e(row,vector\u003cint\u003e(colume)); dp[0][0] = grid[0][0]; for(int i=1; i\u003crow; i++){ dp[i][0] = grid[i][0] + dp[i-1][0]; } for(int j=1; j\u003ccolume; j++){ dp[0][j] = grid[0][j] + dp[0][j-1]; } for(int i=1; i\u003crow; i++){ for(int j=1; j\u003ccolume; j++){ dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]; } } return dp[row-1][colume-1]; } }; ","date":"2020-10-19","objectID":"/posts/leetcode-31/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-31","uri":"/posts/leetcode-31/"},{"categories":["Leetcode"],"content":"链表 \u0026 树 19. 删除链表的倒数第N个节点 一开始就想到了快慢指针,想试一试不加头节点,最后发现头节点总是处理不好,后来看提交记录发现几个月前用c做的,没加头节点,但是存储了前驱结点 ","date":"2020-10-18","objectID":"/posts/leetcode-29/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-29","uri":"/posts/leetcode-29/"},{"categories":["Leetcode"],"content":"cpp 头节点 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { //链表为了操作,应该直接增加头节点 ListNode *h = new ListNode(); h-\u003enext = head; ListNode *p = h, *q = h; while(n--){ q = q-\u003enext; } while(q-\u003enext){ p = p-\u003enext; q = q-\u003enext; } p-\u003enext = p-\u003enext-\u003enext; ListNode *res = h-\u003enext; delete(h); //释放创建的临时头节点,是一个好的习惯 return res; } }; ","date":"2020-10-18","objectID":"/posts/leetcode-29/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-29","uri":"/posts/leetcode-29/"},{"categories":["Leetcode"],"content":"c 不加头节点 struct ListNode* removeNthFromEnd(struct ListNode* head, int n){ struct ListNode*p=head,*q=head,*r; int i; for(i=0;i\u003cn;i++){ p=p-\u003enext; } if(p==NULL){ //特判,当前需要删除的是头节点 head=head-\u003enext; free(q); } else{ while(p){ r=q; //保存前驱结点 p=p-\u003enext; q=q-\u003enext; } r-\u003enext=q-\u003enext; free(q); } return head; } 199. 二叉树的右视图 class Solution { public: vector\u003cint\u003e rightSideView(TreeNode* root) { //层序遍历,记录最后一个节点的值 vector\u003cint\u003e res; if(root == NULL){ return res; } TreeNode *tmp; queue\u003cTreeNode*\u003e q; q.push(root); while(!q.empty()){ int len = q.size(); for(int i=0; i\u003clen; i++){ tmp = q.front(); if(tmp-\u003eleft){ q.push(tmp-\u003eleft); } if(tmp-\u003eright){ q.push(tmp-\u003eright); } q.pop(); if(i == len-1){ res.push_back(tmp-\u003eval); } } } return res; } }; 113. 路径总和 II 没想到测试数据还能是负值的节点…没想到鸭! 然后把判定改在了叶子节点,就过了! 总耗时7分钟…这么简单的题做的还是有点慢鸭 class Solution { public: vector\u003cvector\u003cint\u003e \u003e res; vector\u003cint\u003e v; int shit; int ssum; void findshit(TreeNode *t, vector\u003cint\u003e v, int shit){ shit += t-\u003eval; v.push_back(t-\u003eval); if(!t-\u003eleft \u0026\u0026 !t-\u003eright){ if(shit == ssum){ res.push_back(v); return; } } else{ if(t-\u003eleft){ findshit(t-\u003eleft, v, shit); } if(t-\u003eright){ findshit(t-\u003eright, v, shit); } } v.pop_back(); return; } vector\u003cvector\u003cint\u003e\u003e pathSum(TreeNode* root, int sum) { if(!root){ return res; } ssum = sum; findshit(root, v, 0); return res; } }; 103. 二叉树的锯齿形层次遍历 快乐层序遍历,增加一个奇偶层判定 class Solution { public: vector\u003cvector\u003cint\u003e \u003e res; vector\u003cvector\u003cint\u003e\u003e zigzagLevelOrder(TreeNode* root) { //快乐层序遍历 queue\u003cTreeNode*\u003e q; TreeNode *tmp; if(!root){ return res; } int level = 1; q.push(root); while(!q.empty()){ vector\u003cint\u003e v; int len = q.size(); for(int i=0; i\u003clen; i++){ tmp = q.front(); v.push_back(tmp-\u003eval); q.pop(); if(tmp-\u003eleft){ q.push(tmp-\u003eleft); } if(tmp-\u003eright){ q.push(tmp-\u003eright); } } if(level %2 == 1){ res.push_back(v); } else{ reverse(v.begin(), v.end()); res.push_back(v); } level++; } return res; } }; 236. 二叉树的最近公共祖先 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(!root || root == p || root == q){ return root; } TreeNode *l = lowestCommonAncestor(root-\u003eleft, p, q); TreeNode *r = lowestCommonAncestor(root-\u003eright, p, q); if(l == NULL){ //左子树中没有,返回右子树 return r; } if(r == NULL){ //右子树中没有,返回左子树 return l; } if(r \u0026\u0026 l){ //左右子树中都存在,返回当前节点 return root; } return NULL; } }; ","date":"2020-10-18","objectID":"/posts/leetcode-29/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-29","uri":"/posts/leetcode-29/"},{"categories":["NCEPU"],"content":"基础算法整理 线性表与链表 ","date":"2020-10-17","objectID":"/posts/ncepu-1/:0:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"线性表 typedef struct{ EelemType *elem; int length; int listsize; }Sqlist; ","date":"2020-10-17","objectID":"/posts/ncepu-1/:1:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"链表结构 typedef struct ListNode{ EelemType val; //struct ListNode *next; ListNode *next; }LinkNode, *LinkList; ","date":"2020-10-17","objectID":"/posts/ncepu-1/:2:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"逆转顺序表 void Reverse(int A[], int n){ int i,t; for(int i=0; i\u003cn/2; i++){ t = A[i]; A[i] = A[n-i-1]; A[n-i-1] = t; } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:3:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"删除链表中特定值的元素 void delete_link(LinkList \u0026l,int item){ LinkList p, q = l; ListList tmp; p = q-\u003enext; while(p != NULL){ if(p-\u003eval == item){ q-\u003enext = p-\u003enext; tmp = p; p = p-\u003enext; free(tmp); } else{ q = p; p = p-\u003enext; } } if(l-\u003eval == item){ q = l; l = l-\u003enext; free(q); } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:4:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"逆转线性表 void reverse_link(LinkList \u0026l){ LinkList p,q,r; p = l; q = NULL; while(p != NULL){ //头插法,利用双指针 r = q; q = p; p = p-\u003enext; q-\u003enext = r; } l = q; } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:5:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"复制线性链表(递归) LinkList copy(LinkList l){ LinkList res; if(l == NULL){ return NULL; } else{ res = new LinkNode; res-\u003eval = l-\u003eval; res-\u003enext = copy(l-\u003enext); return res; } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:6:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"两个递增非空线性链表合并 LinkList *merge_list(LinkNode a, LinkNode b){ LinkNode res = new LinkNode(); LinkNode tmp = res; while(a \u0026\u0026 b){ if(a-\u003eval \u003c= b-\u003eval){ tmp-\u003enext = a; a = a-\u003enext; } else{ tmp-\u003enext = b; b = b-\u003enext; } } if(a){ tmp-\u003enext = a; } else{ tmp-\u003enext = b; } tmp-\u003enext = nullptr; return res-\u003enext; } 二叉树 ","date":"2020-10-17","objectID":"/posts/ncepu-1/:7:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"树的结构体 typedef struct BNode { EelemType val; struct BNode *left; struct BNode *right; }BNode, *BTree; ","date":"2020-10-17","objectID":"/posts/ncepu-1/:8:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"树的中序遍历 void inorder(BTree t){ if(t == NULL){ return; } else{ inorder(t-\u003eleft); printf(\"%c\\n\", t-\u003eval); inorder(t-\u003eright); } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:9:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"树的先序遍历 void preorder(BTree t){ if(t == NULL){ return; } printf(\"%c\", t-\u003eval); preorder(t-\u003eleft); preorder(t-\u003eright); } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:10:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"树的后序遍历 void postorder(BTree t){ if(t == NULL){ return; } postorder(t-\u003eleft); postorder(t-\u003eright); printf(\"%c\", t-\u003eval); } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:11:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"先序遍历非递归 void traverse_preorder(BTree t){ stack\u003cBTree\u003e s; BTree n; while (t != NULL || !s.empty()) { while(t!= NULL){ printf(\"%d\", t-\u003eval); s.push(t); t = t-\u003eleft; } n = s.top(); s.pop(); t = n-\u003eright; } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:12:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"二叉树中序遍历 void traverse_inorder(BTree t){ stack\u003cBTree\u003e s; BTree n; while(t!= NULL || !s.empty()){ while(t!= NULL){ s.push(t); t = t-\u003eleft; } n = s.top(); printf(\"%d\", n-\u003eval); s.pop(); t = n-\u003eright; } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:13:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"二叉树层序遍历 void levelorder(BTree t){ BTree n; queue\u003cBTree\u003e q; q.push(t); while(!q.empty()){ n = q.front(); printf(\"%d\",n-\u003eval); if(n-\u003eleft){ q.push(n-\u003eleft); } if(n-\u003eright){ q.push(n-\u003eright); } } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:14:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"建立二叉树 BTree maketree(){ char a; scanf(\"%c\", \u0026a); if(a != ' '){ BTree t = new BNode; t-\u003eval = a-'0'; t-\u003eleft = maketree(); t-\u003eright = maketree(); return t; } else{ return NULL; } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:15:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"建立二叉树(根据数组获得数据) ","date":"2020-10-17","objectID":"/posts/ncepu-1/:16:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"递归方式 BTree createtree(int a[], int i, int n){ BNode *p = new BNode(); if(i\u003en){ return NULL; } else{ p-\u003eval = a[i]; p-\u003eleft = createtree(a, 2*i, n); p-\u003eright = createtree(a, 2*i+1, n); return p; } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:16:1","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"非递归方式 BTree createtree_traversal(int a[], int n){ //在分配内存时,建议使用c的写法,malloc BNode *p[n]; //声明一个指针数组 for(int i=0; i\u003cn; i++){ if(a[i] != 0){ p[i] = (BNode*)malloc(sizeof(BNode)); p[i]-\u003eval = a[i]; } else{ p[i] = NULL; } } for(int i=0; i\u003c=n; i++){ if(p[i] != NULL){ p[i]-\u003eleft = p[2*i]; p[i]-\u003eright = p[2*i+1]; } } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:16:2","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"二叉树的深度 int depth(BTree t){ int rdepth, ldepth; if(t == NULL){ return 0; } else{ ldepth = depth(t-\u003eleft); rdepth = depth(t-\u003eright); } if(ldepth \u003e rdepth){ return ldepth+1; } else{ return rdepth+1; } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:17:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"求结点所在层数 #define max_stack 50 int layernode(BTree t, int item){ BTree stack1[max_stack]; BTree p = t; int stack2[max_stack], flag, top = -1; while(p != NULL || top != -1){ while(p != NULL){ stack1[++top] = p; stack2[top] = 0; p = p-\u003eleft; } p = stack1[top]; flag = stack2[top--]; if(flag == 0){ stack1[++top] = p; stack2[top] = 1; p = p-\u003eright; } else{ if(p-\u003eval == item){ return top+2; } p = NULL; } } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:18:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"交换二叉树所有节点的左右子树的位置 ","date":"2020-10-17","objectID":"/posts/ncepu-1/:19:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"c语言 #define max 50 void exchangebt(BTree t){ BTree queue[max]; BTree tmp, p = t; int front, rear; if(t != NULL){ queue[0] = t; front = -1; rear = 0; } while(front \u003c rear){ p = queue[++front]; tmp = p-\u003eleft; p-\u003eleft = p-\u003eright; p-\u003eright = tmp; } if(p-\u003eleft != NULL){ queue[++rear] = p-\u003eleft; } if(p-\u003eright != NULL){ queue[++rear] = p-\u003eright; } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:19:1","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"c++版本 void swaptree(BTree t){ queue\u003cBTree\u003e q; BTree tmp, p; q.push(t); while(!q.empty()){ p = q.front(); tmp = p-\u003eleft; p-\u003eleft = p-\u003eright; p-\u003eright = tmp; q.pop(); if(p-\u003eleft){ q.push(p-\u003eleft); } if(p-\u003eright){ q.push(p-\u003eright); } } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:19:2","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"删除二叉树中以某个节点为根节点的子树 void delete_node(BTree t, int itm){ //层序遍历首先找到节点- 版本1 queue\u003cBTree\u003e q; BTree p, tmp; q.push(t); while(!q.empty()){ p = q.front(); if(p-\u003eval == itm){ des(p); } q.pop(); if(p-\u003eleft){ q.push(p-\u003eleft); } if(p-\u003eright){ q.push(p-\u003eright); } } //递归先序遍历- 版本2 if(t != NULL){ if(t-\u003eval = itm){ des(t); } delete_node(t-\u003eleft, itm); delete_node(t-\u003eright, itm); } //非递归先序遍历- 版本3 stack\u003cBTree\u003e s; BTree a; while(!s.empty() || p != NULL){ while(p != NULL){ //注意非递归此处为判定 p if(a-\u003eval == itm){ des(a); } p = p-\u003eleft; } a = s.top(); s.pop(); p = a-\u003eright; } } void des(BTree t){ if(t != NULL){ des(t-\u003eleft); des(t-\u003eright); free(t); } } 查找 ","date":"2020-10-17","objectID":"/posts/ncepu-1/:20:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"顺序查找-递归 int recur_search(int a[], int n, int key, int i){ if(i \u003e= n){ return -1; } if(a[i] == key){ return i; } else{ return recur_search(a, n, key, i+1); } } /*函数调用 int pos = recur_search(a, n, key, 0); */ ","date":"2020-10-17","objectID":"/posts/ncepu-1/:21:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"折半查找 int binsearch(int a[], int n, int key){ int low = 0, high = n-1, mid; while(low \u003c= high){ //循环边界 mid = (low + high)/2; if(key == a[mid]){ return mid; } if(key \u003e a[mid]){ low = mid+1; } else{ high = mid-1; } } return -1; } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:22:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"折半查找递归 int recur_binsearch(int a[], int low, int high, int key){ int mid; if(low \u003e high){ return -1; } else{ mid = (low + high)/2; if(a[mid] == key){ return mid; } if(a[mid] \u003e key){ return recur_binsearch(a, low, mid-1, key); } else{ return recur_binsearch(a, mid+1, high, key); } } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:23:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"按值递增线性表中折半查找-插入(非递归) void bin_insert(int a[], int n, int key){ int low = 0, high = n-1, mid; while(low \u003c= high){ mid = (low + high)/2; if(key \u003e a[mid]){ low = mid+1; } else{ high = mid-1; } } for(int i=n; i\u003elow; --i){ a[i] = a[i-1]; } a[low] = key; n++; } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:24:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"递增线性表中折半查找值不小于key的最小元素 int bin_search(int a[], int n, int key){ int low = 0, high = n-1, mid; while(low \u003c= high){ mid = (low+high)/2; if(a[mid] == key){ return mid; } if(key \u003e a[mid]){ low = mid+1; } else{ high = mid-1; } } if(low \u003c= n-1){ return low; } else{ return -1; } } 图 ","date":"2020-10-17","objectID":"/posts/ncepu-1/:25:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"邻接矩阵 #define maxvertexNum 100 typedef char vertexType; typedef int edgeType; typedef struct{ vertexType vex[maxvertexNum]; edgeType edge[maxvertexNum][maxvertexNum]; int vexnum, arcnum; }MGraph; ","date":"2020-10-17","objectID":"/posts/ncepu-1/:26:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"邻接表 typedef struct arcnode{ int adjvex; struct arcnode *next; }arcnode; typedef struct vnode{ vertexType data; arcnode *first; }vnode, adjlist[maxvertexNum]; typedef struct{ adjlist vertices; int vexnum, arcnum; }ALGraph; ","date":"2020-10-17","objectID":"/posts/ncepu-1/:27:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"深度优先遍历 dfs 邻接矩阵 bool visited[maxvertexNum]; queue\u003cint\u003e q; void dfsTraverse(MGraph g){ for(int i=0; i\u003cg.vexnum; i++){ visited[i] = false; } for(int i=0; i\u003cg.vexnum; i++){ if(!visited[i]){ //防止非连通图 dfs(g, i); } } } void dfs(MGraph g, int v){ printf(\"%d\", g.vex[v]); visited[v] = true; for(int i=0; i\u003cg.vexnum; i++){ if(visited[i] != false \u0026\u0026 g.edge[v][i] != 0){ dfs(g, i); } } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:28:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"广度优先搜索 邻接表 void bfsTraverse(ALGraph g, int v){ for(int i=0; i\u003cg.vexnum; i++){ visited[i] = false; } for(int i=0; i\u003cg.vexnum; i++){ if(visited[i] == false){ bfs(g, i); } } } void bfs(ALGraph g, int v){ printf(\"%d\", g.vertices[v].data); queue\u003cint\u003e q; arcnode *tmp; q.push(v); int p,a; while (!q.empty()){ p = q.front(); q.pop(); tmp = g.vertices[p].first; while(tmp){ a = tmp-\u003eadjvex; if(visited[a] == false){ printf(\"%d\", g.vertices[a].data); visited[a] = true; q.push(a); } tmp = tmp-\u003enext; } } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:29:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["NCEPU"],"content":"邻接表的深度遍历 dfs void dfsTraverse(ALGraph g, int v){ for(int i=0; i\u003cg.vexnum; i++){ visited[i] = false; } for(int i=0; i\u003cg.vexnum; i++){ if(visited[i] == false){ dfs(g, i); } } } void dfs(ALGraph g, int v){ printf(\"%d\", g.vertices[v].data); stack\u003cint\u003e s; arcnode *p; int tmp; s.push(v); while(!s.empty()){ tmp = s.top(); p = g.vertices[tmp].first; while(p){ if(visited[p-\u003eadjvex] == false \u0026\u0026 p){ q.push(p-\u003eadjvex); visited[p-\u003eadjvex] = true; printf(\"%d\", g.vertices[p-\u003eadjvex].data); break; } p = p-\u003enext; } if(!p){ s.pop(); } } } ","date":"2020-10-17","objectID":"/posts/ncepu-1/:30:0","tags":["数据结构与算法"],"title":"NCEPU 基础算法","uri":"/posts/ncepu-1/"},{"categories":["Leetcode"],"content":"昨天刷了一些树的题,今天来刷图 207(210).课程表 考察基本拓扑排序的解决,以及拓扑路径的寻找 判定拓扑排序的方法就是,寻找有向图中是否存在环,对于拓扑路径的寻找,有dfs和bfs两种 对于dfs 需要用到栈以及记录节点状态 对于bfs 需要用到队列,记录节点的出入度 建议使用bfs,队列实现,思路清晰 ","date":"2020-10-16","objectID":"/posts/leetcode-28/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-28","uri":"/posts/leetcode-28/"},{"categories":["Leetcode"],"content":"bfs class Solution { private: vector\u003cint\u003e indig; vector\u003cvector\u003cint\u003e\u003e edges; vector\u003cint\u003e res; public: vector\u003cint\u003e findOrder(int numCourses, vector\u003cvector\u003cint\u003e\u003e\u0026 prerequisites) { indig.resize(numCourses); edges.resize(numCourses); for(int i=0; i\u003cprerequisites.size(); ++i){ edges[prerequisites[i][1]].push_back(prerequisites[i][0]); ++indig[prerequisites[i][0]]; } queue\u003cint\u003e q; for(int i=0; i\u003cnumCourses; ++i){ if(indig[i] == 0){ q.push(i); } } while(!q.empty()){ int i = q.front(); q.pop(); res.push_back(i); for(int j=0; j\u003cedges[i].size(); ++j){ if(--indig[edges[i][j]] == 0){ q.push(edges[i][j]); } } } if(res.size() != numCourses){ return {}; } return res; } }; ","date":"2020-10-16","objectID":"/posts/leetcode-28/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-28","uri":"/posts/leetcode-28/"},{"categories":["Leetcode"],"content":"dfs class Solution { private: vector\u003cvector\u003cint\u003e \u003e edges; vector\u003cint\u003e visited; vector\u003cint\u003e res; bool valid = true; public: void dfs(int v){ visited[v] = 1; for(int i=0; i\u003cedges[v].size(); i++){ if(visited[edges[v][i]] == 0){ dfs(edges[v][i]); if(!valid){ return; } } else if(visited[edges[v][i]] == 1){ valid = false; return; } } visited[v] = 2; res.push_back(v); } vector\u003cint\u003e findOrder(int numCourses, vector\u003cvector\u003cint\u003e\u003e\u0026 prerequisites) { visited.resize(numCourses); edges.resize(numCourses); for(int i=0; i\u003cprerequisites.size(); i++){ edges[prerequisites[i][1]].push_back(prerequisites[i][0]); } for(int i=0; i\u003cnumCourses \u0026\u0026 valid; i++){ if(!visited[i]){ dfs(i); } } if(!valid){ return {}; } reverse(res.begin(), res.end()); return res; } }; ","date":"2020-10-16","objectID":"/posts/leetcode-28/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-28","uri":"/posts/leetcode-28/"},{"categories":["Leetcode"],"content":"最近感觉数学有点搞不动了…练习册也都做的差不多了 所以时隔4个月的本辣鸡又来刷leetcode啦,但不是天天刷,只是作为放松,娱乐刷 吸取了去年算法题的惨痛教训,准备把线性表-二叉树-图的算法都刷一遍,给专业课再上一层保险 最近越来越发现新换的顶配SurfacePro6简直写代码太舒服啦!2k屏幕让我眼睛舒适,i7+16G的性能释放让我快乐 (原来的Pro5 i5是真的拉跨…想从巨硬这里提高生产力,真是要下血本呀) 24.两两交换链表中的节点 ","date":"2020-10-15","objectID":"/posts/leetcode-27/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-27","uri":"/posts/leetcode-27/"},{"categories":["Leetcode"],"content":"菜鸡的代码 今天的每日一题正好是链表的,所以直接开写! 这道题是交换链表结点,其实思路相对简单…就是为什么我写的这么啰嗦… class Solution { public: ListNode* swapPairs(ListNode* head) { if(head == nullptr || head-\u003enext == nullptr){ //单独判空多余 return head; } else{ ListNode *p, *q; p = head; q = p-\u003enext; bool tag = false; ListNode *pre; ListNode *shit = (ListNode*)malloc(sizeof(ListNode)); while(q != nullptr){ if(tag == false){ //头节点特判多余 pre = shit; tag = true; } pre-\u003enext = q; p-\u003enext = q-\u003enext; q-\u003enext = p; pre = p; if(p-\u003enext != nullptr){ //判断条件可以写在while中 p = p-\u003enext; q = p-\u003enext; } else{ break; } } return shit-\u003enext; } } }; ","date":"2020-10-15","objectID":"/posts/leetcode-27/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-27","uri":"/posts/leetcode-27/"},{"categories":["Leetcode"],"content":"递归 我竟然没想到用递归…属实有些不应该 class Solution { public: ListNode* swapPairs(ListNode* head) { if (head == nullptr || head-\u003enext == nullptr) { return head; } ListNode* newHead = head-\u003enext; head-\u003enext = swapPairs(newHead-\u003enext); newHead-\u003enext = head; return newHead; } }; ","date":"2020-10-15","objectID":"/posts/leetcode-27/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-27","uri":"/posts/leetcode-27/"},{"categories":["Leetcode"],"content":"递推 同样是一个算法思想,我写了30行,答案写了10行…问题主要集中在边界判断上…感觉还是不太熟 class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0); dummyHead-\u003enext = head; ListNode* temp = dummyHead; while (temp-\u003enext != nullptr \u0026\u0026 temp-\u003enext-\u003enext != nullptr) { ListNode* node1 = temp-\u003enext; ListNode* node2 = temp-\u003enext-\u003enext; temp-\u003enext = node2; node1-\u003enext = node2-\u003enext; node2-\u003enext = node1; temp = node1; } return dummyHead-\u003enext; } }; 最近公共父节点 二叉树寻找两个节点的最近公共父节点,需要用到递归,这种类型题之前见过很多次 代码主要分为三个判定部分 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //当前为空或者为p,q,则直接返回 if(root == NULL || root == p || root == q){ return root; } //递归左右子树 TreeNode *l = lowestCommonAncestor(root-\u003eleft, p, q); TreeNode *r = lowestCommonAncestor(root-\u003eright, p, q); //如果其中有一个子树不存在p,q则返回另一个分支 if(l == NULL){ return r; } if(r == NULL){ return l; } //找到公共父节点 return root; } }; 将有序数组转换为二叉搜索树 经典的二叉树构造,左右子树递归 值得注意的是,在leetcode编译器中,这道题malloc会报错…需要用new(以后c++就都用new吧,避免不必要的麻烦) 动态创建对象时，只需指定其数据类型，而不必为该对象命名，new表达式返回指向该新创建对象的指针，我们可以通过指针来访问此对象 class Solution { public: TreeNode* sortedArrayToBST(vector\u003cint\u003e\u0026 nums) { //利用左右子树递归即可完成 return make_tree(nums, 0, nums.size()-1); } TreeNode* make_tree(vector\u003cint\u003e \u0026nums, int low, int high){ if(low \u003e high){ return NULL; } int mid = (low+high)/2; TreeNode* p = new TreeNode(nums[mid]); //TreeNode *p = (TreeNode*)malloc(sizeof(TreeNode)); p-\u003eval = nums[mid]; p-\u003eleft = make_tree(nums, low, mid-1); p-\u003eright = make_tree(nums, mid+1, high); return p; } }; 98.判断二叉搜索树(排序树) 方法1-递归判断 这道题需要注意的是,如果满足二叉搜索树,需要左子树所有元素都小于当前节点,且右子树所有元素大于当前节点,因此需要设置一个上下界进行判断 方法2-中序遍历 由于中序遍历二叉搜索树,会得到一个递增序列,因此判断这个递增序列就可以知道是否满足 ","date":"2020-10-15","objectID":"/posts/leetcode-27/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-27","uri":"/posts/leetcode-27/"},{"categories":["Leetcode"],"content":"判断上下界 非常巧妙的lower和upper class Solution { public: bool helper(TreeNode* root, long long lower, long long upper) { if (root == nullptr) { return true; } if (root -\u003e val \u003c= lower || root -\u003e val \u003e= upper) { return false; } return helper(root -\u003e left, lower, root -\u003e val) \u0026\u0026 helper(root -\u003e right, root -\u003e val, upper); } bool isValidBST(TreeNode* root) { return helper(root, LONG_MIN, LONG_MAX); } }; ","date":"2020-10-15","objectID":"/posts/leetcode-27/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-27","uri":"/posts/leetcode-27/"},{"categories":["Leetcode"],"content":"中序遍历(非递归) class Solution { public: bool isValidBST(TreeNode* root) { stack\u003cTreeNode*\u003e stack; //inorder为前驱元素 long long inorder = (long long)INT_MIN - 1; //中序遍历 while (!stack.empty() || root != nullptr) { while (root != nullptr) { stack.push(root); root = root -\u003e left; } root = stack.top(); stack.pop(); // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树 if (root -\u003e val \u003c= inorder) { return false; } inorder = root -\u003e val; root = root -\u003e right; } return true; } }; ","date":"2020-10-15","objectID":"/posts/leetcode-27/:5:0","tags":["Leetcode-C++"],"title":"Leetcode Part-27","uri":"/posts/leetcode-27/"},{"categories":["Leetcode"],"content":"中序遍历(递归) class Solution { public: vector\u003cint\u003e v; //中序遍历 void dfs(TreeNode *t){ if(!t){ return; } dfs(t-\u003eleft); v.push_back(t-\u003eval); dfs(t-\u003eright); } bool isValidBST(TreeNode* root) { if(!root){ return true; } dfs(root); for(int i=0; i\u003cv.size()-1; i++){ if(v[i+1] \u003c= v[i]){ return false; } } return true; } }; 二叉树的后序非递归 这个问题困扰了我很久…其实解决这个问题的关键,就是判断好访问结点的时机 对于后序遍历,只有左右子节点都访问完成,该节点才能进行访问,这次务必要记住鸭! class Solution { public: vector\u003cint\u003e postorderTraversal(TreeNode* root) { vector\u003cint\u003e data; if(root == nullptr){ return data; } TreeNode *pre = root; stack\u003cTreeNode*\u003e s; while(root || !s.empty()){ while(root){ s.push(root); root = root-\u003eleft; } root = s.top(); s.pop(); //总是先出栈 if(root-\u003eright == nullptr || root-\u003eright == pre){ //该节点满足后序条件,进行访问(进入队列),并且改变前驱结点 //root赋值为null,要求再次出栈访问 data.push_back(root-\u003eval); pre = root; root = nullptr; } else{ //此时右节点没有访问,需要再进入栈中 s.push(root); root = root-\u003eright; //转向右节点访问 } } return data; } }; ","date":"2020-10-15","objectID":"/posts/leetcode-27/:6:0","tags":["Leetcode-C++"],"title":"Leetcode Part-27","uri":"/posts/leetcode-27/"},{"categories":["数据结构与算法"],"content":"最近发现 Set-Map-优先队列 有许多好用的使用方法,整理一下补充的知识点8! Set ","date":"2020-09-04","objectID":"/posts/DS-16/:0:0","tags":["C++基础语法"],"title":"Map/Set/优先队列 的补充","uri":"/posts/DS-16/"},{"categories":["数据结构与算法"],"content":"文档介绍 在set中，元素的value也标识它(value就是key，类型为T)，并且每个value必须是唯一的 set容器通过key访问单个元素的速度通常比unordered_set容器慢，但它们允许根据顺序对子集进行直接迭代。 与map/multimap不同，map/multimap中存储的是真正的键值对，set中只放value，但在底层实际存放的是由构成的键值对。 使用set的迭代器遍历set中的元素，可以得到有序序列,set中的元素默认按照小于来比较(less()) set中查找某个元素，时间复杂度为：log2n set中的元素不允许修改(底层使用二叉搜索树实现的） set中的底层使用二叉搜索树(红黑树)来实现。 因此利用set自带的排序功能,就可以充当堆(取最大值和最小值) set与multiset最大的区别是multiset中的元素可以重复 使用 multiset 查找重复元素时，找到的是搜索二叉树中序访问的第一个元素 ","date":"2020-09-04","objectID":"/posts/DS-16/:1:0","tags":["C++基础语法"],"title":"Map/Set/优先队列 的补充","uri":"/posts/DS-16/"},{"categories":["数据结构与算法"],"content":"multiset 自定义排序 利用自定义类型 struct rec{ int x,y; }; multiset\u003crec\u003eh; 但是multiset并不知道如何去比较一个自定义的类型,此时可以定义multiset里面rec类型变量之间的小于关系的含义（这里以x为第一关键字为例） 定义一个比较类cmp，cmp内部的operator函数的作用是比较rec类型a和b的大小(以x为第一关键字，y为第二关键字) struct cmp{ bool operator()(const rec\u0026a,const rec\u0026b){ return a.x\u003cb.x||a.x==b.x\u0026\u0026a.y\u003cb.y; } }; 然后将语句 multiset\u003crec\u003e h // 改为 multiset\u003crec,cmp\u003e h; 就告诉了序列 h 如何去比较里面的元素(重载运算符) 此时rec以及multiset的定义部分完整代码为: struct rec{ int x,y; }; struct cmp{ bool operator()(const rec\u0026a,const rec\u0026b){ return a.x\u003cb.x||a.x==b.x\u0026\u0026a.y\u003cb.y; } }; multiset\u003crec,cmp\u003e h; Map Map也是利用的红黑树-RB树(Red-Black Tree)。 map和set的树建立之时就会自动排好序 默认的比较函数 map(T1, T2, less) 即按key的升序(从小到大)排列,当然也可以通过重载函数设置为根据value排序 查找效率为O(log2n) 对于map的 insert 我之前一直用的重载operator [] 虽然该方法在效率上偏慢一些,但可以替换元素键值 不过最好还是构造pair insert吧 map\u003cint, string\u003e m; /* 方法 1*/ pair\u003cint, string\u003e shit = make_pair(1,\"value1\"); m.insert(shit); /* 方法 2*/ m.insert(make_pair(1, \"value1\")); /* 方法 3*/ m.insert(pair\u003cint, string\u003e(1,\"value1\")); /* 方法 3*/ m.insert(map\u003cint, string\u003e::value_type (1,\"value1\")); priority_queue 另外说到set和map,不得不提一下优先队列,都要熟练用鸭! (文末彩蛋) 优先队列本质上是用堆实现的 注意优先队列中的greater和less排序顺序,与正常是反过来的(因为队列头部出队) ","date":"2020-09-04","objectID":"/posts/DS-16/:2:0","tags":["C++基础语法"],"title":"Map/Set/优先队列 的补充","uri":"/posts/DS-16/"},{"categories":["数据结构与算法"],"content":"基本优先队列 #include\u003cqueue\u003e#include\u003ccstdio\u003eusing namespace std; int date[5]; int main() { /* 定义：priority_queue\u003cType, Container, Functional\u003e Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。 */ priority_queue\u003cint\u003e Q; //默认为最大值(大顶堆)优先 priority_queue\u003cint,vector\u003cint\u003e,greater\u003cint\u003e \u003e Q1; //最小值优先 priority_queue\u003cint,vector\u003cint\u003e,less\u003cint\u003e \u003e Q2; //最大值优先 for(int i=1;i\u003c=3;i++) { scanf(\"%d\",\u0026date[i]); Q.push(date[i]); //插入元素 } while(!Q.empty()) { int x = Q.top(); //读取队头元素 Q.pop(); //弹出元素 printf(\"%d\\n\",x); } return 0; } ","date":"2020-09-04","objectID":"/posts/DS-16/:3:0","tags":["C++基础语法"],"title":"Map/Set/优先队列 的补充","uri":"/posts/DS-16/"},{"categories":["数据结构与算法"],"content":"使用 pair 作为优先队列元素 排序规则：pair的比较，先比较第一个元素，第一个相等比较第二个。 ","date":"2020-09-04","objectID":"/posts/DS-16/:4:0","tags":["C++基础语法"],"title":"Map/Set/优先队列 的补充","uri":"/posts/DS-16/"},{"categories":["数据结构与算法"],"content":"使用 自定义类型 作为优先队列元素 #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; /* 方法1 运算符重载 \u003c */ struct tmp1 { int x; tmp1(int a) {x = a;} bool operator \u003c (const tmp1\u0026 a) const { //return x \u003c a.x; //大顶堆 } }; /* 方法2 重写仿函数 */ struct tmp2 { bool operator() (tmp1 a, tmp1 b) { return a.x \u003c b.x; //大顶堆 } }; int main() { tmp1 a(1); tmp1 b(2); tmp1 c(3); priority_queue\u003ctmp1\u003e d; d.push(b); d.push(c); d.push(a); while (!d.empty()) { cout \u003c\u003c d.top().x \u003c\u003c '\\n'; d.pop(); } cout \u003c\u003c endl; priority_queue\u003ctmp1, vector\u003ctmp1\u003e, tmp2\u003e f; f.push(b); f.push(c); f.push(a); while (!f.empty()) { cout \u003c\u003c f.top().x \u003c\u003c '\\n'; f.pop(); } } /* 输出结果: 3 2 1 3 2 1 */ ","date":"2020-09-04","objectID":"/posts/DS-16/:5:0","tags":["C++基础语法"],"title":"Map/Set/优先队列 的补充","uri":"/posts/DS-16/"},{"categories":["C++"],"content":"fill() 与 memset() 的区别 isalnum() 函数 fill与memset的区别 ","date":"2020-09-03","objectID":"/posts/CPP-8/:0:0","tags":["C++基础语法"],"title":"C++ fiil()与memset()","uri":"/posts/CPP-8/"},{"categories":["C++"],"content":"fill 作用:按照单元赋值，将一个区间的元素都赋予val值。函数参数：fill(vec.begin(), vec.end(), val); val为将要替换的值 #include \u003calgorithm\u003efill(vec.begin(), vec.end(), val); //原来容器中每个元素被重置为val ","date":"2020-09-03","objectID":"/posts/CPP-8/:1:0","tags":["C++基础语法"],"title":"C++ fiil()与memset()","uri":"/posts/CPP-8/"},{"categories":["C++"],"content":"memset 作用：按照字节填充某字符 #include \u003ccstring\u003econst int INF = 0x3f3f3f3f; memset(a,INF,sizeof(a)); ","date":"2020-09-03","objectID":"/posts/CPP-8/:2:0","tags":["C++基础语法"],"title":"C++ fiil()与memset()","uri":"/posts/CPP-8/"},{"categories":["C++"],"content":"赋值的区别 ","date":"2020-09-03","objectID":"/posts/CPP-8/:3:0","tags":["C++基础语法"],"title":"C++ fiil()与memset()","uri":"/posts/CPP-8/"},{"categories":["C++"],"content":"memset函数 因为memset函数按照字节填充，所以一般memset只能用来填充char型数组，（因为只有char型占一个字节）。 如果填充int型数组，只能填充0、-1 和 inf（正负） 因为00000000 = 0，-1同理，如果我们把每一位都填充“1”，会导致变成填充入“11111111”。如果我们将inf设为0x3f3f3f3f，0x3f3f3f3f的每个字节都是0x3f！ 全部置为无穷大，只需要memset(a,0x3f,sizeof(a)) 全部置为无穷小可以将-INF设为0x8f ","date":"2020-09-03","objectID":"/posts/CPP-8/:3:1","tags":["C++基础语法"],"title":"C++ fiil()与memset()","uri":"/posts/CPP-8/"},{"categories":["C++"],"content":"fill函数 fill函数可以赋值任何值 ","date":"2020-09-03","objectID":"/posts/CPP-8/:3:2","tags":["C++基础语法"],"title":"C++ fiil()与memset()","uri":"/posts/CPP-8/"},{"categories":["C++"],"content":"运行效率 memset比fill处理速度快一些，所以在能满足需要时，推荐用memset isalnum()函数 void isalnum(int c) 检查所传的字符是否是字母或数字 int isalnum(int c); // c 为被检查的字符 /* 返回值: 如果 c 是一个数字或一个字母，则该函数返回非零值，否则返回 0。 */ ","date":"2020-09-03","objectID":"/posts/CPP-8/:4:0","tags":["C++基础语法"],"title":"C++ fiil()与memset()","uri":"/posts/CPP-8/"},{"categories":["PAT"],"content":"终于搞明白这道题啦! 这道题题目很简单 给定一系列的硬币值, 然后给定一个目标value， 从所有硬币中找出几个, 使得这几个硬币的和正好等于这个value, 而且这个硬币序列应该是满足硬币值字典序的最小序列. 一开始我一直认为不能用0-1背包,也一直不懂大佬们的题解 今天感觉自己看了一些动态规划的概念,应该会对这道题有一些新的认识…然鹅又研究了一会题解还是不会 只好再去百度查查大佬的博客,虽然那些博客之前都看过,但还是试一试吧…突然看到大佬的一句话,之后想了一下,豁然开朗! 这道题能用01背包方法是因为,可以将金额数值设置为边界上限(即背包问题中的容量) 而在该金额上限下,去计算最大值(背包问题中的金额),如果这个最大值等于上限边界,那么就说明当前的选择是符合条件的 简单的来说,就是将边界条件和求最优解(最大值)都设置为\"金额\"这个属性,那么就可以求出是否金额能达到最大值(边界) 没想到鸭没想到,算法太灵性辣 递归公式: F(N, M) = max{ F(N–1, M), F(N–1, M–c(N)) + c(N) }，c(N)表示第N个硬币的面值 那么最后要是F(N, M) == M， 那么就说明我们可以找到这样一组硬币, 使得他们的面值总和恰好等于M。 记录路径：若has(N, M)为真, 则表示从前面N个硬币中选出一组得到最多的不超过M的币值总和里面包括了第N个硬币。那么如果我们需要找到完整路径, 我们就可以从N、M出发，一直回溯到最后一个硬币。 另外这道题还要求输出的最小序列,这就需要在一开始时对序列进行排序(从大到小),因为选取顺序是从头到尾的,而且判定式是小于等于因此遇到符合条件的更小的数值时,会更新dp数组,这样就可以选取到最小序列 对于路线的记录,这里构建了一个choice二维数组,当符合条件时,利用该数组进行回溯(妙啊!) #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int dp[10010], w[10010]; bool choice[10010][110]; int cmp1(int a, int b){ return a\u003eb; } int main() { int n, m; scanf(\"%d%d\", \u0026n, \u0026m); for(int i=1; i\u003c=n; i++) scanf(\"%d\", \u0026w[i]); sort(w+1, w+n+1, cmp1); for(int i=1; i\u003c=n; i++) { //背包递推 for(int j=m; j\u003e=w[i]; j--) { if(dp[j] \u003c=dp[j-w[i]] +w[i]) { choice[i][j] = true; dp[j] = dp[j-w[i]] +w[i]; } } } if(dp[m] !=m) printf(\"No Solution\"); else { vector\u003cint\u003e arr; int v=m, index=n; while(v\u003e0) { //回溯路线 if(choice[index][v] ==true) { arr.push_back(w[index]); v -= w[index]; } index--; } for(int i=0; i\u003carr.size(); i++) { if(i!=0) printf(\" \"); printf(\"%d\", arr[i]); } } return 0; } ","date":"2020-09-03","objectID":"/posts/pat-43/:0:0","tags":["Leetcode-C++"],"title":"PAT-A1068(背包问题)","uri":"/posts/pat-43/"},{"categories":["PAT"],"content":"1054-1066 1054-The Dominant Color 快乐白给题 #include\u003ciostream\u003eusing namespace std; int main(int argc, char const *argv[]) { int a, b; int data[10000000] = {0}; long int tmp; int cmax = 0; long int smax = 0; scanf(\"%d %d\", \u0026a, \u0026b); for(int i=0; i\u003cb; i++){ for(int j=0; j\u003ca; j++){ scanf(\"%ld\", \u0026tmp); data[tmp] += 1; if(data[tmp] \u003e cmax){ cmax = data[tmp]; } smax = tmp; } } printf(\"%ld\", smax); return 0; } 1055-The World’s Richest 这种排序题…真的是要提前构思好,否则写了一大堆,结果发现没排好就尴尬了 考察的是数据分析分组,合理排序的能力 这道题就是需要构造一个年龄的数组,将同一年龄的人放在一堆 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; struct node { char name[10]; int age, money; }; int cmp1(node a, node b) { if(a.money!=b.money) return a.money\u003eb.money; else if(a.age!=b.age) return a.age\u003cb.age; else return (strcmp(a.name, b.name) \u003c0); } int main() { int n, k, num, amin, amax; scanf(\"%d %d\", \u0026n, \u0026k); vector\u003cnode\u003e vt(n), v; vector\u003cint\u003e book(205, 0); for(int i=0; i\u003cn; i++) scanf(\"%s %d %d\", vt[i].name, \u0026vt[i].age, \u0026vt[i].money); sort(vt.begin(), vt.end(), cmp1); for(int i=0; i\u003cn; i++) { if(book[vt[i].age] \u003c100) { v.push_back(vt[i]); book[vt[i].age]++; } } for(int i=0; i\u003ck; i++) { scanf(\"%d %d %d\", \u0026num, \u0026amin, \u0026amax); vector\u003cnode\u003e t; for(int j=0; j\u003cv.size(); j++) { if(v[j].age\u003e=amin\u0026\u0026v[j].age\u003c=amax) t.push_back(v[j]); } if(i!=0) printf(\"\\n\"); printf(\"Case #%d:\", i+1); int flag=0; for(int j=0; j\u003cnum \u0026\u0026 j\u003ct.size(); j++) { printf(\"\\n%s %d %d\", t[j].name, t[j].age, t[j].money); flag=1; } if(flag==0) printf(\"\\nNone\"); } return 0; } 1056-Mice and Rice 花样分组,合并进组 逻辑考察 #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; struct node { int weight, index, rank, index0; }; bool cmp1(node a, node b) { return a.index0 \u003c b.index0; } int main() { int n, g, num; scanf(\"%d%d\", \u0026n, \u0026g); vector\u003cint\u003e v(n); vector\u003cnode\u003e w(n); for(int i=0; i\u003cn; i++) scanf(\"%d\", \u0026v[i]); for(int i=0; i\u003cn; i++) { scanf(\"%d\", \u0026num); w[i].weight=v[num]; w[i].index=i; w[i].index0=num; } queue\u003cnode\u003e q; for(int i=0; i\u003cn; i++) q.push(w[i]); while(!q.empty()) { int size=q.size(); if(size == 1) { node temp=q.front(); w[temp.index].rank=1; break; } int group=size/g; if(size%g != 0) group+=1; node maxnode; int maxn=-1, cnt=0; for(int i=0; i\u003csize; i++) { node temp=q.front(); w[temp.index].rank=group+1; q.pop(); cnt++; if(temp.weight \u003e maxn) { maxn=temp.weight; maxnode = temp; } if(cnt==g || i==size-1) { cnt=0; maxn=-1; q.push(maxnode); } } } sort(w.begin(), w.end(), cmp1); for(int i=0; i\u003cn; i++) { if(i!=0) printf(\" \"); printf(\"%d\", w[i].rank); } return 0; } 1057-Stack 这道题…考察树状数组 以后等我回来再更吧…树状数组有点顶(柳神的方法) 但是也能用分块思想做(网上大佬的方法) 不得不说,分块思想对于这种数据集较大的情况,是一种非常nice的解决方案 #include\u003cstack\u003e#include\u003calgorithm\u003e#include\u003cstring\u003e#include\u003ciostream\u003eusing namespace std; const int maxn = 100010; const int sqrn = 316; stack\u003cint\u003e st; int block[sqrn]; int table[maxn]; void peekm(int k){ int sum = 0; int idx = 0; while(sum + block[idx] \u003c k){ sum += block[idx]; } int num = idx * sqrn; while(sum + table[num] \u003c k){ sum += table[num++]; } printf(\"%d\\n\", num); } void push(int x){ st.push(x); block[x/sqrn]++; table[x]++; } void pop(){ int x = st.top(); st.pop(); block[x/sqrn]--; table[x]--; printf(\"%d\", x); } int main(){ int x, query; fill(block, block+316, 0); fill(table, table+100010, 0); string cmd; for(int i=0; i\u003cquery; i++){ cin \u003e\u003e cmd; if(cmd == \"Push\"){ scanf(\"%d\", x); push(x); } else if(cmd == \"Pop\"){ if(st.empty() == true){ printf(\"Invalid\\n\"); } else{ pop(); } } else{ if(st.empty() == true){ printf(\"Invalid\\n\"); } else{ int k = st.size(); if(k%2 == 1){ k = (k+1)/2; } else{ k = k/2; } peekm(k); } } } return 0; } 1058-A+B in Hogwarts 进制转换,没啥好说的,快乐就完事了 #include \u003ciostream\u003eusing namespace std; int main() { long long a, b, c, d, e, f; scanf(\"%lld.%lld.%lld %lld.%lld.%lld\", \u0026a, \u0026b, \u0026c, \u0026d, \u0026e, \u0026f); long long num = c+b*29+a*29*17+f+e*29+d*29*17; long long g=num/ (17*29); num = num% (17*29); printf(\"%lld.%lld.%lld\", g, num/29, num%29); return 0; } 1059-Prime Factors 这道题要求一个数可拆分为素数相加,因此绝妙的方法就是构建一个素数表 #include \u003ccstd","date":"2020-09-03","objectID":"/posts/pat-42/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 54-66","uri":"/posts/pat-42/"},{"categories":["数据结构与算法"],"content":"基本概念 | 数塔问题 基本概念 已知问题规模为n的前提A，求解一个未知解B。（我们用An表示“问题规模为n的已知条件”） 此时，如果把问题规模降到0，即已知A0，可以得到A0-\u003eB. 如果从A0添加一个元素，得到A1的变化过程。即A0-\u003eA1; 进而有A1-\u003eA2; A2-\u003eA3; …… ; Ai-\u003eAi+1. 这就是严格的归纳推理，也就是我们经常使用的数学归纳法； 对于Ai+1，只需要它的上一个状态Ai即可完成整个推理过程（而不需要更前序的状态）。我们将这一模型称为马尔科夫模型。对应的推理过程叫做“贪心法” 然而，Ai与Ai+1往往不是互为充要条件，随着i的增加，有价值的前提信息越来越少，我们无法仅仅通过上一个状态得到下一个状态，因此可以采用如下方案： {A1-\u003eA2}; {A1, A2-\u003eA3}; {A1,A2,A3-\u003eA4};……; {A1,A2,…,Ai}-\u003eAi+1. 这种方式就是第二数学归纳法。 对于Ai+1需要前面的所有前序状态才能完成推理过程。我们将这一模型称为高阶马尔科夫模型。对应的推理过程叫做“动态规划法” 上述两种状态转移图如下图所示： ","date":"2020-09-02","objectID":"/posts/DS-15/:0:0","tags":["Leetcode-C++"],"title":"动态规划-基本概念","uri":"/posts/DS-15/"},{"categories":["数据结构与算法"],"content":"能用动规解决的问题的特点 能采用动态规划求解的问题的一般要具有3个性质： 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） ","date":"2020-09-02","objectID":"/posts/DS-15/:1:0","tags":["Leetcode-C++"],"title":"动态规划-基本概念","uri":"/posts/DS-15/"},{"categories":["数据结构与算法"],"content":"动规解题的一般思路 动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件） 实际应用中可以按以下几个简化的步骤进行设计： 分析最优解的性质，并刻画其结构特征 递归的定义最优解 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 根据计算最优值时得到的信息，构造问题的最优解 ","date":"2020-09-02","objectID":"/posts/DS-15/:2:0","tags":["Leetcode-C++"],"title":"动态规划-基本概念","uri":"/posts/DS-15/"},{"categories":["数据结构与算法"],"content":"算法实现的说明 动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。 使用动态规划求解问题，最重要的就是确定动态规划三要素： 问题的阶段 每个阶段的状态 从前一个阶段转化到后一个阶段之间的递推关系 递推是自底向上 递归是自顶而下 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解 f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)} ","date":"2020-09-02","objectID":"/posts/DS-15/:3:0","tags":["Leetcode-C++"],"title":"动态规划-基本概念","uri":"/posts/DS-15/"},{"categories":["数据结构与算法"],"content":"算法实现的步骤 创建一个一维数组或者二维数组，保存每一个子问题的结果，具体创建一维数组还是二维数组看题目而定，基本上如果题目中给出的是一个一维数组进行操作，就可以只创建一个一维数组，如果题目中给出了两个一维数组进行操作或者两种不同类型的变量值，比如背包问题中的不同物体的体积与总体积，找零钱问题中的不同面值零钱与总钱数，这样就需要创建一个二维数组(需要创建二维数组的解法，都可以创建一个一维数组运用滚动数组的方式来解决，即一位数组中的值不停的变化) 设置数组边界值，一维数组就是设置第一个数字，二维数组就是设置第一行跟第一列的值，特别的滚动一维数组是要设置整个数组的值，然后根据后面不同的数据加进来变换成不同的值 找出状态转换方程，也就是说找到每个状态跟他上一个状态的关系，根据状态转化方程写出代码 返回需要的值，一般是数组的最后一个或者二维数组的最右下角 数塔问题 ","date":"2020-09-02","objectID":"/posts/DS-15/:4:0","tags":["Leetcode-C++"],"title":"动态规划-基本概念","uri":"/posts/DS-15/"},{"categories":["数据结构与算法"],"content":"问题描述 将一些数字排成数塔的形状，其中第一层一个数字，第二层2个数字，……第n层n个数字，现在要从第一层走到第n层，每次只能走向下一层的两个数字中的一个，问：最后将路径上所有数字相加后得到的和最大是多少？ 输入： 5 5 8 3 12 7 16 4 10 11 6 9 5 3 9 4 输出： 44 # 44是5 -\u003e 3 -\u003e 16 -\u003e 11 -\u003e 9得到的 ","date":"2020-09-02","objectID":"/posts/DS-15/:5:0","tags":["Leetcode-C++"],"title":"动态规划-基本概念","uri":"/posts/DS-15/"},{"categories":["数据结构与算法"],"content":"Code #include\u003ccstdio\u003e#include\u003calgorithm\u003eusing namespace std; const int maxn = 1000; int f[maxn][maxn], dp[maxn][maxn]; int main() { int n; scanf(\"%d\",\u0026n); for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= i; j++) { scanf(\"%d\",\u0026f[i][j]); } } for (int j = 1; j \u003c= n; j++) { dp[n][j] = f[n][j];//最下面一行为边界 } for (int i = n - 1; i \u003e= 1; i--) { for (int j = 1; j \u003c= i; j++) { dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + f[i][j]; }//这里自底向上求和，当前元素和下面一层左边和右边大的那个相加。 } printf(\"%d\\n\",dp[1][1]);//dp[1][1]是从1，1到底层的最大和，也是本题要求的 return 0; } ","date":"2020-09-02","objectID":"/posts/DS-15/:6:0","tags":["Leetcode-C++"],"title":"动态规划-基本概念","uri":"/posts/DS-15/"},{"categories":["PAT"],"content":"最近几天就总结一下解题套路吧…毕竟没几天就要考试了,绝不能做一只轻言放弃鸭!(甲级太顶了…我好菜) 做到现在,感觉甲级题也是有套路的…第一题和第二题白给,第三题树或者排序,第四题图或者动态规划或者一些我还没接触的东西(菜是问题的本源) 树的BFS/DFS ","date":"2020-09-02","objectID":"/posts/pat-41/:0:0","tags":["Leetcode-C++"],"title":"PAT典型题 Part-1","uri":"/posts/pat-41/"},{"categories":["PAT"],"content":"A1053 带权重的树: 提供一个节点上带权重的树,并且要求输出权重和(根节点到叶节点完整路径)符合要求的路径 并且输出要求按照路径的非递增顺序输出 首先对于此类问题的求解,一定会用到递归,那么就要根据题意来写出一个合理的 递归边界 和 递归式 当路径和大于所给值时,break return 当路径和等于所给值时,判断当前是否为节点是否为叶子节点 当路径和小于所给值时,对其子节点进行递归操作 对于如何存储路径,也有两种方式 使用数组,利用变量 nodenum 来记录当前数组中的节点个数 STL-vector 利用push_back 和pop_back 以及size()实现 ","date":"2020-09-02","objectID":"/posts/pat-41/:1:0","tags":["Leetcode-C++"],"title":"PAT典型题 Part-1","uri":"/posts/pat-41/"},{"categories":["PAT"],"content":"CODE #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003calgorithm\u003eusing namespace std; int target; struct node{ int weight; vector\u003cint\u003e child; }; vector\u003cnode\u003e data; vector\u003cint\u003e path; void dfs(int index, int sum){ path.push_back(index); //子节点加入路径 if(sum \u003e target){ //大于所给条件,舍弃 path.pop_back(); return; } if(sum == target){ if(data[index].child.size() !=0) { //判断是否为叶子节点 path.pop_back(); return; } for(int i=0; i\u003cpath.size(); i++){ //打印路径 printf(\"%d%c\", data[path[i]].weight, i != path.size() - 1 ? ' ' : '\\n'); } path.pop_back(); return; } for(int j=0; j\u003cdata[index].child.size(); j++){ // 对子节点递归 int node = data[index].child[j]; dfs(node, sum + data[node].weight); } path.pop_back(); //回溯,删除路径中一开始加入的节点 return; } bool cmp(int a, int b){ return data[a].weight \u003e data[b].weight; } int main(int argc, char const *argv[]) { int n, m, node, k; scanf(\"%d %d %d\", \u0026n, \u0026m, \u0026target); data.resize(n); for(int i=0; i\u003cn; i++) scanf(\"%d\", \u0026data[i].weight); for(int i=0; i\u003cm; i++) { scanf(\"%d %d\", \u0026node, \u0026k); data[node].child.resize(k); for(int j=0; j\u003ck; j++) scanf(\"%d\", \u0026data[node].child[j]); sort(data[node].child.begin(), data[node].child.end(), cmp); //对加入的子节点序列进行排列 } dfs(0, data[0].weight); return 0; } 图的遍历DFS/BFS 无论是dfs还是bfs,都要有一个trave循环,处理非连通情况 ","date":"2020-09-02","objectID":"/posts/pat-41/:2:0","tags":["Leetcode-C++"],"title":"PAT典型题 Part-1","uri":"/posts/pat-41/"},{"categories":["PAT"],"content":"DFS-A1034 考察图的深度遍历,并且有边权附加条件(应该用邻接矩阵保存数据) #include\u003ciostream\u003e#include\u003cstring\u003e#include\u003cmap\u003eusing namespace std; const int maxn = 2010; const int INF = 999999999; //初始极大值条件 map\u003cint, string\u003e intTostring; map\u003cstring, int\u003e stringToint; map\u003cstring, int\u003e gang; int G[maxn][maxn] = {0}; //初始化邻接矩阵 int weight[maxn] = {0}; //初始化权重数组(额外条件) int n, k, numperson = 0; bool vis[maxn] = {false}; //判定访问数组 void dfs(int nowvisit, int \u0026head, int \u0026num, int \u0026totalvalue){ num++; vis[nowvisit] = true; if(weight[nowvisit] \u003e weight[head]){ head = nowvisit; } for(int i=0; i\u003cnum; i++){ if(G[nowvisit][i] \u003e 0){ totalvalue += G[nowvisit][i]; //权重加和 G[nowvisit][i] = G[i][nowvisit] = 0; //将当前计算过的边除去 } if(vis[i] == false){ dfs(i, head, num, totalvalue); //递归访问 } } } void dfstrave(){ for(int i=0; i\u003cnumperson; i++){ if(vis[i] == false){ //没有被访问 int head = i; int num = 0; int totalvalue = 0; dfs(i, head, num, totalvalue); //递归 if(num \u003e 2 \u0026\u0026 totalvalue \u003e k){ //符合条件,放进 res数组 gang[intTostring[head]] = num; } } } } int change(string str){ //字符串名字 转 数字编号,方便数据处理 if(stringToint.find(str) != stringToint.end()){ return stringToint[str]; } else{ stringToint[str] = numperson; intTostring[numperson] = str; return numperson++; } } int main(){ int w; string str1, str2; cin \u003e\u003e n \u003e\u003e k; for(int i=0; i\u003cn; i++){ cin \u003e\u003e str1 \u003e\u003e str2 \u003e\u003e w; int id1 = change(str1); int id2 = change(str2); weight[id1] += w; //权重初始化 weight[id2] += w; G[id1][id2] += w; //邻接矩阵数据初始化 G[id2][id1] += w; } dfstrave(); cout \u003c\u003c gang.size() \u003c\u003c endl; for(auto it = gang.begin(); it != gang.end(); it++){ cout \u003c\u003c it-\u003efirst \u003c\u003c it-\u003esecond \u003c\u003c endl; //遍历打印数据 } return 0; } ","date":"2020-09-02","objectID":"/posts/pat-41/:3:0","tags":["Leetcode-C++"],"title":"PAT典型题 Part-1","uri":"/posts/pat-41/"},{"categories":["PAT"],"content":"BFS-A1076 这道题是讨论weibo的转发,首先给一个用户的树状关系,之后每个用户的转发只能最多三层 因此用到广度优先遍历,即层序遍历,这就需要在结点结构中,加入node属性进行判定 #include\u003ccstdio\u003e#include\u003ccstring\u003e#include\u003cvector\u003e#include\u003cqueue\u003e using namespace std; const int maxv = 1010; struct node{ int id; int layer; }; vector\u003cnode\u003e adj[maxv]; bool inq[maxv] = {false}; //全局访问判定数组 int bfs(int s, int L){ int numforward = 0; queue\u003cnode\u003e q; node start; start.id = s; start.layer = 0; q.push(start); inq[start.id] = true; while(!q.empty()){ node topnode = q.front(); q.pop(); int u = topnode.id; for(int i=0; i\u003cadj[u].size(); i++){ node next = adj[u][i]; next.layer = topnode.layer + 1; if(inq[next.id] == false \u0026\u0026 next.layer \u003c= L){ //遍历队头元素 q.push(next); inq[next.id] = true; numforward++; } } } return numforward; } int main(){ node user; int n, L, numfollow, idfollow; scanf(\"%d%d\", \u0026n, \u0026L); for(int i=1; i\u003c=n; i++){ user.id = i; scanf(\"%d\", \u0026numfollow); for(int j=0; j\u003cnumfollow; j++){ scanf(\"%d\", \u0026idfollow); adj[idfollow].push_back(user); //初始化数据 } } int numquery, s; scanf(\"%d\", \u0026numquery); for(int i=0; i\u003cnumquery; i++){ memset(inq, false, sizeof(inq)); //初始化数组 scanf(\"%d\", \u0026s); int numforward = bfs(s, L); printf(\"%d\\n\", numforward); } return 0; } Dijkstra-A1030 寻找最短的出行路径,并且附加条件为路程消耗最小(权重相加最小) #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eusing namespace std; int n, m, s, d; int e[510][510]; //邻接矩阵 int dis[510]; //离开始点的距离 int cost[510][510]; //路程消耗 vector\u003cint\u003e pre[510]; //路径记录(重点) bool visit[510]; //是否访问过 判定 const int inf=99999999; vector\u003cint\u003e path, temppath; int mincost=inf; void dfs(int v) { temppath.push_back(v); if(v==s) { //到达目的地,进行路径消耗计算 int tempcost=0; for(int i=temppath.size() -1; i\u003e0; i--) { int id=temppath[i], nextid=temppath[i-1]; tempcost += cost[id][nextid]; } if(tempcost\u003cmincost) { mincost = tempcost; path = temppath; } temppath.pop_back(); //回溯 return ; } for(int i=0; i\u003cpre[v].size(); i++) dfs(pre[v][i]); //没有达到目的地,进行递归 temppath.pop_back(); //回溯 } int main() { fill(e[0], e[0] +510*510, inf); //fill初始化 fill(dis, dis+510, inf); scanf(\"%d%d%d%d\", \u0026n, \u0026m, \u0026s, \u0026d); for(int i=0; i\u003cm; i++) { int a, b; scanf(\"%d%d\", \u0026a, \u0026b); scanf(\"%d\", \u0026e[a][b]); e[b][a] = e[a][b]; scanf(\"%d\", \u0026cost[a][b]); cost[b][a] =cost[a][b]; } pre[s].push_back(s); //防止坏数据(可去) // Dijkstra begin dis[s] =0; for(int i=0; i\u003cn; i++) { int u=-1, minn = inf; for(int j=0; j\u003cn; j++) { if(visit[j] ==false \u0026\u0026 dis[j] \u003c minn) { //找到最短边 u=j; minn=dis[j]; } } if(u == -1) //没有找到最短边 break; visit[u] =true; for(int v=0; v\u003cn; v++) { //从当前边找到的最短边顶点出发 if(visit[v] == false \u0026\u0026 e[u][v] !=inf) { //更新距离,并且记录前驱点 if(dis[v] \u003edis[u] +e[u][v]) { dis[v] =dis[u] +e[u][v]; pre[v].clear(); pre[v].push_back(u); } else if(dis[v] ==dis[u] +e[u][v]) { pre[v].push_back(u); } } } } // Dijkstra end dfs(d); //dfs打印路径 for(int i = path.size() -1; i\u003e=0; i--) printf(\"%d \", path[i]); printf(\"%d %d\", dis[d], mincost); return 0; } ","date":"2020-09-02","objectID":"/posts/pat-41/:4:0","tags":["Leetcode-C++"],"title":"PAT典型题 Part-1","uri":"/posts/pat-41/"},{"categories":["数据结构与算法"],"content":"数据结构-树状数组 https://www.jianshu.com/p/7cd5ad2f449a ","date":"2020-09-02","objectID":"/posts/DS-13/:0:0","tags":["Leetcode-C++"],"title":"树状数组","uri":"/posts/DS-13/"},{"categories":["数据结构与算法"],"content":"花了大半天时间,算是稍微理解了背包问题 甲级题要把我虐穿了…这两天肝一肝8…(哭) 首先了解一下什么叫背包问题 背包问题的一个典型例子就是小偷偷东西,有多个大小不同,价值不同的物品,但是小偷的背包能装下的物体的空间有限,这是就要去计算一个最优解,即\"如何能在不超过背包容量的情况下,总体偷取的物品总价值最高\" 对于这类问题,动态规划的解决方法就是,将这个问题划分为多个小问题组成,并计算每个小问题的优化解,在得到的小问题的优化解,逐步扩大求解范围,并在这个过程中继续优化解,因此最后可以得到一个最优解 “拆分小问题” -\u003e “优化推进” 这个过程 基本概念 这里直接贴上简书大佬的文章了 内容搬运自算法图解这本书 参考文章 其实手头就有一本算法图解,之前也看过…虽然之前也看过,但由于当初没有算法功底,所以…看了也都没啥印象,不过现在再看,效果就好了很多,毕竟这本书我认为不是零基础入门的,而是更生动的理解算法的出发点和解决问题的方式 问题分类 背包问题目前我只是接触了最基础的一类问题,因此这算是第一篇吧,后面的其他类型问题还会慢慢学习 0-1背包 完全背包 ","date":"2020-09-01","objectID":"/posts/DS-14/:0:0","tags":["Leetcode-C++"],"title":"动态规划 背包问题-1","uri":"/posts/DS-14/"},{"categories":["数据结构与算法"],"content":"0-1背包 0-1背包名字的由来就是,在待求解问题中,每一个可选元素,都只有一个,即只有 “选” 或 “不选” 两种选择 而对于问题的求解,如果从逻辑上直接过渡到代码实现的话,就需要构造一个二维数组,最后问题也可以优化为一维数组 但二维和一维的区别在于,一维数组遍历顺序有所改变,是从后向前进行遍历 ","date":"2020-09-01","objectID":"/posts/DS-14/:1:0","tags":["Leetcode-C++"],"title":"动态规划 背包问题-1","uri":"/posts/DS-14/"},{"categories":["数据结构与算法"],"content":"二维求解 /* 状态转移方程： 定义f[i][j]:前i个物品，背包容量j下的最优解 1. 当前背包容量不够（j \u003c w[i]），为前i-1个物品最优解：f[i][j] = f[i-1][j] 2. 当前背包容量够，判断选与不选第i个物品 选：f[i][j] = f[i-1][j-w[i]] + v[i] 不选：f[i][j] = f[i-1][j] */ #include\u003cbits/stdc++.h\u003eusing namespace std; const int MAXN = 1005; int w[MAXN]; // 重量 int v[MAXN]; // 价值 int f[MAXN][MAXN]; // f[i][j], j重量下前i个物品的最大价值 int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; ++i) cin \u003e\u003e w[i] \u003e\u003e v[i]; for(int i = 1; i \u003c= n; ++i) for(int j = 1; j \u003c= m; ++j) { // 当前重量装不进，价值等于前i-1个物品 if(j \u003c w[i]) f[i][j] = f[i-1][j]; // 能装，需判断 else f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + v[i]); } cout \u003c\u003c f[n][m]; return 0; } ","date":"2020-09-01","objectID":"/posts/DS-14/:1:1","tags":["Leetcode-C++"],"title":"动态规划 背包问题-1","uri":"/posts/DS-14/"},{"categories":["数据结构与算法"],"content":"一维优化 从后向前遍历 /* 状态转移方程为：f[j] = max(f[j], f[j-w[i]] + v[i] */ for(int i = 1; i \u003c= n; ++i) { for(int j = m; j \u003e= 0; --j) if(j \u003e= w[i]) f[j] = max(f[j], f[j-w[i]] + v[i]); } ","date":"2020-09-01","objectID":"/posts/DS-14/:1:2","tags":["Leetcode-C++"],"title":"动态规划 背包问题-1","uri":"/posts/DS-14/"},{"categories":["数据结构与算法"],"content":"完全背包 ","date":"2020-09-01","objectID":"/posts/DS-14/:2:0","tags":["Leetcode-C++"],"title":"动态规划 背包问题-1","uri":"/posts/DS-14/"},{"categories":["数据结构与算法"],"content":"二维求解 #include\u003ciostream\u003eusing namespace std; const int N = 1010; int f[N][N]; int v[N],w[N]; int main() { int n,m; cin\u003e\u003en\u003e\u003em; for(int i = 1 ; i \u003c= n ;i ++) { cin\u003e\u003ev[i]\u003e\u003ew[i]; } for(int i = 1 ; i\u003c=n ;i++) for(int j = 0 ; j\u003c=m ;j++) { for(int k = 0 ; k*v[i]\u003c=j ; k++) f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); } cout\u003c\u003cf[n][m]\u003c\u003cendl; } ","date":"2020-09-01","objectID":"/posts/DS-14/:2:1","tags":["Leetcode-C++"],"title":"动态规划 背包问题-1","uri":"/posts/DS-14/"},{"categories":["数据结构与算法"],"content":"一维优化 参考文章 #include\u003ciostream\u003eusing namespace std; const int N = 1010; int f[N]; int v[N],w[N]; int main() { int n,m; cin\u003e\u003en\u003e\u003em; for(int i = 1 ; i \u003c= n ;i ++) { cin\u003e\u003ev[i]\u003e\u003ew[i]; } for(int i = 1 ; i\u003c=n ;i++) for(int j = v[i] ; j\u003c=m ;j++) { f[j] = max(f[j],f[j-v[i]]+w[i]); } cout\u003c\u003cf[m]\u003c\u003cendl; } 个人理解 这里着重记录一下目前的理解 0-1背包 一维求解 从后向前遍历 完全背包问题 一维求解 从前向后遍历 当从后向前遍历时,对于当前解的优化,只是涉及到了单独的前驱元素,而此时前驱元素不包含当前判定元素,因此可以保证,在向前遍历过程中的每个元素都可以保证,当前判定元素只使用了一次 但当从前向后遍历时,每个元素都是可以经过前面的累计,即后驱元素在当前元素的选择上,可以继续选择当前判定元素,因此元素使用次数不限制,限制条件只有总体容量限制 ","date":"2020-09-01","objectID":"/posts/DS-14/:2:2","tags":["Leetcode-C++"],"title":"动态规划 背包问题-1","uri":"/posts/DS-14/"},{"categories":["HEXO"],"content":"将网站内容收录入百度谷歌的搜索引擎 百度 ","date":"2020-08-30","objectID":"/posts/hexo-5/:0:0","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["HEXO"],"content":"验证网站所有权 登录百度站长平台 用户中心 –\u003e 站点管理 –\u003e 添加网站 有 文件验证、HTML标签验证、CNAME验证 三种方式 这里选择的是文件验证这种方式。根据指示下载验证文件后，将下载的文件放在博客根目录下的 source 文件夹下，如果你下载的验证文件类型是 html 文件则还需要对该 html 文件做相应修改以保证该文件上传到网站后是一模一样的，即不被渲染和压缩。因此需要在 html 文件第一行加入下面的内容： --- layout: false --- 接着重新部署更新自己的博客后，确认验证文件是否可以正常访问,如果可以访问的话会出现之前下载的验证文件里的信息（即一串字母数字的组合），点击“完成验证”按钮即可。 ","date":"2020-08-30","objectID":"/posts/hexo-5/:1:0","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["HEXO"],"content":"选择提交方式 当网站通过验证之后，我们就可以使用链接提交工具了，目前有 api, sitemap、手动提交 三种方式。三者都是将站点自身的 URL 自动推送至百度，而后等待百度爬虫进行对页面的抓取。这里只说 api 和 sitemap方法…手动提交太慢了 ","date":"2020-08-30","objectID":"/posts/hexo-5/:2:0","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["HEXO"],"content":"sitemap 提交 Sitemap（即站点地图）就是网站上各网页的列表。创建并提交 Sitemap 有助于百度发现网站上的所有网页。 ","date":"2020-08-30","objectID":"/posts/hexo-5/:3:0","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["HEXO"],"content":"安装 Sitemap generator 插件 安装应在 hexo_blog 文件夹下安装,否则插件会无效 npm install hexo-generator-baidu-sitemap --save ","date":"2020-08-30","objectID":"/posts/hexo-5/:3:1","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["HEXO"],"content":"修改配置文件 打开博客站点配置文件 _config.yml，增加 baidusitemap 属性： baidusitemap: path: baidusitemap.xml 这样执行 hexo g 时，会在 public/ 文件夹下生成站点文件 baidusitemap.xml。 ","date":"2020-08-30","objectID":"/posts/hexo-5/:3:2","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["HEXO"],"content":"填写地址 填写site.xml文件所在的地址 blog域名/baidusitemap.xml ","date":"2020-08-30","objectID":"/posts/hexo-5/:4:0","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["HEXO"],"content":"api 提交 这个提交时在 hexo-d 时执行,将新生成的网站推送到 baidu站台 例如当前调用地址为 http://data.zz.baidu.com/urls?site=tronwei.top\u0026token=demotoken123 #host: tronwei.top #token: demotoken123 ","date":"2020-08-30","objectID":"/posts/hexo-5/:5:0","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["HEXO"],"content":"安装插件： npm install hexo-baidu-url-submit --save 最后，打开博客站点配置文件 _config.yml，增加 baidu_url_submit 属性以及修改 url 属性和 deploy 属性： # 百度主动推送 baidu_url_submit: count: 5 ## 提交最新的 5 个链接 host: tronwei.top ## 注意修改为你在百度站长平台中注册的域名 token: demotoken123 ## 注意修改为你的秘钥 path: baidu_urls.txt ## 文本文档的地址 新链接会保存在此文本文档里 deploy: - type: git repo: github: https://github.com/weixusheng/weixusheng.github.io.git gitee: https://gitee.com/tronwei/tronwei.git branch: master - type: baidu_url_submitter # new line 这样执行 hexo generate 时，会在 public/baidu_urls.txt 这个文本文件保存最新的链接 执行 hexo d 时，会从上述文件中读取链接提交到百度站台 谷歌收录 ","date":"2020-08-30","objectID":"/posts/hexo-5/:5:1","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["HEXO"],"content":"验证网站 与百度收录操作相似，但是谷歌的效率要高很多，操作完之后基本就收录完成了。 添加网站进行验证 打开谷歌搜索控制台，选择 URL prefix，输入你的博客域名后进行验证，这里使用的仍然是 HTML 验证方式。与百度收录操作相似的，下载 html 文件到博客根目录下的 source 文件夹并在 html 文件前加上代码： --- layout: false --- 重新部署更新自己博客后，点击 VERIFY 按钮查看是否添加验证成功。 ","date":"2020-08-30","objectID":"/posts/hexo-5/:6:0","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["HEXO"],"content":"提交 Sitemap 安装插件： npm install hexo-generator-sitemap --save 打开博客站点配置文件_config.yml，增加 sitemap 属性： # googleSiteMap sitemap: path: sitemap.xml 执行 hexo g 时，会在 public/ 文件夹下生成站点文件 sitemap.xml。执行 hexo deploy 时，将上述文件部署到云端。 ","date":"2020-08-30","objectID":"/posts/hexo-5/:7:0","tags":["HEXO-NEXT"],"title":"Hexo-百度谷歌收录","uri":"/posts/hexo-5/"},{"categories":["win"],"content":"一开始我还以为 WSL2崩了… 原来重置一下网络就行…应该是昨天折腾梯子导致的 在管理员模式下运行命令后重启即可 netsh winsock reset ","date":"2020-08-30","objectID":"/posts/win-5/:0:0","tags":["WSL"],"title":"WSL2-参考对象类型不支持尝试操作","uri":"/posts/win-5/"},{"categories":["win"],"content":"Win环境下的全局梯子配置 这两天OneNote把我折腾了好久…熬了两天夜 主要问题在于,之前onenote同步数据速度很快,但现如今同步速度甚至达到了不能用的地步,忍不了鸭,我还有好多笔记在里边 所以就想解决方法,第一天晚上,知道了onenote香港cnd服务器被微软撤走了,因此国区数据同步慢(但都慢到不能用了…) 第二天就开始研究怎么不全局加速,使得数据能同步过来,一开始还天真挂香港节点,结果今天一ping,发现数据在美国微软云…我吐了 因为我买的那个加速器软件开全局会安装一个虚拟网卡,很容易出事(之前就是因为这个重装的电脑) 所以我连带着…学会了两个通用的梯子和一个全局代理工具,最后算是解决了OneNote同步问题 SSR-酸酸乳 一开始看大家说酸酸乳,我还一脸疑惑,我在这查梯子,你们给我搞一堆饮料上来是什么操作… 后来查多了才慢慢知道,原来大佬们口口相传的酸酸乳…就是SSR 现在主流的梯子网站都会提供一个订阅地址,而一些就会提供ssr网址,当然也会有的不提供ssr,而提供其他类型的订阅网址 ","date":"2020-08-29","objectID":"/posts/win-4/:0:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"SSR配置教程 ","date":"2020-08-29","objectID":"/posts/win-4/:1:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"安装 Github项目地址 ","date":"2020-08-29","objectID":"/posts/win-4/:1:1","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"SSR Windows客户端安装及运行 下载完成后，解压，然后后运行ShadowsocksR-dotnet2.0.exe 或 ShadowsocksR-dotnet4.0.exe 即可。 SSR Windows客户端的运行，需要.net环境的支持，一般来说Win7以上系统可以直接运行。 如果运行时提示错误，那么需要先安装Microsoft .NET Framework 4。 下载地址 ","date":"2020-08-29","objectID":"/posts/win-4/:2:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"SSR客户端使用教程 ","date":"2020-08-29","objectID":"/posts/win-4/:3:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"1-服务器配置 1.SSR成功运行后，系统任务栏（桌面右下角时间那里，没有的话，就是隐藏起来了）会出现一个小飞机标志。 2.需要先添加SSR服务器，右键点击小飞机——服务器——编辑服务器。 3.在弹出的编辑服务器窗口，直接修改默认的几项参数。修改为你获取的节点数据，或直接导入ssr链接（导入链接，需要你复制链接，右键系统任务栏中的小飞机图标，点击上图中的剪贴板批量导入ssr：//链接）。 服务器IP：前面打勾后可见，需要填写你的VPS服务器IP地址 服务器端口：安装SSR服务端时设置的端口（port） 密码：安装SSR服务端时设置的密码（password） 加密、协议、混淆：这几项分别对应安装SSR服务端时设置的 Stream Cipher、Protocol、obfs 几项，下图中仅为示范，具体按实际填写 混淆参数：留空 ","date":"2020-08-29","objectID":"/posts/win-4/:3:1","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"2-添加订阅地址 如果提供是订阅链接，那么点击下图的服务器订阅——ssr服务器订阅设置 在弹出的窗口点击add，把订阅网址填好后确定。 右键客户端，菜单中选择服务器订阅——更新服务器订阅（不通过代理）。等待更新成功的通知，然后再服务器那一栏中即可看到节点信息。 ","date":"2020-08-29","objectID":"/posts/win-4/:3:2","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"其他配置 设置完成后，点击确定即可完成服务器的设置。 ","date":"2020-08-29","objectID":"/posts/win-4/:3:3","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"模式介绍 右键点击任务栏的小飞机，在弹出的菜单中，通过相关设置搭配，可以对访问流量进行个性化分流。 ","date":"2020-08-29","objectID":"/posts/win-4/:4:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"系统代理模式： SSR的代理模式，通过该项对流量进行二次分流（第一次分流见下文）。决定进入SSR客户端的流量是否走代理。默认为全局模式，下面我们分别介绍。 直连模式： 所有进入SSR的流量不走代理，相当于没有安装SSR，一般我们很少选择这一项 PAC模式： 通过SSR目录中的pac.txt文件，判断进入SSR客户端的流量是否走代理 全局模式： 所有进入SSR客户端的流量都走代理 ","date":"2020-08-29","objectID":"/posts/win-4/:4:1","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"PAC： 即PAC模式用到的pac.txt，在其它模式下不生效。在该菜单下，我们可以对该文件进行相关操作，一般我们选择PAC为GFWList。 在SSR服务器连接成功后，可以点击“更新PAC为GFWList”进行更新。 ","date":"2020-08-29","objectID":"/posts/win-4/:4:2","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"代理规则： 决定哪些流量进入SSR客户端，对电脑流量进行第一次分流。 绕过局域网：局域网的IP直接连接，不进入SSR客户端。 绕过局域网和大陆：局域网和大陆的IP，不进入SSR客户端，直接连接。 绕过局域网和非大陆：大陆以外的IP，不进入SSR客户端，直接连接。这一项很少选择。 用户自定义：很少选择。 全局：所有流量全部进入SSR客户端。 ","date":"2020-08-29","objectID":"/posts/win-4/:4:3","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"各项目常用的搭配为： 系统代理模式：PAC模式。 PAC：更新PAC为GFWList。 代理规则：绕过局域网和大陆。 如何设置SSR开机启动 为了避免每次开机，都需要手动开启SSR，我们可以设置SSR开机自启。具体：右键点击任务栏小飞机——选项设置——开机启动打勾——确定。如下图： ","date":"2020-08-29","objectID":"/posts/win-4/:5:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"局域网其它设备连接SSR 电脑端的SSR，其实可以通过设置，与其它局域网设备共享，实现上网。 右键任务栏小飞机——选项设置——允许来自局域网的连接打勾——确定。 其它局域网设备的网络连接里，设置代理地址为电脑局域网IP，端口为默认的1080。设置生效后，流量就会经过电脑的SSR进行转接了。 ","date":"2020-08-29","objectID":"/posts/win-4/:6:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"常见问题汇总 常见问题汇总 PAC配置文件介绍 V2rayN ","date":"2020-08-29","objectID":"/posts/win-4/:7:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"安装 Github项目地址 ","date":"2020-08-29","objectID":"/posts/win-4/:8:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"使用教程 相比较SSR而言,V2rayN的使用就简单了很多,有一个图形化界面 首先，找到文件夹中的v2rayn.exe文件，双击运行。 添加订阅 点击主界面的订阅-订阅设置，然后粘贴自己的v2ray订阅地址，填写备注等信息。注意勾选备用。然后保存。 更新订阅 点击主界面的订阅-更新订阅，等待几秒钟即可。 启用节点 选择一个节点，单击右键-设为活动服务器，即意味着选中了此节点。（也可以在左键点击节点名称以后按一下回车键，即Enter键） 选择代理模式 在任务栏图标上单击右键，找到Http代理，推荐选择开启PAC，并自动配置系统代理(PAC模式)。勾选后，系统代理正式启动，已经可以达到科学上网效果。此模式下，V2RayN将会针对访问请求自动分流，国内站点直连，被屏蔽站点将走代理。（但也不是万能的，准确性非100%） 显示网速统计 在主界面点击参数设置，勾选启用统计，需要重启v2rayN客户端。 测试服务器状态 在主界面点击测试服务状态，选择测试服务状态，即可查看真实延迟。 更新v2rayN及v2rayCore v2rayCore是v2ray的核心文件，v2rayN是图形化客户端。 在主界面点击检查更新，即可选择更新对象。 Proxifier全局代理 酸酸乳支持全局(PAC模式和代理方式都选择全局即可) V2rayN全局需要搭配 Proxofier实现 ","date":"2020-08-29","objectID":"/posts/win-4/:9:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"配置代理服务器地址 端口填写当前梯子的端口 ","date":"2020-08-29","objectID":"/posts/win-4/:10:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"Name Solutions 只选择第二个勾选项 ","date":"2020-08-29","objectID":"/posts/win-4/:11:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"代理规则-Rules ","date":"2020-08-29","objectID":"/posts/win-4/:12:0","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"指定程序代理 ","date":"2020-08-29","objectID":"/posts/win-4/:12:1","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"设置全局代理 不需要在Appplications中添加程序 直接 更改Action为Proxy socks5 127.0.0.1 即可 ","date":"2020-08-29","objectID":"/posts/win-4/:12:2","tags":["SSR"],"title":"Win-科学上网","uri":"/posts/win-4/"},{"categories":["win"],"content":"PAC模式下的OneNote同步加速 SSR 在酸酸乳 user.rule 中添加如下规则即可。 ! Put user rules line by line in this file. ! See ! OneNote Start .officeapps.live.com .docs.live.net ! OneNote End``` 其他梯子 打开前端软件，找到 用户自定义pac那里，添加如下规则 这个我暂时还没用上,但道理都是在代理规则中添加指向onenote的网址 这个过程需要抓包软件 ||live.com ||live.net ||contentsync-onenote.com 抓包软件 Fiddler4 ","date":"2020-08-29","objectID":"/posts/win-6/:0:0","tags":["OneNote"],"title":"Win-OneNote同步","uri":"/posts/win-6/"},{"categories":["win"],"content":"这两天被苏菲上新装的win10系统折磨的够呛…踩了一堆坑 cnpm国内镜像 | hexo d 报错 微软商店500报错 可能是梯子和加速器配置文件冲突,最后莫名其妙把微软商店搞崩了… 之后把全网给出的方法都试了一遍,还是不行,硬着头皮重装系统了… 以后还是不开全局梯子了…怕了怕了 hexo d 报错 $ hexo d -g ...(省略) FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html TypeError [ERR_INVALID_ARG_TYPE]: The \"mode\" argument must be integer. Received an instance of Object 错误原因在于nodejs版本过高 安装 “node 12.14” 版本即可 cnpm国内镜像 以后再也不挂梯子了…老老实实用镜像吧 ","date":"2020-08-28","objectID":"/posts/win-2/:0:0","tags":["Hexo"],"title":"快乐踩坑","uri":"/posts/win-2/"},{"categories":["win"],"content":"安装 npm install cnpm -g --registry=https://registry.npm.taobao.org ","date":"2020-08-28","objectID":"/posts/win-2/:1:0","tags":["Hexo"],"title":"快乐踩坑","uri":"/posts/win-2/"},{"categories":["win"],"content":"win10下cnpm报错 cnpm : 无法加载文件 C:\\Users\\name\\AppData\\Roaming\\npm\\cnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。 在 管理员模式powershell 下执行 set-ExecutionPolicy RemoteSigned A 即可解决 cnpm真香! ","date":"2020-08-28","objectID":"/posts/win-2/:2:0","tags":["Hexo"],"title":"快乐踩坑","uri":"/posts/win-2/"},{"categories":["win"],"content":"WSL默认安装在C盘,因此有必要迁移出系统盘 下载工具包 Github下载ZIP包 解压 解压之后 在解压之后的目录运行 .\\LxRunOffline.exe list #查看已经安装的WSL 迁移 .\\LxRunOffline.exe move -n Ubuntu -d D:\\ubuntu #安装的WSL 迁移到指定目录 迁移完成 .\\LxRunOffline.exe get-dir -n Ubuntu #可以看到新的目录 ","date":"2020-08-28","objectID":"/posts/win-3/:0:0","tags":["WSL"],"title":"WSL迁移","uri":"/posts/win-3/"},{"categories":["Git"],"content":"强制拉取覆盖本地 remote Incorrect username or password 报错 强制拉取覆盖本地 git fetch --all git reset --hard origin/master git pull remote Incorrect username or password 报错 在 vscode 中链接 github(指第一次链接)经常莫名其妙告诉我账号密码错误…可能之前确实输入错了,但是却没法改变 后来查了好久,才知道还能在控制面板里改! 点击 windows-凭据 ","date":"2020-08-28","objectID":"/posts/github-4/:0:0","tags":["Github"],"title":"Git 强制拉取覆盖本地","uri":"/posts/github-4/"},{"categories":["HEXO"],"content":"删除 .deploy_git 文件夹 ","date":"2020-08-25","objectID":"/posts/hexo-4/:1:0","tags":["HEXO-NEXT"],"title":"部署-spawn failed错误的解决方法","uri":"/posts/hexo-4/"},{"categories":["HEXO"],"content":"修改配置文件 git config --global core.autocrlf false ","date":"2020-08-25","objectID":"/posts/hexo-4/:2:0","tags":["HEXO-NEXT"],"title":"部署-spawn failed错误的解决方法","uri":"/posts/hexo-4/"},{"categories":["HEXO"],"content":"依次执行： hexo clean hexo g hexo d ","date":"2020-08-25","objectID":"/posts/hexo-4/:3:0","tags":["HEXO-NEXT"],"title":"部署-spawn failed错误的解决方法","uri":"/posts/hexo-4/"},{"categories":["HEXO"],"content":"更改用户凭据 控制面板更改用户凭据,github账号密码 ","date":"2020-08-25","objectID":"/posts/hexo-4/:4:0","tags":["HEXO-NEXT"],"title":"部署-spawn failed错误的解决方法","uri":"/posts/hexo-4/"},{"categories":["PAT"],"content":"1045-1053 1045-Favorite Color Stripe 一道经典的动态规划,算取最优解,先对相邻元素进行判定,之后扩大搜索区域,开始区间取max优解,并将算得的局部数据,存入数组,以便更大区间取值时用到 #include\u003ciostream\u003eusing namespace std; int main(int argc, char const *argv[]) { int dp[10001], a[10001], book[201]; int n, m, x, l, num=0, maxn=0; scanf(\"%d %d\",\u0026n, \u0026m); for(int i=1; i\u003c=m; i++){ scanf(\"%d\", \u0026x); book[x] = i; } scanf(\"%d\", \u0026l); for(int j=0; j\u003cl; j++){ scanf(\"%d\", \u0026x); if(book[x] \u003e= 1){ a[num++] = book[x]; } } for(int i=0; i\u003cnum; i++){ dp[i] = 1; for(int j=0; j\u003ci; j++){ if(a[i] \u003e= a[j]){ dp[i] = max(dp[j]+1, dp[i]); } } maxn = max(dp[i], maxn); } printf(\"%d\", maxn); return 0; } 1046-Shortest Distance 这道题的精髓在于,将区间距离,保存在了一个数组中,直接数组元素相减即可得到区间距离 #include\u003ciostream\u003e#include\u003cvector\u003eusing namespace std; int main(int argc, char const *argv[]) { int num; scanf(\"%d\", \u0026num); vector\u003cint\u003e data(num); int sum = 0; for(int i=0; i\u003cnum; i++){ scanf(\"%d\", \u0026data[i]); sum += data[i]; } int shit; int ans; scanf(\"%d\", \u0026shit); int s, e; for(int i=0; i\u003cshit; i++){ ans = 0; int tsum = sum; scanf(\"%d %d\", \u0026s, \u0026e); if(s \u003e e){ for(int j=e; j\u003cs; j++){ tsum -= data[j-1]; } ans = tsum; printf(\"%d\\n\", ans); } else if(e \u003e s){ for(int j=s; j\u003ce; j++){ ans += data[j-1]; } printf(\"%d\\n\", ans); } } return 0; } 1047-Student List for Course 对于 STL 的经典考察 #include\u003ciostream\u003e#include\u003cstring\u003e#include\u003cvector\u003e#include\u003cmap\u003e#include\u003calgorithm\u003e using namespace std; bool cmp(string a, string b){ return a \u003c b; } int main(int argc, char const *argv[]) { map\u003cint, vector\u003cstring\u003e \u003e data; int stnum, cnum; scanf(\"%d %d\", \u0026stnum, \u0026cnum); string id; id.resize(30); int shit, tmp; for(int i=0; i\u003cstnum; i++){ scanf(\"%s %d\", \u0026id[0], \u0026shit); for(int j=0; j\u003cshit; j++){ scanf(\"%d\", \u0026tmp); data[tmp].push_back(id); } } for(int k=1; k\u003c=cnum; k++){ sort(data[k].begin(), data[k].end(), cmp); printf(\"%d %d\\n\", k, data[k].size()); for(int w=0; w\u003cdata[k].size(); w++){ printf(\"%s\\n\", data[k][w].c_str()); } } return 0; } 1048-Find Coins 这道题一开始想用二分查找,但是后来发现,源数据的相互关系就乱套了 看了题解才发现这种相加题,直接用hash就可以解决,很棒的思路 #include \u003ciostream\u003eusing namespace std; int a[1001]; int main() { int n, m, temp; scanf(\"%d %d\", \u0026n, \u0026m); for(int i=0; i\u003cn; i++) { scanf(\"%d\", \u0026temp); a[temp]++; } for(int i=0; i\u003c1001; i++) { if(a[i]) { a[i]--; if(m\u003ei \u0026\u0026 a[m-i]) { printf(\"%d %d\", i, m-i); return 0; } a[i]++; } } printf(\"No Solution\"); return 0; } /* #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cvector\u003e using namespace std; bool cmp(int a, int b){ return a \u003c b; } int main(int argc, char const *argv[]) { int num, shit; int hs[100000] = {0}; scanf(\"%d %d\", \u0026num, \u0026shit); vector\u003cint\u003e data(num); for(int i=1; i\u003c=num; i++){ scanf(\"%d\", \u0026data[i]); hs[data[i]] = i; } sort(data.begin(), data.end(), cmp); int mid; int left, right, sum = 0; for(int j=1; j\u003c=data.size(); j++){ left = j+1; right = data.size()-1; while(left \u003c= right){ mid = (left + right)/2; sum = data[j] + data[mid]; if(sum == shit){ if(hs[data[j]] \u003e hs[data[mid]]){ break; } printf(\"%d %d\", data[j], data[mid]); return 0; } else if(sum \u003e shit){ right = mid-1; } else{ left = mid+1; } } } printf(\"No Solution\"); return 0; } */ 1049-Counting Ones 我直接用了string来做,果不其然,两个测试点超时了,但是真要是考试我能压轴题做成这样,我就太知足了 ","date":"2020-08-25","objectID":"/posts/pat-40/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 45-53","uri":"/posts/pat-40/"},{"categories":["PAT"],"content":"超时-string #include\u003ciostream\u003e#include\u003cstring\u003eusing namespace std; int main(int argc, char const *argv[]) { int shit; scanf(\"%d\", \u0026shit); string data; int cnt = 0; for(int i=1; i\u003c=shit; i++){ data += to_string(i); } for(int j=0; j\u003cdata.size(); j++){ if(data[j] == '1'){ cnt++; } } printf(\"%d\", cnt); return 0; } 1050-String Subtraction 非常快乐的string操作 #include\u003ciostream\u003e#include\u003cstring\u003e#include\u003cvector\u003eusing namespace std; int main(int argc, char const *argv[]) { string a, b; getline(cin, a); getline(cin, b); int len = b.size(); int shit[100000]; for(int i=0; i\u003clen; i++){ shit[b[i]] = 1; } for(int j=0; j\u003ca.size(); j++){ if(shit[a[j]] != 1){ printf(\"%c\", a[j]); } } return 0; } 1051-Pop Sequence 栈的模拟操作,经典类型题 没想到还能这样直接模拟出来,来判断序列是否合理 #include\u003ciostream\u003e#include\u003cstack\u003e#include\u003cvector\u003eusing namespace std; int main(int argc, char const *argv[]) { int m, n, k; // m: maximum stack n:sequence length k:check num scanf(\"%d %d %d\", \u0026m, \u0026n, \u0026k); for(int i=0; i\u003ck; i++){ vector\u003cint\u003e data(n); stack\u003cint\u003e s; for(int j=0; j\u003cn; j++){ scanf(\"%d\", \u0026data[j]); } int cur = 0; for(int k=1; k\u003c=n; k++){ s.push(k); if(s.size() \u003e m){ break; } while(!s.empty() \u0026\u0026 s.top() == data[cur]){ s.pop(); cur++; } } if(cur == n){ printf(\"YES\\n\"); } else{ printf(\"NO\\n\"); } } return 0; } 1052-Linked List Sorting 快乐的模拟链表类型题 #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003calgorithm\u003eusing namespace std; struct node{ int ad; int key; int next; }origin[1000000]; bool cmp(node a, node b){ return a.key \u003c b.key; } int main(int argc, char const *argv[]) { int n, ad, cnt = 0; scanf(\"%d %d\", \u0026n, \u0026ad); int a, b, c; for(int i=0; i\u003cn; i++){ scanf(\"%d %d %d\", \u0026a, \u0026b, \u0026c); origin[a].ad = a; origin[a].key = b; origin[a].next = c; } vector\u003cnode\u003e data; while(ad != -1){ data.push_back(origin[ad]); ad = origin[ad].next; } sort(data.begin(), data.end(), cmp); cnt = data.size(); if(cnt == 0){ printf(\"0 -1\\n\"); return 0; } else{ printf(\"%d %05d\\n\", cnt, data[0].ad); for(int k=0; k\u003ccnt; k++){ if(k == 0){ printf(\"%05d %d \", data[k].ad, data[k].key); } else{ printf(\"%05d\\n%05d %d \", data[k].ad, data[k].ad, data[k].key); } if(k == data.size()-1){ printf(\"-1\"); } } } return 0; } 1053-Path of Equal Weight 经典 dfs + 二级条件 的遍历 最后琢磨琢磨自己终于写出来了…下次遇到树遍历不再怕啦! #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003calgorithm\u003eusing namespace std; int target; struct node{ int weight; vector\u003cint\u003e child; }; vector\u003cnode\u003e data; vector\u003cint\u003e path; void dfs(int index, int sum){ path.push_back(index); if(sum \u003e target){ path.pop_back(); return; } if(sum == target){ if(data[index].child.size() !=0) { path.pop_back(); return; } for(int i=0; i\u003cpath.size(); i++){ /* if(i != 0){ printf(\" \"); } printf(\"%d\", data[path[i]].weight); if(i == path.size()-1){ printf(\"\\n\"); } */ printf(\"%d%c\", data[path[i]].weight, i != path.size() - 1 ? ' ' : '\\n'); } path.pop_back(); return; } for(int j=0; j\u003cdata[index].child.size(); j++){ int node = data[index].child[j]; dfs(node, sum + data[node].weight); } path.pop_back(); return; } bool cmp(int a, int b){ return data[a].weight \u003e data[b].weight; } int main(int argc, char const *argv[]) { int n, m, node, k; scanf(\"%d %d %d\", \u0026n, \u0026m, \u0026target); data.resize(n); for(int i=0; i\u003cn; i++) scanf(\"%d\", \u0026data[i].weight); for(int i=0; i\u003cm; i++) { scanf(\"%d %d\", \u0026node, \u0026k); data[node].child.resize(k); for(int j=0; j\u003ck; j++) scanf(\"%d\", \u0026data[node].child[j]); sort(data[node].child.begin(), data[node].child.end(), cmp); } //path.push_back(0); dfs(0, data[0].weight); return 0; } ","date":"2020-08-25","objectID":"/posts/pat-40/:1:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 45-53","uri":"/posts/pat-40/"},{"categories":["PAT"],"content":"1041-1044 1041-Be Unique 快乐hash #include\u003cset\u003e#include\u003cvector\u003e#include\u003ciostream\u003e using namespace std; int main(int argc, char const *argv[]) { int num; cin \u003e\u003e num; set\u003cint\u003e s1; vector\u003cint\u003e data(num); int shit[100000] = {0}; int tmp; for(int i=0; i\u003cnum; i++){ cin \u003e\u003e tmp; data[i] = tmp; shit[tmp]++; } int j; for(j=0; j\u003cnum; j++){ if(shit[data[j]] == 1){ printf(\"%d\", data[j]); break; } } if(j == num){ printf(\"None\"); } return 0; } 1042-Shuffling Machine 打扰了,这题没看懂啥意思 #include \u003ccstdio\u003eusing namespace std; int main() { int cnt; scanf(\"%d\", \u0026cnt); int start[55], end[55], scan[55]; for(int i=1; i\u003c55; i++) { scanf(\"%d\", \u0026scan[i]); end[i] =i; } for(int i=0; i\u003ccnt; i++) { for(int j=1; j\u003c55; j++) start[j] =end[j]; for(int k=1; k\u003c55; k++) end[scan[k]] =start[k]; } char c[6] = {\"SHCDJ\"}; for(int i=1; i\u003c55; i++) { end[i] =end[i] -1; printf(\"%c%d\", c[end[i]/13], end[i]%13+1); if(i!=54) printf(\" \"); } return 0; } 1043-Is It a Binary Search Tree 这道题考察二叉搜索树,并且让我引发了一些思考 对于给定树(搜索树)的遍历序列,可以直接建树,之后进行树的遍历 而如果直接对遍历序列进行操作,就会…没啥思路 并且搜索树的镜像树,就是对左右树的访问次序颠倒即可 #include\u003ciostream\u003e#include\u003cvector\u003e using namespace std; struct node{ int data; node *left, *right; }; void insert(node* \u0026root, int data){ if(root == NULL){ root = new node; root-\u003edata = data; root-\u003eleft = root-\u003eright = NULL; return; } if(data \u003c root-\u003edata){ insert(root-\u003eleft, data); } else{ insert(root-\u003eright, data); } } void preorder(node* root, vector\u003cint\u003e \u0026vi){ if(root == NULL){ return; } vi.push_back(root-\u003edata); preorder(root-\u003eleft, vi); preorder(root-\u003eright, vi); } void preorder_mirro(node* root, vector\u003cint\u003e \u0026vi){ if(root == NULL){ return; } vi.push_back(root-\u003edata); preorder_mirro(root-\u003eright, vi); preorder_mirro(root-\u003eleft, vi); } void posterorder(node* \u0026root, vector\u003cint\u003e \u0026vi){ if(root == NULL){ return; } posterorder(root-\u003eleft, vi); posterorder(root-\u003eright, vi); vi.push_back(root-\u003edata); } void posterorder_mirro(node* \u0026root, vector\u003cint\u003e \u0026vi){ if(root == NULL){ return; } posterorder_mirro(root-\u003eright, vi); posterorder_mirro(root-\u003eleft, vi); vi.push_back(root-\u003edata); } vector\u003cint\u003e origin, pre, prem, post, postm; int main(int argc, char const *argv[]) { int n,data; node* root = NULL; scanf(\"%d\", \u0026n); for(int i=0; i\u003cn; i++){ scanf(\"%d\", \u0026data); origin.push_back(data); insert(root, data); } preorder(root, pre); preorder_mirro(root, prem); if(origin == pre){ printf(\"YES\\n\"); posterorder(root, post); for(int i=0; i\u003cpost.size(); i++){ printf(\"%d\", post[i]); if(i \u003c post.size()-1){ printf(\" \"); } } } else if(origin == prem){ printf(\"YES\\n\"); posterorder_mirro(root, postm); for(int i=0; i\u003cpostm.size(); i++){ printf(\"%d\", postm[i]); if(i \u003c postm.size()-1){ printf(\" \"); } } } else{ printf(\"NO\\n\"); } return 0; } 1044-Shopping in Mars 这道题需要解决的问题是,查找相加恰好为一定值的序列 即可构造一个递增的相加值序列,而对于这种递增序列查找某一符合的值,就可以用二分法 真的没想到二分法还能这么神奇…太强了 我爱甲级压轴题…(哭) #include\u003ciostream\u003e#include\u003cvector\u003eusing namespace std; vector\u003cint\u003e ans, sum; int n, m, tmpsum; int func(int i, int \u0026j){ int left = i; int right = n; while(left \u003c right){ int mid = (left+right)/2; if(sum[mid]-sum[i-1] \u003e= m){ right = mid; } else{ left = mid+1; } } j = right; int tsum = sum[j]-sum[i-1]; return tsum; } int main(int argc, char const *argv[]) { scanf(\"%d %d\", \u0026n, \u0026m); sum.resize(n+1); for(int i=0; i\u003cn; i++){ scanf(\"%d\", \u0026sum[i]); sum[i] += sum[i-1]; } int maxshit = sum[n]; for(int i=1; i\u003c=n; i++){ int j; tmpsum = func(i, j); if(tmpsum \u003e maxshit){ continue; } else if(tmpsum \u003e= m){ if(tmpsum \u003c maxshit){ ans.clear(); maxshit = tmpsum; } ans.push_back(i); ans.push_back(j); } } for(int j=0; j\u003cans.size(); j+=2){ printf(\"%d-%d\\n\", ans[j],ans[j+1]); } return 0; } ","date":"2020-08-22","objectID":"/posts/pat-39/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 41-44","uri":"/posts/pat-39/"},{"categories":["PAT"],"content":"1036-1040 1036-Boys vs Girls 边界查询比较,不算太难 #include \u003ciostream\u003eusing namespace std; int main() { int n; scanf(\"%d\", \u0026n); string female, male; int femalescore=-1, malescore=101; for(int i=0; i\u003cn; i++) { string name, sex, num; int score; cin\u003e\u003ename\u003e\u003esex\u003e\u003enum; scanf(\"%d\", \u0026score); if(sex==\"F\") { if(femalescore\u003cscore) { femalescore=score; female=name+\" \"+num; } } else if(malescore\u003escore) { malescore=score; male=name+\" \"+num; } } if(femalescore!=-1) cout\u003c\u003cfemale\u003c\u003cendl; else printf(\"Absent\\n\"); if(malescore!=101) cout\u003c\u003cmale\u003c\u003cendl; else printf(\"Absent\\n\"); if(femalescore!=-1\u0026\u0026malescore!=101) printf(\"%d\", femalescore-malescore); else printf(\"NA\"); return 0; } 1037-Magic Coupon 代码实现上不难,不过逻辑有些难想(贪心算法) #include \u003ccstdio\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int main() { int m, n, ans=0, p=0, q=0; scanf(\"%d\", \u0026m); vector\u003cint\u003e v1(m); for(int i=0; i\u003cm; i++) scanf(\"%d\", \u0026v1[i]); scanf(\"%d\", \u0026n); vector\u003cint\u003e v2(n); for(int i=0; i\u003cn; i++) scanf(\"%d\", \u0026v2[i]); sort(v1.begin(), v1.end()); sort(v2.begin(), v2.end()); while(p\u003cm \u0026\u0026 q\u003cn \u0026\u0026 v1[p] \u003c0 \u0026\u0026 v2[q] \u003c0) { ans+=v1[p] *v2[q];p++; q++; } p=m-1, q=n-1; while(p\u003e=0 \u0026\u0026 q\u003e=0 \u0026\u0026 v1[p] \u003e0 \u0026\u0026 v2[q] \u003e0) { ans+=v1[p] *v2[q]; p--; q--; } printf(\"%d\", ans); return 0; } 1038-Recover the Smallest Number 甲级压轴题都好难…哭了,向压轴题低头 这道题用到了贪心算法…不过也太难想了 因为要将多个不同长度的数字字符组成为一个总体值最小的,就用到了区间相邻相加并排序的方式来实现 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003calgorithm\u003eusing namespace std; bool cmp0(string a, string b) { return a+b\u003cb+a; } string str[10010]; int main() { int n; scanf(\"%d\", \u0026n); for(int i=0; i\u003cn; i++) cin\u003e\u003estr[i]; sort(str, str+n, cmp0); string s; for(int i=0; i\u003cn; i++) s+=str[i]; while(s.length() !=0\u0026\u0026s[0] =='0') s.erase(s.begin()); if(s.length() ==0) cout\u003c\u003c0; cout\u003c\u003cs; return 0; } 1039-Course List for Student 这道题是对stl的考察 ","date":"2020-08-22","objectID":"/posts/pat-38/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 36-40","uri":"/posts/pat-38/"},{"categories":["PAT"],"content":"scanf(string)的方法 首先要对string申请空间 string a; a.resize(10); 之后在scanf中填入字符串的首地址 scanf(\"%s\", \u0026a[0]); ","date":"2020-08-22","objectID":"/posts/pat-38/:1:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 36-40","uri":"/posts/pat-38/"},{"categories":["PAT"],"content":"CODE #include\u003ciostream\u003e#include\u003cmap\u003e#include\u003cvector\u003e#include\u003cstring\u003e#include\u003calgorithm\u003eusing namespace std; int main(int argc, char const *argv[]) { map\u003cstring, vector\u003cint\u003e \u003e data; int n, k, no, num; string name; name.resize(30); //cin \u003e\u003e n \u003e\u003e k; scanf(\"%d %d\", \u0026n, \u0026k); for(int i=0; i\u003ck; i++){ scanf(\"%d %d\", \u0026no, \u0026num); for(int j=0; j\u003cnum; j++){ //cin \u003e\u003e name; scanf(\"%s\", \u0026name[0]); data[name].push_back(no); } } for(int i=0; i\u003cn; i++){ //cin \u003e\u003e name; scanf(\"%s\", \u0026name[0]); sort(data[name].begin(), data[name].end()); //cout \u003c\u003c name \u003c\u003c \" \" \u003c\u003c data[name].size(); printf(\"%s %d\", name.c_str(), data[name].size()); for(int k=0; k\u003cdata[name].size(); k++){ printf(\" %d\", data[name][k]); } printf(\"\\n\"); } return 0; } 1040-Longest Symmetric String 动态规划经典题 由于动态规划中一大核心思想就是,保存局部值,以便在更大区间时,可以加以利用 而这道题就是,构建一个二维数组,来保存区间是否对称,并且利用两个for循环,在小区间的基础上对更大区间进行判断,并更新二维数组的值 虽然看懂了代码,但下次让我写,我可能还是写不出来… 以后多复习吧 #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003cstring\u003eusing namespace std; int data[1010][1010]; int main(int argc, char const *argv[]) { string s; getline(cin, s); int len = s.size(), ans = 1; for(int i=0; i\u003clen; i++){ data[i][i] = 1; if(s[i] == s[i+1]){ data[i][i+1] = 1; ans = 2; } } for(int shit = 3; shit \u003c= len; shit++){ for(int i=0; i\u003clen; i++){ int j = i+shit-1; if(s[i] == s[j] \u0026\u0026 data[i+1][j-1] == 1){ data[i][j] = 1; ans = shit; } } } printf(\"%d\", ans); return 0; } ","date":"2020-08-22","objectID":"/posts/pat-38/:2:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 36-40","uri":"/posts/pat-38/"},{"categories":["PAT"],"content":"1031-1035 一直在做题,但是没更新blog,这两天都补上 1031 Hello World for U 这道题是打印图形题,由于这个图形较为特殊(U型),因此利用一个数组,先将图形字符存在二维数组中,最后直接打印即可 但是这就需要注意打印边界 #include\u003ciostream\u003e#include\u003cstring\u003eusing namespace std; int main(int argc, char const *argv[]) { char data[30][30]; string c; cin \u003e\u003e c; fill(data[0],data[0]+30*30,' '); int n = c.size() + 2; int n1 = n/3; int n2 = n/3 + n%3; int index = 0; for(int i=0; i\u003cn1; i++){ data[i][0] = c[index++]; } for(int i=1; i\u003c=n2-2; i++){ data[n1-1][i] = c[index++]; } for(int i=n1-1; i\u003e=0; i--){ data[i][n2-1] = c[index++]; } for(int i=0; i\u003cn1; i++){ for(int j=0; j\u003cn2; j++){ printf(\"%c\", data[i][j]); } printf(\"\\n\"); } return 0; } 1032-Sharing 这道题就是利用结构体来模拟链表,题解中for循环写的很棒,利用 .next 作为for循环的递条件 #include \u003ccstdio\u003eusing namespace std; struct NODE { char key; int next; bool flag; }node[100000]; int main() { int s1, s2, n, a, b; scanf(\"%d%d%d\", \u0026s1, \u0026s2, \u0026n); char data; for(int i=0; i\u003cn; i++) { scanf(\"%d %c %d\", \u0026a, \u0026data, \u0026b); node[a] = {data, b, false}; } for(int i=s1; i!=-1; i=node[i].next){ node[i].flag=true; } for(int i=s2; i!=-1; i=node[i].next) { if(node[i].flag==true) { printf(\"%05d\", i); return 0; } } printf(\"-1\"); return 0; } 1033-To Fill or Not to Fill 这道题…贪心算法的经典例题吧,做完这道题确实对贪心有了更深刻的理解 好题好题 #include\u003ciostream\u003e#include\u003calgorithm\u003e#include\u003cvector\u003e using namespace std; const int inf = 99999999; struct station{ double pris; double dis; }; bool cmp(station a, station b){ return a.dis \u003c b.dis; } int main(int argc, char const *argv[]) { double cmax, d, avg; int n; scanf(\"%lf%lf%lf%d\", \u0026cmax, \u0026d, \u0026avg, \u0026n); vector\u003cstation\u003e sta(n+1); sta[0] = {0.0, d}; for(int i=1; i\u003c=n; i++){ scanf(\"%lf%lf\", \u0026sta[i].pris, \u0026sta[i].dis); } sort(sta.begin(), sta.end(), cmp); double nowdis = 0.0, maxdis = 0.0, nowpris = 0.0, totalpris = 0.0, leftdis = 0.0; //特判不存加原点加油站 if(sta[0].dis != 0){ printf(\"The maximum travel distance = 0.00\"); return 0; } else{ nowpris = sta[0].pris; } while(nowdis \u003c d){ maxdis = nowdis + cmax*avg; //最大行驶路程 double minpris = inf; double minprisdis = 0; int flag = 0; //找到第一个符合条件的车站 for(int i=1; i\u003c=n \u0026\u0026 sta[i].dis \u003c= maxdis; i++){ if(sta[i].dis \u003c= nowdis){ continue; } if(sta[i].pris \u003c nowpris){ totalpris += (nowpris * (sta[i].dis - nowdis - leftdis)/avg); leftdis = 0.0; nowpris = sta[i].pris; nowdis = sta[i].dis; flag = 1; break; } if(sta[i].pris \u003c minpris){ minpris = sta[i].pris; minprisdis = sta[i].dis; } } if(flag == 0 \u0026\u0026 minpris != inf){ totalpris += (nowpris * (cmax - leftdis/avg)); leftdis = (cmax*avg)-(minprisdis - nowdis); nowdis = minprisdis; nowpris = minpris; } if(flag == 0 \u0026\u0026 minpris == inf){ nowdis += cmax*avg; printf(\"The maximum travel distance = %.2f\", nowdis); return 0; } } printf(\"%.2f\", totalpris); return 0; } 1034-Head of a Gang 连通图判定 + 附加条件(权重)判定 首先一个快乐dfs寻找连通图,其次在连通图内的循环中,寻找max值 #include\u003ciostream\u003e#include\u003cmap\u003eusing namespace std; map\u003cstring,int\u003e stoim; map\u003cint,string\u003e itosm; int idnum = 1; int sifunc(string a){ if(stoim[a] == 0){ stoim[a] = idnum; itosm[idnum] = a; return idnum++; } else{ return stoim[a]; } } int k; int g[2010][2010]; int weight[2010]; bool visited[2010]; map\u003cstring, int\u003e ans; void dfs(int v, int \u0026head, int \u0026totalnum, int \u0026totalweight){ visited[v] = true; totalnum++; if(weight[v] \u003e weight[head]){ head = v; } for(int i=1; i\u003cidnum; i++){ if(g[v][i] \u003e 0){ totalweight += g[v][i]; g[v][i] = g[i][v] = 0; if(visited[i] == false){ dfs(i, head, totalnum, totalweight); } } } } void dfstrave(){ for(int i=1; i\u003cidnum; i++){ if(visited[i] == false){ int head = i, totalnum = 0, totalweight = 0; dfs(i, head, totalnum, totalweight); if(totalnum \u003e 2 \u0026\u0026 totalweight \u003e k){ ans[itosm[head]] = totalnum; } } } } int main(int argc, char const *argv[]) { int n, w; cin \u003e\u003e n \u003e\u003e k; string s1, s2; for(int i=0; i\u003cn; i++){ cin \u003e\u003e s1 \u003e\u003e s2 \u003e\u003e w; int id1 = sifunc(s1); int id2 = sifunc(s2); g[id1][id2] += w; g[id2][id1] += w; weight[id1] += w; weight[id2] += w; } dfstrave(); cout\u003c\u003c ans.size() \u003c\u003c endl; for(auto it=ans.begin(); it!=ans.end(); it++) cout\u003c\u003c it-\u003efirst \u003c\u003c\" \"\u003c\u003c it-\u003esecond \u003c\u003c endl; return 0; } 1035-Password 这道题对于字符串的简单","date":"2020-08-21","objectID":"/posts/pat-37/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 31-35","uri":"/posts/pat-37/"},{"categories":["PAT"],"content":"1026-1030 今天才收到了乙级的证书，突然意识到离甲级考试就剩20天了，加油鸭！ 1026-Table Tennis 这道快乐模拟类型的题，我搞了两个小时…模拟类型最好的解决方法就是，在纸上把所有处理情况提前写好，类似于各种情况下的决策树，如果直接开始写，绝对会懵的 后来看到柳神在评论下说，这类复杂模拟不会考了…啊这… #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003calgorithm\u003e#include\u003ccmath\u003eusing namespace std; struct person{ int arrive, start, time; bool vip; }tmpperson; struct tablenode{ int end = 8*3600, num; bool vip; }; bool cmp1(person a, person b){ return a.arrive \u003c b.arrive; } bool cmp2(person a, person b){ return a.start \u003c b.start; } vector\u003cperson\u003e player; vector\u003ctablenode\u003etable; void alloctable(int personid, int tableid){ if(player[personid].arrive \u003c= table[tableid].end){ player[personid].start = table[tableid].end; } else{ player[personid].start = player[personid].arrive; } table[tableid].end = player[personid].start + player[personid].time; table[tableid].num++; } int findnextvip(int vipid){ vipid++; while(vipid \u003c player.size() \u0026\u0026 player[vipid].vip == false){ vipid++; } return vipid; } int main(int argc, char const *argv[]) { int n, k, m, viptable; scanf(\"%d\", \u0026n); for(int i=0; i\u003cn; i++){ int h,m,s,tmptime, flag; scanf(\"%d:%d:%d %d %d\", \u0026h, \u0026m, \u0026s, \u0026tmptime, \u0026flag); tmpperson.arrive = h*3600 + m*60 + s; tmpperson.start = 21 * 3600; if(tmpperson.arrive \u003e= 21*3600){ continue; } tmpperson.time = tmptime \u003c= 120 ? tmptime*60 : 7200; tmpperson.vip = ((flag == 1) ? true : false); player.push_back(tmpperson); } scanf(\"%d%d\", \u0026k,\u0026m); table.resize(k+1); for(int i=0; i\u003cm; i++){ scanf(\"%d\", \u0026viptable); table[viptable].vip = true; } sort(player.begin(), player.end(), cmp1); int i=0, vipid = -1; vipid = findnextvip(vipid); while(i \u003c player.size()){ int index = -1, minendtime = 999999999; for(int j=1; j\u003c=k; j++){ //找到最先结束的table if(table[j].end \u003c minendtime){ minendtime = table[j].end; index = j; } } if(table[index].end \u003e= 21*3600){ break; } if(player[i].vip == true \u0026\u0026 i\u003cvipid){ i++; continue; } if(table[index].vip == true){ // vip table if(player[i].vip == true){ //vip table \u0026\u0026 vip man alloctable(i, index); if(vipid == i){ vipid = findnextvip(vipid); } i++; } else{ // vip table !vip man if(vipid \u003c player.size() \u0026\u0026 player[vipid].arrive \u003c= table[index].end){ alloctable(vipid, index); vipid = findnextvip(vipid); //先不跳过,留给非vip的下次循环 } else{ alloctable(i, index); i++; } } } else{ // !vip table if(player[i].vip == false){ alloctable(i, index); i++; } else{ //vip man int vipindex = -1, minvipendtime = 999999999; for(int j=1; j\u003c=k; j++){ //寻找符合要求的 vip table if(table[j].vip == true \u0026\u0026 table[j].end \u003c minvipendtime){ minvipendtime = table[j].end; vipindex = j; } } if(vipindex != -1 \u0026\u0026 player[i].arrive \u003e= table[vipindex].end){ alloctable(i, vipindex); if(vipid == i){ vipid = findnextvip(vipid); } i++; } else{ //没找到 vip table alloctable(i, index); if(vipid == i){ vipid = findnextvip(vipid); } i++; } } } } sort(player.begin(), player.end(), cmp2); // 注意最后 double四舍五入的方法，先 round 函数，再 .0f 输出 for(int i=0; i\u003cplayer.size() \u0026\u0026 player[i].start \u003c 21*3600; i++){ printf(\"%02d:%02d:%02d \", player[i].arrive/3600, player[i].arrive % 3600 / 60, player[i].arrive%60); printf(\"%02d:%02d:%02d \", player[i].start/3600, player[i].start% 3600 / 60, player[i].start%60); printf(\"%.0f\\n\", round((player[i].start-player[i].arrive) /60.0)); } for(int i=1; i\u003c=k; i++){ if(i != 1){ printf(\" \"); } printf(\"%d\", table[i].num); } return 0; } 1027-Colors in Mars 快乐的进制转换,巧妙使用char数组 #include \u003ccstdio\u003eusing namespace std; int main() { char c[14] = {\"0123456789ABC\"}; printf(\"#\"); for(int i=0; i\u003c3; i++) { int num; scanf(\"%d\", \u0026num); printf(\"%c%c\", c[num/13], c[num%13]); } return 0; } 1028-List Sorting 一道稍微快乐的常规排序题,不过需要注意的是,题中要求 非递减 那么就需要在 cmp 中用 \u003c= 符号 #include\u003ciostream\u003e#include\u003calgorithm\u003e#include\u003cstring\u003eusing namespace std; const int maxn = 100001; struct Node{ int no, score; string name; }node[maxn]; int c; bool cmp(Node a, Node b){ if(c == 1){ return a.no \u003c b.no; } else if(c == 2){ if(a.name == b.name){ return a.no \u003c b.no; } else{ return a.name \u003c= b.name; } } else { if(a.score == b.score){ return a.no \u003c b.no; } else{ return a.score \u003c= b.score;","date":"2020-08-15","objectID":"/posts/pat-36/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 26-30","uri":"/posts/pat-36/"},{"categories":["PAT"],"content":"1022-1025 甲级慢慢上道啦! 1022-Digital Library 考察 map一对多映射,只需要构造 map\u003cstring,vector \u003e 结构 #include \u003ciostream\u003e#include \u003cmap\u003e#include \u003cset\u003eusing namespace std; map\u003cstring, set\u003cint\u003e \u003etitle, author, key, pub, year; void query(map\u003cstring, set\u003cint\u003e \u003e\u0026m, string\u0026str) { if(m.find(str) !=m.end()) { for(auto it=m[str].begin(); it!=m[str].end(); it++) printf(\"%07d\\n\", *it); } else cout\u003c\u003c\"Not Found\\n\"; } int main() { int n, m, id, num; scanf(\"%d\", \u0026n); string ttitle, tauthor, tkey, tpub, tyear; for(int i=0; i\u003cn; i++) { scanf(\"%d\\n\", \u0026id); getline(cin, ttitle); title[ttitle].insert(id); getline(cin, tauthor); author[tauthor].insert(id); while(cin \u003e\u003e tkey) { key[tkey].insert(id); charc=getchar(); if(c=='\\n') break; } getline(cin, tpub); pub[tpub].insert(id); getline(cin, tyear); year[tyear].insert(id); } scanf(\"%d\", \u0026m); for(int i=0; i\u003cm; i++) { scanf(\"%d: \", \u0026num); string temp; getline(cin, temp); cout\u003c\u003cnum\u003c\u003c\": \"\u003c\u003ctemp\u003c\u003c\"\\n\"; if(num==1) query(title, temp); else if(num==2) query(author, temp); else if(num==3) query(key, temp); else if(num==4) query(pub,temp); else if(num==5) query(year, temp); } return 0; } 1023-Have Fun with Numbers 快乐的手动进制运算,驾轻就熟 #include \u003ccstdio\u003e#include \u003cstring\u003e#include\u003ciostream\u003eusing namespace std; int book[10]; int main() { string s; getline(cin,s); int flag=0, len = s.size(); for(int i=len-1; i\u003e=0; i--) { int temp = s[i] -'0'; book[temp]++; temp = temp*2+flag; flag=0; if(temp\u003e=10) { temp=temp-10; flag=1; } s[i] = (temp+'0'); book[temp]--; } int flag1=0; for(int i=0; i\u003c10; i++) { if(book[i] !=0) flag1=1; } printf(\"%s\", (flag==1||flag1==1) ?\"No\\n\" : \"Yes\\n\"); if(flag==1) printf(\"1\"); cout \u003c\u003c s; return 0; } 1024-Palindromic Number 跟上道题一样的套路,对于回文数的判断,直接逆置直接比较就好 #include\u003cstring\u003e#include\u003calgorithm\u003e#include\u003ciostream\u003e using namespace std; bool isshit(string s){ string s2 = s; reverse(s.begin(),s.end()); if(s == s2){ return true; } return false; } int main(int argc, char const *argv[]) { string s,s2; int num, carry; cin \u003e\u003e s \u003e\u003e num; bool shit; shit = isshit(s); if(shit){ cout \u003c\u003c s \u003c\u003c endl; cout \u003c\u003c \"0\"; return 0; } for(int j=1; j\u003c=num; j++){ s2 = s; reverse(s2.begin(), s2.end()); int tmp; carry = 0; for(int i=s.size()-1; i\u003e=0; i--){ tmp = (s[i]-'0')+(s2[i]-'0'); tmp += carry; carry = 0; if(tmp \u003e10){ carry = 1; } tmp = tmp%10; s[i] = tmp+'0'; } if(carry == 1){ s = \"1\"+s; } shit = isshit(s); if(shit || j == num){ cout \u003c\u003c s \u003c\u003c endl; cout \u003c\u003c j; break; } } return 0; } 1025-PAT Ranking 这道题让我很开心,直接ac啦,甲级也有点慢慢上道了呢! 对于这种排序,搞结构体肯定没有错 #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003cstring\u003e#include\u003calgorithm\u003e#include\u003ccstring\u003e using namespace std; struct node{ string id; int score; int area; int rank; int localrank; }; bool cmp(node a, node b){ if(a.score == b.score){ return a.id \u003c b.id; } else{ return a.score \u003e b.score; } } int main(int argc, char const *argv[]) { int a, num; cin \u003e\u003e a; vector\u003cvector\u003cnode\u003e \u003e data(a); vector\u003cnode\u003e res; string id; int score; int pre; int rank; int tmprank; for(int i=0; i\u003ca; i++){ cin \u003e\u003e num; for(int j=0; j\u003cnum; j++){ cin \u003e\u003e id \u003e\u003e score; data[i].push_back({id, score, i, 0, 0}); } sort(data[i].begin(), data[i].end(),cmp); pre = 101; rank = 1; for(auto it = data[i].begin(); it!=data[i].end(); it++){ if(it-\u003escore != pre){ pre = it-\u003escore; it-\u003elocalrank = rank; tmprank = rank; } else{ it-\u003elocalrank = tmprank; } rank++; } for(int k=0; k\u003cnum; k++){ res.push_back(data[i][k]); } } sort(res.begin(), res.end(), cmp); printf(\"%d\\n\", res.size()); pre = 101; rank = 1; for(int i=0; i\u003cres.size(); i++){ //1234567890005 1 1 1 if(res[i].score == pre){ res[i].rank = tmprank; } else{ res[i].rank = rank; tmprank = rank; pre = res[i].score; } rank++; node shit = res[i]; printf(\"%s %d %d %d\\n\", shit.id.c_str(), shit.rank, shit.area+1, shit.localrank); } return 0; } ","date":"2020-08-14","objectID":"/posts/pat-35/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 22-25","uri":"/posts/pat-35/"},{"categories":["PAT"],"content":"1021 1021-Deepest Root 这道题主要解决思路为 图的深度遍历的应用-找到连通图.找到最高树 这道题感觉算是稍微吃透了 数组对于路径的保存有极好的作用,这里利用tmp保存尾端符合条件(maxheight边界条件)的尾端结点,在dijkstra也有类似的应用 #include\u003cset\u003e#include\u003ciostream\u003e#include\u003cvector\u003eusing namespace std; vector\u003cvector\u003cint\u003e \u003e v; bool shit[10010]; set\u003cint\u003e res; vector\u003cint\u003e tmp; int maxheight = 0, n; void dfs(int node, int height){ if(height \u003e maxheight){ tmp.clear(); tmp.push_back(node); maxheight = height; } else if(height == maxheight){ tmp.push_back(node); } shit[node] = true; for(int i=0; i\u003cv[node].size(); i++){ if(shit[v[node][i]] == false){ dfs(v[node][i], height+1); } } } int main(int argc, char const *argv[]) { scanf(\"%d\", \u0026n); v.resize(n+1); int a, b, cnt=0, s; for(int i=0; i\u003cn; i++){ //插入数据 scanf(\"%d%d\", \u0026a, \u0026b); v[a].push_back(b); v[b].push_back(a); } for(int i=1; i\u003c=n; i++){ if(shit[i] == false){ dfs(i, 1); if(i == 1){ if(tmp.size() != 0){ s = tmp[0]; } for(int j=0; j\u003ctmp.size(); j++){ res.insert(tmp[j]); } } cnt++; } if(cnt \u003e= 2){ printf(\"Error: %d components\", cnt); } else{ tmp.clear(); maxheight = 0; fill(shit, shit+10010, false); dfs(s, 1); for(int i=0; i\u003ctmp.size(); i++){ res.insert(tmp[i]); } for(auto it = res.begin(); it != res.end(); it++){ printf(\"%d\\n\", *it); } } } return 0; } ","date":"2020-08-14","objectID":"/posts/pat-34/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 21","uri":"/posts/pat-34/"},{"categories":["PAT"],"content":"1016-1020 1016-Phone Bills 一道比较巧妙而复杂的快乐排序题 开始的时候看到题被吓到了,以为很复杂,但是其实就是 筛选合理数据 + 排序 就能解决的问题 对于这种分秒格式的数据,应该化为秒数表示,这样区间值计算和比较 并且这种带有开头结尾的合理区间判断,这道题的排序判断相邻元素的方法就很好 #include \u003ciostream\u003e#include \u003cmap\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; struct node { string name; int status, month, time, day, hour, minute; }; bool cmp(node a, node b) { return a.name!=b.name?a.name\u003cb.name : a.time\u003cb.time; } double billFromZero(node call, int*rate) { double total=rate[call.hour] *call.minute+rate[24] *60*call.day; for (int i=0; i\u003ccall.hour; i++) total+=rate[i] *60; return total/100.0; } int main() { int rate[25] = {0}, n; for (int i=0; i\u003c24; i++) { scanf(\"%d\", \u0026rate[i]); rate[24] += rate[i]; } scanf(\"%d\", \u0026n); vector\u003cnode\u003e data(n); for (inti=0; i\u003cn; i++) { cin\u003e\u003edata[i].name; scanf(\"%d:%d:%d:%d\", \u0026data[i].month, \u0026data[i].day, \u0026data[i].hour,\u0026data[i].minute); string temp; cin\u003e\u003etemp; data[i].status = (temp==\"on-line\") ?1 : 0;data[i].time=data[i].day*24*60+data[i].hour*60+data[i].minute; } sort(data.begin(), data.end(), cmp); map\u003cstring, vector\u003cnode\u003e \u003e custom; for (int i=1; i\u003cn; i++) { if (data[i].name==data[i-1].name\u0026\u0026data[i-1].status==1\u0026\u0026data[i].status==0) { custom[data[i-1].name].push_back(data[i-1]); custom[data[i].name].push_back(data[i]); } } for (auto it : custom) { vector\u003cnode\u003e temp=it.second; cout\u003c\u003cit.first; printf(\" %02d\\n\", temp[0].month); double total=0.0; for (int i=1; i\u003ctemp.size(); i+=2) { double t=billFromZero(temp[i], rate) -billFromZero(temp[i-1],rate); printf(\"%02d:%02d:%02d %02d:%02d:%02d %d $%.2f\\n\", temp[i-1].day,temp[i-1].hour, temp[i-1].minute, temp[i].day, temp[i].hour,temp[i].minute, temp[i].time-temp[i-1].time, t); total+=t; } printf(\"Total amount: $%.2f\\n\", total); } return 0; } 1017-Queueing at Bank 又是这种银行窗口排队题 一开始想像之前一样用队列,发现只要找到队列中最早结束的队列就可,因为顾客可以随意挑选队列,所以只需要记录endtime即可 对于这种时间的,依旧是需要转为秒数进行判断,格式化时间比较是别想了 并且需要注意的情况是,顾客可能需要等待队列,或者队列等待顾客两种情况 题目只要求计算等待时间,所以只需要在特定的情况下进行 result += time 计算 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; struct node { int come, time; } tempcustomer; bool cmp1(node a, node b) { return a.come\u003cb.come; } int main() { int n, k; scanf(\"%d%d\", \u0026n, \u0026k); vector\u003cnode\u003e custom; for(int i=0; i\u003cn; i++) { int hh, mm, ss, time; scanf(\"%d:%d:%d %d\", \u0026hh, \u0026mm, \u0026ss, \u0026time); int cometime = hh*3600+mm*60+ss; if(cometime\u003e61200) continue; tempcustomer = {cometime, time*60}; custom.push_back(tempcustomer); } sort(custom.begin(), custom.end(), cmp1); vector\u003cint\u003e window(k, 28800); double result=0.0; for(int i=0; i\u003ccustom.size(); i++) { int tempindex=0, minfinish=window[0]; for(int j=1; j\u003ck; j++) { if(minfinish \u003e window[j]) { minfinish = window[j]; tempindex = j; } } if(window[tempindex] \u003c= custom[i].come) { window[tempindex] = custom[i].come+custom[i].time; } else { result += (window[tempindex] -custom[i].come); window[tempindex] += custom[i].time; } } if(custom.size() ==0) printf(\"0.0\"); else printf(\"%.1f\", result/60.0/custom.size()); return 0; } 1018-Public Bike Management dijkstra模板 计算一级条件 加上 dfs 计算二级条件 并且 dijkstra中建立 pre链接数组 在 dfs 中为寻找递归提供方向 但是这个代码量…给我要看哭了,难道甲级不光拼的是算法能力,还拼谁敲的快嘛 这道题的 dfs 用的真是精妙!甚至让我体会到了dfs所蕴含的无限魔力 总之是一道很好的经典题 经典 dfs 对于路径记录以及路径最值的比较 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eusing namespace std; const int inf=99999999; int cmax, n, sp, m; int minNeed=inf, minBack=inf; int e[510][510], dis[510], weight[510]; bool visit[510]; vector\u003cint\u003e pre[510]; vector\u003cint\u003e path, temppath; /* DFS NB! */ void dfs(int v) { temppath.push_back(v); //首先进入 if(v==0) { //递归边界 int need=0, back=0; for(int i=temppath.size() -1; i\u003e=0; i--) { int id=temppath[i]; if(weight[id] \u003e0) { back+=weight[id]; } else { if(back \u003e (0-weight[id])) { back+=weight[id]; } else { need += ((0-weight[id]) -back); back=0; } } } if(need \u003c minNeed) { minNeed=need; minBack=back; path=temppath; //赋值新的path } else if(need==minNeed \u0026\u0026 back\u003cminBack) { minBack=back; path=temppath; //赋值新的path } temppath.pop_back(); //当前临时路径数组退回上级(初始状态) return; } for(int i=0; i\u003cpre[v].size(); i++) //快乐递归 dfs(pre[v][i]); temppa","date":"2020-08-13","objectID":"/posts/pat-33/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 16-20","uri":"/posts/pat-33/"},{"categories":["PAT"],"content":"1011-1015 甲级题刷的有点不太顺手,慢慢来8 1011-World Cup Betting 一道相对简单的排序题,里边对于字符的输出很巧妙 #include \u003ccstdio\u003eusing namespace std; int main() { char c[4] = {\"WTL\"}; double ans=1.0; for(int i=0; i\u003c3; i++) { double maxvalue=0.0; int maxchar=0; for(int j=0; j\u003c3; j++) { double temp; scanf(\"%lf\", \u0026temp); if(maxvalue\u003c=temp) { maxvalue=temp; maxchar=j; } } ans*=maxvalue; printf(\"%c \", c[maxchar]); } printf(\"%.2f\", (ans*0.65-1) *2); return 0; } 1012-The Best Rank 一道复杂的排序题,用到了 结构体实例中排序标志 的运用 对不同的实例类别的确定 #include \u003ccstdio\u003e#include \u003calgorithm\u003eusing namespace std; struct node { int id, best; int score[4], rank[4]; }stu[2005]; int exist[1000000], flag=-1; bool cmp1(node a, node b) { return a.score[flag] \u003eb.score[flag]; } int main() { int n, m, id; scanf(\"%d %d\", \u0026n, \u0026m); for(int i=0; i\u003cn; i++) { scanf(\"%d %d %d %d\", \u0026stu[i].id, \u0026stu[i].score[1], \u0026stu[i].score[2],\u0026stu[i].score[3]); stu[i].score[0] = (stu[i].score[1] +stu[i].score[2] +stu[i].score[3])/3.0+0.5; } for(flag=0; flag\u003c=3; flag++) { sort(stu, stu+n, cmp1); stu[0].rank[flag] =1; for(int i=1; i\u003cn; i++) { stu[i].rank[flag] =i+1; if(stu[i].score[flag] ==stu[i-1].score[flag]) stu[i].rank[flag] =stu[i-1].rank[flag]; } } for(int i=0; i\u003cn; i++) { exist[stu[i].id] =i+1; stu[i].best=0; int minn=stu[i].rank[0]; for(int j=1; j\u003c=3; j++) { if(stu[i].rank[j] \u003cminn) { minn=stu[i].rank[j]; stu[i].best=j; } } } char c[5] = {'A', 'C', 'M', 'E'}; for(int i=0; i\u003cm; i++) { scanf(\"%d\", \u0026id); int temp=exist[id]; if(temp) { int best=stu[temp-1].best; printf(\"%d %c\\n\", stu[temp-1].rank[best], c[best]); } else { printf(\"N/A\\n\"); } } return 0; } 1013-Battle Over Cities 考察连通图的确定,深度遍历,经典例题 #include\u003ciostream\u003e#include\u003calgorithm\u003e using namespace std; int v[1010][1010]; bool visit[1010]; int n; void dfs(int node){ visit[node] = true; for(int i=1; i\u003c=n; i++){ if(visit[i] == false \u0026\u0026 v[node][i] == 1){ dfs(i); } } } int main(int argc, char const *argv[]) { int m, k, a, b; scanf(\"%d%d%d\",\u0026n ,\u0026m ,\u0026k); for(int i=0; i\u003cm; i++){ scanf(\"%d%d\", \u0026a, \u0026b); v[a][b] = v[b][a] = 1; } for(int i=0; i\u003ck; i++){ fill(visit, visit+1010, false); scanf(\"%d\", \u0026a); int cnt = 0; visit[a] = true; for(int j=1; j\u003c=n; j++){ if(visit[j] == false){ dfs(j); cnt++; } } printf(\"%d\\n\", cnt-1); } return 0; } 1014-Waiting in Line 考察队列应用,以及数据边界的判断 #include\u003ciostream\u003e#include\u003cqueue\u003e#include\u003cvector\u003e using namespace std; struct node{ int poptime, endtime; queue\u003cint\u003e q; }; int main(int argc, char const *argv[]) { int n, m, k, q, index = 1; //n: 窗口的数量 m:队列的最大容量 k:顾客总数 q:需要查询的顾客数 scanf(\"%d%d%d%d\", \u0026n, \u0026m, \u0026k, \u0026q); vector\u003cint\u003e time(k+1), result(k+1); for(int i=1; i\u003c=k; i++){ scanf(\"%d\", \u0026time[i]); } vector\u003cnode\u003e window(n+1); vector\u003cbool\u003e sorry(k+1, false); for(int i=1; i\u003c=m; i++){ for(int j=1; j\u003c=n; j++){ if(index \u003c= k){ window[j].q.push(time[index]); if(window[j].endtime \u003e= 540){ sorry[index] = true; } window[j].endtime += time[index]; if(i == 1){ window[j].poptime = window[j].endtime; } result[index] = window[j].endtime; index++; } } } while(index \u003c= k){ int tmpmin = window[1].poptime, tmpwindow = 1; for(int i=2; i\u003c=n; i++){ if(window[i].poptime \u003c tmpmin){ tmpmin = window[i].poptime; tmpwindow = i; } } window[tmpwindow].q.pop(); window[tmpwindow].q.push(time[index]); window[tmpwindow].poptime += window[tmpwindow].q.front(); if(window[tmpwindow].endtime \u003e= 540){ sorry[index] = true; } window[tmpwindow].endtime += time[index]; result[index] = window[tmpwindow].endtime; index++; } for(int i=1; i\u003c=q; i++){ int query, minute; scanf(\"%d\", \u0026query); minute = result[query]; if(sorry[query] == true){ printf(\"Sorry\\n\"); } else{ printf(\"%02d:%02d\\n\", (minute+480)/60, (minute+480)%60); } } return 0; } 1015-Reversible Primes 考察素数判断,以及进制转换 题解中利用 do-while 来记录转换进制得到的数 运用的十分好,申请数组空间,确定数组长度,之后转为十进制,以后可以直接拿来用 #include \u003ccstdio\u003e#include \u003ccmath\u003eusing namespace std; bool isprime(int n) { if(n\u003c=1) return false; int sqr=int(sqrt(n*1.0)); for(int i=2; i\u003c=sqr; i++) { if(n%i==0) return false; } return true; } int main() { int n, d, arr[100]; while(scanf(\"%d\", \u0026n) !=EOF) { if(n\u003c0) break; scanf(\"%d\", \u0026d); if(is","date":"2020-08-11","objectID":"/posts/pat-32/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 11-15","uri":"/posts/pat-32/"},{"categories":["PAT"],"content":"算法笔记 - BFS-DFS DFS ","date":"2020-08-10","objectID":"/posts/pat-31/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 图的遍历","uri":"/posts/pat-31/"},{"categories":["PAT"],"content":"邻接矩阵 const int maxv = 1000; const int inf = 1000000000; int n, G[maxv][maxv]; bool vis[maxv] = false; void dfs(int u, int depth){ vis[u] = true; for(int v=0; v\u003cn; v++){ if(vis[v] == false \u0026\u0026 G[u][v] != inf){ dfs(v, depth+1); } } } void dfstrave(){ for(int u=0; u\u003cn; u++){ if(vis[u] == false){ dfs(u, 1); } } } ","date":"2020-08-10","objectID":"/posts/pat-31/:1:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 图的遍历","uri":"/posts/pat-31/"},{"categories":["PAT"],"content":"邻接表 vector\u003cint\u003e adj[maxv]; int n; bool dfs(int u, int depth){ vis[u] = true; for(int i=0; i\u003cadj[u].size(); i++){ int v = adj[u][i]; if(vis[v] == false){ dfs(v, depth+1); } } } void dfstrave(){ for(int u = 0; u \u003c n; u++){ if(vis[u] == false){ dfs(u, 1); } } } BFS ","date":"2020-08-10","objectID":"/posts/pat-31/:2:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 图的遍历","uri":"/posts/pat-31/"},{"categories":["PAT"],"content":"邻接矩阵 int n, G[maxv][maxv]; bool inq[maxv] = {false}; void bfs(int u){ queue\u003cint\u003e q; q.push(u); inq[u] = true; while(!q.empty()){ int u = q.front(); q.pop(); for(int v=0; v\u003cn; v++){ if(inq[v] == false \u0026\u0026 G[u][v] != inf){ q.push(v); inq[v] = true; } } } } void bfstrave(){ for(int u=0; u\u003cn; u++){ if(inq[u] == false){ bfs(q); } } } ","date":"2020-08-10","objectID":"/posts/pat-31/:3:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 图的遍历","uri":"/posts/pat-31/"},{"categories":["PAT"],"content":"邻接表 vector\u003cint\u003e adj[maxv]; int n; bool inq[maxv] = {false}; void bfs(int u){ queue\u003cint\u003e q; q.push(u); inq[u] = true; while(!q.empty()){ int u = q.front(); q.pop(); for(int i=0; i\u003cadj[u].size(); i++){ int v = adj[u][i]; if(inq[v] == false){ q.push(v); inq[v] = true; } } } } void bfstrave(){ for(int u=0; u\u003cn; u++){ if(inq[u] == false){ bfs(q); } } } ","date":"2020-08-10","objectID":"/posts/pat-31/:4:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 图的遍历","uri":"/posts/pat-31/"},{"categories":["PAT"],"content":"算法笔记 - Heap ","date":"2020-08-10","objectID":"/posts/pat-30/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 堆","uri":"/posts/pat-30/"},{"categories":["PAT"],"content":"堆的自上而下的调整 void downadjust(int low, int high){ int i = low, j = i*2; //和两个子节点比较 while(j \u003c= high){ if(j+1 \u003c= high \u0026\u0026 heap[j+1] \u003e heap[j]){ j = j+1; //挑选最大的子节点 } if(heap[j] \u003e heap[i]){ wap(heap[j], heap[i]); i = j; j = i*2; //交换,并递推处理交换的结点 } else{ break; } } } ","date":"2020-08-10","objectID":"/posts/pat-30/:1:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 堆","uri":"/posts/pat-30/"},{"categories":["PAT"],"content":"建堆 void createheap(){ for(int i=n/2; i \u003e= 1; i--){ downadjust(i, n); } } ","date":"2020-08-10","objectID":"/posts/pat-30/:2:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 堆","uri":"/posts/pat-30/"},{"categories":["PAT"],"content":"删除堆顶元素 void deletetop(){ heap[1] = heap[n--]; downadjust(1, n); } ","date":"2020-08-10","objectID":"/posts/pat-30/:3:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 堆","uri":"/posts/pat-30/"},{"categories":["PAT"],"content":"向上调整 void upadjust(int low, int high){ int i = high, j = i/2; //和父节点比较 while(j \u003e= low){ if(heap[j] \u003c heap[i]){ swap(heap[j], heap[i]); i = j; j = i/2; //递推交换后的父节点 } else{ break; } } } ","date":"2020-08-10","objectID":"/posts/pat-30/:4:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 堆","uri":"/posts/pat-30/"},{"categories":["PAT"],"content":"添加元素 void insert(int x){ heap[n++]; upadjust(1, n); } ","date":"2020-08-10","objectID":"/posts/pat-30/:5:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 堆","uri":"/posts/pat-30/"},{"categories":["PAT"],"content":"算法笔记 - 并查集 所谓并查集,就是判断两个元素是否在同一集合中,在kruskal中有所应用,实现起来还蛮简单的 本质上利用数组 初始化 for(int i=1; i\u003c=N; i++){ father[i] = i; } 查找 ","date":"2020-08-09","objectID":"/posts/pat-29/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 并查集","uri":"/posts/pat-29/"},{"categories":["PAT"],"content":"递推 int findfather(int x){ while( != father[x]){ x = father[x]; } return x; } ","date":"2020-08-09","objectID":"/posts/pat-29/:1:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 并查集","uri":"/posts/pat-29/"},{"categories":["PAT"],"content":"递归 int findfather(int x){ if(x == father[x]){ return x; } else return findfather(father[x]); } 合并 void union(int a, int b){ int faa = findfather(a); //寻找父节点 int fab = findfather(b); if(faa != fab){ father[faa] = fab; //链接父节点 } } 路径压缩 ","date":"2020-08-09","objectID":"/posts/pat-29/:2:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 并查集","uri":"/posts/pat-29/"},{"categories":["PAT"],"content":"递推 int findfather(int x){ int a = x; while(x != father[x]){ x = father[x]; } while(a != father[a]){ int z = a; a = father[a]; father[z] = x; } return x; } ","date":"2020-08-09","objectID":"/posts/pat-29/:3:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 并查集","uri":"/posts/pat-29/"},{"categories":["PAT"],"content":"递归 int findfather(int v){ if(v == father[v]){ return v; //找到根节点 } else{ int f = findfather(father[v]); father[v] = f; //赋值 return f; //返回根节点 } } ","date":"2020-08-09","objectID":"/posts/pat-29/:4:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 并查集","uri":"/posts/pat-29/"},{"categories":["PAT"],"content":"算法笔记 - 树专题 遍历 最基础的知识点,还是敲一遍把 ","date":"2020-08-09","objectID":"/posts/pat-28/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"先序遍历 void preorder(node* root){ if(root == NULL){ return; } printf(\"%d\\n\", root-\u003edata); preorder(root-\u003elchild); preorder(root-\u003erchild); } ","date":"2020-08-09","objectID":"/posts/pat-28/:1:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"中序遍历 void inorder(node* root){ if(root == NULL){ return; } inorder(root-\u003elchild); printf(\"%d\\n\", root-\u003edata); inorder(root-\u003erchild); } ","date":"2020-08-09","objectID":"/posts/pat-28/:2:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"后序遍历 void inorder(node* root){ if(root == NULL){ return; } inorder(root-\u003elchild); inorder(root-\u003erchild); printf(\"%d\\n\", root-\u003edata); } ","date":"2020-08-09","objectID":"/posts/pat-28/:3:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"层序遍历 void layerorder(node* root){ queue\u003cnode*\u003e q; q.push(root); while(!q.empty()){ node* mow = q.front(); q.pop(); printf(\"%d\", now-\u003edata); if(now-\u003elchild != NULL){ q.push(now-\u003elchild); } if(now-\u003erchild != NULL){ q.push(now-\u003erchild); } } } ","date":"2020-08-09","objectID":"/posts/pat-28/:4:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"层序遍历记录层数 struct node{ int data; int layer; node* lchild; node* rchild; } void layerorder(node* root){ queue\u003cnode*\u003e q; root-\u003elayer = 1; q.push(root); while(!q.empty()){ node *now = q.front(); q.pop(); printf(\"%d\", now-\u003edata); if(now-\u003elchild != NULL){ now-\u003elchild-\u003elayer++; q.push(now-\u003elchild); } if(now-\u003erchild != NULL){ now-\u003erchild-\u003elayer++; q.push(now-\u003erchild); } } } ","date":"2020-08-09","objectID":"/posts/pat-28/:5:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"先序序列和中序序列 构建二叉树 node* create(int prel, int prer, int inl, int inr){ if(prel \u003e prer){ return NULL; } node* root = new node; root-\u003edata = pre[prel]; int k; for(k=inl; k\u003c= inr; k++){ if(in[k] == pre[prel]){ //在中序序列中,找到前序遍历中的根节点 break; } } int numleft = k-inl; root-\u003elchild = create(prel+1, prel+numleft, inl, k-1); root-\u003erchild = create(prel+numleft+1, prer, k+1, inr); return root; } ","date":"2020-08-09","objectID":"/posts/pat-28/:6:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"二叉查找树 ","date":"2020-08-09","objectID":"/posts/pat-28/:7:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"查找 void search(node* root, int x){ if(root == NULL){ printf(\"search failed\\n\"); return; } if(x == root-\u003edata){ printf(\"%d\\n\", root-\u003edata); } else if(x \u003c root-\u003edata){ search(root-\u003elchild, x); } else{ search(root-\u003erchild, x); } } ","date":"2020-08-09","objectID":"/posts/pat-28/:7:1","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"插入 void insert(node* \u0026root, int x){ if(root == NULL){ root = newNode(x); return; } if(x == rot-\u003edata){ return; } else if(x \u003c root-\u003edata){ insert(root-\u003elchild, x); } else{ insert(root-\u003erchild, x); } } ","date":"2020-08-09","objectID":"/posts/pat-28/:7:2","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"建立 node* create(int data[], int n){ node* root = NULL; for(int i=0; i\u003cn; i++){ insert(root, data[i]); } return root; } ","date":"2020-08-09","objectID":"/posts/pat-28/:7:3","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"查找最大值 node* findmax(node* root){ while(root-\u003erchild != NULL){ root = root-\u003erchild; } return root; } ","date":"2020-08-09","objectID":"/posts/pat-28/:7:4","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"删除结点 如果当前节点root不存在左右结点,说明是叶子结点,直接删除 如果当前root存在左孩子,那么在左子树中寻找结点前驱pre(最右结点),然后让pre的数据覆盖root 如果当前root存在右子树,那么在右子树中寻找结点后继next(最左结点),然后让next的数据覆盖root void delete(node* \u0026root, int x){ if(root == NULL){ return; } if(root -\u003e data == x){ if(root-\u003elchild == NULL \u0026\u0026 root-\u003erchild == NULL){ root = NULL; } else if(root-\u003elchild != NULL){ node* pre = findmax(root-\u003elchild); root-\u003edata = pre-\u003edata; deletenode(root-\u003elchild, pre-\u003edata); } else{ node* next = findmax(root-\u003erchild); root-\u003edata = next-\u003edata; deletenode(root-\u003elchild, next-\u003edata); } } else if(root-\u003edata \u003e x){ deletenode(root-\u003elchild, x); } else{ deletenode(root-\u003erchild, x); } } 平衡二叉树 struct node{ int v, height; node *lchild, *rchild; }; struct* newnode(int v){ node* node = new node; node-\u003ev = v; node-\u003eheight = 1; node-\u003elchild = node-\u003erchild = NULL; return node; } //获取当前高度 int getheight(node* root){ if(root == NULL){ return 0; } return root-\u003eheight; } //计算平衡因子 int getbalancefactor(node* root){ return getheight(root-\u003elchild)-getheight(root-\u003erchild); } //更新root的height void updateheight(node* root){ root-\u003eheight = max(getheight(root-\u003elchild), getheight(root-\u003erchild))+1; } //查找 void search(node* root, int x){ if(root == NULL){ printf(\"search failed\\n\"); return; } if(x == root-\u003edata){ printf(\"%d\\n\", root-\u003edata); } else if(x \u003c root-\u003edata){ search(root-\u003elchild, x); } else{ search(root-\u003erchild, x); } } 平衡二叉树插入 ","date":"2020-08-09","objectID":"/posts/pat-28/:7:5","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"左旋 void l(node* \u0026root){ node* tmp = root-\u003erchild; root-\u003erchild = tmp-\u003elchild; tmp-\u003elchild = root; updateheight(root); updateheight(tmp); root = tmp; } ","date":"2020-08-09","objectID":"/posts/pat-28/:8:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"右旋 void r(node* \u0026root){ node* tmp = root-\u003elchild; root-\u003elchild = tmp-\u003erchild; tmp-\u003erchild = root; updateheight(root); updateheight(tmp); root-\u003etmp; } ","date":"2020-08-09","objectID":"/posts/pat-28/:9:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["PAT"],"content":"插入操作 void insert(node* \u0026root, int v){ if(root == NULL){ root = newnode(v); return; } if(v \u003c root-\u003ev){ insert(root-\u003elchild, v); updateheight(root); if(getbalancefactor(root-\u003elchild) == 1){ r(root); //LL旋转 } else if(getbalancefactor(root-\u003elchild) == -1){ l(root-\u003elchild); r(root); //LR旋转 } } else{ insert(root-\u003erchild, v); updateheight(root); if(getbalancefactor(root) == -2){ if(getbalancefactor(root-\u003erchild) == -1){ l(root); //RR旋转 } else if(getbalancefactor(root-\u003erchild) == 1){ r(root-\u003erchild); l(root); //RL旋转 } } } } ","date":"2020-08-09","objectID":"/posts/pat-28/:10:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 树专题","uri":"/posts/pat-28/"},{"categories":["C++"],"content":"这几天每日六个多小时的数学课让我晕晕,码点代码来放松下心情吧 C malloc() 返回类型: 申请的同变量类型的指针 typename* p = (typename*)malloc(sizeof(typename)) 在使用malloc函数时,会向内存申请一块大小sizeof(node)的空间,并且返回指向这块空间的指针,但此时这个指针是一个未确定类型的指针 void* ,因此需要把他强制转换成为 node* 类型的指针,因此在malloc前面加上(node*),如果申请失败,会返回一个空指针NULL free()对应于malloc()释放内存,参数为需要释放内存空间的指针变量 C++ new() new是c++中用来申请动态空间的运算符.其返回类型同样是申请的同变量类型的指针 typename* p = new typename delete()对应于new()参数也是对应空间的指针 ","date":"2020-08-09","objectID":"/posts/CPP-7/:0:0","tags":["C++基础语法"],"title":"C++ 申请空间","uri":"/posts/CPP-7/"},{"categories":["PAT"],"content":"1005-1010 1005-Spell It Right 相对比较简单,不过要注意测试用例的数据大小 #include\u003ccstdio\u003e#include\u003ciostream\u003e#include\u003cstring\u003eusing namespace std; int main(int argc, char const *argv[]) { int shit, sum = 0, tmp; string shit2; cin \u003e\u003e shit2; /* 不能这样用,因为给的测试数据太大了 while(shit != 0){ tmp = shit%10; sum += tmp; shit = shit/10; } */ for(int i=0; i\u003cshit2.length(); i++){ sum += shit2[i]-'0'; } string tb[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}; string ans = to_string(sum); cout \u003c\u003c tb[ans[0]-'0']; for(int i=1; i\u003cans.length(); i++){ cout \u003c\u003c \" \" \u003c\u003c tb[ans[i]-'0']; } return 0; } 1006-Sign In and Sign Out 快乐白给题 #include\u003ciostream\u003e#include\u003cstring\u003eusing namespace std; int main(int argc, char const *argv[]) { int num; cin \u003e\u003e num; string tmpid, f_id, l_id, s1, s2, tmp1, tmp2; cin \u003e\u003e tmpid \u003e\u003e s1 \u003e\u003e s2; f_id = tmpid; l_id = tmpid; for(int i=1; i\u003cnum; i++){ cin \u003e\u003e tmpid \u003e\u003e tmp1 \u003e\u003e tmp2; if(tmp1 \u003c s1){ s1 = tmp1; f_id = tmpid; } if(tmp2 \u003e s2){ s2 = tmp2; l_id = tmpid; } } cout \u003c\u003c f_id \u003c\u003c \" \" \u003c\u003c l_id; return 0; } 1007-Maximum Subsequence Sum 一个相对简单的动态规划(然而我刚开始并不会) #include\u003cvector\u003e#include\u003ciostream\u003eusing namespace std; int main(int argc, char const *argv[]) { int num; cin \u003e\u003e num; vector\u003cint\u003e data(num); for(int i=0; i\u003cnum; i++){ cin \u003e\u003e data[i]; } int tmp = 0, tmpindex = 0, left = 0, right = num-1, max = -1; for(int i=0; i\u003cnum; i++){ tmp += data[i]; if(tmp \u003c 0){ tmp = 0; tmpindex = i+1; } else{ if(tmp \u003e max){ left = tmpindex; right = i; max = tmp; } } } if(max \u003c 0){ max = 0; } cout \u003c\u003c max \u003c\u003c \" \" \u003c\u003c data[left] \u003c\u003c \" \" \u003c\u003c data[right]; return 0; } 1008-Elevator 这道题题解有一个点写的很是精妙 while(cin \u003e\u003e a) 原来这也可以判定输入边界! #include \u003ciostream\u003eusing namespace std; int main() { int a, now=0, sum=0; cin\u003e\u003ea; while(cin \u003e\u003e a) { if(a \u003e now) sum = sum+6* (a-now); else sum = sum+4* (now-a); now = a; sum += 5; } cout \u003c\u003c sum; return 0; } 1009-Product of Polynomials ","date":"2020-08-05","objectID":"/posts/pat-27/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 05-10","uri":"/posts/pat-27/"},{"categories":["PAT"],"content":"菜鸡的方法 这道题我写的有些麻烦,而且需要注意的是,当系数为0是是不会输出的,所以最后还要去除一下系数为0的项 ","date":"2020-08-05","objectID":"/posts/pat-27/:1:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 05-10","uri":"/posts/pat-27/"},{"categories":["PAT"],"content":"earse()函数的使用 在消除系数为0项的过程中,遇到了earse()函数,发现这个函数说道还挺多的 首先earse用迭代器的话,就会有些麻烦 迭代器方式 当使用erase以迭代器方式删除vector中的元素时，vector会自动将被删除元素后边的元素往上挪一位，所以此时指向删除元素的迭代器指向了被删除元素后面的元素，所以在循环中，此时迭代器就不应该 +1 for (itE = listE.begin(); itE != listE.end();){ if (currE-\u003estart == findV){ listE.erase(itE); } else{ itE++; } } 更好的写法 for (itE = listE.begin(); itE != listE.end();){ if (currE-\u003estart == findV){ itE=listE.erase(itE); } else{ itE++; } } 这段代码就是利用了erase的返回值，当我们用erase删除一个元素后，erase返回的是下一个元素的迭代器，将这个返回值赋给那个原来指向被删除元素的迭代器，所以这个迭代器就指向了下一个元素,保证迭代器的指向安全 利用begin + i的方式 删除data容器中第i个元素(推荐写法) data.erase(data.begin() + i) ","date":"2020-08-05","objectID":"/posts/pat-27/:1:1","tags":["Leetcode-C++"],"title":"PAT-Advanced 05-10","uri":"/posts/pat-27/"},{"categories":["PAT"],"content":"CODE #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003cset\u003e#include\u003calgorithm\u003eusing namespace std; int main(int argc, char const *argv[]) { int num1, num2; int tmp1; double tmp2; vector\u003cdouble\u003e res(2000,0); vector\u003cdouble\u003e data1(1000,0); vector\u003cdouble\u003e data2(1000,0); set\u003cint\u003e s1; set\u003cint\u003e s2; cin \u003e\u003e num1; for(int j=0; j\u003cnum1; j++){ cin \u003e\u003e tmp1 \u003e\u003e tmp2; s1.insert(tmp1); data1[tmp1] += tmp2; } cin \u003e\u003e num2; for(int j=0; j\u003cnum2; j++){ cin \u003e\u003e tmp1 \u003e\u003e tmp2; s2.insert(tmp1); data2[tmp1] += tmp2; } vector\u003cint\u003e res2; set\u003cint\u003e nr; int sum; double sum2; for(auto i=s1.begin(); i!=s1.end(); i++){ for(auto j=s2.begin(); j!=s2.end(); j++){ sum = *i+*j; sum2 = data1[*i] * data2[*j]; if(nr.find(sum) == nr.end()){ nr.insert(sum); res2.push_back(sum); } res[sum] += sum2; } } sort(res2.begin(), res2.end(), greater\u003cint\u003e()); for(int w = 0; w \u003c res2.size(); w++){ if(int(res[res2[w]]) == 0){ res2.erase(res2.begin()+w); } } cout \u003c\u003c res2.size(); for(int k=0; k\u003cres2.size(); k++){ printf(\" %d %.1f\", res2[k], res[res2[k]]); } return 0; } ","date":"2020-08-05","objectID":"/posts/pat-27/:2:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 05-10","uri":"/posts/pat-27/"},{"categories":["PAT"],"content":"柳神的代码 这个代码就清晰了很多,首先他只保存了第一个数据集,而在输入第二个数据集时,直接进行了计算,并且,对于系数为0的判断,进行了单独计数和最后输出的判断 #include \u003ciostream\u003eusing namespace std; int main() { int n1, n2, a, cnt=0; scanf(\"%d\", \u0026n1); double b, arr[1001] = {0.0}, ans[2001] = {0.0}; for(int i=0; i\u003cn1; i++) { scanf(\"%d %lf\", \u0026a, \u0026b); arr[a] =b; } scanf(\"%d\", \u0026n2); for(int i=0; i\u003cn2; i++) { scanf(\"%d %lf\", \u0026a, \u0026b); for(int j=0; j\u003c1001; j++) ans[j+a] +=arr[j] *b; } for(int i=2000; i\u003e=0; i--) if(ans[i] !=0.0) cnt++; printf(\"%d\", cnt); for(int i=2000; i\u003e=0; i--) if(ans[i] !=0.0) printf(\" %d %.1f\", i, ans[i]); return 0; } 1010-Radix 这道题没想到用的是二分法,让我很是惊讶 并且题解中包含了三个新的知识点 ","date":"2020-08-05","objectID":"/posts/pat-27/:3:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 05-10","uri":"/posts/pat-27/"},{"categories":["PAT"],"content":"rbegin(),rend() c.begin() 返回一个迭代器，它指向容器c的第一个元素 c.end() 返回一个迭代器，它指向容器c的最后一个元素的下一个位置 c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素 c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置 反向迭代器是一种反向遍历容器的迭代器。也就是从最后一个元素到第一个元素遍历容器。反向迭代器将自增（和自减）的含义反过来了： 对于反向迭代器 ++ 运算将访问前一个元素，而 – 运算则访问下一个元素 ","date":"2020-08-05","objectID":"/posts/pat-27/:4:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 05-10","uri":"/posts/pat-27/"},{"categories":["PAT"],"content":"pow(int, int) double pow(double x, double y) 返回 x 的 y 次幂，即 xy ","date":"2020-08-05","objectID":"/posts/pat-27/:5:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 05-10","uri":"/posts/pat-27/"},{"categories":["PAT"],"content":"max_element(first, last, comp); first: 容器比较起始位置 last: 容器比较结束位置 comp: 比较函数(可选) ","date":"2020-08-05","objectID":"/posts/pat-27/:6:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 05-10","uri":"/posts/pat-27/"},{"categories":["PAT"],"content":"CODE #include \u003ciostream\u003e#include \u003ccctype\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003eusing namespace std; long long convert(string n, long long radix) { long long sum = 0; int index = 0, temp = 0; for (auto it=n.rbegin(); it!=n.rend(); it++) { //反向迭代器 temp = isdigit(*it) ? *it-'0' : *it-'a'+10; sum += temp * pow(radix, index++); //pow函数,指数运算 } return sum; } long long find_radix(string n, long long num) { char it = *max_element(n.begin(), n.end()); //max_element : 返回容器中最大值的第一个位置 long long low= (isdigit(it) ?it-'0': it-'a'+10) +1; //二分法确定边界 long long high=max(num, low); while (low\u003c=high) { long long mid= (low+high) /2; long long t = convert(n, mid); //转换为 mid 进制 if (t\u003c0||t\u003enum){ //判断是否满足条件 high=mid-1; //前半部分二分 } else if(t==num){ return mid; } else { low=mid+1; //后半部分二分 } } return -1; } int main() { string n1, n2; long long tag=0, radix=0, result_radix; cin \u003e\u003e n1 \u003e\u003e n2 \u003e\u003e tag \u003e\u003e radix; result_radix = tag==1 ?find_radix(n2, convert(n1, radix)) :find_radix(n1, convert(n2, radix)); if (result_radix!=-1) { printf(\"%lld\", result_radix); } else { printf(\"Impossible\"); } return 0; } ","date":"2020-08-05","objectID":"/posts/pat-27/:7:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 05-10","uri":"/posts/pat-27/"},{"categories":["PAT"],"content":"树 DFS遍历 + 深度记录 1004-Counting Leaves #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; vector\u003cint\u003ev[100]; int book[100], maxdepth = -1; //记录层数对应的叶子节点数目数组 和 树的最大深度 void dfs(int index, int depth) { if(v[index].size() ==0) { //当前为叶子节点 book[depth]++; //当前层数叶子节点 +1 maxdepth = max(maxdepth, depth); //更新最大层数 return; //递归边界 } for(int i=0; i\u003cv[index].size(); i++) //递归当前节点对应的所有子节点 dfs(v[index][i], depth+1); } int main() { int n, m, k, node, c; scanf(\"%d %d\", \u0026n, \u0026m); for(int i=0; i\u003cm; i++) { scanf(\"%d %d\",\u0026node, \u0026k); for(int j=0; j\u003ck; j++) { scanf(\"%d\", \u0026c); v[node].push_back(c); //构建当前树 } } dfs(1, 0); printf(\"%d\", book[0]); //分开,符合格式化打印要求 for(int i=1; i\u003c=maxdepth; i++) printf(\" %d\", book[i]); return 0; } ","date":"2020-08-04","objectID":"/posts/pat-26/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 1004","uri":"/posts/pat-26/"},{"categories":["PAT"],"content":"Dijkstra + 二级判定 1003-Emergency dijkstra算法…需要我慢慢理解一下了 对于这道题,首先需要想到的是图的矩阵 之后对于二级判定,要写好判定 #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int n, m, c1, c2; int e[510][510], weight[510], dis[510], num[510], w[510]; bool visit[510]; const int inf = 99999999; //初始化最大值 int main() { scanf(\"%d%d%d%d\", \u0026n, \u0026m, \u0026c1, \u0026c2); for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026weight[i]); fill(e[0], e[0] + 510 * 510, inf); //初始化 矩阵 为空值 fill(dis, dis + 510, inf); //初始化 距离数组 为空值 int a, b, c; for(int i = 0; i \u003c m; i++) { scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026c); //读入边值 e[a][b] = e[b][a] = c; } /* 初始化 开始条件 begin*/ dis[c1] = 0; w[c1] = weight[c1]; num[c1] = 1; /* 初始化 开始条件 end*/ for(int i = 0; i \u003c n; i++) { /* 找到最小值边 begin*/ int u = -1, minn = inf; for(int j = 0; j \u003c n; j++) { if(visit[j] == false \u0026\u0026 dis[j] \u003c minn) { u = j; minn = dis[j]; } } /* 找到最小值边 end*/ if(u == -1) break; //没有最小边- 结束当前 visit[u] = true; //标记访问 /* 核心代码 begin*/ for(int v = 0; v \u003c n; v++) { if(visit[v] == false \u0026\u0026 e[u][v] != inf) { //从当前边出发,判断是否有更近路径 if(dis[u] + e[u][v] \u003c dis[v]) { dis[v] = dis[u] + e[u][v]; //更新距离 num[v] = num[u]; //更新路径数目 w[v] = w[u] + weight[v]; //更新权重和 } else if(dis[u] + e[u][v] == dis[v]) { num[v] = num[v] + num[u]; //更新路径数目 if(w[u] + weight[v] \u003e w[v]) w[v] = w[u] + weight[v]; //更新权重和 } } } /* 核心代码 end*/ } printf(\"%d %d\", num[c2], w[c2]); return 0; } ","date":"2020-08-04","objectID":"/posts/pat-25/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 1003","uri":"/posts/pat-25/"},{"categories":["Ubuntu"],"content":"首先查看开机时,在GRUB中,windows处在第几项,如果当前windows在第四项,则此时需要改为3,因为GRUB从第0项开始计数 $ sudo gedit /etc/default/grub 找到set_default 改为 3 保存,重启电脑,即可发现 默认光标移至第四项 ","date":"2020-08-04","objectID":"/posts/ubuntu-29/:0:0","tags":["双系统"],"title":"GRUB2 引导顺序","uri":"/posts/ubuntu-29/"},{"categories":["win"],"content":"众所周知,win10的UI一直都很一言难尽,这次的WSL-Terminal也是看的我难受,后来才发现原来微软做了一个能改主题色的工具 项目地址 下载地址 用CMD到工具目录下执行命令(powershell不可以) colortool.exe -b [theme] 常用主题 deuteranopia OneHalfDark OneHalfLight solarized_dark solarized_light 最后右键cmd标题栏,选择默认值,保存设置 没有之前那么辣眼睛啦 ","date":"2020-08-04","objectID":"/posts/win-1/:0:0","tags":["Terminal"],"title":"Terminal更换主题","uri":"/posts/win-1/"},{"categories":["Ubuntu"],"content":"好久没有更新了…那么今天就来搞出个大招!—WSL! 喜欢Ubuntu是必然的,不臃肿,安装环境还轻松快乐,我超爱这里的 但是生态一直是Ubuntu的问题,虽然适合开发,但是日常使用的话,会很麻烦,虽然也会有替代的东西可以使用,但是一般配置起来成本会很高,而且很多情况下,易用性也远远达不到win环境下的使用效率…所以经常就是双系统下来回切换…开机关机 之前听过学长说过wsl,但当时由于刚接触Ubuntu,所以认为原生系统当然是最好的,但经历了一个月的痛苦挣扎,我又想到了学长的一番话,打算试一试 去网上看了一下风评,感觉大多都不错,那就开始吧! 这里默认安装的是 wsl-2 版本 官方教程 安装Ubuntu子系统 ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:0:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"启用wsl dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:1:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"开启虚拟机 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重启电脑 ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:2:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"下载安装子系统 windows store中安装Ubunut子系统 ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:3:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"安装wsl2内核 下载地址 ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:4:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"查看当前安装版本 wsl --list --verbose ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:5:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"升级至wsl2 wsl --set-version \u003cdistribution name\u003e \u003cversionNumber\u003e # \u003cdistribution name\u003e: Ubuntu-20.04 # \u003cversionNumber\u003e: 2 # 示例: wsl --set-version Ubuntu-20.04 2 至此,安装wsl2完成,经过巨硬的集成,轻松又快乐 VSCODE配置 vscode安装romote wsl插件 记得先换linux源,否则库下载太慢了 ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:6:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"安装依赖库 sudo apt-get update sudo apt-get install wget ca-certificates ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:7:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"安装vscode服务器 code . 在vscode中,拓展插件需要额外重新安装在wsl环境中,这个需要注意一下 配置C++环境 官方教程 sudo apt-get update sudo apt-get install build-essential gdb # g++编译环境 ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:8:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"task.json { \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"shell\", \"label\": \"g++ build active file\", \"command\": \"/usr/bin/g++\", \"args\": [\"-g\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\"], \"options\": { \"cwd\": \"/usr/bin\" }, \"problemMatcher\": [\"$gcc\"], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:9:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"g++ build and debug active file\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"g++ build active file\", \"miDebuggerPath\": \"/usr/bin/gdb\" } ] } ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:10:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Ubuntu"],"content":"c_cpp_properties.json { \"configurations\": [ { \"name\": \"Linux\", \"includePath\": [\"${workspaceFolder}/**\"], //可设置外部库路径 \"defines\": [], \"compilerPath\": \"/usr/bin/gcc\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"clang-x64\" } ], \"version\": 4 } 最后wsl下的vscode也非常好用,让我属实有些被惊艳到了 buff加成: 效率*2 ","date":"2020-08-04","objectID":"/posts/ubuntu-28/:11:0","tags":["WSL"],"title":"WSL安装过程","uri":"/posts/ubuntu-28/"},{"categories":["Git"],"content":"填写git信息 git config --global user.name 你的英文名 #此英文名不需要跟GitHub账号保持一致 git config --global user.email 你的邮箱 #此邮箱不需要跟GitHub账号保持一致 ","date":"2020-08-03","objectID":"/posts/github-3/:1:0","tags":["Github"],"title":"Git创建SSH公钥","uri":"/posts/github-3/"},{"categories":["Git"],"content":"生成本机ssh ssh-keygen -t rsa -C \"自己的邮箱地址\" ","date":"2020-08-03","objectID":"/posts/github-3/:2:0","tags":["Github"],"title":"Git创建SSH公钥","uri":"/posts/github-3/"},{"categories":["Git"],"content":"查看ssh密钥 cat ~/.ssh/id_rsa.pub ","date":"2020-08-03","objectID":"/posts/github-3/:3:0","tags":["Github"],"title":"Git创建SSH公钥","uri":"/posts/github-3/"},{"categories":["PAT"],"content":"栈-计算中缀表达式 简单计算器 实现运算 30/90-26+97-5-6-13/88*6+51/29+79*87+57*92 需要两个步骤: 中缀表达式转后缀表达式 计算后缀表达式 #include\u003ciostream\u003e#include\u003ccstdio\u003e#include\u003cstring\u003e#include\u003cstack\u003e#include\u003cqueue\u003e#include\u003cmap\u003e using namespace std; struct node { double num; char op; bool flag; //true表示操作数,false表示操作符 }; string str; stack\u003cnode\u003e s; queue\u003cnode\u003e q; // 操作符栈 map\u003cchar, int\u003e op; //后缀表达式序列 void change(){ double num; node tmp; for(int i=0; i\u003cstr.length(); i++){ if(str[i] \u003e= '0' \u0026\u0026 str[i] \u003c= '9'){ tmp.flag = true; tmp.num = str[i++]-'0'; while (i \u003c str.length() \u0026\u0026 str[i] \u003e= '0' \u0026\u0026 str[i] \u003c= '9'){ tmp.num = tmp.num*10 + (str[i]-'0'); i++; } q.push(tmp); } else{ tmp.flag = false; while(!s.empty() \u0026\u0026 op[str[i]] \u003c= op[s.top().op]){ q.push(s.top()); s.pop(); } tmp.op = str[i]; s.push(tmp); i++; } } while(!s.empty()){ q.push(s.top()); s.pop(); } } double cal(){ double tmp1,tmp2; node cur, tmp; while(!q.empty()){ cur = q.front(); q.pop(); if(cur.flag == true){ s.push(cur); } else{ tmp2 = s.top().num; s.pop(); tmp1 = s.top().num; s.pop(); tmp.flag = true; if(cur.op == '+'){ tmp.num = tmp1+tmp2; } else if(cur.op == '-'){ tmp.num = tmp1-tmp2; } else if(cur.op == '*'){ tmp.num = tmp1*tmp2; } s.push(tmp); } } return s.top().num; } int main(){ op['+'] = op['-'] = 1; op['*'] = op['/'] = 2; while(getline(cin,str), str!=\"0\"){ for(auto it = str.end(); it!= str.begin(); it--){ if(*it == ' '){ str.erase(it); } } while(!s.empty()){ s.pop(); } change(); printf(\".2f\\n\", cal()); } return 0; } ","date":"2020-08-01","objectID":"/posts/pat-24/:0:0","tags":["Leetcode-C++"],"title":"栈和队列","uri":"/posts/pat-24/"},{"categories":["PAT"],"content":"这几天一直在思考怎么准备甲级,看了很多经验贴之后,决定首先把\"算法笔记\"这本书看完吧,因为刚刷到第三道题就是dijkstra(菜鸡惊讶),想了想还是先把这些基本算法实现学明白再说吧…这几天把树看完了,图还剩最短路径和最小生成树 所以今天开始恢复每日更新! 在更新这些算法实现前,先把之前欠下的第二道题补上(嘿嘿,又能水一帖了) 1002 A+B for Polynomials 常规题,数组+hash #include\u003ciostream\u003e#include\u003ccstdlib\u003e using namespace std; int main(int argc, char const *argv[]) { int cnt = 0; double data[1001] = {0}; int num1, num2; int tmp; double tmp2; cin \u003e\u003e num1; for(int i=0; i\u003cnum1; i++){ cin \u003e\u003e tmp \u003e\u003e tmp2; if(data[tmp] == 0){ cnt++; } data[tmp] += tmp2; } cin \u003e\u003e num2; for(int i=0; i\u003cnum2; i++){ cin \u003e\u003e tmp \u003e\u003e tmp2; if(data[tmp] == 0){ cnt++; } data[tmp] += tmp2; } cout \u003c\u003c cnt; for(int j=1000; j\u003e=0; j--){ if(data[j]!=0){ cout \u003c\u003c \" \" \u003c\u003c j \u003c\u003c \" \" \u003c\u003c data[j]; } } system(\"pause\"); return 0; } ","date":"2020-08-01","objectID":"/posts/pat-23/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 1002","uri":"/posts/pat-23/"},{"categories":["PAT"],"content":"甲级的第一道题! 终于不用为了线上考试继续在Win10环境写代码了,亲一口俺最爱的Ubuntu A+B Format 这道题我一开始担心越界,所以写了一个取每一位的函数,但后来看了柳神的题解…发现确实是自己想多了 #include\u003ccstdlib\u003e#include\u003ciostream\u003e#include\u003ccmath\u003e#include\u003cstack\u003e using namespace std; int main(int argc, char const *argv[]) { long long a, b, c; cin \u003e\u003e a \u003e\u003e b; c = a+b; if(c \u003c 0){ cout \u003c\u003c \"-\"; } if(c == 0){ cout \u003c\u003c \"0\"; return 0; } int carry; int cnt = 0; c = abs(c); stack\u003cchar\u003e data; while(c != 0){ carry = c%10; data.push(carry+'0'); cnt++; if(cnt%3 == 0){ data.push(','); } c = c/10; } if(data.top() == ','){ data.pop(); } int sizes = data.size(); for(int i=0; i\u003csizes; i++){ cout \u003c\u003c data.top(); data.pop(); } return 0; } ","date":"2020-07-27","objectID":"/posts/pat-22/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 1001","uri":"/posts/pat-22/"},{"categories":["PAT"],"content":"柳神代码 就很机制!直接 to_string() 然后用一个巧妙的取余对应值来判断逗号的位置 #include \u003ciostream\u003eusing namespace std; int main() { int a, b; cin \u003e\u003e a \u003e\u003e b; string s = to_string(a + b); int len = s.length(); for (int i = 0; i \u003c len; i++) { cout \u003c\u003c s[i]; if (s[i] == '-') continue; if ((i + 1) % 3 == len % 3 \u0026\u0026 i != len - 1) cout \u003c\u003c \",\"; } return 0; } ","date":"2020-07-27","objectID":"/posts/pat-22/:1:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 1001","uri":"/posts/pat-22/"},{"categories":["PAT"],"content":"由于甲级是英文题目…所以先需要背一些常见的单词,这里整理一下! 数据结构类型 Deduplication 链表去重 for every seniority level 对于每一个高层，对于每一层 recursively 递归 ascend 上升 increasing 上升 descend 下降 decreasing 下降 Stripe 条纹，链 radix 基数，进制，根 intersection 交点，交集 non-leaf nodes 非叶子结点 fewest intersections 最少结点的 every seniority level 每一层 vertices 顶点 edges 边 indices 索引 labeling 标记 M by N matrix m行n列矩阵 permutation 一组排列 Quadratic probing 二次方探查法 with positive increments only 只是正向增加 Topological Order 拓扑排序 clique 团 数字单词 suffix 后缀 radix 根，基数 decimal 小数的，十进位的 sub-string 子串 alphabetical 按字母顺序 even 偶数 odd 奇怪的，奇数 two-digit number 两位数 decimal system 十进制 == decimal number any numeral system 任何进制 absolute value 绝对值 Note: Simple chopping is assumed without rounding. 不用四舍五入 结构内部关系 threshold 起征点，下限，开端 top-down 自顶向下 symmetric 对称的 disjoint 不相交的，脱节，解体 partition 分割，分隔 separate 分开的，独有的，另外的 respectively 各自地 randomize 使…随机化 adjacent 毗连的，邻近的 be supposed to 应该，被期望 exactly 确切地 distinct 清晰的，明显的，不同的 distinguish 区分，区别 fundamental 基本的，重要的 indirect 间接的，拐弯抹角的，迂回的 specify 具体说明 general 通用的，普遍的，普通的 potential 潜在的 inadequate 不充分的 动词 implementation 实现 be supposed to 应该，被期望 simulate 假装，模拟，模仿 collaborate 合作 forward 转发 denote 代表，指示，表示 recommendation 推荐，建议 cluster 集群 register 注册 连接词 For the sake of simplicity 为了简单起见 It is assumed that 我们假定… for the sake of 为了 hence 因此 形容词 stuck 动不了的，被卡住的 notorious 臭名昭著的，声名狼藉的，众人皆知的 名词 key words 关键词 casino 赌场 tie 平局 shuffles 洗牌 gamblers 赌徒 a deck of playing cards 一副牌 Joker 鬼牌 红桃（Heart） 黑桃（Spade） 方片（Diamond） 梅花（Club） course 课程 Course List for Student 学生选课情况 property 房产，财产 estate 房产 unit price 单价 bonus 奖金，红利，好处 coupon 优惠券 Forbes 福布斯（美国著名财经杂志） followers 追随者，支持者 trophy 奖牌，奖杯 Lottery 彩票 Graduate Admission 研究生入学 volume 容积，量，体积 MRI 核磁共振像 scattered cities 分散的城市 candidate 候选的 residential 住宅区 client 委托人，客户，当事人 quota 限额 题目要求 sequence {A[1], A[2], …} is said to be “smaller” than sequence {B[1], B[2], …} if there exists k \u003e= 1 such that A[i]=B[i] for all i \u003c k, and A[k] \u003c B[k] 如果序列{A[1], A[2], …}与 {B[1], B[2], …}，如果存在k\u003e=1，使得对任意的i \u003c k都有A[i] == B[i]，而A[k] \u003c B[k]成立，那么就称为方案A比方案B小 Each input file contains one test case. 每一个输入文件包含一个测试用例。 one-way is 1 if the street is one-way from V1 to V2, or 0 if not 如果该道路是从V1到V2的单行线，则one-way为1，否则为0 ","date":"2020-07-25","objectID":"/posts/pat-21/:0:0","tags":["Leetcode-C++"],"title":"PAT-Advanced 单词整理","uri":"/posts/pat-21/"},{"categories":["PAT"],"content":"没有满分,只考了96(排名40/500+)…但不得不说三个小时的解题过程跟过山车一般,一开始83分,差点以为这次考试要翻车了!不过还好一直沉下心debug…最后前四道题全部AC,但最后一道题有一个测试点超时了,因为方法过于暴力(菜鸡猛锤自己大腿),但我也服吧…毕竟代码能力还有待提高! 最后感觉这个分数还算满意吧!只复习了一个月,从一开始的C都用不明白,到现在能挣扎一下了,而且之前模拟考试一次94,一次96(这次考试没翻车就好嘿嘿) 下一步等证书邮寄到家啦! 让人欣慰的是终于能开个甲级专栏了! 备战九月甲级PAT冲冲冲! 下面把这次考试的代码放上吧,蛮有意义的! 第一道题 #include\u003ccstdlib\u003e#include\u003cmap\u003e#include\u003ciostream\u003e#include\u003cstring\u003e#include\u003cvector\u003e#include\u003ccstdio\u003e using namespace std; int main(int argc, char const *argv[]) { vector\u003cstring\u003e month = {\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"}; int d, y,num; char m[20]; cin \u003e\u003e num; for(int i=0; i\u003cnum; i++){ scanf(\"%s %d, %d\",\u0026m,\u0026d,\u0026y); //find month int tmpm; string tmp; char data[100]; for(int j=0; j\u003c12; j++){ if(month[j] == m){ tmpm = j+1; break; } } sprintf(data,\"%04d%02d%02d\",y,tmpm,d); tmp = data; int k; for(k=0; k\u003c4; k++){ if(tmp[k] != tmp[7-k]){ cout \u003c\u003c \"N \"; break; } } if(k == 4){ cout \u003c\u003c \"Y \"; } cout \u003c\u003c tmp \u003c\u003c endl; } system(\"pause\"); return 0; } 第二道题 #include\u003ccstdlib\u003e#include\u003ciostream\u003e using namespace std; int main(int argc, char const *argv[]) { int num, k; cin \u003e\u003e num \u003e\u003e k; int tmp; int l,r; int max = 0; bool comb = false, has = false; for(int i=0; i\u003cnum; i++){ cin \u003e\u003e tmp; if(tmp \u003e max){ max = tmp; } if(comb == false \u0026\u0026 tmp\u003ek){ comb = true; l = i; r = i; } else if(comb == true \u0026\u0026 tmp\u003ek){ r = i; } else if(tmp \u003c= k){ if(comb){ comb = false; printf(\"[%d, %d]\\n\",l,r); has = true; } else{ continue; } } } if(comb == true){ printf(\"[%d, %d]\\n\",l,r); has = true; } if(!has){ printf(\"%d\\n\", max); } system(\"pause\"); return 0; } 第三道题 #include\u003ciostream\u003e#include\u003ccstdlib\u003e#include\u003calgorithm\u003e#include\u003cstring\u003e#include\u003cvector\u003e#include\u003ccctype\u003e using namespace std; int converts(char a){ if(isdigit(a)){ return a-'0'; } else{ return a-'a'+10; } } //vector\u003cchar\u003e v = {'a','b',c,d,e,f,g,h,i,j,k} char cons(int a){ if(a\u003c10){ return a+'0'; } else { return 'a'+(a-10); } } int main(int argc, char const *argv[]) { string a,b; cin \u003e\u003e a \u003e\u003e b; int sum; if(a.size()\u003eb.size()){ sum = a.size(); int shit = b.size(); for(int i=0; i\u003ca.size()-shit; i++){ b = \"0\"+b; } } else{ sum = b.size(); int shit = a.size(); for(int i=0; i\u003cb.size()-shit; i++){ a = \"0\"+a; } } reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); char data[1000000]; int carry = 0; int j; for(j=0; j\u003csum; j++){ int m = converts(a[j]); int n = converts(b[j]); int shit = (m+n+carry)%30; carry = (m+n+carry)/30; char shit2 = cons(shit); data[j] = shit2; } if(carry != 0){ data[j] = carry+'0'; } string res = data; // 11feik2ir reverse(res.begin(),res.end()); int cnt = 0; for(int i=0; i\u003cres.size(); i++){ if(res[i] == '0'){ cnt++; } else{ break; } } res = res.substr(cnt,res.size()-cnt); //cout \u003c\u003c res; if(res == \"\"){ cout \u003c\u003c \"0\"; } else{ cout \u003c\u003c res; } system(\"pause\"); return 0; } 第四道题 #include\u003cstring\u003e#include\u003ciostream\u003e#include\u003calgorithm\u003e#include\u003ccstdlib\u003e#include\u003ccmath\u003e using namespace std; bool iss(int a){ if(a == 1){ return false; } int b = (int)sqrt(double(a)); for(int i=2; i\u003cb; i++){ if(a%i == 0){ return false; } } return true; } int main(int argc, char const *argv[]) { bool has = false; string s; cin \u003e\u003e s; for(int i=0; i\u003cs.size(); i++){ string a = s.substr(i,s.size()-i); if(iss(stoi(a))){ cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c \"Yes\" \u003c\u003c endl; } else { cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c \"No\" \u003c\u003c endl; has = true; } } if(!has){ cout \u003c\u003c \"All Prime!\"; } system(\"pause\"); return 0; } 第五道题 没有AC,一个测试点超时了 #include\u003cset\u003e#include\u003ccstdlib\u003e#include\u003ciostream\u003e#include\u003cvector\u003e#include\u003calgorithm\u003e#include\u003ccmath\u003e#include\u003ccstdio\u003e using namespace std; int main(int argc, char const *argv[]) { int s1,s2; //scanf(\"%d %d\",\u0026s1,\u0026s2); cin \u003e\u003e s1 \u003e\u003e s2; int n, m; cin \u003e\u003e n \u003e\u003e m; //scanf(\"%d %d\",\u0026n,\u0026m); vector\u003cbool\u003e shit(n,false); set\u003cint\u003e data1; //输入的 set\u003cint\u003e data2; //差值 data2.insert(abs(s1-s2)); data1.insert(s1); data1.insert(s2); vector\u003cvector\u003cint\u003e\u003e res; res.resize(n,vector\u003cint\u003e(m)); for(int i=0; i\u003cn; i++){ for(int j=0; j\u003cm; j++){ int tmp; cin \u003e\u003e tmp; res[i][j] = tmp; } } for(int i=0; i\u003cm; i++){ for(int j=0; j\u003cn; j++){ if(!shit[j]){ int tmp = res[j][i]; if(data1.fi","date":"2020-07-25","objectID":"/posts/pat-20/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 考完啦!","uri":"/posts/pat-20/"},{"categories":["PAT"],"content":"对PAT历年真题中常用的模板函数进行总结 寻找字符串中的某一个字符 #include\u003ccstring\u003eif (s2.find(s1[i]) == string::npos \u0026\u0026 ans.find(toupper(s1[i])) == string::npos){ ans += toupper(s1[i]); } 最大公约数 int gcd(int a, int b){ if(b ==0){ return a; } else{ return gcd(b, a%b); } } 单个字符大小写转换 #include\u003ciostream\u003estring a; a[i] = tolower(a[i]); 字符串整体大小写转换 利用transform()函数实现 transform(str.begin(),str.end(),str.begin(),::tolower); transform(str.begin(),str.end(),str.begin(),::toupper); 十进制转二进制 运用短除法 while(scanf(\"%d\",\u0026n)!=EOF) //EOF: END OF FILE { i=0; while(n\u003e0) { a[i++]=n%2; n=n/2; } for(j=i-1;j\u003e=0;j--) //注意是反向输出 printf(\"%d\",a[j]); printf(\"\\n\"); } 求素数 m=(int)sqrt((double)s); //首先求出平方根 for(i=2;i\u003c=m;i++){ if(s%i==0) //当前不为素数 if(i\u003em){ //当前为素数 } } set自带排序,默认从小到大 sort默认升序排序 手动实现加法进位 string add(string data1, string data2){ string s = data1; int carry = 0; for(int i=s.size()-1; i\u003e=0; i--){ s[i] = (data1[i]-'0'+data2[i]-'0'+carry)%10 + '0'; carry = (data1[i]-'0'+data2[i]-'0'+ carry)/10; } if(carry \u003e 0){ s = \"1\" + s; } return s; } 手动实现除法 s为被除数,a为除数 int len = s.length(); t = (s[0] - '0') / a; if ((t != 0 \u0026\u0026 len \u003e 1) || len == 1){ cout \u003c\u003c t; } temp = (s[0] - '0') % a; for (int i = 1; i \u003c len; i++) { t = (temp * 10 + s[i] - '0') / a; cout \u003c\u003c t; temp = (temp * 10 + s[i] - '0') % a; } cout \u003c\u003c \" \" \u003c\u003c temp; C++格式化输出补0 //头文件：\u003ciomanip\u003e //函数：setw(int n) //函数：setfill(char c) cout \u003c\u003c setw(8) \u003c\u003c setfill('0') \u003c\u003c 123; //输出 00000123 ","date":"2020-07-23","objectID":"/posts/pat-19/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 函数总结","uri":"/posts/pat-19/"},{"categories":["PAT"],"content":"B1091-B1095 上一次PAT考试真题: 一个半小时做完前四道题,两个测试点没过,第五题AC 成绩: 96 错的两个测试点,一个是getchar(),另一个是输出格式不对…我人傻了 PAT所有的真题都刷完撒花了,这一个月确实从一个低级菜鸡变成了一个高级菜鸡,不仅熟悉了c++的基本语法,并且感觉coding能力也变强了不少,确实刷题才是变强的唯一途径 希望25号的考试能取得一个好成绩!下一步备战甲级! Beijing 冲冲冲! 1091 N-自守数 简单AC aor(int i=0; i\u003cnum; i++){ cin \u003e\u003e tmp; bool hasshit = false; for(int j=1; j\u003c10; j++){ if(isshit(tmp, j)){ printf(\"%d %d\\n\", j, tmp*tmp*j); hasshit = true; break; } } if(!hasshit){ printf(\"No\\n\"); } } system(\"pause\"); return 0; } 1092 最好吃的月饼 一道快乐计数题 #include\u003ccstdlib\u003e#include\u003cvector\u003e#include\u003ciostream\u003e#include\u003calgorithm\u003e using namespace std; struct bing{ int id; int cnt; }; bool cmp(bing a, bing b){ if(a.cnt == b.cnt){ return a.id \u003c b.id; } else{ return a.cnt \u003e b.cnt; } } int main(int argc, char const *argv[]) { int m, c, tmp; cin \u003e\u003e m \u003e\u003e c; vector\u003cbing\u003e data(m); /* for(int i=0; i\u003cm; i++){ data[i].id = i; data[i].cnt = 0; } */ for(int k=0; k\u003cc; k++){ for(int j=0; j\u003cm; j++){ cin \u003e\u003e tmp; data[j].id = j; data[j].cnt += tmp; } } sort(data.begin(), data.end(), cmp); int max = data[0].cnt; printf(\"%d\\n\", max); for(int i=0; i\u003cm; i++){ if(data[i].cnt == max){ if(i != 0){ printf(\" \"); } printf(\"%d\", data[i].id+1); } else{ break; } } system(\"pause\"); return 0; } 1093 字符串A+B 这个getchar()就真的梦幻,之前不加出问题,现在加了还出问题… 这回知道了,以后像这种连续输入行的中间不需要加,如果后面接\"%c\",就需要加上 #include\u003ccstdlib\u003e#include\u003cset\u003e#include\u003ciostream\u003e#include\u003cstring\u003e using namespace std; int main(int argc, char const *argv[]) { string a, b; getline(cin, a); //getchar(); getline(cin, b); string c = a+b; set\u003cchar\u003e data; for(int i=0; i\u003cc.size(); i++){ if(data.find(c[i]) == data.end()){ printf(\"%c\", c[i]); data.insert(c[i]); } } system(\"pause\"); return 0; } 1094 谷歌的招聘 这道题输出格式没有弄明白,需要输出这个部分字符串,我最后输出成int了,消去了0 #include\u003ccstdlib\u003e#include\u003ciostream\u003e#include\u003cstring\u003e#include\u003ccmath\u003e using namespace std; bool isshit(int a){ if (a == 0 || a == 1) return false; //int s = (int)sqrt(double(a)); for(int i=2; i*i\u003c=a; i++){ if(a%i == 0){ return false; } } return true; } int main(int argc, char const *argv[]) { int num, k; string s; cin \u003e\u003e num \u003e\u003e k; getchar(); getline(cin, s); int i=0; string tmp; int shit; bool has = false; while(i+k \u003c= num){ tmp = s.substr(i,k); shit = stoi(tmp); if(isshit(shit)){ //printf(\"%d\",shit); cout \u003c\u003c tmp; //has = true; //break; return 0; } i++; } //if(!has){ printf(\"404\\n\"); //} //system(\"pause\"); return 0; } 1095 解码PAT准考证 这道题我写的有一点点麻烦,不过还好,至少写的过程中思路清晰一点 ","date":"2020-07-23","objectID":"/posts/pat-18/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 91~95","uri":"/posts/pat-18/"},{"categories":["PAT"],"content":"大佬的解法 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cunordered_map\u003e#include \u003calgorithm\u003eusing namespace std; struct node { string t; int value; }; bool cmp(const node \u0026a, const node \u0026b) { return a.value != b.value ? a.value \u003e b.value : a.t \u003c b.t; } int main() { int n, k, num; string s; cin \u003e\u003e n \u003e\u003e k; vector\u003cnode\u003e v(n); for (int i = 0; i \u003c n; i++) cin \u003e\u003e v[i].t \u003e\u003e v[i].value; for (int i = 1; i \u003c= k; i++) { cin \u003e\u003e num \u003e\u003e s; printf(\"Case %d: %d %s\\n\", i, num, s.c_str()); vector\u003cnode\u003e ans; int cnt = 0, sum = 0; if (num == 1) { for (int j = 0; j \u003c n; j++) if (v[j].t[0] == s[0]) ans.push_back(v[j]); } else if (num == 2) { for (int j = 0; j \u003c n; j++) { if (v[j].t.substr(1, 3) == s) { cnt++; sum += v[j].value; } } if (cnt != 0) printf(\"%d %d\\n\", cnt, sum); } else if (num == 3) { unordered_map\u003cstring, int\u003e m; for (int j = 0; j \u003c n; j++) if (v[j].t.substr(4, 6) == s) m[v[j].t.substr(1, 3)]++; for (auto it : m) ans.push_back({it.first, it.second}); } sort(ans.begin(), ans.end(),cmp); for (int j = 0; j \u003c ans.size(); j++) printf(\"%s %d\\n\", ans[j].t.c_str(), ans[j].value); if (((num == 1 || num == 3) \u0026\u0026 ans.size() == 0) || (num == 2 \u0026\u0026 cnt == 0)) printf(\"NA\\n\"); } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-18/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 91~95","uri":"/posts/pat-18/"},{"categories":["PAT"],"content":"菜鸡的解法 比较函数懒得写了… #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003cmap\u003e#include\u003cstring\u003e#include\u003ccstdlib\u003e using namespace std; struct lnode{ string id; int score; }; struct knode{ int rnum,snum; }; int main(int argc, char const *argv[]) { // B123180908127 int m, n; cin \u003e\u003e m \u003e\u003e n; // id-score string id; int score; // level-date string level; string kaochang, date; //vector-levle map\u003cstring, vector\u003clnode\u003e \u003e lmap; map\u003cstring, knode\u003e kmap; map\u003cstring, map\u003cstring, int\u003e \u003e dmap; for(int i=0; i\u003cm; i++){ cin \u003e\u003e id \u003e\u003e score; level = id[0]; kaochang = id.substr(1,3); date = id.substr(4,6); // insert lmap lmap[level].push_back(lnode{id, score}); // insert kmap //if(kmap.find(kaochang) == kmap.end()){ //kmap[kaochang].snum = score; //kmap[kaochang].rnum = 1; //} //else{ kmap[kaochang].snum += score; kmap[kaochang].rnum++; //} //insert dmap; //if(dmap[date].find(kaochang) == dmap[date].end()){ //dmap[date][kaochang] = 1; //} //else{ dmap[date][kaochang]++; //} } int mode; string shit; for(int j=0; j\u003cn; j++){ cin \u003e\u003e mode \u003e\u003e shit; cout \u003c\u003c \"Case \" \u003c\u003c j+1 \u003c\u003c endl; switch (mode) { case 1: for(int k=0; k\u003clmap[shit].size(); k++){ cout \u003c\u003c lmap[shit][k].id \u003c\u003c \" \" \u003c\u003c lmap[shit][k].score \u003c\u003c endl; } break; case 2: cout \u003c\u003c kmap[shit].rnum \u003c\u003c\" \"\u003c\u003c kmap[shit].snum \u003c\u003c endl; break; case 3: for(auto it = dmap[shit].begin(); it!=dmap[shit].end(); it++){ cout \u003c\u003c it-\u003efirst \u003c\u003c \" \" \u003c\u003c it-\u003esecond \u003c\u003c endl; } break; } } system(\"pause\"); return 0; } map和vector中的数据赋值问题 在对vector和map容器添加数据的过程中,经常会遇到累加的情况 一开始我认为,对于vector需要先初始化为0,map要首先find键值,再分情况进行赋值(map key-value的初始化) 但是看了题解之后发现不需要进行空判定,直接 += value 即可 例如map中: //if(kmap.find(kaochang) == kmap.end()){ //kmap[kaochang].snum = score; //kmap[kaochang].rnum = 1; //} //else{ kmap[kaochang].snum += score; kmap[kaochang].rnum++; //} 当键值不存在时,如果进行key-value值的改变,会直接新建键值对,并且这个过程中,value为0.因此可以直接进行赋值操作,而不需要判断key为空 再例如vector中: struct bing{ int id; int cnt; }; vector\u003cbing\u003e data(m); /* for(int i=0; i\u003cm; i++){ data[i].id = i; data[i].cnt = 0; } */ for(int k=0; k\u003cc; k++){ for(int j=0; j\u003cm; j++){ cin \u003e\u003e tmp; data[j].id = j; data[j].cnt += tmp; } } 对于vector中的结构体进行赋值,直接 += 即可,而不需要对其初始化为0 ","date":"2020-07-23","objectID":"/posts/pat-18/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 91~95","uri":"/posts/pat-18/"},{"categories":["PAT"],"content":"B1086-B1090 第四道题(20分)没想出来…题没太看懂,并且逻辑有些复杂…呜呜呜 别的题都是常规题,都AC了,满分好难… 1086-就不告诉你 这道题有两个知识点,一个是int转string,需要用到 to_string() 函数 第二个就是 string 转 int 的 stoi()函数 #include \u003ciostream\u003e#include \u003cstdlib.h\u003e#include \u003cstring\u003e#include\u003calgorithm\u003eusing namespace std; int main() { int s1,s2; cin \u003e\u003e s1 \u003e\u003e s2; int sum = s1 * s2; string res = to_string(sum); reverse(res.begin(),res.end()); printf(\"%d\", stoi(res)); return 0; } 1087-有多少不同的值 快乐白给题 #include\u003cset\u003e#include\u003ciostream\u003e#include\u003ccstdlib\u003eusing namespace std; int main(int argc, char const *argv[]) { int num; int cnt = 0; //double shit; cin \u003e\u003e num; set\u003cint\u003e res; int s; for(int i=1; i\u003c=num; i++){ s = i/2+i/3+i/5; if(res.find(s) == res.end()){ res.insert(s); cnt++; } } printf(\"%d\",cnt); system(\"pause\"); return 0; } 1088-三人行 这道题需要注意的一个点就是,对于 double = x/y ,如果 x,y 都为 int,那么结果还是int取整数部分 如果想计算除法得到小数,那么需要 x,y 也为 double 对于类似的数字(比较大小)题,要特别注意判断 int(整数) 还是 double(小数) 的情况 #include\u003ccmath\u003e#include\u003ciostream\u003e#include\u003ccstdlib\u003eusing namespace std; int rev(int a){ int tmp1; int tmp2; tmp1 = a%10; tmp2 = a/10; return (tmp1*10 + tmp2); } int main(int argc, char const *argv[]) { int m; double x, y; cin \u003e\u003e m \u003e\u003e x \u003e\u003e y; double charg = x/y; bool isfind = false; double shit[3]; /* find alpha */ for(int i=10; i\u003c=99; i++){ if(fabs(i-rev(i)) == charg*rev(i)){ shit[0] = i; isfind = true; } } shit[1] = rev(shit[0]); shit[2] = (shit[1])/y; if(isfind){ printf(\"%d\",int(shit[0])); for(int k=0; k\u003c3; k++){ if(shit[k] \u003e m){ printf(\" Cong\"); } if(shit[k] == m){ printf(\" Ping\"); } if(shit[k] \u003c m){ printf(\" Gai\"); } } } else{ printf(\"No Solution\"); } //system(\"pause\"); return 0; } 1089-狼人杀-简单版 这道题心态直接崩了,题读不懂呀,后来读懂了也没有思路 看了题解才有点思路,枚举法好强!没想到做了这么多题,还是会遇到没有思路的题 对于此类数据判定,并且限制条件多的题,需要将程序中的条件提前列好,并且分析终止条件 例如本题中的,两个谎言者,一个狼人谎言,一个人类谎言,以及狼人和普通人的正负区分 ","date":"2020-07-23","objectID":"/posts/pat-17/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 86~90","uri":"/posts/pat-17/"},{"categories":["PAT"],"content":"大佬的方法 大佬直接用正负判定是否符合,太强了!好的思路! #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003ccmath\u003eusing namespace std; int main() { int n; cin \u003e\u003e n; vector\u003cint\u003e v(n+1); for (int i = 1; i \u003c= n; i++) cin \u003e\u003e v[i]; for (int i = 1; i \u003c= n; i++) { for (int j = i + 1; j \u003c= n; j++) { vector\u003cint\u003e lie, a(n + 1, 1); a[i] = a[j] = -1; for (int k = 1; k \u003c= n; k++) if (v[k] * a[abs(v[k])] \u003c 0) lie.push_back(k); if (lie.size() == 2 \u0026\u0026 a[lie[0]] + a[lie[1]] == 0) { cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c j; return 0; } } } cout \u003c\u003c \"No Solution\"; return 0; } ","date":"2020-07-23","objectID":"/posts/pat-17/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 86~90","uri":"/posts/pat-17/"},{"categories":["PAT"],"content":"菜鸡的方法 相比大佬简洁的判断,我的判断就写的麻烦了很多,主要是逻辑不清晰,只能将不同的情况分开讨论 #include\u003ccstdlib\u003e#include\u003cvector\u003e#include\u003ciostream\u003e#include\u003ccmath\u003eusing namespace std; int main(int argc, char const *argv[]) { int num, tmp; cin \u003e\u003e num; vector\u003cint\u003e data(num); for(int i=0; i\u003cnum; i++){ cin \u003e\u003e tmp; data[i] = tmp;// insert data } bool shit_l = false, shit_r = false; int cnt; for(int i=0; i\u003cnum; i++){ for(int j=i+1; j\u003cnum; j++){ shit_r = false; shit_l = false; cnt = 0; for(int k=0; k\u003cnum; k++){ int s = data[k]; if((abs(s) == i+1 || abs(s) == j+1) \u0026\u0026 s\u003e0){ if(k == i || k == j){ shit_l = true; } else{ shit_r = true; } cnt++; } if(s \u003c 0){ if(abs(s) != i+1 \u0026\u0026 abs(s) != j+1){ if(k == i || k == j){ shit_l = true; } else{ shit_r = true; } cnt++; } } } // shit2 is shit if(shit_l \u0026\u0026 shit_r \u0026\u0026 cnt == 2){ printf(\"%d %d\",i+1,j+1); system(\"pause\"); return 0; } } } printf(\"No Solution\"); system(\"pause\"); return 0; } 1090-危险品装箱 map-set 的组合使用,快乐AC #include\u003cmap\u003e#include\u003cset\u003e#include\u003ciostream\u003e#include\u003ccstdlib\u003eusing namespace std; int main(int argc, char const *argv[]) { int m, n, s1, s2; cin \u003e\u003e m \u003e\u003e n; map\u003cint,set\u003cint\u003e \u003e data; for(int i=0; i\u003cm; i++){ cin \u003e\u003e s1 \u003e\u003e s2; data[s1].insert(s2); data[s2].insert(s1); } int cnt; for(int k=0; k\u003cn; k++){ cin \u003e\u003e cnt; int tmp; bool shit = false; set\u003cint\u003e res; for(int j=0; j\u003ccnt; j++){ cin \u003e\u003e tmp; res.insert(tmp); } for(auto it = res.begin(); it!=res.end(); it++){ set\u003cint\u003e tmpshit = data[*it]; for(auto it2 = tmpshit.begin(); it2!=tmpshit.end(); it2++){ if(res.find(*it2) != res.end()){ shit = true; break; } } } if(shit){ cout \u003c\u003c \"No\" \u003c\u003c endl; } else{ cout \u003c\u003c \"Yes\" \u003c\u003c endl; } } //system(\"pause\"); return 0; } ","date":"2020-07-23","objectID":"/posts/pat-17/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 86~90","uri":"/posts/pat-17/"},{"categories":["PAT"],"content":"B1081-B1085 第一次模拟考试-94分 第四道题测试点超时,第五道题排序时没转int,这两个点都没想到…确实是坑. 7.23更新 经过上次五道题的深刻反省,感觉现在代码规范了一些,思路也越来越清晰,下一步二刷,总结知识点,冲刺满分! 1081-检查密码 这道题写麻烦了…搞了一堆continue…其实if-else if就可以解决 ","date":"2020-07-23","objectID":"/posts/pat-16/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 81~85","uri":"/posts/pat-16/"},{"categories":["PAT"],"content":"大佬教我写代码 #include \u003ciostream\u003e#include \u003ccctype\u003eusing namespace std; int main() { int n; cin \u003e\u003e n; getchar(); for (int i = 0; i \u003c n; i++) { string s; getline(cin, s); if (s.length() \u003e= 6) { int invalid = 0, hasAlpha = 0, hasNum = 0; for (int j = 0; j \u003c s.length(); j++) { if (s[j] != '.' \u0026\u0026 !isalnum(s[j])) invalid = 1; else if (isalpha(s[j])) hasAlpha = 1; else if (isdigit(s[j])) hasNum = 1; } if (invalid == 1) cout \u003c\u003c \"Your password is tai luan le.\\n\"; else if (hasNum == 0) cout \u003c\u003c \"Your password needs shu zi.\\n\"; else if (hasAlpha == 0) cout \u003c\u003c \"Your password needs zi mu.\\n\"; else cout \u003c\u003c \"Your password is wan mei.\\n\"; } else cout \u003c\u003c \"Your password is tai duan le.\\n\"; } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-16/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 81~85","uri":"/posts/pat-16/"},{"categories":["PAT"],"content":"菜鸡代码 #include\u003ccstdio\u003e#include\u003ciostream\u003e using namespace std; int main(int argc, char const *argv[]) { int num; string s; cin \u003e\u003e num; getchar(); bool hasa,hasd,shit; for(int i=0; i\u003cnum; i++){ hasa = false; hasd = false; shit = false; s = \"\"; getline(cin, s); if(s.size() \u003c 6){ cout \u003c\u003c \"Your password is tai duan le.\"\u003c\u003c endl; continue; } for(int j=0; j\u003cs.size(); j++){ if(isdigit(s[j])){ hasd = true; } else if(isalpha(s[j])){ hasa = true; } else if(s[j] != '.'){ shit = true; } } if(shit){ cout \u003c\u003c \"Your password is tai luan le.\" \u003c\u003c endl; continue; } if(hasa == false){ cout \u003c\u003c \"Your password needs zi mu.\"\u003c\u003c endl; continue; } if(hasd == false){ cout \u003c\u003c \"Your password needs shu zi.\"\u003c\u003c endl; continue; } cout \u003c\u003c \"Your password is wan mei.\"\u003c\u003c endl; } return 0; } 1082-射击比赛 这个没啥好说的…快乐白给题 #include\u003ccstdio\u003e#include\u003ciostream\u003eusing namespace std; int main(int argc, char const *argv[]) { int num; cin \u003e\u003e num; int max = 0, min = 10000; int id,x,y,len; int idmax,idmin; for(int i=0; i\u003cnum; i++){ cin \u003e\u003e id \u003e\u003e x \u003e\u003e y; len = x*x + y*y; if(len \u003c min){ idmin = id; min = len; } if(len \u003e max){ idmax = id; max = len; } } printf(\"%04d %04d\", idmin, idmax); return 0; } 1083-是否存在相等的差 快乐白给题 #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003ccmath\u003e#include\u003cmap\u003e#include\u003calgorithm\u003e using namespace std; struct node{ int div,cnt; }; bool cmp(node a, node b){ return a.div \u003e b.div; } int main(int argc, char const *argv[]) { int num,tmp,div,cnt=0; cin \u003e\u003e num; vector\u003cnode\u003e ans; map\u003cint,int\u003e divid; for(int i=0; i\u003cnum; i++){ cin \u003e\u003e tmp; div = abs(tmp-(i+1)); if(divid.find(div) == divid.end()){ ans.push_back(node{div,1}); divid[div] = cnt++; } else{ ans[divid[div]].cnt++; } } sort(ans.begin(), ans.end(), cmp); for(int j=0; j\u003ccnt; j++){ if(ans[j].cnt \u003e 1){ printf(\"%d %d\\n\",ans[j].div, ans[j].cnt); } } return 0; } 1084-外观数列 这道题我认为不应该超时的…可能是++太猛了吧… #include\u003ciostream\u003e#include\u003cstring\u003e using namespace std; int main(int argc, char const *argv[]) { string d,tmp,shit; int num, cnt; int j; cin \u003e\u003e d; scanf(\"%d\", \u0026num); for(int k=0; k\u003cnum-1; k++){ /* 超时代码 tmp = \"\"; cnt = 1; for(int j=0; j\u003cd.size(); j++){ if(d[j+1] == d[j]){ cnt++; } else{ shit = cnt+'0'; tmp = tmp + d[j] + shit; cnt = 1; } } d = tmp; */ string t; for (int i = 0; i \u003c d.length(); i = j) { for (j = i; j \u003c d.length() \u0026\u0026 d[j] == d[i]; j++); t += d[i] + to_string(j - i); } d = t; } printf(\"%s\", d.c_str()); return 0; } 1085-PAT单位排行 这道题里的这个int整数坑藏的很深,在cmp函数里就要转成int进行比较,最后输出判定rank也要转int 以后要格外注意这种\"只要整数部分\"的题目 这里用到transform()函数,对字符串进行了小写变换 #include\u003ccstdio\u003e#include\u003cstring\u003e#include\u003ciostream\u003e#include\u003cvector\u003e#include\u003cmap\u003e#include\u003calgorithm\u003e using namespace std; struct node{ string lib; double score; int pnum; }; double shitx(double score, string id){ if(id[0] == 'B'){ return score/1.5; } if(id[0] == 'A'){ return score; } if(id[0] == 'T'){ return score*1.5; } } bool cmp(node a, node b){ if((int)a.score == (int)b.score){ if(a.pnum == b.pnum){ return a.lib \u003c b.lib; } else{ return a.pnum \u003c b.pnum; } } else{ return (int)a.score \u003e (int)b.score; } } int main(int argc, char const *argv[]) { int num,cnt = 0; double score; string id, lib; cin \u003e\u003e num; map\u003cstring,int\u003e namex; vector\u003cnode\u003e ans; for(int i=0; i\u003cnum; i++){ cin \u003e\u003e id \u003e\u003e score \u003e\u003e lib; transform(lib.begin(), lib.end(), lib.begin(), ::tolower); if(namex.find(lib) == namex.end()){ ans.push_back(node{lib,shitx(score,id),1}); namex[lib] = cnt++; } else{ int tmp = namex[lib]; ans[tmp].pnum++; ans[tmp].score = ans[tmp].score + shitx(score,id); } } sort(ans.begin(), ans.end(), cmp); int index = 1; printf(\"%d\\n\", cnt); for(int k=0; k\u003ccnt; k++){ if(k\u003e0 \u0026\u0026 (int)ans[k-1].score != (int)ans[k].score){ index = k+1; } printf(\"%d %s %d %d\\n\",index, ans[k].lib.c_str(), (int)ans[k].score, ans[k].pnum); } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-16/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 81~85","uri":"/posts/pat-16/"},{"categories":["PAT"],"content":"B1076-B1080 这五道题让我产生了许多反思,由于代码中变量以及语法上的不规范,造成了许多不必要的麻烦,虽然代码确实可以跑起来,但性价比太低了,规范整洁的代码习惯,不仅可以让写代码过程思路清晰,并且debug过程变得轻松很多.小辣鸡以后要重视这方面啦! 7.23更新 1076-Wifi密码 快乐白给题 #include\u003ccstdio\u003e#include\u003cvector\u003e#include\u003ciostream\u003eusing namespace std; int main(int argc, const char** argv) { int num; int i=0; scanf(\"%d\", \u0026num); vector\u003cvector\u003cchar\u003e \u003e chos; chos.resize(4, vector\u003cchar\u003e(2)); vector\u003cchar\u003e res(num); getchar(); for(int i=0; i\u003cnum; i++){ //A-T B-F C-F D-F scanf(\"%c-%c %c-%c %c-%c %c-%c\",\u0026chos[0][0], \u0026chos[0][1], \u0026chos[1][0],\u0026chos[1][1], \u0026chos[2][0],\u0026chos[2][1], \u0026chos[3][0],\u0026chos[3][1]); for(int k=0; k\u003c4; k++){ if(chos[k][1] == 'T'){ res[i] = chos[k][0]; } } getchar(); } for(int w=0; w\u003cnum; w++){ switch (res[w]) { case 'A': printf(\"1\"); break; case 'B': printf(\"2\"); break; case 'C': printf(\"3\"); break; case 'D': printf(\"4\"); break; } } return 0; } 1077-互评成绩计算 这道题就暴露了我写的代码中很多的问题 首先是变量命名不规范 “count\"简写为\"cnt” “temp\"简写为\"tmp” 其次对于相似功能的变量,应该放在一起命名和赋值,这样方便后期debug阶段查看 ","date":"2020-07-23","objectID":"/posts/pat-15/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 76~80","uri":"/posts/pat-15/"},{"categories":["PAT"],"content":"柳神的代码 #include \u003ciostream\u003eusing namespace std; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c n; i++) { int g2, g1 = 0, cnt = -2, temp, maxn = -1, minn = m + 1; cin \u003e\u003e g2; for (int j = 0; j \u003c n-1; j++) { cin \u003e\u003e temp; if (temp \u003e= 0 \u0026\u0026 temp \u003c= m) { if (temp \u003e maxn) maxn = temp; if (temp \u003c minn) minn = temp; g1 += temp; cnt++; } } cout \u003c\u003c int((((g1 - minn - maxn) * 1.0 / cnt) + g2) / 2 + 0.5) \u003c\u003c endl; } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-15/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 76~80","uri":"/posts/pat-15/"},{"categories":["PAT"],"content":"菜鸡的代码 #include\u003ccstdio\u003e#include\u003cvector\u003eusing namespace std; int main(int argc, const char** argv) { int num, full; scanf(\"%d %d\", \u0026num, \u0026full); int temp_count, temp_input, teacher, stdscore; int avg, max, min; bool bool_max, bool_min; int res; vector\u003cint\u003e sum(num-1); for(int i=0; i\u003cnum; i++){ temp_count = 0; stdscore = 0; bool_max = true; bool_min = true; max = 0; min = full; for(int k=0; k\u003cnum; k++){ scanf(\"%d\", \u0026temp_input); if(k == 0){ teacher = temp_input; } else{ if(temp_input\u003e= 0 \u0026\u0026 temp_input\u003c= full){ max = temp_input \u003e max ? temp_input:max; min = temp_input \u003c min ? temp_input:min; sum[temp_count++] = temp_input; } } } for(int w=0; w\u003ctemp_count; w++){ if(sum[w] == max \u0026\u0026 bool_max){ sum[w] = 0; bool_max = false; } if(sum[w] == min \u0026\u0026 bool_min){ sum[w] = 0; bool_min = false; } stdscore += sum[w]; } avg = stdscore/(temp_count-2); res = (teacher+avg+1)/2; printf(\"%d\\n\", res); } return 0; } 1078-字符串压缩与解压 这道题我一开始写的有点麻烦,主要担心越界,但是发现题解直接i+1了,因为字符串最后还有一个终结符 #include\u003ccstdio\u003e#include\u003cstring\u003e#include\u003ciostream\u003eusing namespace std; int main(int argc, char const *argv[]) { char mode; string data; scanf(\"%c\", \u0026mode); getchar(); int temp_count; int temp_num = 0; if(mode == 'C'){ getline(cin, data); temp_count = 1; for(int i=0; i\u003cdata.size(); i++){ if(data[i] == data[i+1]){ temp_count++; } else{ if(temp_count!=1){ printf(\"%d\",temp_count); temp_count = 1; } printf(\"%c\",data[i]); } } } else if(mode == 'D'){ getline(cin,data); for(int i=0; i\u003cdata.size(); i++){ if(isdigit(data[i])){ temp_num = temp_num*10 + data[i]-'0'; } else{ if(temp_num!= 0){ for(int a=0 ;a\u003ctemp_num-1; a++){ printf(\"%c\", data[i]); } } printf(\"%c\", data[i]); temp_num = 0; } } } return 0; } 1079-延迟的回文数* 这道题有一个超级重点的知识点,就是对于较大数的加法,这里使用string进行位加法,类似于程序实现手动加法步骤 应该作为一个函数模板掌握,另外对于限制次数的操作,可以使用 while(n–) 实现 #include\u003ccstdio\u003e#include\u003cstring\u003e#include\u003calgorithm\u003e#include\u003ciostream\u003e using namespace std; string rev(string data){ reverse(data.begin(), data.end()); return data; } /* 重点 */ string add(string data1, string data2){ string s = data1; int carry = 0; for(int i=s.size()-1; i\u003e=0; i--){ s[i] = (data1[i]-'0'+data2[i]-'0'+carry)%10 + '0'; carry = (data1[i]-'0'+data2[i]-'0'+ carry)/10; } if(carry \u003e 0){ s = \"1\" + s; } return s; } int main(int argc, char const *argv[]) { string origin, s; cin \u003e\u003e origin; int n = 10; if(origin == rev(origin)){ cout \u003c\u003c origin \u003c\u003c \" is a palindromic number.\\n\"; return 0; } while(n--){ s = add(origin, rev(origin)); cout \u003c\u003c origin \u003c\u003c \" + \" \u003c\u003c rev(origin) \u003c\u003c \" = \" \u003c\u003c s \u003c\u003c endl; if(s == rev(s)){ cout \u003c\u003c s \u003c\u003c \" is a palindromic number.\\n\"; return 0; } origin = s; } cout \u003c\u003c \"Not found in 10 iterations.\\n\"; return 0; } 1080-MOOC期终成绩 这道题虽然不难(想明白之后感觉不难…)但蕴含的知识点很多,看懂题解之后,我花了半个小时一遍一遍的看代码 并且反思为什么自己写不出来这样的code 总结出几个点,首先是变量命名不规范,其次是对于判断功能写的拖泥带水,冗余代码很多,最后导致思路越写越乱 因此应该在读懂题意的条件下,认真分析每一处数据的限制条件,以及解决方法,这样才能思路清晰的一气呵成 另外要善于用vector的push_back(),结构体的新建实例化可以直接 node{s, score, -1, -1, 0} #include\u003cmap\u003e#include\u003cvector\u003e#include\u003ciostream\u003e#include\u003calgorithm\u003eusing namespace std; struct node{ string name; int gp,gm,gf,g; }; bool cmp(node a, node b){ return a.g != b.g ? a.g \u003e b.g : a.name \u003c b.name; } int main(int argc, char const *argv[]) { int p, m, n, score, cnt = 1; string s; cin \u003e\u003e p \u003e\u003e m \u003e\u003e n; vector\u003cnode\u003e v, ans; map\u003cstring, int\u003e idx; for(int i=0; i\u003cp; i++){ cin \u003e\u003e s \u003e\u003e score; if(score \u003e= 200){ v.push_back(node{s, score, -1, -1, 0}); idx[s] = cnt++; } } for(int i=0 ;i\u003cm; i++){ cin \u003e\u003e s \u003e\u003e score; if(idx[s] != 0){ v[idx[s]-1].gm = score; } } for(int i=0; i\u003cn; i++){ cin \u003e\u003e s \u003e\u003e score; int temp = idx[s]-1; if(idx[s] != 0){ v[temp].gf = v[temp].g = score; if(v[temp].gm \u003e v[temp].gf){ v[temp].g = (int)(v[temp].gm*0.4 + v[temp].gf*0.6 + 0.5); } } } for(int i=0; i\u003cv.size(); i++){ if(v[i].g \u003e= 60){ ans.push_back(v[i]); } } sort(ans.begin(), ans.end(),cmp); for(int i=0; i\u003cans.size(); i++){ printf(\"%s %d %d %d %d\\n\", ans[i].name.c_str(), ans[i].gp, ans[i].gm, ans[i].gf, ans[i].g); } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-15/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 76~80","uri":"/posts/pat-15/"},{"categories":["PAT"],"content":"B1074-B1075 今天只有两道题…因为都是我最怕的快乐数据题 7.23更新 1074-宇宙无敌加法器* 这道题我写了80行代码…题解是35行 我太菜,主要是没想明白怎么处理开始的0,最后用的vector存储有效数字 看了题解发现字符串还能有这种补0的迷幻操作,学到了…谢谢大佬 最后的判断0开始输出简直是点睛之笔! 而我的方法就很笨了,需要vector慢慢转数据呜呜呜 ","date":"2020-07-23","objectID":"/posts/pat-14/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 74~75","uri":"/posts/pat-14/"},{"categories":["PAT"],"content":"题解方法 #include\u003ccstdio\u003e#include\u003cvector\u003e#include\u003ciostream\u003eusing namespace std; int main() { string s, s1, s2, ans; int carry = 0, flag = 0; cin \u003e\u003e s \u003e\u003e s1 \u003e\u003e s2; ans = s; string ss1(s.length() - s1.length(), '0'); s1 = ss1 + s1; string ss2(s.length() - s2.length(), '0'); s2 = ss2 + s2; for(int i = s.length() - 1; i \u003e= 0; i--) { int mod = s[i] == '0' ? 10 : (s[i] - '0'); ans[i] = (s1[i] - '0' + s2[i] - '0' + carry) % mod + '0'; carry = (s1[i] - '0' + s2[i] - '0' + carry) / mod; } if (carry != 0) ans = '1' + ans; for(int i = 0; i \u003c ans.size(); i++) { if (ans[i] != '0' || flag == 1) { flag = 1; cout \u003c\u003c ans[i]; } } if (flag == 0) cout \u003c\u003c 0; return 0; } ","date":"2020-07-23","objectID":"/posts/pat-14/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 74~75","uri":"/posts/pat-14/"},{"categories":["PAT"],"content":"菜鸡的方法 有两个测试点没过 分数: 16/20 #include\u003ccstdio\u003e#include\u003cvector\u003e#include\u003ciostream\u003eusing namespace std; vector\u003cint\u003e shit1(21); vector\u003cint\u003e data1(21); vector\u003cint\u003e data2(21); vector\u003cint\u003e num_convert(int num, vector\u003cint\u003e data){ int temp; int sum = 0; while(num \u003e 0){ temp = num %10; data[++sum] = temp; num = num/10; } data[0] = sum; return data; } int main(int argc, const char** argv) { int shit, num1, num2; scanf(\"%d %d %d\", \u0026shit, \u0026num1, \u0026num2); vector\u003cint\u003e res(20); shit1 = num_convert(shit,shit1); data1 = num_convert(num1,data1); data2 = num_convert(num2,data2); int size1 = data1[0]; int size2 = data2[0]; int leftshit, tempsum; int j = 1; int inshit = 0; while(size1 \u003e 0 || size2 \u003e 0){ tempsum = 0; if(size1 \u003e0 \u0026\u0026 size2 \u003e0){ tempsum = data1[j] + data2[j]; size1--; size2--; } else{ if(size1 \u003e 0){ tempsum = data1[j]; size1--; } else{ tempsum = data2[j]; size2--; } } if(inshit){ tempsum += inshit; } int convert_shit1; if(shit1[j] == 0){ convert_shit1 = 10; } else{ convert_shit1 = shit1[j]; } if(tempsum \u003e= convert_shit1){ inshit = tempsum/convert_shit1; } else{ inshit = 0; } leftshit = tempsum % convert_shit1; res[j] = leftshit; j++; } int h = j-1; if(inshit){ res[j] = 1; h = j; } for(; h\u003e0; h--){ printf(\"%d\", res[h]); } if(j == 1){ printf(\"0\"); } return 0; } 1075-链表元素分类 这道题我搞了很多一维vector…有点创建上瘾了 就是没想到二维vector和结构体,可能之前用结构体有阴影了 因为只得到了17分,完成度太低,就不放自己写的代码了 这道题有一个点很值得学习,一个是vector的push_back() 最后用vector.size()遍历,这样不需要提前分配空间,省了很多事 之前学习过,如果需要scanf中输入二维vector中,需要提前分配空间 vector\u003cvector\u003cint\u003e \u003e data; data.resize(m, vector\u003cint\u003e(n)); 而使用push_back生成的非预分配二维vector vector\u003cint\u003e v[3]; v[i].push_back(data); 在最后的输出中,由于当前的next地址和下一节点地址相同,那么可以在一行内输出 这样不仅输出清晰,而且还可以有效解决最后一个地址是-1的特殊情况 精妙的方法! ","date":"2020-07-23","objectID":"/posts/pat-14/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 74~75","uri":"/posts/pat-14/"},{"categories":["PAT"],"content":"CODE #include\u003ccstdio\u003e#include\u003cmap\u003e#include\u003cvector\u003e#include \u003ciostream\u003eusing namespace std; struct node { int data, next; }list[100000]; // hash vector\u003cnode\u003e vector\u003cint\u003e v[3]; int main() { int start, n, k, a; scanf(\"%d%d%d\", \u0026start, \u0026n, \u0026k); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", \u0026a); scanf(\"%d%d\", \u0026list[a].data, \u0026list[a].next); } int p = start; while(p != -1) { int data = list[p].data; if (data \u003c 0) v[0].push_back(p); else if (data \u003e= 0 \u0026\u0026 data \u003c= k) v[1].push_back(p); else v[2].push_back(p); p = list[p].next; } int flag = 0; for (int i = 0; i \u003c 3; i++) { for (int j = 0; j \u003c v[i].size(); j++) { if (flag == 0) { printf(\"%05d %d \", v[i][j], list[v[i][j]].data); flag = 1; } else { printf(\"%05d\\n%05d %d \", v[i][j], v[i][j], list[v[i][j]].data); } } } printf(\"-1\"); return 0; } ","date":"2020-07-23","objectID":"/posts/pat-14/:3:0","tags":["Leetcode-C++"],"title":"PAT-Basic 74~75","uri":"/posts/pat-14/"},{"categories":["PAT"],"content":"B1069-B1073 7.23更新 1069-微博转发抽奖 没啥难的,考察基础逻辑输出 #include\u003ccstdio\u003e#include\u003cset\u003e#include\u003cstring\u003e#include\u003ciostream\u003eusing namespace std; int main(int argc, const char** argv) { int M, N, start; scanf(\"%d %d %d\", \u0026N, \u0026M ,\u0026start); set\u003cstring\u003e havegot; string temp; int num = 0; int move = 0; for(int i=0; i\u003cN; i++){ cin \u003e\u003e temp; if(i == start-1+num*M+move){ if(havegot.find(temp) == havegot.end()){ num++; havegot.insert(temp); cout \u003c\u003c temp \u003c\u003c endl; } else{ move++; } } } if(havegot.size() == 0){ printf(\"Keep going...\"); } return 0; } 1070-结绳 这道题需要先赋值,因为可能只有一根绳子 不知道为什么,额外写判断还是不行,只好先把vector第一个坑先占上了 #include\u003ccstdio\u003e#include\u003cvector\u003e#include\u003calgorithm\u003e#include\u003citerator\u003eusing namespace std; int main(int argc, const char** argv) { int num; scanf(\"%d\", \u0026num); double temp; double sum = 0; vector\u003cdouble\u003e data(num); for(int i=0; i\u003cnum; i++){ scanf(\"%lf\", \u0026temp); data[i] = temp; } sort(data.begin(), data.end(), less\u003cdouble\u003e()); /* if(data.size() == 1){ printf(\"%d\", (int)data[0]); return 0; } */ sum = data[0]; for(int k=1; k\u003cdata.size(); k++){ sum += data[k]; sum = sum/2; } int res = (int)sum; printf(\"%d\", res); return 0; } 1071-小赌怡情 没啥难的…一次AC #include\u003ccstdio\u003eusing namespace std; int main(int argc, const char** argv) { int shit, num; scanf(\"%d %d\",\u0026shit, \u0026num); int data1, data2, guss, gushit; for(int i=0; i\u003cnum; i++){ scanf(\"%d %d %d %d\", \u0026data1, \u0026guss, \u0026gushit, \u0026data2); if(gushit \u003e shit){ printf(\"Not enough tokens. Total = %d.\\n\",shit); } else{ if((data1 \u003c data2 \u0026\u0026 guss == 1) || (data1 \u003e data2 \u0026\u0026 guss == 0)){ shit += gushit; printf(\"Win %d! Total = %d.\\n\", gushit,shit); } else{ shit -= gushit; printf(\"Lose %d. Total = %d.\\n\", gushit,shit); if(shit == 0){ printf(\"Game Over.\"); break; } } } } return 0; } 1072-开学寄语 emmmm,这个也不难,一次AC #include\u003ccstdio\u003e#include\u003cset\u003e#include\u003cvector\u003eusing namespace std; int main(int argc, const char** argv) { int pnum, shitnum; set\u003cint\u003e shit; scanf(\"%d %d\", \u0026pnum, \u0026shitnum); int tempshit; for(int i=0; i\u003cshitnum; i++){ scanf(\"%d\", \u0026tempshit); shit.insert(tempshit); } char name[10]; int tempnum,tempshit2; int count = 0, tempcount, pcount = 0; vector\u003cint\u003e data(6); for(int k=0; k\u003cpnum; k++){ tempcount = 0; scanf(\"%s %d\", \u0026name, \u0026tempnum); for(int h=0; h\u003ctempnum; h++){ scanf(\"%d\", \u0026tempshit2); if(shit.find(tempshit2) != shit.end()){ count++; data[tempcount] = tempshit2; tempcount++; } } if(tempcount != 0){ printf(\"%s: \",name); for(int w=0; w\u003ctempcount; w++){ if(w != 0){ printf(\" \"); } printf(\"%04d\",data[w]); } printf(\"\\n\"); pcount++; } } printf(\"%d %d\",pcount, count); return 0; } 1073-多选题常见计分法* 这道题就很梦幻了,好久没遇到这么快乐(自闭)的题了 其实本来我代码都快写完了,但我看了一眼我写的三层for循环,又想到没写到的选项判断,我就果断放弃了 这道题的精妙之处就是解决选项判断问题 我一开始想用单独的vector和find进行选项判断,但是感觉好复杂 题解则使用了位运算,这是我根本没想到的(长见识了!) 并且位运算还很是神奇,用到了\"{1, 2, 4, 8, 16}“这个数组作为运算base,这就是二进制转十进制的操作 之后将两个十进制的二进制数进行位运算判断 对于每到选择题答案a,b,c,d,e依次可用00001，00010，00100，01000，10000表示 例如一道选择题选了a,c则可表示为00101； 令正确答案与考生答案异或： 1.异或为0则该题做对 例：00101 ^ 00101 = 0 2.异或非0则该题做错 例：00101 ^ 00010 = 7 漏选 例：00101 ^ 00001 = 4 此时可以通过与操作对做错和漏选进行区分，漏选和答案或为答案 1.做错 例：00101 | 00010 = 00111 2.漏选 例：00101 | 00001 = 00101 与答案相等 最后通过与操作定位错误点 00101 ^ 00010 = 00111 00111 \u0026 00001 = 00001 选错 00111 \u0026 00010 = 00010 选错（对的未选） 00111 \u0026 00100 = 00100 选错 00111 \u0026 01000 = 00000 00111 \u0026 10000 = 00000 #include \u003cvector\u003e#include \u003ccmath\u003e#include \u003ccstdio\u003eusing namespace std; int main() { int n, m, optnum, truenum, temp, maxcnt = 0; int hash[] = {1, 2, 4, 8, 16}, opt[1010][110] = {0}; char c; scanf(\"%d %d\", \u0026n, \u0026m); vector\u003cint\u003e fullscore(m), trueopt(m); vector\u003cvector\u003cint\u003e \u003e cnt(m, vector\u003cint\u003e(5)); for (int i = 0; i \u003c m; i++) { scanf(\"%d %d %d\", \u0026fullscore[i], \u0026optnum, \u0026truenum); for (int j = 0; j \u003c truenum; j++) { scanf(\" %c\", \u0026c); trueopt[i] += hash[c-'a']; } } for (int i = 0; i \u003c n; i++) { double grade = 0; for (int j = 0; j \u003c m; j++) { getchar(); scanf(\"(%d\", \u0026temp); for (int k = 0; k \u003c temp; k++) { scanf(\" %c)\", \u0026c); opt[i][j] += hash[c-'a']; } int el = opt[i][j] ^ trueopt[j]; if (el) { if ((opt[i][j] | trueopt[j]) == trueopt[j]) { grade += fullscore[j] * 1.0 / 2; } if (el) { for (int","date":"2020-07-23","objectID":"/posts/pat-13/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 69~73","uri":"/posts/pat-13/"},{"categories":["PAT"],"content":"B1065-B1068 7.23更新 1065-单身狗 这道题双向map加上set就可以解决 #include\u003ccstdio\u003e#include\u003cmap\u003e#include\u003cset\u003eusing namespace std; int main(int argc, const char** argv) { int num; scanf(\"%d\", \u0026num); int s1,s2; map\u003cint, int\u003e data; for(int i=0; i\u003cnum; i++){ scanf(\"%d %d\", \u0026s1, \u0026s2); data[s1] = s2; data[s2] = s1; } int num2, count = 0; int temp; scanf(\"%d\", \u0026num2); set\u003cint\u003e data2; set\u003cint\u003e res; for(int k=0; k\u003cnum2; k++){ scanf(\"%d\", \u0026temp); data2.insert(temp); } for(auto it = data2.begin(); it!=data2.end(); it++){ if(data2.find(data[*it]) == data2.end()){ count++; res.insert(*it); } } printf(\"%d\\n\", count); int flag = 0; for(auto it2 = res.begin(); it2!=res.end(); it2++){ if(flag == 0){ flag = 1; } else{ printf(\" \"); } printf(\"%05d\", *it2); } return 0; } 1066-图像过滤 快乐白给打印题 #include\u003ccstdio\u003eusing namespace std; int main(int argc, const char** argv) { int row, num, shit1, shit2, yeah; scanf(\"%d %d %d %d %d\", \u0026row, \u0026num, \u0026shit1, \u0026shit2, \u0026yeah); int temp; for(int i=0; i\u003crow; i++){ for(int j=0; j\u003cnum; j++){ scanf(\"%d\", \u0026temp); if(j != 0){ printf(\" \"); } if(temp\u003c= shit2 \u0026\u0026 temp\u003e= shit1){ printf(\"%03d\", yeah); } else{ printf(\"%03d\", temp); } } if(i != row-1){ printf(\"\\n\"); } } return 0; } 1067-试密码 这道题有两个点,一个是由于输入的字符串中有空格,所以需要使用getline() 另外,在输入第一行的数字之后,如果要进行getline(),需要取到第一行最后的’\\n’换行符 #include\u003cstring\u003e#include\u003ccstdio\u003e#include\u003ciostream\u003eusing namespace std; int main(int argc, const char** argv) { string password; int num; cin \u003e\u003e password \u003e\u003e num; string input; getchar(); getline(cin, input); while(input != \"#\"){ if(input == password){ cout \u003c\u003c \"Welcome in\"; break; } else{ cout \u003c\u003c \"Wrong password: \"\u003c\u003c input \u003c\u003c endl; if(--num == 0){ cout \u003c\u003c \"Account locked\"; break; } } getline(cin, input); } return 0; } 1068-万绿丛中一点红* 这道题很不错,输入矩阵数据类型的经典例题 一开始我也没写出来,巧妙在于他将矩阵的不同位置信息,直接写在了一个二维数组中,这样每个点都可以对应使用 另外一点是,对于二维vector的建立,相比与之前的一行定义,我还是更推荐这种写在两行的,结构清晰 第一行代码是定义行,第二行代码是定义列,利用resize() vector\u003cvector\u003cint\u003e\u003e v; v.resize(n, vector\u003cint\u003e(m)); #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cmap\u003eusing namespace std; int m, n, tol; vector\u003cvector\u003cint\u003e\u003e v; int dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}}; bool judge(int i, int j) { for (int k = 0; k \u003c 8; k++) { int tx = i + dir[k][0]; //确定位置 int ty = j + dir[k][1]; if (tx \u003e= 0 \u0026\u0026 tx \u003c n \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c m \u0026\u0026 v[i][j] - v[tx][ty] \u003e= 0 - tol \u0026\u0026 v[i][j] - v[tx][ty] \u003c= tol) return false; } return true; } int main() { int cnt = 0, x = 0, y = 0; scanf(\"%d%d%d\", \u0026m, \u0026n, \u0026tol); v.resize(n, vector\u003cint\u003e(m)); map\u003cint, int\u003e mapp; for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c m; j++) { scanf(\"%d\", \u0026v[i][j]); mapp[v[i][j]]++; } } for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c m; j++) { if (mapp[v[i][j]] == 1 \u0026\u0026 judge(i, j) == true) { cnt++; x = i + 1; y = j + 1; } } } if (cnt == 1) printf(\"(%d, %d): %d\", y, x, v[x-1][y-1]); else if (cnt == 0) printf(\"Not Exist\"); else printf(\"Not Unique\"); return 0; } ","date":"2020-07-23","objectID":"/posts/pat-12/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 65~68","uri":"/posts/pat-12/"},{"categories":["PAT"],"content":"B1059-B1064 7.23更新 1059-C语言竞赛 这道题没啥难的,主要是写好素数判断函数和最后的分情况判定 #include\u003ccstdio\u003e#include\u003cmap\u003e#include\u003ccmath\u003e using namespace std; int is_s(int a){ int i; for(int i=2; i\u003c= sqrt(a); i++){ if(a%i == 0){ return false; } } return true; } int main(int argc, const char** argv) { int num; scanf(\"%d\", \u0026num); map\u003cint,int\u003e data; int tempid,rank; for(int i=0; i\u003cnum; i++){ scanf(\"%d\", \u0026tempid); data[tempid] = i+1; } int search; scanf(\"%d\", \u0026search); for(int j=0; j\u003csearch; j++){ scanf(\"%d\", \u0026tempid); rank = data[tempid]; if(rank == -1){ printf(\"%04d: Checked\\n\",tempid); } else if(rank == 1){ printf(\"%04d: Mystery Award\\n\",tempid); data[tempid] = -1; } else if(rank == NULL){ printf(\"%04d: Are you kidding?\\n\",tempid); } else if(is_s(rank)){ printf(\"%04d: Minion\\n\",tempid); data[tempid] = -1; } else{ printf(\"%04d: Chocolate\\n\",tempid); data[tempid] = -1; } } return 0; } 1060-爱丁顿数 这道压轴数学题,其实没有很难,但我写的有点复杂了…写了个O(n2)复杂度的循环 其实一个for循环就能完成判断,最后导致一个测试点没过 #include\u003ccstdio\u003e#include\u003ccmath\u003e#include\u003cvector\u003e#include\u003calgorithm\u003e#include\u003citerator\u003e#include\u003ciostream\u003e using namespace std; int main(int argc, const char** argv) { int num; scanf(\"%d\", \u0026num); vector\u003cint\u003e data(num); for(int h=0; h\u003cnum; h++){ scanf(\"%d\", \u0026data[h]); } sort(data.begin(), data.end(), greater\u003cint\u003e()); /* 一个测试点超时 int next = 0, max = 0; bool ok = true; for(int i=0; i\u003cnum; i++){ for(int j=0; j\u003ci; j++){ if(data[j] \u003c i+1){ ok = false; break; } } if(ok){ max = i; } else{ break; } } */ /* 正确方法 */ int k; for(k=0; k\u003cnum \u0026\u0026 k+1 \u003c data[k]; k++); printf(\"%d\", k); //printf(\"%d\", max); return 0; } 1061-判断题 快乐白给题 #include\u003ccstdio\u003e#include\u003cvector\u003eusing namespace std; int main(int argc, const char** argv) { int pnum, qnum; scanf(\"%d %d\", \u0026pnum, \u0026qnum); vector\u003cint\u003e score(qnum); for(int h=0; h\u003cqnum; h++){ scanf(\"%d\", \u0026score[h]); } vector\u003cint\u003e right(qnum); for(int w=0; w\u003cqnum; w++){ scanf(\"%d\", \u0026right[w]); } int temp_score; int temp_choose; for(int i=0; i\u003cpnum; i++){ temp_score = 0; for(int k=0; k\u003cqnum; k++){ scanf(\"%d\", \u0026temp_choose); if(temp_choose == right[k]){ temp_score += score[k]; } } printf(\"%d\\n\", temp_score); } return 0; } 1062-最简分数 考察最大公约数,和分数比较(转double类型) 之前看到过最大公约数函数,但是不知道什么时候能用上,就没背熟,这道题是经典例子 ","date":"2020-07-23","objectID":"/posts/pat-11/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 59~64","uri":"/posts/pat-11/"},{"categories":["PAT"],"content":"求最大公约数-辗转相除法 ","date":"2020-07-23","objectID":"/posts/pat-11/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 59~64","uri":"/posts/pat-11/"},{"categories":["PAT"],"content":"CODE #include\u003ccstdio\u003eusing namespace std; int gcd(int a, int b){ return b == 0 ? a : gcd(b, a%b); } int main(int argc, const char** argv) { int s1,s2,s3,s4,shit; scanf(\"%d/%d %d/%d %d\", \u0026s1,\u0026s2,\u0026s3,\u0026s4,\u0026shit); double shit1 = (double)s1/s2; double shit2 = (double)s3/s4; double temp; if(shit1 \u003e shit2){ temp = shit2; shit2 = shit1; shit1 = temp; } int flag = 0; for(int i=0; i\u003cshit; i++){ double temp_shit = (double)i/shit; if(temp_shit\u003cshit2 \u0026\u0026 temp_shit\u003eshit1 \u0026\u0026 gcd(i,shit) == 1){ if(flag == 0){ flag = 1; } else{ printf(\" \"); } printf(\"%d/%d\", i,shit); } } return 0; } 1063-计算谱半径 快乐白给题 2020.7.16 这道题有一个很重要的知识点: 小数点后保留两位四舍五入的输出 printf函数在进行格式输出(double类型)时,自带四舍五入!但是整数时需要进行+0.5处理 int temp = int(data + 0.5); ","date":"2020-07-23","objectID":"/posts/pat-11/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 59~64","uri":"/posts/pat-11/"},{"categories":["PAT"],"content":"CODE #include\u003ccstdio\u003e#include\u003ccstdlib\u003e#include\u003ccmath\u003e using namespace std; int main(int argc, const char** argv) { int num; scanf(\"%d\", \u0026num); int data1,data2; double sum, min = 0; for(int i=0; i\u003cnum; i++){ sum = 0; scanf(\"%d %d\", \u0026data1, \u0026data2); sum = data1*data1 + data2*data2; sum = sqrt(sum); if(min \u003c sum){ min = sum; } } printf(\"%.2f\",min); return 0; } 1064-朋友数 知识点: set默认排序,从小到大 #include\u003ccstdio\u003e#include\u003cset\u003eusing namespace std; int main(int argc, const char** argv) { int num; scanf(\"%d\", \u0026num); set\u003cint\u003e data; int temp, sum = 0; int count = 0; for(int i=0; i\u003cnum; i++){ sum = 0; scanf(\"%d\", \u0026temp); while(temp \u003e 0){ sum += temp%10; temp = temp/10; } if(data.find(sum) == data.end()){ data.insert(sum); count++; } } printf(\"%d\\n\", count); int flag = 0; for(auto it = data.begin(); it != data.end(); it++){ if(flag == 0){ flag = 1; } else{ printf(\" \"); } printf(\"%d\", *it); } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-11/:3:0","tags":["Leetcode-C++"],"title":"PAT-Basic 59~64","uri":"/posts/pat-11/"},{"categories":["PAT"],"content":"B1058 7.23更新 今天只有一道题,上午数学,下午调试路由器,跟学校保安秀了一波操作,然后把礼物送给老师 我才知道原来宽带经销商还有连接多个运营商的 因为github间歇性无法访问,让我很是难受,最后联系技术人员上门操作 才知道其中间歇性的缘由,因为可能移动的缆线可以访问,而一段时间后切换到电信的缆线导致无法访问,dns解析失败,最后gg 其实我一开始预料到了dns的问题,电脑也从添加hosts行,再到后来直接换掉hosts源,但都是无济于事,因为我没想到原来路由器里还有一个dns 最后技术人员告诉我改变一下路由器的dns解析,我改成谷歌的8888,问题就解决啦! 网络真是神奇嗷!(计算机网络没学好…) 晚上想着刷题,结果上来第一题我就傻了…写了好久也没写明白,输入判断太复杂了… 1058-选择题* 这道题我错就错在不该用结构体,并且没有想到用set进行比较,而且输出格式还搞错了,这道题很经典 既然今天就做这一道题,那就好好分析一下 首先题目的输入 3 4 3 4 2 a c 2 5 1 b 5 3 2 b c 1 5 4 a b d e (2 a c) (2 b d) (2 a c) (3 a b e) (2 a c) (1 b) (2 a b) (4 a b d e) (2 b d) (1 e) (2 b c) (4 a b c d) 难点在于后面的字符输入,首先对于正确选项,需要 scanf(\" %c\", \u0026c); //前面有一个空格 下一步在读入字符串时,需要首先读入一个\"\\n\"换行符 原因在于,如果是scanf(\"%s\"),那么此时会将回车当作结束,但如果当前是scanf(\"%c\"),那么就会将回车也当作字符进行输入,因此,如果想忽略掉这个回车,就需要特性的scanf(\"\\n\") 在输入格式化字符串时,可以对格式的前后进行scanf限定 例如题解中的 scanf(\"(%d\", \u0026k); for(int l = 0; l \u003c k; l++) { scanf(\" %c\", \u0026c); } scanf(\")\"); 就将括号中的字符进行巧妙的读取 在判定两个集合的元素是否相同时,可以直接用set和\"==“进行判断 set1 == set2 最后有一个巧妙的点就是: 没有必要在数组复杂的数据面前使用结构体,虽然结构清晰,但是代码冗余巨大,且逻辑会变得复杂,完全可以用多个一维数组来构造数据,并用下标进行区分 ","date":"2020-07-23","objectID":"/posts/pat-10/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 58","uri":"/posts/pat-10/"},{"categories":["PAT"],"content":"题解 #include \u003ccstdio\u003e#include \u003cvector\u003e#include \u003cset\u003eusing namespace std; int main() { int n, m, temp, k; scanf(\"%d%d\", \u0026n, \u0026m); vector\u003cset\u003cchar\u003e\u003e right(m); vector\u003cint\u003e total(m), wrongCnt(m); for(int i = 0; i \u003c m; i++) { scanf(\"%d%d%d\", \u0026total[i], \u0026temp, \u0026k); for(int j = 0; j \u003c k; j++) { char c; scanf(\" %c\", \u0026c); right[i].insert(c); } } for(int i = 0; i \u003c n; i++) { int score = 0; scanf(\"\\n\"); for(int j = 0; j \u003c m; j++) { if(j != 0) scanf(\" \"); scanf(\"(%d\", \u0026k); set\u003cchar\u003e st; char c; for(int l = 0; l \u003c k; l++) { scanf(\" %c\", \u0026c); st.insert(c); } scanf(\")\"); if(st == right[j]) { score += total[j]; } else { wrongCnt[j]++; } } printf(\"%d\\n\", score); } int maxWrongCnt = 0; for(int i = 0; i \u003c m; i++) { if(wrongCnt[i] \u003e maxWrongCnt) { maxWrongCnt = wrongCnt[i]; } } if(maxWrongCnt == 0) printf(\"Too simple\"); else { printf(\"%d\", maxWrongCnt); for(int i = 0; i \u003c m; i++) { if(wrongCnt[i] == maxWrongCnt) { printf(\" %d\", i + 1); } } } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-10/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 58","uri":"/posts/pat-10/"},{"categories":["PAT"],"content":"B1053-B1057 7.23更新 1053-住房空置率 这道题不算太难 有一个小知识点: 在打印\"%“时,需要%%进行转义输出 ","date":"2020-07-23","objectID":"/posts/pat-9/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 53~57","uri":"/posts/pat-9/"},{"categories":["PAT"],"content":"柳神解法 #include \u003ciostream\u003eusing namespace std; int main() { int n, d, k, maybe = 0, must = 0; double e, temp; cin \u003e\u003e n \u003e\u003e e \u003e\u003e d; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e k; int sum = 0; for (int j = 0; j \u003c k; j++) { cin \u003e\u003e temp; if (temp \u003c e) sum++; } if(sum \u003e (k / 2)) { k \u003e d ? must++ : maybe++; } } double mayberesult = (double)maybe / n * 100; double mustresult = (double)must / n * 100; printf(\"%.1f%% %.1f%%\", mayberesult, mustresult); //百分号 % 注意转义 return 0; } ","date":"2020-07-23","objectID":"/posts/pat-9/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 53~57","uri":"/posts/pat-9/"},{"categories":["PAT"],"content":"第二种解法 #include \u003cstdio.h\u003e int main() { int N, D, K; int empty = 0, pempty = 0, lower; float e, E; scanf(\"%d %f %d\", \u0026N, \u0026e, \u0026D); for(int i = 0; i \u003c N; i++) { lower = 0; scanf(\"%d\", \u0026K); for(int j = 0; j \u003c K; j++) { scanf(\"%f\", \u0026E); if(E \u003c e) lower++; } if(lower \u003e K / 2 \u0026\u0026 K \u003e D) empty++; else if(lower \u003e K / 2) pempty++; } printf(\"%.1f%% %.1f%%\", 100.0 * pempty / N, 100.0 * empty / N); return 0; } 1054-求平均值* 这道题是真的梦幻,首先考察对于数字的合法输入,让我一点思路都没有 看了题解发现,可以巧妙的运用sprintf和sscanf函数解决,即对字符串格式化读入,格式化读出,并判断两次字符串是否相同 这个方法一定要掌握,很棒 #include\u003ccstdio\u003e#include\u003ccstdlib\u003e#include\u003ccstring\u003e using namespace std; int main(int argc, const char** argv) { int num; scanf(\"%d\", \u0026num); char a[50], b[50]; double temp = 0.0, sum = 0.0; bool flag; int count = 0; for(int i=0; i\u003cnum; i++){ flag = false; scanf(\"%s\", \u0026a); //重点 sscanf(a, \"%lf\", \u0026temp); sprintf(b, \"%.2f\", temp); for(int j=0; j\u003cstrlen(a); j++){ if(a[j] != b[j]){ flag = true; } } if(flag || temp \u003c-1000 || temp \u003e1000){ printf(\"ERROR: %s is not a legal number\\n\", a); continue; } else{ count ++; sum += temp; } } if(count == 1) printf(\"The average of 1 number is %.2f\", sum); else if(count \u003e 1) printf(\"The average of %d numbers is %.2f\", count, sum / count); else printf(\"The average of 0 numbers is Undefined\"); return 0; } 1055-集体照 这道题我得了20分,虽然两个测试点没过,但也蛮开心的 后来看了题解,发现写的有些复杂…题解在源数据中直接进行跳跃取值的方法属实机智 由于我对特殊的第一排和后面的排分开继续逻辑判断,并用了一个全局的大容量vector,导致冗余很大,完全可以申请一个临时vector ","date":"2020-07-23","objectID":"/posts/pat-9/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 53~57","uri":"/posts/pat-9/"},{"categories":["PAT"],"content":"大佬题解 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cstring\u003eusing namespace std; struct node { string name; int height; }; int cmp(struct node a, struct node b) { return a.height != b.height ? a.height \u003e b.height : a.name \u003c b.name; } int main() { int n, k, m; cin \u003e\u003e n \u003e\u003e k; vector\u003cnode\u003e stu(n); for(int i = 0; i \u003c n; i++) { cin \u003e\u003e stu[i].name \u003e\u003e stu[i].height; } sort(stu.begin(), stu.end(), cmp); int t = 0, row = k; while(row) { if(row == k) m = n - n / k * (k - 1); else m = n / k; vector\u003cstring\u003e ans(m); //临时vector ans[m / 2] = stu[t].name; // 左边一列 int j = m / 2 - 1; for(int i = t + 1; i \u003c t + m; i = i + 2) //跳跃取值 ans[j--] = stu[i].name; // 右边一列 j = m / 2 + 1; for(int i = t + 2; i \u003c t + m; i = i + 2) ans[j++] = stu[i].name; // 输出当前排 cout \u003c\u003c ans[0]; for(int i = 1; i \u003c m; i++) cout \u003c\u003c \" \" \u003c\u003c ans[i]; cout \u003c\u003c endl; t = t + m; row--; } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-9/:3:0","tags":["Leetcode-C++"],"title":"PAT-Basic 53~57","uri":"/posts/pat-9/"},{"categories":["PAT"],"content":"菜鸡的题解 typedef struct{ int height; string name; }person, *point_person; int cmp(person a, person b){ if(a.height == b.height){ return a.name \u003c b.name; } return a.height \u003e b.height; } int main(int argc, const char** argv) { int N,K,n,m; scanf(\"%d %d\\n\", \u0026N, \u0026K); n = N/K; m = N%K; int last_row = m+n; vector\u003cperson\u003e data(N); for(int i=0; i\u003cN; i++){ person new_person; cin \u003e\u003e new_person.name \u003e\u003e new_person.height; data[i] = new_person; } sort(data.begin(), data.end(),cmp); vector\u003cstring\u003e shit(m+n,\"0\"); //菜鸡的全局vector,并不好用 int cur = 0, mid; int charge = last_row-K; for(int k=0; k\u003cK; k++){ if(k==0){ mid = last_row/2 +1; --mid; shit[mid] = data[cur++].name; for(int h=1,max = last_row; last_row\u003e0; last_row-=2){ if((mid-h)\u003e=0){ shit[mid-h] = data[cur++].name; } if((mid+h)\u003cmax){ shit[mid+h] = data[cur++].name; } h++; } for(auto i = shit.begin(); i\u003cshit.end(); i++){ if(i == shit.end()-1){ printf(\"%s\\n\", (*i).c_str()); } else{ printf(\"%s \", (*i).c_str()); } } } else{ mid = K/2 +1; --mid; shit[mid] = data[cur++].name; int temp; for(int h=1,max = K,temp = K; temp\u003e0; temp-=2){ if((mid-h)\u003e=0){ shit[mid-h] = data[cur++].name; } if((mid+h)\u003cmax){ shit[mid+h] = data[cur++].name; } h++; } for(auto i = shit.begin(); i\u003cshit.end()-charge; i++){ if(i == shit.end()-1-charge){ printf(\"%s\\n\", (*i).c_str()); } else{ printf(\"%s \", (*i).c_str()); } } } } return 0; } 1056-组合数的和 快乐白给题 #include\u003ccstdio\u003e using namespace std; int main(int argc, const char** argv) { int num; scanf(\"%d\", \u0026num); int sum = 0; int temp; for(int i=0; i\u003cnum; i++){ scanf(\"%d\", \u0026temp); sum += (temp*10+temp)*(num-1); } printf(\"%d\", sum); return 0; } 1057-数零壹 这道题考察 十进制转二进制 的代码实现,运用短除法 ","date":"2020-07-23","objectID":"/posts/pat-9/:4:0","tags":["Leetcode-C++"],"title":"PAT-Basic 53~57","uri":"/posts/pat-9/"},{"categories":["PAT"],"content":"十进制转二进制 #include\u003cstdio.h\u003e int main() { int n; int a[32]={0}; int i,j; while(scanf(\"%d\",\u0026n)!=EOF) //EOF: END OF FILE { i=0; while(n\u003e0) { a[i]=n%2; n=n/2; i++; } for(j=i-1;j\u003e=0;j--) //注意是反向输出 printf(\"%d\",a[j]); printf(\"\\n\"); } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-9/:5:0","tags":["Leetcode-C++"],"title":"PAT-Basic 53~57","uri":"/posts/pat-9/"},{"categories":["PAT"],"content":"AC题解 #include\u003ccstdio\u003e#include\u003cstring\u003e#include\u003ciostream\u003e using namespace std; int main(int argc, const char** argv) { string s; getline(cin,s); int sum=0; for(int i=0; i\u003cs.size(); i++){ if(isalpha(s[i])){ /* if(s[i]\u003c='Z' \u0026\u0026 s[i]\u003e='A'){ sum += s[i]-'A'+1; } else{ sum += s[i]-32-'A'+1; } */ sum += tolower(s[i]) - 'a' + 1; //优化判断 } } int count1 = 0, count0 = 0; while(sum != 0){ if(sum%2 == 1){ count1++; } else{ count0++; } sum = sum/2; } printf(\"%d %d\", count0, count1); return 0; } ","date":"2020-07-23","objectID":"/posts/pat-9/:6:0","tags":["Leetcode-C++"],"title":"PAT-Basic 53~57","uri":"/posts/pat-9/"},{"categories":["PAT"],"content":"B1044-B1052 刷完一半啦!继续冲! 7.23更新 1044-火星数字 这道题有点复杂,需要对数字和字母分别判断,并写两个转换函数 对于判断char是否为数字,可以使用isdigit()函数,对于是否为字母,可以使用isalpha()函数 字符串截取 substr(pos,length); pos为起始位置,length为截取长度 数字 string转int: stoi()函数 ","date":"2020-07-23","objectID":"/posts/pat-8/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"atoi()和stoi() 都是C++的字符处理函数，把数字字符串转换成int输出 头文件都是#include 不同点： atoi()的参数是 const char* ,因此对于一个字符串str我们必须调用 c_str()的方法把这个string转换成 const char类型的,而stoi()的参数是const string,不需要转化为 const char*； 如图： stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！ ","date":"2020-07-23","objectID":"/posts/pat-8/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"CODE #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; string a[13] = {\"tret\", \"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jly\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"}; string b[13] = {\"####\", \"tam\", \"hel\", \"maa\", \"huh\", \"tou\", \"kes\", \"hei\", \"elo\", \"syy\", \"lok\", \"mer\", \"jou\"}; string s; int len; void func1(int t) { if (t / 13) cout \u003c\u003c b[t / 13]; if ((t / 13) \u0026\u0026 (t % 13)) cout \u003c\u003c \" \"; if (t % 13 || t == 0) cout \u003c\u003c a[t % 13]; } void func2() { int t1 = 0, t2 = 0; string s1 = s.substr(0, 3), s2; if (len \u003e 4) s2 = s.substr(4, 3); for (int j = 1; j \u003c= 12; j++) { if (s1 == a[j] || s2 == a[j]) t2 = j; if (s1 == b[j]) t1 = j; } cout \u003c\u003c t1 * 13 + t2; } int main() { int n; cin \u003e\u003e n; getchar(); for (int i = 0; i \u003c n; i++) { getline(cin, s); len = s.length(); if (isdigit(s[0])) func1(stoi(s)); else func2(); cout \u003c\u003c endl; } return 0; } 1045-快速排序 这道压轴题很有意思…(为什么压轴全是数学题哭) 用了两个序列,分别是max序列和min序列 max从前往后取,min序列从后向前取,最后比较两个序列 ","date":"2020-07-23","objectID":"/posts/pat-8/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"柳神 太强了…我实在是想不出来呀 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eint v[100000]; using namespace std; int main() { int n, max = 0, cnt = 0; scanf(\"%d\", \u0026n); vector\u003cint\u003e a(n), b(n); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", \u0026a[i]); b[i] = a[i]; } sort(a.begin(), a.end()); for (int i = 0; i \u003c n; i++) { if(a[i] == b[i] \u0026\u0026 b[i] \u003e max) v[cnt++] = b[i]; if (b[i] \u003e max) max = b[i]; } printf(\"%d\\n\", cnt); for(int i = 0; i \u003c cnt; i++) { if (i != 0) printf(\" \"); printf(\"%d\", v[i]); } printf(\"\\n\"); return 0; } 第二种方法 #include \u003cstdio.h\u003e int main() { int N, count = 0; int array[100000], lmax[100000], rmin[100000]; scanf(\"%d\", \u0026N); for(int i = 0; i \u003c N; i++) scanf(\"%d\", array + i); for(int i = 0, max = i; i \u003c N; i++) lmax[i] = array[i] \u003e= array[max] ? array[max = i] : array[max]; for(int i = N - 1, min = i; i \u003e= 0; i--) rmin[i] = array[i] \u003c= array[min] ? array[min = i] : array[min]; for(int i = 0; i \u003c N; i++) { if(array[i] == lmax[i] \u0026\u0026 array[i] == rmin[i]) count++; else array[i] = 0; } printf(\"%d\\n\", count); for(int i = 0; i \u003c N \u0026\u0026 count; i++) if(array[i]) printf(\"%d%c\", array[i], --count ? ' ' : '\\0'); printf(\"\\n\"); return 0; } 1046-划拳 快乐白给题 #include\u003cstdio.h\u003eusing namespace std; int main(int argc, const char** argv) { int num, acount = 0, bcount = 0; int sum; scanf(\"%d\", \u0026num); int temp1, temp2, temp3, temp4; for(int i=0; i\u003cnum; i++){ scanf(\"%d %d %d %d\", \u0026temp1, \u0026temp2, \u0026temp3, \u0026temp4); sum = temp1+temp3; if(temp2 == sum){ if(temp2 == temp4){ continue; } else{ acount++; } } if(temp4 == sum){ bcount++; } } printf(\"%d %d\", bcount, acount); return 0; } 1047-编程团体赛 快乐白给题 #include\u003cstdio.h\u003eusing namespace std; int main(int argc, const char** argv) { int num; scanf(\"%d\", \u0026num); int id, pid, score; int maxid, maxscore = 0; int hash[10000] = {0}; for(int i=0; i\u003cnum; i++){ scanf(\"%d-%d %d\", \u0026id, \u0026pid, \u0026score); hash[id] += score; if(hash[id] \u003e maxscore){ maxid = id; maxscore = hash[id]; } } printf(\"%d %d\", maxid, maxscore); return 0; } 1048-数字加密 这道题有点没说清楚,我以为位数不够不需要补0,加上判断就AC了 #include\u003ccstdio\u003e#include\u003calgorithm\u003e#include\u003cstring\u003e#include\u003ciostream\u003eusing namespace std; int main(int argc, const char** argv) { string a,b; cin \u003e\u003e a \u003e\u003e b; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int sum, count; if(a.size() \u003e b.size()){ b.append(a.size()-b.size(),'0'); } else{ a.append(b.size()-a.size(),'0'); } count = a.size(); for(int i=0; i\u003ccount; i++){ if((i+1)%2 == 1){ //single sum = (a[i]-'0') + (b[i]-'0'); sum = sum%13; if(sum == 10){ b[i] = 'J'; } else if(sum == 11){ b[i] = 'Q'; } else if(sum == 12){ b[i] = 'K'; } else{ b[i] = sum + '0'; } } else{ sum = (b[i]-'0')-(a[i]-'0'); if(sum \u003c 0){ sum += 10; } b[i] = sum + '0'; } } reverse(b.begin(),b.end()); cout \u003c\u003c b; return 0; } 1049-数列的片段和 又是一道让我伤心的数学题,需要画图,将数据画到一个方格中就可以发现其中的规律 但是由于题目改的更加严谨了,所以需要写一个我看不懂的代码才能AC /* 正经的代码(非AC) */ #include\u003cstdio.h\u003eint main() { int n; scanf(\"%d\", \u0026n); // 数的个数 double sum = 0, num; // 和，数 for (int i = 1; i \u003c= n; ++i) { scanf(\"%lf\", \u0026num); sum += num * i * (n - i + 1); // 数×所在片段数 } printf(\"%.2lf\", sum); // 两位小数 return 0; } /*看不懂但是AC的代码*/ #include \u003ccstdio\u003eusing namespace std; #define ll long long ll n,summ,tmpa; double tpda; int main(){ scanf(\"%lld\",\u0026n); for(ll i=0;i\u003cn;++i){ scanf(\"%lf\",\u0026tpda); tmpa = ((ll)(tpda*10000)+5)/10; //从结果上来看，这么做吧原来的浮点数乘以1000再转为整型 summ += tmpa * (i+1) * (n-i); //为什么要先乘以一万再加5除以十？是因为最低位会产生精度误差。 } //加五除十是为了四舍五入 printf(\"%lld.%02lld\",summ/1000,((summ%1000)+5)/10); return 0; } 1050-螺旋矩阵* 这道题是典型的画图题,但是其中还混杂了一些数学技巧 由于要求 m*n = N,且 m-n 要求最小,这里需要取N的平方跟,在平方跟的基础上递加1,寻找最小的m ","date":"2020-07-23","objectID":"/posts/pat-8/:3:0","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"二维vector 首先对于一维vector的初始化: vector\u003cint\u003e a(N); 如果需要在scanf中对vector读取数据,则必须声明vector长度 这道题需要用到二维vector,正好学习了一下 对于二维的初始化: 第一种方法 vector\u003cvector\u003cint\u003e \u003e b(m, vector\u003cint\u003e(n)); /* m为行数 n为列数*/ 第二种方法-resize() vector\u003cvector\u003cchar\u003e \u003e chos; chos.resize(4, vector\u003cchar\u003e(2)); ","date":"2020-07-23","objectID":"/posts/pat-8/:4:0","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"sqrt() 需要注意的一点是,需要将其中的变量转为double n = sqrt((double)N); ","date":"2020-07-23","objectID":"/posts/pat-8/:5:0","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"sort和qsort的用法与区别 ","date":"2020-07-23","objectID":"/posts/pat-8/:6:0","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"qsort的用法 void qsort(void *base, int nelem, int width, int (*fcmp)(const void *,const void *)); /* *base: 待排序数组首地址 nelem: 数组中待排序元素数量 width: 各元素的占用空间大小 fcmp: 指向函数的指针，用于确定排序的顺序 */ 对int类型数组排序 int num[100]; int cmp ( const void *a , const void *b ) { return *(int *)a - *(int *)b; } qsort(num,100,sizeof(num[0]),cmp); 对char类型数组排序（同int类型） char word[100]; int cmp( const void *a , const void *b ) { return *(char *)a - *(char *)b; } qsort(word,100,sizeof(word[0]),cmp); 对double类型数组排序（特别要注意） double in[100]; int cmp( const void *a , const void *b ) { return *(double *)a \u003e *(double *)b ? 1 : -1; } //返回值的问题，显然cmp返回的是一个整型，所以避免double返回小数而被丢失。 qsort(in,100,sizeof(in[0]),cmp)； ","date":"2020-07-23","objectID":"/posts/pat-8/:6:1","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"sort的用法 头文件： #include \u003calgorithm\u003eusing namespace std; 说明：sort有默认的比较函数，默认是按升序排列。 void sort(RanIt first, RanIt last, Pred pr); /*前两个参数为迭代器指针，分别指向容器的首尾，第三个参数为比较方法。*/ 默认（不写）：对于内置类型，按照升序排列； 标准库自带函数：functional提供了一堆基于模板的比较函数对象： equal_to\u003cType\u003e、not_equal_to\u003cType\u003e、greater\u003cType\u003e、greater_equal\u003cType\u003e、less\u003cType\u003e、less_equal\u003cType\u003e。 升序：sort(begin,end,less\u003cdata-type\u003e()); 降序：sort(begin,end,greater\u003cdata-type\u003e()). 自定义函数： int cmp(const int \u0026a,const int \u0026b){ return a\u003eb } /*Sort中的cmp函数参数可以直接是参与比较的引用类型。*/ ","date":"2020-07-23","objectID":"/posts/pat-8/:6:2","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"区别 qsort与sort的区别： std::sort是一个改进版的qsort. std::sort函数优于qsort的一些特点：对大数组采取9项取样，更完全的三路划分算法，更细致的对不同数组大小采用不同方法排序。 cmp函数和qsort中cmp函数的不同 ​int cmp(const int \u0026a,const int \u0026b){ return a\u003eb } Sort中的cmp函数参数可以直接是参与比较的引用类型，sort可以采用标准库自带的比较函数，而qsort没有。 cmp函数比较时qsort用“-”，而sort用”\u003e”。 sort函数是c++中标准模板库的的函数，在qsort()上已经进行了优化，根据情况的不同可以采用不同的算法，所以较快。 在同样的元素较多和同样的比较条件下，sort()的执行速度都比qsort()要快。另外，sort()是类属函数，可以用于比较任何容器，任何元素，任何条件。使用时需调用algorithm 另外在使用sort函数中的greater和less时,需要iterator头文件 #include\u003citerator\u003e ","date":"2020-07-23","objectID":"/posts/pat-8/:6:3","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"CODE 这道矩阵打印很经典,之前在leetcode上也遇到过,今天算是差不多弄懂了,难点不在于矩阵打印的模板,而是如何分析一个规律性打印,并转换为代码实现的过程 #include \u003calgorithm\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003ccstdio\u003eusing namespace std; int cmp(int a, int b) {return a \u003e b;} int main() { int N, m, n, t = 0; scanf(\"%d\", \u0026N); for (n = sqrt((double)N); n \u003e= 1; n--) { if (N % n == 0) { m = N / n; break; } } vector\u003cint\u003e a(N); for (int i = 0; i \u003c N; i++) scanf(\"%d\", \u0026a[i]); sort(a.begin(), a.end(), cmp); vector\u003cvector\u003cint\u003e \u003e b(m, vector\u003cint\u003e(n)); int level = m / 2 + m % 2; for (int i = 0; i \u003c level; i++) { for (int j = i; j \u003c= n - 1 - i \u0026\u0026 t \u003c= N - 1; j++) b[i][j] = a[t++]; for (int j = i + 1; j \u003c= m - 2 - i \u0026\u0026 t \u003c= N - 1; j++) b[j][n - 1 - i] = a[t++]; for (int j = n - i - 1; j \u003e= i \u0026\u0026 t \u003c= N - 1; j--) b[m - 1 - i][j] = a[t++]; for (int j = m - 2 - i; j \u003e= i + 1 \u0026\u0026 t \u003c= N - 1; j--) b[j][i] = a[t++]; } for (int i = 0; i \u003c m; i++) { for (int j = 0 ; j \u003c n; j++) { printf(\"%d\", b[i][j]); if (j != n - 1) printf(\" \"); } printf(\"\\n\"); } return 0; } 1051-复数乘法 这道题也挺有意思(难)的 坑点主要在精度范围,如果保留两位小数,则当小于0.01时,会表示为0.00,这时需要赋值为0,并且需要用到绝对值abs()函数 #include\u003ccstdio\u003e#include\u003ccmath\u003eusing namespace std; int main(int argc, const char** argv) { double s1,s2,s3,s4; scanf(\"%lf %lf %lf %lf\",\u0026s1, \u0026s2, \u0026s3, \u0026s4); double A,B; A = s1*s3*cos(s2+s4); B = s1*s3*sin(s2+s4); if(abs(A) \u003c 0.01){ A = 0; } if(abs(B) \u003c 0.01){ B = 0; } if(B \u003e= 0){ printf(\"%.2f+%.2fi\", A, B); } else{ printf(\"%.2f%.2fi\", A, B); } return 0; } 1052-卖个萌 这道题一个点是格式输入 对于\"[╮][╭][o][~][/~][\u003c][\u003e]“字符的输入 可以使用类似正则的表达式取字符 if(c == '['){ scanf(\"%[^]]\", \u0026data); } 这里意味着从 “[” 开始取字符串取到 “]” 为止 并且对于char数组中添加字符串,需要赋初始值为’\\0' 这样可以在字符串取出时,遇到结束符 char data[3][10][5] = {'\\0'}; 另外对于最内层的字符串,需要使用 *data[m][n] 访问 ","date":"2020-07-23","objectID":"/posts/pat-8/:7:0","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"柳神解法 这vector-string和substr()用的是真的酷炫,学到了! 另外注意转义字符: @/@ 的 ‘' 是转义字符，想要输出 ‘' 就要用 ‘\\’ 表示 #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int main() { vector\u003cvector\u003cstring\u003e \u003e v; for(int i = 0; i \u003c 3; i++) { string s; getline(cin, s); vector\u003cstring\u003e row; int j = 0, k = 0; while(j \u003c s.length()) { if(s[j] == '[') { while(k++ \u003c s.length()) { if(s[k] == ']') { row.push_back(s.substr(j+1, k-j-1)); break; } } } j++; } v.push_back(row); } int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) { int a, b, c, d, e; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d \u003e\u003e e; if(a \u003e v[0].size() || b \u003e v[1].size() || c \u003e v[2].size() || d \u003e v[1].size() || e \u003e v[0].size() || a \u003c 1 || b \u003c 1 || c \u003c 1 || d \u003c 1 || e \u003c 1) { cout \u003c\u003c \"Are you kidding me? @\\\\/@\" \u003c\u003c endl; continue; } cout \u003c\u003c v[0][a-1] \u003c\u003c \"(\" \u003c\u003c v[1][b-1] \u003c\u003c v[2][c-1] \u003c\u003c v[1][d-1] \u003c\u003c \")\" \u003c\u003c v[0][e-1] \u003c\u003c endl; } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-8/:8:0","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"第二种解法 #include\u003ccstdio\u003e#include\u003ccstring\u003eusing namespace std; int main(int argc, const char** argv) { int num; int n[5]; char c; char data[3][10][5] = {'\\0'}; for(int i=0; i\u003c3; i++){ for(int index=0; (c = getchar())!='\\n';){ if(c == '['){ scanf(\"%[^]]\", data[i][index++]); } } } scanf(\"%d\", \u0026num); for(int j=0; j\u003cnum; j++){ for(int k=0; k\u003c5; k++){ scanf(\"%d\", n+k); --n[k]; } if(n[0] \u003c 0 || n[0] \u003e 9 || !(*data[0][n[0]]) || n[1] \u003c 0 || n[1] \u003e 9 || !(*data[1][n[1]]) || n[2] \u003c 0 || n[2] \u003e 9 || !(*data[2][n[2]]) || n[3] \u003c 0 || n[3] \u003e 9 || !(*data[1][n[3]]) || n[4] \u003c 0 || n[4] \u003e 9 || !(*data[0][n[4]])) puts(\"Are you kidding me? @\\\\/@\"); else{ printf(\"%s(%s%s%s)%s\\n\", data[0][n[0]], data[1][n[1]],data[2][n[2]], data[1][n[3]], data[0][n[4]]); } } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-8/:9:0","tags":["Leetcode-C++"],"title":"PAT-Basic 44~52","uri":"/posts/pat-8/"},{"categories":["PAT"],"content":"B1041-B1043 7.23更新 下午看了俄罗斯的\u003c太空第一步\u003e,之前也看过几个俄系科幻片,不得不说俄国特效做的一点都不比美国拍的那些差,但都有一个通病就是剧情节奏掌握的不是很好,但从故事角度来说,还是很震撼的,不得不佩服苏联的勇气,战斗民族是真的勇,看到最后有一种历经磨难艰险终究胜利的鼓舞,生活也是一样的道理,总会有各种各样难以预测的错误和失败,但只要一直去坚持,一直抱有希望和信心,就一定会造就新的奇迹 1041-考试座位号 这道题提醒了我一个知识点: 对于字符串的复制,不可以直接用等号赋值,需要用到strcpy() 另外在结构体的构造中,尾部最好留有一个指针和一个变量,这样 malloc 还能清晰一点,并且使用方便 ","date":"2020-07-23","objectID":"/posts/pat-7/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 41~43","uri":"/posts/pat-7/"},{"categories":["PAT"],"content":"柳神代码 运用了string-hash 很好的思路,省了结构体 #include \u003ciostream\u003eusing namespace std; int main() { string stu[1005][2], s1, s2; int n, m, t; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) { cin \u003e\u003e s1 \u003e\u003e t \u003e\u003e s2; stu[t][0] = s1; stu[t][1] = s2; } cin \u003e\u003e m; for(int i = 0; i \u003c m; i++) { cin \u003e\u003e t; cout \u003c\u003c stu[t][0] \u003c\u003c \" \" \u003c\u003c stu[t][1] \u003c\u003c endl; } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-7/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 41~43","uri":"/posts/pat-7/"},{"categories":["PAT"],"content":"菜鸡的代码 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cmap\u003e#include\u003cstring.h\u003e using namespace std; typedef struct{ char ida[17]; int sitid; }*person,node; int main(int argc, const char** argv) { int num; scanf(\"%d\", \u0026num); map\u003cint,node\u003emp1; char tempid[17]; int tryid,sitid; for(int i=0; i\u003cnum; i++){ scanf(\"%s %d %d\", \u0026tempid, \u0026tryid, \u0026sitid); person person_temp = (person)malloc(sizeof(node)); person_temp-\u003esitid = sitid; strcpy(person_temp-\u003eida, tempid); mp1[tryid] = *person_temp; } int query,queryid; scanf(\"%d\", \u0026query); for(int k=0; k\u003cquery; k++){ scanf(\"%d\", \u0026queryid); printf(\"%s %d\\n\", mp1[queryid].ida, mp1[queryid].sitid); } return 0; } 1042-字符统计 一道快乐的哈希白给题,不过这道题虽然AC了,但代码写的实在是冗余的不行 下面总结一下优化的点 截止到目前为止,pat中有许多题会涉及到字母的判断和大小写,而c在\u003cctype.h\u003e中提供了对于字母处理的函数 对于相同值的情况取更小,可以从后向前进行处理 ","date":"2020-07-23","objectID":"/posts/pat-7/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 41~43","uri":"/posts/pat-7/"},{"categories":["PAT"],"content":"菜鸡的冗余代码 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cstring\u003e#include\u003ciostream\u003e using namespace std; int main(int argc, const char** argv) { string s; int max = 0; int maxid; int tempid; getline(cin, s); int hashmap[500] = {0}; for(int i=0; i\u003cs.size(); i++){ if(s[i]\u003e= 'A' \u0026\u0026 s[i]\u003c= 'Z'){ //大写字母 tempid = s[i]+32-'0'; hashmap[tempid]++; if(max \u003c hashmap[tempid]){ max = hashmap[tempid]; maxid = tempid; } if(max == hashmap[tempid]){ maxid = maxid \u003c tempid ? maxid:tempid; } } else if(s[i]\u003e='a' \u0026\u0026 s[i]\u003c='z'){ tempid = s[i]-'0'; hashmap[tempid]++; if(max \u003c hashmap[tempid]){ max = hashmap[tempid]; maxid = tempid; } if(max == hashmap[tempid]){ maxid = maxid \u003c tempid ? maxid:tempid; } } } printf(\"%c %d\",(char)(maxid+'0'), max); return 0; } ","date":"2020-07-23","objectID":"/posts/pat-7/:3:0","tags":["Leetcode-C++"],"title":"PAT-Basic 41~43","uri":"/posts/pat-7/"},{"categories":["PAT"],"content":"大佬教我写代码 #include \u003cstdio.h\u003e#include \u003cctype.h\u003e int main() { char c; int count[26] = {0}, max = 25; while((c = getchar()) != '\\n') if(isalpha(c)) //判断是否为字母 count[tolower(c) - 'a']++; for(int i = 25; i \u003e= 0; i--) if(count[i] \u003e= count[max]) max = i; printf(\"%c %d\", max + 'a', count[max]); return 0; } 1043-输出PATest 这道题也是虽然AC了,但是写的非常麻烦 看了大佬的题解之后…感觉大佬写的太精妙了! 大佬确定了需要固定输出的字符串,在输出中,按照这个字符串模板进行输出,一个字符串内部的for循环就可以搞定 ","date":"2020-07-23","objectID":"/posts/pat-7/:4:0","tags":["Leetcode-C++"],"title":"PAT-Basic 41~43","uri":"/posts/pat-7/"},{"categories":["PAT"],"content":"菜鸡的冗余代码 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cmap\u003e#include\u003ciostream\u003e using namespace std; int main(int argc, const char** argv) { map\u003cchar,int\u003emp; mp['P'] = 0,mp['A'] = 0,mp['T'] = 0; mp['e'] = 0,mp['s'] = 0,mp['t'] = 0; string s; getline(cin, s); int count = 0; for(int i=0; i\u003cs.size(); i++){ if(s[i] == 'P'){ //PATest mp['P']++; count++; continue; } if(s[i] == 'A'){ //PATest mp['A']++; count++; continue; } if(s[i] == 'T'){ //PATest mp['T']++; count++; continue; } if(s[i] == 'e'){ //PATest mp['e']++; count++; continue; } if(s[i] == 's'){ //PATest mp['s']++; count++; continue; } if(s[i] == 't'){ //PATest mp['t']++; count++; continue; } } int j = 0; while(j \u003c count){ if(mp['P']){ printf(\"P\"); mp['P']--; j++; } if(mp['A']){ printf(\"A\"); mp['A']--; j++; } if(mp['T']){ printf(\"T\"); mp['T']--; j++; } if(mp['e']){ printf(\"e\"); mp['e']--; j++; } if(mp['s']){ printf(\"s\"); mp['s']--; j++; } if(mp['t']){ printf(\"t\"); mp['t']--; j++; } } return 0; } ","date":"2020-07-23","objectID":"/posts/pat-7/:5:0","tags":["Leetcode-C++"],"title":"PAT-Basic 41~43","uri":"/posts/pat-7/"},{"categories":["PAT"],"content":"大佬教我写代码 #include \u003cstdio.h\u003e int main() { char c, *str = \"PATest\"; /* use as index for count[] */ int i, flag = 1, count[128] = {0}; /* for each ASCII char */ /* Read and count numbers for every character */ while((c = getchar()) != '\\n') count[(int)c]++; /* Print any character in \"PATest\" if it is still left */ while(flag) for(i = 0, flag = 0; i \u003c 6; i++) if(count[(int)str[i]]-- \u003e 0) /* Check the number left */ putchar(str[i]), flag = 1; return 0; } ","date":"2020-07-23","objectID":"/posts/pat-7/:6:0","tags":["Leetcode-C++"],"title":"PAT-Basic 41~43","uri":"/posts/pat-7/"},{"categories":["PAT"],"content":"柳神大佬 用了快乐map! #include \u003ciostream\u003eusing namespace std; int main() { int map[128] = {0}, c; while ((c = cin.get()) != EOF) map[c]++; while (map['P'] \u003e 0 || map['A'] \u003e 0 || map['T'] \u003e 0 || map['e'] \u003e 0 || map['s'] \u003e 0 || map['t'] \u003e 0) { if (map['P']-- \u003e 0) cout \u003c\u003c 'P'; if (map['A']-- \u003e 0) cout \u003c\u003c 'A'; if (map['T']-- \u003e 0) cout \u003c\u003c 'T'; if (map['e']-- \u003e 0) cout \u003c\u003c 'e'; if (map['s']-- \u003e 0) cout \u003c\u003c 's'; if (map['t']-- \u003e 0) cout \u003c\u003c 't'; } return 0; } 头文件 ctype.h ","date":"2020-07-23","objectID":"/posts/pat-7/:7:0","tags":["Leetcode-C++"],"title":"PAT-Basic 41~43","uri":"/posts/pat-7/"},{"categories":["PAT"],"content":"判断函数 从上面这两道题,我发现这个头文件很有用处,记录一下 另外对于字符串转变为hash的处理过程,可以用getchar()函数进行处理,而不需要额外开一个string空间 int isalnum(int c) 该函数检查所传的字符是否是字母和数字。 int isalpha(int c) 该函数检查所传的字符是否是字母。 int iscntrl(int c) 该函数检查所传的字符是否是控制字符。 int isdigit(int c) 该函数检查所传的字符是否是十进制数字。 int isgraph(int c) 该函数检查所传的字符是否有图形表示法。 int islower(int c) 该函数检查所传的字符是否是小写字母。 int isprint(int c) 该函数检查所传的字符是否是可打印的。 int ispunct(int c) 该函数检查所传的字符是否是标点符号字符。 int isspace(int c) 该函数检查所传的字符是否是空白字符。 int isupper(int c) 该函数检查所传的字符是否是大写字母。 int isxdigit(int c) 该函数检查所传的字符是否是十六进制数字。 ","date":"2020-07-23","objectID":"/posts/pat-7/:8:0","tags":["Leetcode-C++"],"title":"PAT-Basic 41~43","uri":"/posts/pat-7/"},{"categories":["PAT"],"content":"转换函数 int tolower(int c) 该函数把大写字母转换为小写字母。 int toupper(int c) 该函数把小写字母转换为大写字母。 ","date":"2020-07-23","objectID":"/posts/pat-7/:9:0","tags":["Leetcode-C++"],"title":"PAT-Basic 41~43","uri":"/posts/pat-7/"},{"categories":["PAT"],"content":"B1036-B1040 一个半小时前四道题AC,第五道数学题挂了…我爱数学! 希望25号能拿个满分 7.23更新 1036-跟奥巴马一起编程 跟之前沙漏题一个套路,printf就完事了 #include\u003cstdio.h\u003eusing namespace std; int main(int argc, const char** argv) { int num; char signal; scanf(\"%d %c\", \u0026num, \u0026signal); int row = (num+1)/2; int j; for(j=0; j\u003cnum; j++){ printf(\"%c\", signal); } printf(\"\\n\"); for(int i=0; (i \u003c row-2); i++){ printf(\"%c\", signal); for(int k=0; k\u003c(num-2); k++){ printf(\" \"); } printf(\"%c\\n\", signal); } for(j=0; j\u003cnum; j++){ printf(\"%c\", signal); } return 0; } 1037-在霍格沃茨找零钱 经典送分白给题 #include\u003cstdio.h\u003eusing namespace std; int main(int argc, const char** argv) { long int data[3]; int s1,s2,s3,k1,k2,k3; scanf(\"%d.%d.%d %d.%d.%d\", \u0026s1,\u0026s2,\u0026s3,\u0026k1,\u0026k2,\u0026k3); long int sum1,sum2; int cache = 17*29; sum1 = s1*cache + s2*29 + s3; sum2 = k1*cache + k2*29 + k3; int change = sum2-sum1; bool shit = false; if(change \u003c 0){ shit = true; change = abs(change); } data[0] = change/cache; change %= cache; data[1] = change/29; change %= 29; data[2] = change; if(shit){ printf(\"-\"); } printf(\"%d.%d.%d\", data[0], data[1], data[2]); return 0; } 1038-统计同成绩学生 快乐hash #include\u003cstdio.h\u003e int main(int argc, const char** argv) { int hashdata[100000] = {0}; int num; scanf(\"%d\",\u0026num); int temp; for(int i=0; i\u003cnum; i++){ scanf(\"%d\",\u0026temp); hashdata[temp]++; } int query; scanf(\"%d\", \u0026query); for(int j=0; j\u003cquery; j++){ scanf(\"%d\", \u0026temp); if(j != query-1){ printf(\"%d \", hashdata[temp]); } else{ printf(\"%d\", hashdata[temp]); } } return 0; } 1039-到底买不买 这道题跟之前那些操作字符串一个套路 #include\u003cstdio.h\u003e#include\u003cstring\u003e#include\u003ciostream\u003e using namespace std; int main(int argc, const char** argv) { int data[1000] = {0}; bool shit = false; string s1,s2; getline(cin, s1); getline(cin, s2); int sum = s1.size(); int count = 0; for(int j=0 ; j\u003cs1.size(); j++){ data[s1[j]]++; } for(int i=0; i\u003cs2.size(); i++){ if(data[s2[i]] == 0){ //没有找到 shit = true; count++; } else{ data[s2[i]]--; sum--; } } if(shit){ printf(\"No %d\", count); } else{ printf(\"Yes %d\", sum); } return 0; } 1040-有几个PAT 这道题我一开始想用三指针,不过写着写着就晕了,而且还少算了很多情况 无奈看了一眼题解…发现这道题这么真实吗,就三行代码… 我发现最后一道压轴题,不是数学问题就是排序实现问题,等我再去看看算法笔记 每个A对应的PA组合数量是A之前P的数量， 每个T对应的PAT组合数量是T之前所有A对应的PA组合数量的累加 所有的PAT组合数量是所有T对应的PAT组合数量的累加 感觉这道题有点动态规划那味儿了 #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main() { string s; cin \u003e\u003e s; int len = s.length(), result = 0, countp = 0, countt = 0; for (int i = 0; i \u003c len; i++) { if (s[i] == 'T') countt++; } for (int i = 0; i \u003c len; i++) { if (s[i] == 'P') countp++; if (s[i] == 'T') countt--; if (s[i] == 'A') result = (result + (countp * countt) % 1000000007) % 1000000007; } cout \u003c\u003c result; return 0; } ","date":"2020-07-23","objectID":"/posts/pat-6/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 36~40","uri":"/posts/pat-6/"},{"categories":["C++"],"content":"C++ stoi()函数用法 头文件: #include \u003cstring\u003e 用法： stoi（字符串，起始位置，n进制） 将 n 进制的字符串转化为 10 进制 //将字符串 str 从 0 位置开始到末尾的 2 进制转换为十进制 stoi(str, 0, 2); 实例: #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main() { string str = \"1010\"; int a = stoi(str, 0, 2); cout \u003c\u003c a \u003c\u003c endl; return 0; // 输出 10 } ","date":"2020-07-20","objectID":"/posts/CPP-6/:0:0","tags":["C++基础语法"],"title":"C++ stoi()函数","uri":"/posts/CPP-6/"},{"categories":["C++"],"content":"C++ transform()函数用法 transform函数的作用是：将某操作应用于指定范围的每个元素 transform函数有两个重载版本： 重载版本-1 transform(first,last,result,op); //first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。 利用transform函数将一个给定的字符串中的小写字母改写成大写字母，并将结果保存在一个叫second的数组里，原字符串内容不变。 #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; char op(char ch) { if(ch\u003e='A'\u0026\u0026ch\u003c='Z') return ch+32; else return ch; } int main() { string first,second; cin\u003e\u003efirst; second.resize(first.size()); transform(first.begin(),first.end(),second.begin(),op); cout\u003c\u003csecond\u003c\u003cendl; return 0; } ","date":"2020-07-19","objectID":"/posts/CPP-5/:0:0","tags":["C++基础语法"],"title":"C++ transform()","uri":"/posts/CPP-5/"},{"categories":["C++"],"content":"利用::func()实现转换 transform(str.begin(),str.end(),str.begin(),::tolower); transform(str.begin(),str.end(),str.begin(),::toupper); 重载版本-2 transform(first1,last1,first2,result,binary_op); //first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。 注意：第二个重载版本必须要保证两个容器的元素个数相等才行，否则会抛出异常。 给你两个vector向量（元素个数相等），请你利用transform函数将两个vector的每个元素相乘，并输出相乘的结果。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eusing namespace std; void print(int \u0026elem){cout\u003c\u003celem\u003c\u003c\" \";} int op(int a,int b){return a*b;} int main() { vector \u003cint\u003e A,B,SUM; int n; cin\u003e\u003en; for(int i=0;i\u003cn;i++) { int t; cin\u003e\u003et; A.push_back(t); } for(int i=0;i\u003cn;i++) { int t; cin\u003e\u003et; B.push_back(t); } SUM.resize(n); transform(A.begin(),A.end(),B.begin(),SUM.begin(),op); for_each(SUM.begin(),SUM.end(),print); return 0; } ","date":"2020-07-19","objectID":"/posts/CPP-5/:1:0","tags":["C++基础语法"],"title":"C++ transform()","uri":"/posts/CPP-5/"},{"categories":["PAT"],"content":"B1029-B1035 前几天学完了c++和STL的基础,今天开始换c++写,发现解题速度提升很明显,由于c++向下兼容c,所以简直是各种语法糖呀,磨刀不误砍柴工! 2020-07-19 优化题解 1029-旧键盘 这道题收获了一个大坑: 由于这道题其中的一个限制是,没有重复元素,所以我就想当然的用了set,由于set本身有序,而题中要求是按照插入顺序,我就换成了unordered_set,我想这应该没问题了吧,结果就是无法通过… 后来看到一篇blog才发现,无序set并不是根据insert顺序排列，而是根据元素hash值排列 字符转大小写用toupper和tolower，在cctype头文件里，如果不包含头文件 cctype 仅仅有 iostream 也是可以的 对于string.find(x),如果没找到,则返回\"string::npos\" #include\u003cstdio.h\u003e#include\u003cstring\u003e#include\u003ciostream\u003eusing namespace std; int main(){ string s1, s2,ans; cin \u003e\u003e s1 \u003e\u003e s2; for (int i = 0; i \u003c s1.length(); i++){ if (s2.find(s1[i]) == string::npos \u0026\u0026 ans.find(toupper(s1[i])) == string::npos){ ans += toupper(s1[i]); } } cout \u003c\u003c ans; } 1030-完美数列 这道题直接用c做的,感觉还算简单,不过最后有一个测试点超时了,原因在于比较算法没有优化… 以后这种寻找最大最小值的函数,还是要多思考 ","date":"2020-07-19","objectID":"/posts/pat-5/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 29~35","uri":"/posts/pat-5/"},{"categories":["PAT"],"content":"C++ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eusing namespace std; int main() { int n; long long p; scanf(\"%d%lld\", \u0026n, \u0026p); vector\u003cint\u003e v(n); for (int i = 0; i \u003c n; i++) cin \u003e\u003e v[i]; sort(v.begin(), v.end()); int result = 0, temp = 0; for (int i = 0; i \u003c n; i++) { for (int j = i + result; j \u003c n; j++) { if (v[j] \u003c= v[i] * p) { temp = j - i + 1; if (temp \u003e result) result = temp; } else { break; } } } cout \u003c\u003c result; return 0; } ","date":"2020-07-19","objectID":"/posts/pat-5/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 29~35","uri":"/posts/pat-5/"},{"categories":["PAT"],"content":"C #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e int cmp(const void *a, const void *b){ int* m = (int*)a; int* n = (int*)b; return *m-*n; } int main(int argc, const char** argv) { int data[100000]; int N,p; scanf(\"%d %d\", \u0026N, \u0026p); for(int i=0; i\u003cN; i++){ scanf(\"%d\", \u0026data[i]); } qsort(data, N, sizeof(int), cmp); int max_count = 0; /* for(int i=0; i\u003cN; i++){ for(int j=0; j\u003cN; j++){ if(data[j] \u003c= 1L*p*data[i]){ if(max_count \u003c (j-i+1)){ max_count = (j-i+1); } } } } */ for(int first=0,last=0; last\u003cN \u0026\u0026 max_count\u003c N-first; first++){ while(last\u003cN \u0026\u0026 data[last] \u003c= 1L*data[first]*p){ last++; } if(max_count\u003c last-first){ max_count = last-first; } } printf(\"%d\", max_count); return 0; } 1031 查验身份证 这道题…我一开始用的string,后来少写一个字母判断的逻辑,结果就崩了… 以后先在纸上写好需要什么判断逻辑和限制,再敲代码 ","date":"2020-07-19","objectID":"/posts/pat-5/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 29~35","uri":"/posts/pat-5/"},{"categories":["PAT"],"content":"C++ #include \u003ciostream\u003eusing namespace std; int a[17] = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2}; int b[11] = {1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2}; string s; bool isTrue() { int sum = 0; for (int i = 0; i \u003c 17; i++) { if (s[i] \u003c '0' || s[i] \u003e '9') return false; sum += (s[i] - '0') * a[i]; } int temp = (s[17] == 'X') ? 10 : (s[17] - '0'); return b[sum%11] == temp; } int main() { int n, flag = 0; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e s; if (!isTrue()) { cout \u003c\u003c s \u003c\u003c endl; flag = 1; } } if (flag == 0) cout \u003c\u003c \"All passed\"; return 0; } ","date":"2020-07-19","objectID":"/posts/pat-5/:3:0","tags":["Leetcode-C++"],"title":"PAT-Basic 29~35","uri":"/posts/pat-5/"},{"categories":["PAT"],"content":"C #include\u003cstdio.h\u003e #include\u003cstring.h\u003eint main() { int N; scanf(\"%d\",\u0026N); int quan[18] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2}; char jiaoyan[11] = {'1','0','X','9','8','7','6','5','4','3','2'}; bool flag = true; char id[20]; for(int i = 0;i \u003c N;i++) { scanf(\"%s\",id); int j,sum = 0; for(j = 0;j\u003c17;j++) { if(!(id[j] \u003e= '0'\u0026\u0026id[j] \u003c= '9')) break; sum += (id[j]-'0')*quan[j]; } if(j\u003c17) { flag = false; printf(\"%s\\n\",id); } else{ if(jiaoyan[sum % 11] != id[17]) { flag = false; printf(\"%s\\n\",id); } } } if(flag == true) printf(\"All passed\\n\"); return 0; } 1032-挖掘机技术哪家强 一道经典快乐白给题 #include\u003cstdio.h\u003e#include\u003cmap\u003e using namespace std; int main(int argc, const char** argv) { int num; int max = 0; int maxid; scanf(\"%d\", \u0026num); map\u003cint,int\u003e map1; int first,second; for(int i=0; i\u003cnum ;i++){ scanf(\"%d %d\",\u0026first, \u0026second); map1[first] += second; if(max \u003c map1[first]){ maxid = first; max = map1[first]; } } printf(\"%d %d\", maxid, max); return 0; } 1033-旧键盘打字 这道题也是不算难,但这逻辑给我整的不会写了,改了好久才AC #include\u003cstdio.h\u003e#include\u003cmap\u003e#include\u003cstring\u003e#include\u003ciostream\u003e using namespace std; int main(int argc, const char** argv) { bool has = false; string s1; getline(cin,s1); string s2; getline(cin,s2); bool shitup = false; if(s1.find('+') != string::npos){ shitup = true; } for(int j=0; j\u003cs2.size(); j++){ char a = s2[j]; if(a\u003e='A' \u0026\u0026 a\u003c='Z' \u0026\u0026 shitup){ continue; } if(s1.find(a) == string::npos){ if(a\u003e='a' \u0026\u0026 a\u003c='z'){ if(s1.find(a-32) != string::npos){ continue; } } printf(\"%c\",a); has = true; } } if(has == false){ printf(\"\\n\"); } return 0; } 1034-有理数四则运算 这道题我认输,刷到现在为止感觉最难受的一道题,真要是考试遇到这样的题,我心态就gg了 如果总结这道题的技巧,那就是提前在纸上写好完整逻辑 另外将题目中的逻辑,以及输出进行模块化,这道题以后常回家看看 ","date":"2020-07-19","objectID":"/posts/pat-5/:4:0","tags":["Leetcode-C++"],"title":"PAT-Basic 29~35","uri":"/posts/pat-5/"},{"categories":["PAT"],"content":"最大公约数 一个很重要的计算模板 int gcd(int a, int b){ if(b == 0){ return a; } else{ return gcd(b, a%b); } } ","date":"2020-07-19","objectID":"/posts/pat-5/:5:0","tags":["Leetcode-C++"],"title":"PAT-Basic 29~35","uri":"/posts/pat-5/"},{"categories":["PAT"],"content":"CODE 这个题打印的思路很棒，直接在函数内部按步骤打印，而不需要返回完整的字符串最后一起打印 #include \u003cstdio.h\u003e#include \u003ciostream\u003e#include \u003ccmath\u003eusing namespace std; long long a, b, c, d; long long gcd(long long t1, long long t2) { return t2 == 0 ? t1 : gcd(t2, t1 % t2); } void func(long long m, long long n) { if (m * n == 0) { printf(\"%s\", n == 0 ? \"Inf\" : \"0\"); return ; } bool flag = ((m \u003c 0 \u0026\u0026 n \u003e 0) || (m \u003e 0 \u0026\u0026 n \u003c 0)); m = abs(m); n = abs(n); long long x = m / n; printf(\"%s\", flag ? \"(-\" : \"\"); if (x != 0) printf(\"%lld\", x); if (m % n == 0) { if(flag) printf(\")\"); return ; } if (x != 0) printf(\" \"); m = m - x * n; long long t = gcd(m, n); m = m / t; n = n / t; printf(\"%lld/%lld%s\", m, n, flag ? \")\" : \"\"); } int main() { scanf(\"%lld/%lld %lld/%lld\", \u0026a, \u0026b, \u0026c, \u0026d); func(a, b); printf(\" + \"); func(c, d); printf(\" = \"); func(a * d + b * c, b * d); printf(\"\\n\"); func(a, b); printf(\" - \"); func(c, d); printf(\" = \"); func(a * d - b * c, b * d); printf(\"\\n\"); func(a, b); printf(\" * \"); func(c, d); printf(\" = \"); func(a * c, b * d); printf(\"\\n\"); func(a, b); printf(\" / \"); func(c, d); printf(\" = \"); func(a * d, b * c); return 0; } 1035-插入与归并* 度过了上一题对自己的否定,看到这道题之后我再次进入了人生的思考之中… 原来还考排序算法的实现啊…然后现去复习了一会排序 这道题有一个很精妙的处理技巧,那就是对于插入排序,由于前半段有序,而题中要求输出再迭代一轮的数据,题中直接进行有序段长度加1,利用sort函数进行排序 不过对于归并排序,就只能一遍遍模拟了,利用了一个flag来控制循环,使得最后多运行一次 这是一道很棒的题!对排序的理解有很大帮助,要多复习这道题 22号模拟考的这道题，我当场就傻掉了…太难了… #include\u003ccstdio\u003e#include\u003calgorithm\u003eusing namespace std; int main(){ int n; scanf(\"%d\",\u0026n); int a[n]; int b[n]; for(int i=0 ;i\u003cn ;i++){ scanf(\"%d\",\u0026a[i]); } for(int i=0 ;i\u003cn ;i++){ scanf(\"%d\",\u0026b[i]); } int i,j; for(i=0 ;i\u003cn-1 \u0026\u0026 b[i+1]\u003e=b[i] ;i++); //i记录了第一个相同元素的位置 for(j=i+1 ;j\u003cn \u0026\u0026 a[j]==b[j];j++); //j记录了最后一个相同元素的位置+1 if(j==n){ //如果最后一个相同的位置是n-1 那么说明是插入排序 printf(\"Insertion Sort\\n\"); sort(a,a+i+2); }else{ printf(\"Merge Sort\\n\"); int k = 1; //下一次进行排序的子序列长度是2*k int flag = 1; //设置flag变量后，模拟归并过程。直到达到给出的状态，然后再进行一次归并，将结果输出即可。 while(flag) { flag = 0; for (i = 0; i \u003c n; i++) { if (a[i] != b[i]) flag = 1; } k = k * 2; for (i = 0; i \u003c n / k; i++){ sort(a + i * k, a + (i + 1) * k); } sort(a + n / k * k, a + n); } } for(int i=0 ;i\u003cn-1 ;i++){ printf(\"%d \",a[i]); } printf(\"%d\\n\",a[n-1]); return 0; } ","date":"2020-07-19","objectID":"/posts/pat-5/:6:0","tags":["Leetcode-C++"],"title":"PAT-Basic 29~35","uri":"/posts/pat-5/"},{"categories":["C++"],"content":"算法笔记知识点汇总-C++ STL 7.18更新完成 这里为了精简一点,所以只记录一些个人觉得重要的东西,由于是第一遍学,所以相对基础 在STL容器中,只有vector和string支持 *(it+i)的访问方式 vector 向量,变长数组 对于定义STL容器,方法都一样 vector\u003cint\u003e vector1; 迭代器,方法也一样 vector\u003cint\u003e :: iterator it; 如果其中填装的结构也是容器,则需要注意,在括号后要加入一个空格,以区分 « 否则编译会出错 vector \u003cvector\u003cint\u003e \u003e vector1; ","date":"2020-07-18","objectID":"/posts/CPP-4/:0:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"函数操作 push_back(): 在vector后面添加一个元素 pop_back(): 删除vector尾元素 size(): 获得元素个数 clear(): 清空元素 insert(it, x): 在迭代器it处,插入元素x erase(it): 删除迭代器处的元素 erase(first, last): 删除first到last之间的元素(前闭后开,first,last为迭代器) set 集合:内部自动有序,且不含重复元素的集合 底层实现为红黑树,也可以使用unordered_set容器,底层实现为散列,速度比set快很多 ","date":"2020-07-18","objectID":"/posts/CPP-4/:1:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"函数操作 insert(x): 将x元素插入到set中 find(value): 查找值为value的元素,并返回迭代器 erase(x): 删除迭代器对应的元素 erase(value): 删除值为value的元素 erase(first,last) size() clear() string c++对char[]进行封装,从而产生string类型 对于在printf中输出string,可以使用c_str()函数 string s = \"hello world\"; printf(\"%s\", s.c_str()); 对于string的加法,代表两个string进行拼接 而对于两个string的比较符号,比较规则为字典序,与char[]的比较规则相同 ","date":"2020-07-18","objectID":"/posts/CPP-4/:2:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"操作函数 length(),size() insert(pos,string) insert(it1,it2,it3): it为被插入字符串的欲插入位置,it2,it3为待插入字符串的起始和终止位置迭代器(前闭后开) erase(it),erase(first,last) erase(pos, length): 从起始位置pos开始,删除length个元素 substr(pos, length): 从pos位置开始,截取length长度元素,并返回(字符串并不会发生改变) string::npos 是一个常数,作为find函数失配时的返回值 find(str2): 如果str2为str的字串,返回其在str中的第一次出现的位置 if(str.find(str2) != string::npos){ /*code*/ } replace(pos, length, str2): 将str从pos位置开始,长度为length的字串替换为str2 map 映射,字典,键值唯一 map\u003cstring int\u003e mp; map\u003cset\u003cint\u003e string\u003e mp2; 访问键和对应的值 it-\u003efirst //访问键 it-\u003esecond //访问值 由于map底层为红黑树实现,因此键会从大到小进行排列自动排序 ","date":"2020-07-18","objectID":"/posts/CPP-4/:3:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"操作函数 find(key) erase(it), erase(key), erase(first,last) size() clear() queue 队列是一种限制性的数据结构,因此只能通过front()访问队首元素,back()访问队尾元素 在使用front()和back()函数前,必须用empty()判断队列是否为空 ","date":"2020-07-18","objectID":"/posts/CPP-4/:4:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"操作函数 push(x) 队尾入队 pop() 队首出队 front() 获得队首元素 back() 获得队尾元素 empty() 判断queue是否为空 size() 返回队列长度 priority_queue 优先队列,底层用堆来实现,在任何时候push进队列,堆(heap)都会调整结构,保证队首元素为优先级最大 头文件: queue 和队列不同,priority_queue没有front()和back()函数,只能通过top()来访问队首元素(堆顶元素) ","date":"2020-07-18","objectID":"/posts/CPP-4/:5:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"操作函数 push() top() pop() empty() size() ","date":"2020-07-18","objectID":"/posts/CPP-4/:6:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"优先级的设置 priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e \u003e q; priority_queue\u003cint, vector\u003cint\u003e, greator\u003cint\u003e \u003e p; 第一个参数vector-int填写的是底层数据结构(heap)的容器,如果第一个参数为char,则第二个参数为vector-char 第三个参数为是对第一个参数的比较类,less-int表示数字越大的优先级越大 ","date":"2020-07-18","objectID":"/posts/CPP-4/:7:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"结构体优先级 struct fruit{ string name; int price; friend bool operator \u003c (fruit f1, fruit f2){ return f1.price \u003c f2.price; //价格高的水果,优先级高 } }; priority_queue\u003cfruit\u003e q; //结构体内部会自动排序,而不需要额外写别的比较函数 friend为友元,结构体内对 “\u003c” 进行了重载(重载\"\u003e“会报错) f1 == f2 等价于判断 !(f1\u003cf2) \u0026\u0026 !(f2\u003cf1) 其中对于小于号的重载,结果与sort函数中的cmp排列是相反的 /*cmp*/ return a\u003eb; //递减排序,大的元素在前面 /* \u003c 重载*/ return a\u003eb; //递增排序,小的元素在前面 将比较函数写在结构体外面 struct fruit{ string name; int price; }f1,f2,f3; struct cmp{ bool operator()(fruit f1, fruit f2){ return f1.price \u003e f2.price; } } priority_queue\u003cfruit, vector\u003cfruit\u003e, cmp\u003e q; 如果结构体内数据较为庞大,应该使用引用来提高效率,此时比较类的参数应该加上\"const\"和”\u0026\" friend bool operator \u003c (const fruit \u0026f1, const fruit \u0026f2){ return f1.price \u003e f2.price; } bool operator() (const fruit \u0026f1, const fruit \u0026f2){ return f1.price \u003e f2.price; } stack ","date":"2020-07-18","objectID":"/posts/CPP-4/:7:1","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"操作函数 push() top() pop() empty() siza() pair 头文件 map 内部有两个元素的结构体,分别对应first和second pair\u003cstring, int\u003e p; pair\u003cstring, int\u003e p(\"haha\", 5); //初始化数据 pair\u003cstring, int\u003e(\"haha\", 5) //创建临时变量 make_pair(\"haha\", 5); //创建临时变量 pair经常用作插入map中 map\u003cstring, int\u003e mp; mp.insert(make_pair(\"haha\",5)); for(auto it = mp.begin(); it!=mp.end(); it++){ cout \u003c\u003c it-\u003efirst \u003c\u003c it-\u003esecond; } ","date":"2020-07-18","objectID":"/posts/CPP-4/:8:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"比较函数 pair可以使用 ==,!=,\u003c,\u003c=,\u003e,\u003e=进行比较,比较规则是首先对first的大小作为标准,只有当first相等时才会去判断second的大小 algorithm头文件下的常用函数 ","date":"2020-07-18","objectID":"/posts/CPP-4/:9:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"max() 返回最大值 max(x,y) 三个值取最大,利用嵌套 max(x,max(y,z)) ","date":"2020-07-18","objectID":"/posts/CPP-4/:10:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"min() 返回最小值 ","date":"2020-07-18","objectID":"/posts/CPP-4/:11:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"abs() 返回绝对值,需要注意的是,abs只能用于整型int,浮点数的绝对值需要使用fabs()函数 ","date":"2020-07-18","objectID":"/posts/CPP-4/:12:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"swap() swap(x,y)交换x,y两个变量的值 ","date":"2020-07-18","objectID":"/posts/CPP-4/:13:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"reverse() 将数组指针在[it1, it2)之间的元素或容器的迭代器在[it1, it2)之间的元素进行反转 注意区间,前闭后开 int a[10] = {10,11,12,13,14,15}; reverse(a, a+4); //将 a[0]到a[3] 的元素进行反转 string a = \"abcdefg\"; reverse(a.begin()+2, a.begin()+5); //对 a[2]到a[4] 的元素进行反转 ","date":"2020-07-18","objectID":"/posts/CPP-4/:14:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"fil() 可以将数组或容器的某一区间赋值为某个相同得值 int a[5] = {1,2,3,4,5}; fill(a, a+5, 233); //将 a[0]到a[4] 均赋值为233 ","date":"2020-07-18","objectID":"/posts/CPP-4/:15:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["C++"],"content":"lower_bound()和upper_bound() 首先，lower_bound和upper_bound是C++ STL中提供的非常实用的函数。其操作对象可以是vector、set以及map lower_bound返回值一般是\u003e= 给定val的最小指针（iterator） upper_bound返回值则是 \u003e 给定val的最小指针（iterator） #include \u003ciostream\u003e // std::cout#include \u003calgorithm\u003e // std::lower_bound, std::upper_bound, std::sort#include \u003cvector\u003e // std::vector using namepace std; int main () { int myints[] = {10,20,30,30,20,10,10,20}; vector\u003cint\u003e v(myints,myints+8); // 10 20 30 30 20 10 10 20 sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 vector\u003cint\u003e::iterator low,up; low = lower_bound (v.begin(), v.end(), 20); up = upper_bound (v.begin(), v.end(), 20); cout \u003c\u003c \"lower_bound at position \" \u003c\u003c (low- v.begin()) \u003c\u003c '\\n'; cout \u003c\u003c \"upper_bound at position \" \u003c\u003c (up - v.begin()) \u003c\u003c '\\n'; return 0; } ","date":"2020-07-18","objectID":"/posts/CPP-4/:16:0","tags":["C++基础语法"],"title":"C++ Part-4","uri":"/posts/CPP-4/"},{"categories":["PAT"],"content":"B1019-B1028 2020-07-18 优化题解 这两天发生了很多事情,所以拖更啦…并且PAT的神奇测试点把我搞自闭了,还好发生了一些快乐的事情,把心态调整了回来 1019 数字黑洞 看到这种长度很长的数,我就有一种想用char来解决的冲动 但是实践表明,在一些逻辑稍微复杂题面前,这是一种很不明智的方法 而直接用除法取余操作来操作每个位,则适用于很多情况,并且出现bug的可能性更小 最好在处理一道题的时候,尽量不去对复杂数进行int和char数组之间的转换 ","date":"2020-07-18","objectID":"/posts/pat-4/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"菜鸡的笨方法 int cmp_small(const void* a, const void*b){ char* m = (char*)a; char* n = (char*)b; return strcmp(a,b); } int cmp_big(const void* a, const void*b){ char* m = (char*)a; char* n = (char*)b; return strcmp(b,a); } int toint(char* a){ int res1 = 0; for(int j=0; j\u003c 4; j++){ res1 = (a[j]-'0') + res1*10; } return res1; } main(){ char init_data[5]; char small[5]; char big[5]; int m; int n; int res = 0; int flag = 0; scanf(\"%s\", \u0026init_data); //读入初始数到char数组 //判断是否全部相同 if((init_data[0] == init_data[1]) \u0026\u0026 (init_data[0] == init_data[2]) \u0026\u0026 (init_data[0]== init_data[3])){ printf(\"%s - %s = 0 0 0 0\",init_data,init_data); return 0; } while(res!=6174){ strcpy(small,init_data); strcpy(big,init_data); //非递减排序(递增) qsort(big,4,sizeof(init_data[0]),cmp_big); m = toint(big); //char 转为 int //递减 qsort(small,4,sizeof(init_data[0]),cmp_small); n = toint(small); printf(\"%04d - %04d\",m,n); res = m-n; sprintf(init_data, \"%d\", res); //int 转为 char数组 if(res == 6174){ printf(\" = %04d\",res); } else{ printf(\" = %04d\\n\",res); } } return 0; } 对于我的这种方法,有几个明显的缺点,首先将int转换成char数组,而这个是大可不必的,完全可以用int数组来解决,其次,对于递增和递减两种数的处理,我竟然写了两个cmp函数…完全可以用一个cmp和一个reverse来解决 ","date":"2020-07-18","objectID":"/posts/pat-4/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"C++ 题解 #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; bool cmp(char a, char b) {return a \u003e b;} int main() { string s; cin \u003e\u003e s; s.insert(0, 4 - s.length(), '0'); do { string a = s, b = s; sort(a.begin(), a.end(), cmp); sort(b.begin(), b.end()); //默认升序(非降序)排列 int result = stoi(a) - stoi(b); s = to_string(result); s.insert(0, 4 - s.length(), '0'); cout \u003c\u003c a \u003c\u003c \" - \" \u003c\u003c b \u003c\u003c \" = \" \u003c\u003c s \u003c\u003c endl; } while (s != \"6174\" \u0026\u0026 s != \"0000\"); return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"AC题解 int cmp(const void *a, const void *b) { return *(int*)b - *(int*)a; } int sort(int n) { int digits[4] = {n/1000, n%1000/100, n%100/10, n%10}; qsort(digits, 4, sizeof(int), cmp); return digits[0] * 1000 + digits[1] * 100 + digits[2] * 10 + digits[3]; } int reverse(int n) { return n/1000 + n%1000/100 * 10 + n%100/10 * 100 + n%10 * 1000; } int main() { int N; scanf(\"%d\", \u0026N); do { N = sort(N); printf(\"%04d - %04d = %04d\\n\", N, reverse(N), N - reverse(N)); N = N - reverse(N); }while(N != 0 \u0026\u0026 N != 6174) ; return 0; } 1020 月饼 这道题我AC啦!很开心 这道题有个知识点就是二位数组的cmp函数,并且在cmp函数中对于double类型以及非int型数据的处理,以下是一个必须避免的错误,这种数据类型下不可以直接返回相减的值,而需要进行判断后返明确的return 1 or return -1 int cmp(const void*a , const void*b){ double m = ((double*)a)[1]; double n = ((double*)b)[1]; return (m-n); //递减 } int cmp(const void*a , const void*b){ if(((double*)a)[1]\u003e((double*)b)[1]) return -1; else return 1; } int main(){ int n; int need; double price = 0; double data[1000][2]; scanf(\"%d %d\", \u0026n, \u0026need); for(int i=0; i\u003cn; i++){ scanf(\"%lf\", \u0026data[i][0]); } for(int j=0; j\u003cn; j++){ double avg; scanf(\"%lf\", \u0026avg); data[j][1] = avg/data[j][0]; } qsort(data, n, sizeof(double)*2, cmp); //排序 while(need!=0){ for(int k=0; k\u003cn; k++){ if(need \u003e data[k][0]){ need -= data[k][0]; price+= (data[k][1]*data[k][0]); } else{ price+= (data[k][1]*need); need = 0; } } break; } printf(\"%.2f\", price); } 1021 个位数统计 这道简单AC,快乐hash就完事了 ","date":"2020-07-18","objectID":"/posts/pat-4/:3:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"C++ #include \u003ciostream\u003eusing namespace std; int main() { string s; cin \u003e\u003e s; int a[10] = {0}; for (int i = 0; i \u003c s.length(); i++) a[s[i] - '0']++; for (int i = 0; i \u003c 10; i++) { if (a[i] != 0) printf(\"%d:%d\\n\", i, a[i]); } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:4:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"C int main(){ int hash[10] = {0}; int max = 0; char num[1001]; scanf(\"%s\", \u0026num); int i = 0; while(num[i]!= '\\0'){ int cur = num[i]-'0'; if(cur\u003emax){ max = cur; } hash[cur]++; i++; } for(int k=0; k\u003c10; k++){ if(hash[k]!=0){ printf(\"%d:%d\",k, hash[k]); if(k != max){ //此处判断较为多余 printf(\"\\n\"); } } } return 0; } 1022 D进制的A+B ","date":"2020-07-18","objectID":"/posts/pat-4/:5:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"C++ 十进制转 N 进制: 将每一次 t%d 的结果保存在int类型的数组s中，然后将 t/d，直到 t=0 为止 此时s中保存的就是 t 在 D 进制下每一位的结果的倒序，最后倒序输出s数组即可 #include \u003ciostream\u003eusing namespace std; int main() { int a, b, d; cin \u003e\u003e a \u003e\u003e b \u003e\u003e d; int t = a + b; if (t == 0) { cout \u003c\u003c 0; return 0; } int s[100]; int i = 0; while (t != 0) { s[i++] = t % d; t = t / d; } for (int j = i - 1; j \u003e= 0; j--) cout \u003c\u003c s[j]; return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:6:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"菜鸡题解 我也不知道为啥,有一个测试点通不过…呜呜呜 而且写的还有点复杂,关于进制的处理,我还是不太熟悉,其实完全不必使用int数组 int main(){ long int a,b,c; int res[100000]; int i = 0; int d; scanf(\"%ld %ld %d\", \u0026a, \u0026b ,\u0026d); c = a+b; int temp; while(c \u003e d){ temp = c%d; c = c/d; res[i] = temp; i++; } res[i] = c; for(int k=i; k\u003e=0; k--){ printf(\"%d\", res[k]); } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:7:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"AC题解-C int main() { int A, B, D, Sum; scanf(\"%d %d %d\", \u0026A, \u0026B, \u0026D); Sum = A + B; int power = 1; while(Sum / D \u003e= power) { power *= D; } for(; power \u003e 0; Sum %= power, power /= D){ printf(\"%d\", Sum / power); } return 0; } */ 1023 组个最小数 快乐AC,嘿嘿,这道题没啥好说的,主要处理好数的第一位就完事了 int main(){ int data[10]; for(int k=0; k\u003c10; k++){ scanf(\"%d\", \u0026data[k]); } // find first int first = 0; for(int i=1; i\u003c10; i++){ if(data[i]!= 0){ first = i; (data[i])--; break; } } printf(\"%d\",first); int n; for(int j=0; j\u003c10; j++){ if(data[j]!=0){ n = data[j]; for(int h=0; h\u003cn; h++){ printf(\"%d\", j); } } } return 0; } 1024 科学计数法 这道题…唉,我的方法就不放上了 题目给出的是这种输入\"+1.23400E-03\",我想都没想直接开始char[]操作,来提取数中的前后部分,最后好不容易调试完成,发现只通过了一半的测试点… 看了题解才发现,我原来输在了scanf上…于是乎在那个深夜,我自闭了 这道题的知识点都是在输入和输出函数上(感觉乙级考的就是数据的格式化输入输出…) ","date":"2020-07-18","objectID":"/posts/pat-4/:8:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"C++ substr(pos, count)方法 其中pos为起始位置,count为截取字符串数量,如果没有count参数,则一直截取到字符串的末尾 #include \u003ciostream\u003eusing namespace std; int main() { string s; cin \u003e\u003e s; int i = 0; while (s[i] != 'E') i++; string t = s.substr(1, i-1); int n = stoi(s.substr(i+1)); if (s[0] == '-') cout \u003c\u003c \"-\"; if (n \u003c 0) { cout \u003c\u003c \"0.\"; for (int j = 0; j \u003c abs(n) - 1; j++) cout \u003c\u003c '0'; for (int j = 0; j \u003c t.length(); j++) if (t[j] != '.') cout \u003c\u003c t[j]; } else { cout \u003c\u003c t[0]; int cnt, j; for (j = 2, cnt = 0; j \u003c t.length() \u0026\u0026 cnt \u003c n; j++, cnt++) cout \u003c\u003c t[j]; if (j == t.length()) { for (int k = 0; k \u003c n - cnt; k++) cout \u003c\u003c '0'; } else { cout \u003c\u003c '.'; for (int k = j; k \u003c t.length(); k++) cout \u003c\u003c t[k]; } } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:9:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"C int main() { int exponent; char line[10000], *p = line; scanf(\"%[^E]E%d\", line, \u0026exponent); if(*p++ == '-') putchar('-'); if(exponent \u003e= 0) { putchar(*p); for(p += 2; exponent; exponent--) putchar(*p ? *p++ : '0'); if(*p) { putchar('.'); while(*p) putchar(*p++); } } if(exponent \u003c 0) { printf(\"0.\"); for(exponent++; exponent; exponent++) putchar('0'); for(; *p; p++) if(*p != '.') putchar(*p); } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:10:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"scanf格式化输入 对于char的格式化输入,从这道题中学到了一种新的方法 就是利用字符串匹配(不知道这算不算正则表达式…) 例如在字符串\"+1.23400E-03\"中,可以使用 scanf(\"%[^E]E%s\",\u0026a, \u0026b); 其中\"^E\"表示字符串读取到E截至,即只读取 +1.23400 此外还可以使用 scanf(\"%[0-9]E%s\",\u0026a, \u0026b); 表示只读取数字,得到 123400 1025 反转链表 这道题我用的双hash,最后果然就…写懵了 最后之通过了一半的AC(自闭复发)自己的方法就不放了… 看了题解之后不禁扪心自问(结构体它不香吗!) 题解中有一个很有用的细节,就是 #define SWAPNODE(A, B) {Node temp = A; A = B; B = temp;} 建立一个全局预编译函数,感觉好有b格嗷!学到了 此外题解中对于链表的建立和排序操作,写的很精妙,一道好题 ","date":"2020-07-18","objectID":"/posts/pat-4/:11:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"菜鸡的方法 #include\u003ccstdlib\u003e#include\u003cvector\u003e#include\u003ciostream\u003e#include\u003calgorithm\u003e#include\u003cmap\u003e#include\u003ciomanip\u003e using namespace std; struct node{ int id; int next; }; int main(int argc, char const *argv[]) { int address, num, k; int tmpad,tmpid,tmpnext; cin \u003e\u003e address \u003e\u003e num \u003e\u003e k; vector\u003cnode\u003e data(100000); map\u003cint,int\u003e mp; for(int i=0; i\u003cnum; i++){ cin \u003e\u003e tmpad \u003e\u003e tmpid \u003e\u003e tmpnext; data[tmpad] = node{tmpid, tmpnext}; mp[tmpid] = tmpad; } vector\u003cint\u003e res; while(address != -1){ res.push_back(data[address].id); address = data[address].next; } // reverse for(int i=0; i\u003cres.size()/k; i++){ reverse(res.begin()+i*k,res.begin()+k*(i+1)); } for(int i=0; i\u003cres.size(); i++){ if(i == res.size()-1){ printf(\"%05d %d -1\",mp[res[i]],res[i]); } else{ printf(\"%05d %d %05d\\n\",mp[res[i]], res[i], mp[res[i+1]]); } } system(\"pause\"); return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:12:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"C #define SWAPNODE(A, B) {Node temp = A; A = B; B = temp;} typedef struct node{ int addr; int data; int next; }node, *Node; int main() { int A, N, K; node nodes[100000] = {0}; Node np[100000] = {0}, *p; scanf(\"%d %d %d\", \u0026A, \u0026N, \u0026K); for(int i = 0; i \u003c N; i++) { np[i] = nodes + i; scanf(\"%d %d %d\", \u0026np[i]-\u003eaddr, \u0026np[i]-\u003edata, \u0026np[i]-\u003enext); } for(int i = 0; i \u003c N; i++) { for(int j = i; j \u003c N; j++) //这个判定写的很好!值得借鉴 if(np[j]-\u003eaddr == (i ? np[i - 1]-\u003enext : A)) { SWAPNODE(np[i], np[j]); break; } if(np[i]-\u003enext == -1) N = i + 1; } for(int i = 0; i \u003c N / K; i++) { p = np + i * K; for(int j = 0; j \u003c K / 2; j++) SWAPNODE(p[j], p[K - j - 1]); } for(int i = 0; i \u003c N - 1; i++) printf(\"%05d %d %05d\\n\", np[i]-\u003eaddr, np[i]-\u003edata, np[i + 1]-\u003eaddr); printf(\"%05d %d -1\\n\", np[N - 1]-\u003eaddr, np[N - 1]-\u003edata); return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:13:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"C++ 虽然C的方法十分花里胡哨,但是C++实在是太舒服了 这里值得注意的是,用到了begin(list)的带参数用法,返回参数的起始位置,和list.begin()是一样的 #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main() { int first, k, n, temp; cin \u003e\u003e first \u003e\u003e n \u003e\u003e k; int data[100005], next[100005], list[100005]; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e temp; cin \u003e\u003e data[temp] \u003e\u003e next[temp]; } int sum = 0;//不一定所有的输入的结点都是有用的，加个计数器 while (first != -1) { list[sum++] = first; first = next[first]; } for (int i = 0; i \u003c (sum - sum % k); i += k) reverse(begin(list) + i, begin(list) + i + k); for (int i = 0; i \u003c sum - 1; i++) printf(\"%05d %d %05d\\n\", list[i], data[list[i]], list[i + 1]); printf(\"%05d %d -1\", list[sum - 1], data[list[sum - 1]]); return 0; } 1026 程序运行时间 这道白给题有一个知识点,double的四舍五入: 加上 0.5 之后转 int int_num = (int)(double_num + 0.5); int main(){ double s1,s2; scanf(\"%lf %lf\", \u0026s1, \u0026s2); double dvalue = s2-s1; long int d; d = (int)(dvalue/100+0.5); /* c中需要在前面int两端加上括号,而c++不需要,可以直接写为: d = int(dvalue/100+0.5); */ int hour = 0, minutes = 0, second = 0; second = d%60; d /= 60; minutes = d%60; hour = d/60; printf(\"%02d:%02d:%02d\",hour,minutes,second); } 1027 打印沙漏 这道题我虽然AC了,但是心很累,为何我写的这么啰嗦 哦,原来是数学没学好,那没事了 int main(){ int s; char signal; scanf(\"%d %c\", \u0026s, \u0026signal); int sum = s; s = (s+1)/2; int minus; int shit = 0,count = 0,minus = 1;; for(int i=1; s \u003e= minus; i++){ s = s-minus; minus = 2*i +1; count++; } int k, w, j; for(k=0; k \u003c count; k++){ for(j=0; j\u003c k; j++){ printf(\" \"); } for(w=0; w\u003c((count-k)*2-1); w++){ printf(\"%c\",signal); shit++; } printf(\"\\n\"); } for(k=count-2; k\u003e=0; k--){ for(j=k; j\u003e0; j--){ printf(\" \"); } for(w=((count-k)*2-1); w\u003e0; w--){ printf(\"%c\",signal); shit++; } printf(\"\\n\"); } printf(\"%d\", sum-shit); return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:14:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"题解 绝对值 M阶的沙漏需要用到的字符个数为2M2-1 这绝对值用的我服了…学到了 #define ABS(X) ((X) \u003e= 0 ? (X) : -(X)) int main() { char c; int N, M; scanf(\"%d %c\", \u0026N, \u0026c); for(M = 1; 2 * M * M - 1 \u003c= N; M++) ; M--; for(int i = 0; i \u003c 2 * M - 1; i ++) { for(int j = 0; j \u003c M - 1 - ABS(M - 1 - i); j++) putchar(' '); for(int j = 0; j \u003c 2 * ABS(M - 1 - i) + 1; j++) putchar(c); putchar('\\n'); } printf(\"%d\", N - 2 * M * M + 1); return 0; } 1028 人口普查 这道题鸭,我自己写有一个测试点就是过不去,去看了眼题解,差点没给我气昏过去 strcmp()这函数鸭,我服辣 ","date":"2020-07-18","objectID":"/posts/pat-4/:15:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"C++ #include \u003ciostream\u003eusing namespace std; int main() { int n, cnt = 0; cin \u003e\u003e n; string name, birth, maxname, minname, maxbirth = \"1814/09/06\", minbirth = \"2014/09/06\"; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e name \u003e\u003e birth; if (birth \u003e= \"1814/09/06\" \u0026\u0026 birth \u003c= \"2014/09/06\") { cnt++; if (birth \u003e= maxbirth) { maxbirth = birth; maxname = name; } if (birth \u003c= minbirth) { minbirth = birth; minname = name; } } } cout \u003c\u003c cnt; if (cnt != 0) cout \u003c\u003c \" \" \u003c\u003c minname \u003c\u003c \" \" \u003c\u003c maxname; return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:16:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"菜鸡的方法 用了快乐结构体,结果还用笨了 typedef struct { char name[100]; int age; }person,*node; int main(){ int num,year,month,day; int max,maxd=0,max_day = 200*365,count = 0; int min,mind = max_day; scanf(\"%d\", \u0026num); node data[100000]; char temp_name[100]; int init_day = 2014*365 + 9*30 + 6; int temp_age,sumday; for(int i=0; i\u003cnum; i++){ scanf(\"%s %d/%d/%d\", \u0026temp_name, \u0026year, \u0026month, \u0026day); sumday = (year*365 + 30*month + day); temp_age = init_day-sumday; node newp = (node)malloc(sizeof(person)); if(temp_age \u003c= max_day \u0026\u0026 temp_age\u003e0){ strcpy(newp-\u003ename, temp_name); newp-\u003eage = temp_age; data[i] = newp; if(temp_age \u003e maxd){ max = i; maxd = temp_age; } if(temp_age \u003c mind){ min = i; mind = temp_age; } count++; } } if(count == 0){ printf(\"0\"); } else{ printf(\"%d %s %s\",count, data[max]-\u003ename, data[min]-\u003ename); } return 0; ","date":"2020-07-18","objectID":"/posts/pat-4/:17:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"题解 题解是真的机智,首先对于日期的比较,直接strcmp 然后将日期和名字放到同一个char数组中 int main() { int N, count = 0; char cur[17], eldest[17] = {'9'}, youngest[17] = {'0'}; scanf(\"%d\", \u0026N); for(int i = 0; i \u003c N; i++) { scanf(\"%s %s\", cur + 11, cur); if(strcmp(cur, \"1814/09/06\") \u003e= 0 \u0026\u0026 strcmp(cur, \"2014/09/06\") \u003c= 0) { if(strcmp(cur, eldest) \u003c= 0) memcpy(eldest, cur, 17); if(strcmp(cur, youngest) \u003e= 0) memcpy(youngest, cur, 17); count++; } } if(count) printf(\"%d %s %s\", count, eldest + 11, youngest + 11); else printf(\"0\"); return 0; } ","date":"2020-07-18","objectID":"/posts/pat-4/:18:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"strcmp strcmp() 用来比较字符串(区分大小写） 原型为：int strcmp(const char *s1, const char *s2); s1, s2 为需要比较的两个字符串。字符串大小的比较是以ASCII码表上的顺序来决定，此顺序亦为字符的值。strcmp()首先将s1 第一个字符值减去s2 第一个字符值，若差值为0则再继续比较下个字符，若差值不为0 则将差值返回。 例如字符串\"Ac\"和\"ba\"比较则会返回字符\"A\"(65)和’b’(98)的差值(－33)。 #include \u003cstring.h\u003emain(){ char *a = \"aBcDeF\"; char *b = \"AbCdEf\"; char *c = \"aacdef\"; char *d = \"aBcDeF\"; printf(\"strcmp(a, b) : %d\\n\", strcmp(a, b)); printf(\"strcmp(a, c) : %d\\n\", strcmp(a, c)); printf(\"strcmp(a, d) : %d\\n\", strcmp(a, d)); } 输出结果： strcmp(a, b) : 32 strcmp(a, c) :-31 strcmp(a, d) : 0 ","date":"2020-07-18","objectID":"/posts/pat-4/:19:0","tags":["Leetcode-C++"],"title":"PAT-Basic 19~28","uri":"/posts/pat-4/"},{"categories":["PAT"],"content":"B1013-B1018 我刷的太慢了(虽然题很简单)…但感觉解题速度越来越快了!继续加油! 2020-07-18 优化题解 B1013-数素数 这道题的精髓就是在于如何算素数呀 之前算素数的时候没用sqrt函数,但发现还是直接用函数来的方便 标准模板 m=(int)sqrt((double)s); //首先求出平方根 for(i=2;i\u003c=m;i++){ if(s%i==0) //当前不为素数 if(i\u003em){ //当前为素数 } } ","date":"2020-07-18","objectID":"/posts/pat-3/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 13~18","uri":"/posts/pat-3/"},{"categories":["PAT"],"content":"C++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; bool isprime(int a) { for (int i = 2; i * i \u003c= a; i++) if(a % i == 0) return false; return true; } int main() { int M, N, num = 2, cnt = 0; cin \u003e\u003e M \u003e\u003e N; vector\u003cint\u003e v; while (cnt \u003c N) { if (isprime(num)) { cnt++; if (cnt \u003e= M) v.push_back(num); } num++; } cnt = 0; for (int i = 0; i \u003c v.size(); i++) { cnt++; if (cnt % 10 != 1) printf(\" \"); printf(\"%d\", v[i]); if (cnt % 10 == 0) printf(\"\\n\"); } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-3/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 13~18","uri":"/posts/pat-3/"},{"categories":["PAT"],"content":"C #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include \u003cmath.h\u003e int main(){ int a, b; //输入 scanf(\"%d %d\", \u0026a, \u0026b); int count = 0; //计数 int m; //平方跟 int i; //循环计数 int s=2; //当前判断的数 int flag; //判断素数 //find single num while(count \u003c b){ flag = 0; m=(int)sqrt((double)s); //求素数 for(i=2;i\u003c=m;i++) if(s%i==0) break; if(i\u003em){ flag = 0; ++count; } else{ flag = 1; } if(flag == 0){ // is single if(count \u003e= a){ printf(\"%d\", s); if((count-a+1)%10 == 0 \u0026\u0026 count!= b){ printf(\"\\n\"); } else if(count != b) { printf(\" \"); } } } s++; } return 0; } B1014-福尔摩斯的约会 不知道为啥…我写的代码就是有一个测试点没法通过,哭了 ","date":"2020-07-18","objectID":"/posts/pat-3/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 13~18","uri":"/posts/pat-3/"},{"categories":["PAT"],"content":"字符类型的判断 直接用ascii判断大小即可 例如判断字符在A和G之间 a1[i]\u003e='A'\u0026\u0026a1[i]\u003c='G' ","date":"2020-07-18","objectID":"/posts/pat-3/:3:0","tags":["Leetcode-C++"],"title":"PAT-Basic 13~18","uri":"/posts/pat-3/"},{"categories":["PAT"],"content":"格式输出 printf(\"%02d:\", output2); 表示把整型数据打印最低两位，如果不足两位，用0补齐 ","date":"2020-07-18","objectID":"/posts/pat-3/:4:0","tags":["Leetcode-C++"],"title":"PAT-Basic 13~18","uri":"/posts/pat-3/"},{"categories":["PAT"],"content":"字符类型判断 头文件 #include \u003cctype.h\u003e isdigit 判断是否为数字,若为数字则返回1 isalpha 判断是否为字母,若为字母返回1 #include \u003cstdio.h\u003e#include \u003cctype.h\u003e int main() { char str1[61], str2[61], str3[61], str4[61]; scanf(\"%s %s %s %s\", str1, str2, str3, str4); int DAY; char *weekdays[] = {\"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\", \"SUN\"}; for(DAY = 0; str1[DAY] \u0026\u0026 str2[DAY]; DAY++) if(str1[DAY] == str2[DAY] \u0026\u0026 str1[DAY] \u003e= 'A' \u0026\u0026 str1[DAY] \u003c= 'G') { printf(\"%s\", weekdays[str1[DAY] - 'A']); break; } int HH; for(HH = DAY + 1; str1[HH] \u0026\u0026 str2[HH]; HH++) if(str1[HH] == str2[HH]) { if(str1[HH] \u003e= 'A' \u0026\u0026 str1[HH] \u003c= 'N') { printf(\" %02d\", str1[HH] - 'A' + 10); break; } if(isdigit(str1[HH])) { printf(\" %02d\", str1[HH] - '0'); break; } } int MM; for(MM = 0; str3[MM] \u0026\u0026 str4[MM]; MM++) if(str3[MM] == str4[MM] \u0026\u0026 isalpha(str3[MM])) { printf(\":%02d\", MM); break; } return 0; } /*测试点4无法通过 #include\u003cstdlib.h\u003e #include\u003cstdio.h\u003e #include \u003cctype.h\u003e int main(){ char a1[61], a2[61], a3[61], a4[61]; scanf(\"%s\", a1); scanf(\"%s\", a2); scanf(\"%s\", a3); scanf(\"%s\", a4); //输入字符串 int flag = 0; //找到了第一个 int output1; //输出星期 int output2,output3=0; char week[7][10] = {\"MON\",\"TUE\",\"WED\",\"THU\",\"FRI\",\"SAT\",\"SUN\"}; //判断第一对字符串 int i=0; while(a1[i]!= '\\0' \u0026\u0026 a2[i]!= '\\0'){ //第一个字符串 if(a1[i] == a2[i] \u0026\u0026 flag == 0 \u0026\u0026 (a1[i]\u003e='A'\u0026\u0026a1[i]\u003c='G')){ //找到第一个 output1 = a1[i]-'A'; printf(\"%s \", week[output1]); flag = 1; i = i+1; } if(a1[i] == a2[i] \u0026\u0026 flag == 1 \u0026\u0026 ((a1[i]\u003e='A'\u0026\u0026a1[i]\u003c='N') || (a1[i]\u003e='0'\u0026\u0026a1[i]\u003c='9'))){ output2 = isdigit(a1[i]); if(output2){ //当前为数字 output2 = a1[i]-'0'; printf(\"%02d:\", output2); } else{ //字母 output2 = a1[i]- 'A' + 10; printf(\"%02d:\", output2); } break; } i++; } //第一个字符串结束 i = 0; while(a3[i] \u0026\u0026 a4[i]){ if((a3[i] == a4[i]) \u0026\u0026 (a3[i]\u003e='a'\u0026\u0026a3[i]\u003c='z')){ printf(\"%02d\", i); break; } i++; } return 0; } */ B1015-德才论 这道题算是我目前做过的pat里最难的了 就是逻辑太复杂,给我整迷糊了 巧妙的点有几个 构建数据类型 这道题很典型,即一个实例下对应多个属性,创建一个结构体再好不过了 qsort函数 太重要了,尤其是多条件下的排序(之前只用过单条件),简直无敌,必须背下来! 主要就是根据函数最后的return值来进行判定排序先后 ","date":"2020-07-18","objectID":"/posts/pat-3/:5:0","tags":["Leetcode-C++"],"title":"PAT-Basic 13~18","uri":"/posts/pat-3/"},{"categories":["PAT"],"content":"C++ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eusing namespace std; struct node { int num, de, cai; }; int cmp(struct node a, struct node b) { if ((a.de + a.cai) != (b.de + b.cai)) return (a.de + a.cai) \u003e (b.de + b.cai); else if (a.de != b.de) return a.de \u003e b.de; else return a.num \u003c b.num; } int main() { int n, low, high; scanf(\"%d %d %d\", \u0026n, \u0026low, \u0026high); vector\u003cnode\u003e v[4]; node temp; int total = n; for (int i = 0; i \u003c n; i++) { scanf(\"%d %d %d\", \u0026temp.num, \u0026temp.de, \u0026temp.cai); if (temp.de \u003c low || temp.cai \u003c low) total--; else if (temp.de \u003e= high \u0026\u0026 temp.cai \u003e= high) v[0].push_back(temp); else if (temp.de \u003e= high \u0026\u0026 temp.cai \u003c high) v[1].push_back(temp); else if (temp.de \u003c high \u0026\u0026 temp.cai \u003c high \u0026\u0026 temp.de \u003e= temp.cai) v[2].push_back(temp); else v[3].push_back(temp); } printf(\"%d\\n\", total); for (int i = 0; i \u003c 4; i++) { sort(v[i].begin(), v[i].end(), cmp); for (int j = 0; j \u003c v[i].size(); j++) printf(\"%d %d %d\\n\", v[i][j].num, v[i][j].de, v[i][j].cai); } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-3/:6:0","tags":["Leetcode-C++"],"title":"PAT-Basic 13~18","uri":"/posts/pat-3/"},{"categories":["PAT"],"content":"C #include\u003cstdlib.h\u003e#include\u003cstdio.h\u003e typedef struct _student{ int id; int d; int c; int rank; int sum; }sstudent, *Student; int rank(Student s, int h, int l){ if(s-\u003ed\u003cl || s-\u003ec\u003cl) return 0; else if(s-\u003ed\u003e=h \u0026\u0026 s-\u003ec\u003e=h) return 4; else if(s-\u003ed\u003e=h) return 3; else if(s-\u003ed\u003e=s-\u003ec) return 2; else return 1; } int comp(const void *a, const void *b){ Student s1= *(Student*)a; Student s2= *(Student*)b; if(s1-\u003erank != s2-\u003erank) return s1-\u003erank-s2-\u003erank; else if(s1-\u003esum != s2-\u003esum) return s1-\u003esum-s2-\u003esum; else if(s1-\u003ed != s2-\u003ed) return s1-\u003ed - s2-\u003ed; else if(s1-\u003eid != s2-\u003eid) return s2-\u003eid-s1-\u003eid; else{ return 0; } } int main() { int n, l, h,m=0; Student students[100000] = {0}; scanf(\"%d %d %d\", \u0026n, \u0026l, \u0026h); for(int i=0; i\u003cn; i++){ Student s = (Student)malloc(sizeof(sstudent)); scanf(\"%d %d %d\", \u0026s-\u003eid, \u0026s-\u003ed, \u0026s-\u003ec); s-\u003esum = s-\u003ed + s-\u003ec; if((s-\u003erank = rank(s, h, l)) != 0){ students[m++] = s; } } qsort(students, m, sizeof(Student), comp); printf(\"%d\\n\", m); for(int i = m - 1; i \u003e= 0; i--) printf(\"%d %d %d\\n\", students[i]-\u003eid, students[i]-\u003ed, students[i]-\u003ec); return 0; } B1016-部分A+B 这道题两种方案 第一种是大佬用long int来进行求解,然后/10取余算出来 第二种就是我的char数组,位操作 这道题蛮简单的,没啥好说的 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cstring.h\u003e/* long depart(long a, long b){ long pa; for(pa=0; a; a/=10){ if(a%10 == b){ pa = pa*10+b; } } return pa; } int main(){ long a,b; int pa,pb; scanf(\"%ld %d %ld %d\", \u0026a, \u0026pa, \u0026b, \u0026pb); printf(\"%ld\", depart(a,pa)+depart(b,pb)); return 0; } */ int main(){ char s1[11], s2[11]; int a,b; int res1 = 0, res2 = 0; scanf(\"%s %d %s %d\", \u0026s1, \u0026a, \u0026s2, \u0026b); int k = strlen(s1); for(int i=0; i\u003cstrlen(s1); i++){ if((s1[i]-'0') == a){ res1 = res1*10+(s1[i]-'0'); } } for(int j=0; j\u003cstrlen(s2); j++){ if((s2[j]-'0') == b){ res2 = res2*10+(s2[j]-'0'); } } printf(\"%d\", (res1+res2)); return 0; } B1017-A除以B 这道题就很神奇了,我真是没想到 用算法模拟手动除法方式,两位为单位算,神奇呀! ","date":"2020-07-18","objectID":"/posts/pat-3/:7:0","tags":["Leetcode-C++"],"title":"PAT-Basic 13~18","uri":"/posts/pat-3/"},{"categories":["PAT"],"content":"C++ #include \u003ciostream\u003eusing namespace std; int main() { string s; int a, t = 0, temp = 0; cin \u003e\u003e s \u003e\u003e a; int len = s.length(); t = (s[0] - '0') / a; if ((t != 0 \u0026\u0026 len \u003e 1) || len == 1) cout \u003c\u003c t; //判断首位 temp = (s[0] - '0') % a; for (int i = 1; i \u003c len; i++) { t = (temp * 10 + s[i] - '0') / a; cout \u003c\u003c t; temp = (temp * 10 + s[i] - '0') % a; } cout \u003c\u003c \" \" \u003c\u003c temp; return 0; } ","date":"2020-07-18","objectID":"/posts/pat-3/:8:0","tags":["Leetcode-C++"],"title":"PAT-Basic 13~18","uri":"/posts/pat-3/"},{"categories":["PAT"],"content":"C int main() { int B; char A[1001], *p = A; scanf(\"%s %d\", A, \u0026B); int twodigit, remainder = 0; for(int i = 0; A[i]; i ++) { twodigit = remainder * 10 + (A[i] - '0'); A[i] = twodigit / B + '0'; remainder = twodigit % B; } B = remainder; if(A[0] == '0' \u0026\u0026 A[1] != '\\0') p++; printf(\"%s %d\", p, B); return 0; } B1018-石头剪刀布 这道题我感觉我做的还不错(嘿嘿),逐渐上道了吧 用到了前面学到的结构体思想 我愿称他为一道开窍题,哈哈哈 typedef struct{ int win_j; int win_s; int win_b; int lose; int balance; char win_max; }play,*player; void charge_func(char aplay, char bplay, player a, player b){ if(aplay == bplay){ (a-\u003ebalance)++; (b-\u003ebalance)++; } else if(aplay == 'C' \u0026\u0026 bplay == 'J'){ (a-\u003ewin_s)++; (b-\u003elose)++; } else if(aplay == 'J' \u0026\u0026 bplay == 'B'){ (a-\u003ewin_j)++; (b-\u003elose)++; } else if(aplay == 'B' \u0026\u0026 bplay == 'C'){ (a-\u003ewin_b)++; (b-\u003elose)++; } else if(bplay == 'C' \u0026\u0026 aplay == 'J'){ (b-\u003ewin_s)++; (a-\u003elose)++; } else if(bplay == 'J' \u0026\u0026 aplay == 'B'){ (b-\u003ewin_j)++; (a-\u003elose)++; } else if(bplay == 'B' \u0026\u0026 aplay == 'C'){ (b-\u003ewin_b)++; (a-\u003elose)++; } } char max(int B, int C, int J) //第一种比较方法 { if(B \u003e= C \u0026\u0026 B \u003e= J) return 'B'; if(C \u003e B \u0026\u0026 C \u003e= J) return 'C'; /* J \u003e B \u0026\u0026 J \u003e C */ return 'J'; } void find_max(player k){ //我的比较方法 int max = k-\u003ewin_b; k-\u003ewin_max = 'B'; if(k-\u003ewin_s \u003e max){ max = k-\u003ewin_s; k-\u003ewin_max = 'C'; } if(k-\u003ewin_j \u003e max){ k-\u003ewin_max = 'J'; } } int main(){ player a = (player)malloc(sizeof(play)); player b = (player)malloc(sizeof(play)); a-\u003ewin_b = a-\u003ewin_j = a-\u003ewin_s = a-\u003ebalance = a-\u003elose = 0; b-\u003ewin_b = b-\u003ewin_j = b-\u003ewin_s = b-\u003ebalance = b-\u003elose = 0; int n; scanf(\"%d\", \u0026n); char aplay,bplay; //两个玩家的出招 for(int i=0; i\u003cn; i++){ scanf(\" %c %c\", \u0026aplay, \u0026bplay); charge_func(aplay, bplay, a, b); } int win_a = (a-\u003ewin_b) + (a-\u003ewin_s) + (a-\u003ewin_j); int win_b = (b-\u003ewin_b) + (b-\u003ewin_s) + (b-\u003ewin_j); printf(\"%d %d %d\\n\", win_a, a-\u003ebalance, a-\u003elose); printf(\"%d %d %d\\n\", win_b, b-\u003ebalance, b-\u003elose); find_max(a); find_max(b); //char max1,max2; //max1 = max(a-\u003ewin_b, a-\u003ewin_s, a-\u003ewin_j); //max2 = max(b-\u003ewin_b, b-\u003ewin_s, b-\u003ewin_j); printf(\"%c %c\",a-\u003ewin_max, b-\u003ewin_max); //printf(\"%c %c\",max1, max2); } 今天有点刷不动了,明天继续! ","date":"2020-07-18","objectID":"/posts/pat-3/:9:0","tags":["Leetcode-C++"],"title":"PAT-Basic 13~18","uri":"/posts/pat-3/"},{"categories":["PAT"],"content":"B1011-B1012 2020-07-18 优化题解 B1011-A+B 和 C 没啥好说哒 main(){ long a,b,c,d; int num; scanf(\"%d\", \u0026num); for(int i=1; i\u003c=num; i++){ scanf(\"%ld %ld %ld\", \u0026a, \u0026b, \u0026c); d = a+b; if(d\u003ec){ printf(\"Case #%d: true\\n\", i); } else{ printf(\"Case #%d: false\\n\", i); } } return 0; } B1012-数字分类 这道题就很墨迹…而且我的方法还不能全部通过测试点,就很迷 我也不知道我错在哪里了…主要PAT也不提示输出的错误,太不人性化了… ","date":"2020-07-18","objectID":"/posts/pat-2/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 11~12","uri":"/posts/pat-2/"},{"categories":["PAT"],"content":"收获 在调试我的方法的时候,double输出显示nan 出现这个是因为\"在计算除法运算时，分母为0，导致结果是个无穷大的数，无法显示就用NaN代替了\" 以后处理数据要注意分母的值 !运算符 可以直接使用 !flag 进行取反操作 int flag = 0; flag = !flag; //flag = 1 ","date":"2020-07-18","objectID":"/posts/pat-2/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 11~12","uri":"/posts/pat-2/"},{"categories":["PAT"],"content":"C++ #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int main() { int n, num, A1 = 0, A2 = 0, A5 = 0; double A4 = 0.0; cin \u003e\u003e n; vector\u003cint\u003e v[5]; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e num; v[num%5].push_back(num); } for (int i = 0; i \u003c 5; i++) { for (int j = 0; j \u003c v[i].size(); j++) { if (i == 0 \u0026\u0026 v[i][j] % 2 == 0) A1 += v[i][j]; if (i == 1 \u0026\u0026 j % 2 == 0) A2 += v[i][j]; if (i == 1 \u0026\u0026 j % 2 == 1) A2 -= v[i][j]; if (i == 3) A4 += v[i][j]; if (i == 4 \u0026\u0026 v[i][j] \u003e A5) A5 = v[i][j]; } } for (int i = 0; i \u003c 5; i++) { if (i != 0) printf(\" \"); if (i == 0 \u0026\u0026 A1 == 0 || i != 0 \u0026\u0026 v[i].size() == 0) { printf(\"N\"); continue; } if (i == 0) printf(\"%d\", A1); if (i == 1) printf(\"%d\", A2); if (i == 2) printf(\"%d\", v[2].size()); if (i == 3) printf(\"%.1f\", A4 / v[3].size()); if (i == 4) printf(\"%d\", A5); } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-2/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 11~12","uri":"/posts/pat-2/"},{"categories":["PAT"],"content":"正确答案 #define MAXN 1000 int n[MAXN]; int n5[MAXN];//配合a5，存储所有被 5 除后余 4 的数字 int k = 0; int main() { int a1 = 0, a2 = 0, a3 = 0, a5 = 0, count4 = 0; int flag1 = 0, flag2 = 0, flag3 = 0, flag4 = 0, flag5 = 0; double a4, sum4 = 0; int N, i; int flag = 1;//配合a2，用来* -1 scanf(\"%d\",\u0026N); for (i = 0; i \u003c N; i++) { scanf(\"%d\",\u0026n[i]); } for (i = 0; i \u003c N; i++) { if (n[i] % 5 == 0 \u0026\u0026 n[i] % 2 == 0) { a1 += n[i]; flag1 = 1; } if (n[i] % 5 == 1) { a2 = a2 + flag * n[i]; flag *= (-1); flag2 = 1; } if (n[i] % 5 == 2) { a3++; flag3 = 1; } if (n[i] % 5 == 3) { sum4 = sum4 + n[i]; count4++; flag4 = 1; } if (n[i] % 5 == 4) { n5[k++] = n[i]; flag5 = 1; } } a4 = sum4 / count4; a5 = n5[0]; for (i = 1; i \u003c k; i++) { if (n5[i] \u003e a5) { a5 = n5[i]; } } if (flag1) { printf(\"%d\",a1); } else { printf(\"N\"); } printf(\" \"); if (flag2) { printf(\"%d\", a2); } else { printf(\"N\"); } printf(\" \"); if (flag3) { printf(\"%d\", a3); } else { printf(\"N\"); } printf(\" \"); if (flag4) { printf(\"%.1lf\", a4); } else { printf(\"N\"); } printf(\" \"); if (flag5) { printf(\"%d\", a5); } else { printf(\"N\"); } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-2/:3:0","tags":["Leetcode-C++"],"title":"PAT-Basic 11~12","uri":"/posts/pat-2/"},{"categories":["PAT"],"content":"我的蜜汁答案 int main(){ int a1=0, a2=0, a3=0, a5=0, cur, temp, flag=0,count=0; int useless; scanf(\"%d\", \u0026useless); double a4=0; char ch; while(1){ ch = getchar(); if(ch == '\\n'){ break; } scanf(\"%d\", \u0026cur); temp = cur%5; if(temp == 0 \u0026\u0026 cur%2 == 0){ a1 += cur; } else if(temp == 1){ if(flag == 0){ a2 += cur; } else{ a2 -= cur; } flag = !flag; } else if(temp == 2){ a3++; } else if(temp == 3) { a4 += cur; ++count; } else if(temp = 4) { if(cur \u003e a5){ a5 = cur; } } } if(a1 == 0){ printf(\"N\"); } else { printf(\"%d\", a1); } if(a2 == 0){ printf(\" N\"); } else { printf(\" %d\", a2); } if(a3 == 0){ printf(\" N\"); } else { printf(\" %d\", a3); } if(a4 == 0){ printf(\" N\"); } else { a4 = a4/count; printf(\" %.1f\", a4); } if(a5 == 0){ printf(\" N\"); } else { printf(\" %d\", a5); } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-2/:4:0","tags":["Leetcode-C++"],"title":"PAT-Basic 11~12","uri":"/posts/pat-2/"},{"categories":["PAT"],"content":"备考7月份的PAT! 冲鸭 B1001-B1010 2020-07-18 优化题解 B1001-害死人不偿命的(3n+1)猜想 没啥好说的… #include\u003cstdlib.h\u003e#include\u003cstdio.h\u003eint main(){ int input_num; scanf(\"%d\",\u0026input_num); int count = 0; if(input_num \u003c= 1000){ while(input_num != 1){ if(input_num%2 == 1){ input_num = (3*input_num +1)/2; } else{ input_num = input_num/2; } count++; } } printf(\"%d\", count); } B1002-写出这个数 ","date":"2020-07-18","objectID":"/posts/pat-1/:0:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"C++ #include\u003ccstdlib\u003e#include\u003cstring\u003e#include\u003ciostream\u003eusing namespace std; int main(int argc, char const *argv[]) { string s; cin \u003e\u003e s; int sum = 0; string str[10] = {\"ling\", \"yi\", \"er\", \"san\", \"si\", \"wu\", \"liu\", \"qi\", \"ba\", \"jiu\"}; for(int i=0; i\u003cs.length(); i++){ sum += s[i]-'0'; } string res = to_string(sum); for(int j=0; j\u003cres.length(); j++){ if(j != 0){ cout \u003c\u003c \" \"; } cout \u003c\u003c str[res[j]-'0']; } system(\"pause\"); return 0; } ","date":"2020-07-18","objectID":"/posts/pat-1/:1:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"C int main(){ char pinyin[10][5] = {\"ling\", \"yi\", \"er\", \"san\", \"si\", \"wu\", \"liu\", \"qi\", \"ba\", \"jiu\"}; char getnum; int sum; while((getnum = getchar())!= '\\n'){ sum += getnum - '0'; } char res[4]; sprintf(res, \"%d\", sum); for(int i=0; res[i]!=0; i++){ //printf(\"%s\\n\", res[i]); if(i != 0){ printf(\" \"); } printf(\"%s\", pinyin[res[i]-'0']); } return 0; } 这道题有一个很有用的函数 sprintf,将int打印到一个char数组中,判定结尾为 //res为char数组 res[i]!=0 还有一个很好的判断,学到了 while((getnum = getchar())!= '\\n') 这道题思路很好,值得反复推敲 B1003-我要通过！ 我愿称他为一道快乐计数题 并且题目我没读懂,汉语的魅力让我沉醉 题目解释: 关于上面正确字符串的定义, 这是典型的递归定义, 第1点和第2点是初始条件, 第3点是归纳条件. 来说下显然可以得到的结论, 正确字符串必定有且只有一个P和一个T, 其余的都是A, 并且P在T的前面, 更具体地, 正确字符串必定是A...APA...ATA...A的模式. 仔细观察第3点, aPbATca和aPbTc的区别在于前者的P和T之前多了个A, T之后多了a, 可以想象, 面对一个给定字符串, 先要数出P之前有多少个A, P和T之间有多少个A, T之后有多少个A, 首先判断是否符合第2点, 不符合就在T之后去掉与P之前相同数量的A, 在P和T之间去掉一个A, 然后再判断剩下来的字符串是否为正确字符串, 重复若干次去掉的操作, 最后肯定归结到是否符合第2点. 但是有更好的办法, 既然每次都是去掉一个中间A和一个尾部a, 想象最后得到的aPATa形式, 将P前面A的数量设为x, P和T之间A的数量设为1, 那么每增加一个中间A就增加一个尾部a, 假设增加y次得到给定的字符串. 对于给定的字符串, P前面A的数量仍为x, P和T之间A的数量变为1+y, T之后A的数量变为x+xy=x(1+y), 那么给了一个字符串, 判断 中间A的数量 是否大于0而且 T之后A的数量 是否等于 P前A的数量 乘以 P和T之间A的数量 就可以了. #include \u003ciostream\u003e#include \u003cmap\u003eusing namespace std; int main() { int n, p = 0, t = 0; string s; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) { cin \u003e\u003e s; map\u003cchar, int\u003e m; for(int j = 0; j \u003c s.size(); j++) { m[s[j]]++; if (s[j] == 'P') p = j; if (s[j] == 'T') t = j; } if (m['P'] == 1 \u0026\u0026 m['A'] != 0 \u0026\u0026 m['T'] == 1 \u0026\u0026 m.size() == 3 \u0026\u0026 t-p != 1 \u0026\u0026 p * (t-p-1) == s.length()-t-1) printf(\"YES\\n\"); else printf(\"NO\\n\"); } return 0; } B1004-成绩排名 没啥好说的… int main(){ int stnum,score; scanf(\"%d\", \u0026stnum); char max_name[20],max_no[20],min_name[20],min_no[20],temp_name[20], temp_no[20]; int max = -1, min=101; for(int i=0; i\u003c stnum; i++){ scanf(\"%s %s %d\", temp_name, temp_no, \u0026score); if(score \u003e max){ max = score; strcpy(max_name,temp_name); strcpy(max_no,temp_no); } if(score \u003c min){ min = score; strcpy(min_name,temp_name); strcpy(min_no,temp_no); } } printf(\"%s %s\\n\", max_name, max_no); printf(\"%s %s\\n\", min_name, min_no); return 0; } B1005-继续(3n+1)猜想 ","date":"2020-07-18","objectID":"/posts/pat-1/:2:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"菜鸡的方法 #include\u003ccstdlib\u003e#include\u003ciostream\u003e#include\u003cset\u003e#include\u003cvector\u003e#include\u003calgorithm\u003e using namespace std; int main(int argc, char const *argv[]) { int num, tmp; cin \u003e\u003e num; set\u003cint\u003e set1; vector\u003cint\u003e data; for(int i=0; i\u003cnum; i++){ cin \u003e\u003e tmp; data.push_back(tmp); while(tmp != 1){ if(tmp % 2 == 1){ tmp = (3*tmp+1)/2; } else{ tmp = tmp/2; } if(set1.find(tmp) != set1.end()){ break; } set1.insert(tmp); } } vector\u003cint\u003e res; for(int i=0; i\u003cnum; i++){ if(set1.find(data[i]) == set1.end()){ res.push_back(data[i]); } } sort(res.begin(),res.end(),greater\u003cint\u003e()); for(int j=0; j\u003cres.size(); j++){ if(j != 0){ cout \u003c\u003c \" \"; } cout \u003c\u003c res[j]; } system(\"pause\"); return 0; } ","date":"2020-07-18","objectID":"/posts/pat-1/:3:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"别人的方法 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int arr[10000]; bool cmp(int a, int b) {return a \u003e b;} int main() { int k, n, flag = 0; cin \u003e\u003e k; vector\u003cint\u003e v(k); for (int i = 0; i \u003c k; i++) { cin \u003e\u003e n; v[i] = n; while (n != 1) { if (n % 2 != 0) n = 3 * n + 1; n = n / 2; if (arr[n] == 1) break; arr[n] = 1; } } sort(v.begin(), v.end(), cmp); for (int i = 0; i \u003c v.size(); i++) { if (arr[v[i]] == 0) { if (flag == 1) cout \u003c\u003c \" \"; cout \u003c\u003c v[i]; flag = 1; } } return 0; } B1006-换个格式输出整数 题目 这道题思路很棒,通过除和取余运算,将int数值每位装进一个char数组中,然后进行单个位操作 int main(){ int j,num; scanf(\"%d\", \u0026num); int i = 0; int res[3] = {0}; while(num != 0){ res[i++] = num%10; num = num/10; } for(j=0; j\u003cres[2]; j++){ printf(\"%s\", \"B\"); } for(j=0; j\u003cres[1]; j++){ printf(\"%s\", \"S\"); } for(j=0; j\u003cres[0]; j++){ printf(\"%d\", j+1); } return 0; } B1007-素数对猜想 这道数学题让我蒙了呀,暴力超时 原来素数有一种快的求法,我太菜辣 ","date":"2020-07-18","objectID":"/posts/pat-1/:4:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"求素数 m 不必被 2 ~ m-1 之间的每一个整数去除，只需被 2 ~ $\\sqrt{m}$ 之间的每一个整数去除就可以了。如果 m 不能被 2 ~ $\\sqrt{m}$ 间任一整数整除，m 必定是素数。例如判别 17 是是否为素数，只需使 17 被 2~4 之间的每一个整数去除，由于都不能整除，可以判定 17 是素数。 原因：因为如果 m 能被 2 ~ m-1 之间任一整数整除，其二个因子必定有一个小于或等于 $\\sqrt{m}$，另一个大于或等于 $\\sqrt{m}$。例如 16 能被 2、4、8 整除，16=28，2 小于 4，8 大于 4，16=44，4=$\\sqrt{16}$，因此只需判定在 2~4 之间有无因子即可。 参考文章 int main() { int n,k,prime,nprime; int i,j,f; scanf(\"%d\",\u0026n); k==0;prime=3;nprime=3; for(i=5;i\u003c=n;i+=2){ f=0; for(j=2;j*j\u003c=i;j++){ if(i%j==0){ f=1; //求素数 break; } } if(f==0){ nprime = i; if(nprime-prime==2) k++; prime=nprime; } } printf(\"%d\\n\",k); return 0; } B1008-数组元素循环右移问题 这道题我有两种解法嘿嘿 第一种方法是用一个大大的数组,提供可以移动的空间,数组内部移动 第二种是用c的qsort函数,数组内部排序 ","date":"2020-07-18","objectID":"/posts/pat-1/:5:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"大空间移动法 int main(){ int N,M; scanf(\"%d %d\", \u0026N, \u0026M); int data[300]; M = M%N; for(int i = 0; i\u003c N; i++){ scanf(\"%d\", \u0026data[i]); } int a = N; int b = N-M; for(int j=0; j\u003cb; j++){ data[a] = data[j]; a++; } for(int k=0; k\u003c N; k++){ if(k != 0){ printf(\" \"); } printf(\"%d\", data[b]); b++; } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-1/:6:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"快排法 int cmp_int(const void* a , const void* b) { return ( *(int*)a - *(int*)b ); } int main(){ int N,M; scanf(\"%d %d\", \u0026N, \u0026M); int data[N]; M = M%N; for(int i = 0; i\u003c N; i++){ scanf(\"%d\", \u0026data[i]); } int a = N-M; int temp; for(int i=0; i\u003cM; i++){ temp = data[i]; data[i] = data[a]; data[a] = temp; a++; } qsort(\u0026data[M], N-M, sizeof(int),cmp_int); for(int k = 0; k\u003c N; k++){ printf(\"%d\", data[k]); } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-1/:7:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"reverse()函数 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eusing namespace std; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003e a(n); for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; m %= n; if (m != 0) { reverse(begin(a), begin(a) + n); reverse(begin(a), begin(a) + m); reverse(begin(a) + m, begin(a) + n); } for (int i = 0; i \u003c n - 1; i++) cout \u003c\u003c a[i] \u003c\u003c \" \"; cout \u003c\u003c a[n - 1]; return 0; } B1009-说反话 这道题我也有三种解法 没错,其中一种就是我的笨方法 ","date":"2020-07-18","objectID":"/posts/pat-1/:8:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"C++栈 #include \u003ciostream\u003e#include \u003cstack\u003eusing namespace std; int main() { stack\u003cstring\u003e v; string s; while(cin \u003e\u003e s) v.push(s); cout \u003c\u003c v.top(); v.pop(); while(!v.empty()) { cout \u003c\u003c \" \" \u003c\u003c v.top(); v.pop(); } return 0; } ","date":"2020-07-18","objectID":"/posts/pat-1/:9:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"字符串截至法 竟然可以把字符串一个位置直接赋值’\\0’截断 这是我没想到的操作,学到了(我太菜辣啊!) int main(){ int i; char data[81]; gets(data); for(i=strlen(data)-1; i\u003e=0; i--){ if(data[i] == ' '){ printf(\"%s\", \u0026data[i+1]); printf(\"%c\", data[i]); data[i] = '\\0'; } if(i==0){ printf(\"%s\", \u0026data[i]); } } } ","date":"2020-07-18","objectID":"/posts/pat-1/:10:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"笨方法 搞一个超大数组,然后数组内操作,这是我从之前方法学到的 但是跟字符串截断相比…算了不比了 int main(){ char word[162]; int word_count = 0; gets(word); int p = 0; int q = 161; while(word[p] != '\\0'){ while(word[p]!= ' ' \u0026\u0026 word[p]!= '\\0'){ word_count++; p++; } for(int i=1; i\u003cword_count+1; i++){ word[q] = word[p-i]; q--; } ++p; word_count = 0; word[q] = ' '; q--; } int start = 161-p+2; for(int k=1; k\u003cp; k++){ printf(\"%c\", word[start]); start++; } return 0; } B1010-一元多项式求导 这道题就是之前说到的用flag判断输出空格 另外getchar()判断输入结尾,属实厉害嗷,学到了 c++就简便很多了,快乐c++ ","date":"2020-07-18","objectID":"/posts/pat-1/:11:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"C++ #include \u003ciostream\u003eusing namespace std; int main() { int a, b, flag = 0; while (cin \u003e\u003e a \u003e\u003e b) { if (b != 0) { if (flag == 1) cout \u003c\u003c \" \"; cout \u003c\u003c a * b \u003c\u003c \" \" \u003c\u003c b - 1; flag = 1; } } if (flag == 0) cout \u003c\u003c \"0 0\"; return 0; } ","date":"2020-07-18","objectID":"/posts/pat-1/:12:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"菜鸡的方法 #include\u003ccstdlib\u003e#include\u003ciostream\u003eusing namespace std; int main(int argc, char const *argv[]) { char ch; int tmp1, tmp2; bool flag = false; while(1){ cin \u003e\u003e tmp1 \u003e\u003e tmp2; if(tmp2 != 0){ if(flag){ cout \u003c\u003c \" \"; } else{ flag = true; } cout \u003c\u003c tmp1*tmp2 \u003c\u003c \" \" \u003c\u003c tmp2-1; } if((ch = getchar()) == '\\n'){ break; } } if (flag == false) cout \u003c\u003c \"0 0\"; system(\"pause\"); return 0; } ","date":"2020-07-18","objectID":"/posts/pat-1/:13:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["PAT"],"content":"C实现 int main(){ int a,b; int flag=0; char ch; while(1){ scanf(\"%d%d\",\u0026a,\u0026b); if(b!=0){ if(flag==0) printf(\"%d\",a*b); else printf(\" %d\",a*b); printf(\" %d\",b-1); flag=1; } ch = getchar(); if(ch == '\\n'){ break; } } if(flag==0) printf(\"0 0\"); //flag为0代表，所有的输入指数都为0，如果不为0的话 return 0;//就置1了。 } ","date":"2020-07-18","objectID":"/posts/pat-1/:14:0","tags":["Leetcode-C++"],"title":"PAT-Basic 01~10","uri":"/posts/pat-1/"},{"categories":["Ubuntu"],"content":"可视化界面操作起来很慢(并且linux是Appimage安装包),还是bash来的实在,今天把COSCMD配置了一下 安装pip sudo curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py sudo python3 get-pip.py 配置文件 coscmd config -a AChT4ThiXAbpBDEFGhT4ThiXAbp**** -s WE54wreefvds3462refgwewe**** -b examplebucket-1250000000 -r ap-beijing # -a 密钥 ID hexo # -s 密钥 Key # -b 指定的存储桶名称 # -r 存储桶所在地域 上传 coscmd upload 上传当前位置 1.png 文件到 存储桶 pat-11 文件夹下(pat-11若没有存在,则新建) coscmd upload 1.png pat-11/ #文件 coscmd upload -r \u003clocalpath\u003e \u003ccospath\u003e #文件夹 # 忽略 .txt 和 .doc 的后缀文件 coscmd upload -rs /data/examplefolder data/examplefolder --ignore *.txt,*.doc 下载 coscmd download \u003ccospath\u003e \u003clocalpath\u003e #文件 coscmd download -r \u003ccospath\u003e \u003clocalpath\u003e #文件夹 删除 coscmd delete \u003ccospath\u003e #文件 coscmd delete -r \u003ccospath\u003e #文件夹 获取URL coscmd signurl coscmd signurl pat-11/1.png ","date":"2020-07-11","objectID":"/posts/ubuntu-27/:0:0","tags":["腾讯COS"],"title":"COSCMD工具","uri":"/posts/ubuntu-27/"},{"categories":["C++"],"content":"算法笔记知识点汇总-C++语法基础 double类型,scanf需要使用\"%lf\" 字符串(char数组)scanf不需要\u0026,例如: scanf(\"%s\",str); 当需要申请较大空间的数组时,应将其定义在主函数的外面,因为在函数内部申请的局部变量来自于系统栈,函数外申请的全局变量来自于静态存储区 实用的输出格式 %md,%0md,%.mf %md可以使不足m位的int型变量以m位进行右对齐输出,其中高位用空格补齐,如果本身超过m位,则保持原样 #include\u003cstdio.h\u003e int main(){ int a = 123, b=123456; printf(\"%5d\\n, a\"); printf(\"%5d\\n\", b); return 0; } /* 输出结果: 123 123456 */ %0md即用0来代替空格进行补齐 %.mf代表小数点后保留几位 常用的math函数 fabs(double x): 对double类型变量取绝对值 floor(double x): 对double类型变量向下取整,返回类型为double ceil(double x): 对double类型变量向上取整 pow(double a, double b): 用于返回 ab sqrt(double x): 返回算数平方跟 log(double x): 返回以自然数为底的对数 在c语言中没有对任意底数求对数的函数,因此必须使用换底公式来进行求解 round(double x): 用于将double类型变量进行四舍五入,返回double类型 memset 对数组中的每一个元素赋予相同的值 memset(a, 0, sizeof(a)); gets() 对于scanf函数来说,其中的 %s 取字符串会通过空格或换行符来识别一个字符串的结束 因此,scanf(\"%s\", \u0026a); 无法全部取到 “hello world”,遇到空格就会终止 gets()函数用于输入一整行字符串,因为其识别换行符作为输入的终止 sscanf和sprintf 可以简单的将其看作,输入输出对象从screen换成了字符串数组 结构体的初始化: 构造函数 不需要写返回类型,并且函数名和结构体名字相同,一般来说,对于一个普通定义的结构体,其内部会默认生成一个构造函数 如果对构造函数进行自定义,可以写多个函数,以适应不同的初始化场合 struct studentinfo{ int id; char gender; studentinfo(){}; studentinfo(){ gender = _gender; } studentinfo(){ gender = _gender; id = _id; } } EOF 当题目没有说明多少数据会输入时,可以利用scanf的返回值是否为EOF来判断输入是否结束(EOF = END OF FILE) while(scanf(\"%d, \u0026n\") != EOF){ /*code*/ } ","date":"2020-06-28","objectID":"/posts/CPP-3/:0:0","tags":["C++基础语法"],"title":"C++ Part-3","uri":"/posts/CPP-3/"},{"categories":["数据结构与算法"],"content":"学到STL中的set和map,发现底层实现是红黑树,之前一直听说过这个结构,这次遇到了实际应用,早晚都要学,不如今天学了 红黑树概述 历史上AVL树流行的另一变种是红黑树（red-black tree）。对红黑树的操作能保证在最坏情况下动态几何操作的时间为O(logN) 。AVL树是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 STL中的关联式容器默认的底层实现都是红黑树，以及Linux内核中包括进程队列等结构也是基于红黑树 红黑树是二叉查找树，但在每个节点上增加了一位存储位表示该节点的颜色，具体可以是 RED 或 BLACK。通过对任一条从根到叶子的路径上各节点着色方式的限制，红黑树确保了没有一条路径会比其他路径长到两倍，因而基本上是平衡的。它所追求的的是局部平衡而不是AVL树中的非常严格的平衡。 ","date":"2020-06-28","objectID":"/posts/DS-12/:0:0","tags":["Leetcode-C++"],"title":"红黑树","uri":"/posts/DS-12/"},{"categories":["数据结构与算法"],"content":"着色规则 每个节点不是红色就是黑色 根节点为黑色 如果节点为红，其子节点必须为黑（一条路径上不能出现连续的两个红色节点） 任一节点至NULL（树尾端）的任何路径，所含之黑节点数必须相同 根据规则4，新增节点必须为红；根据规则3，新增节点之父点必须为黑 当新节点根据二叉查找树的规则（键值大小）到达其插入点，却未能符合上述条件，就必须调整颜色并旋转树形 AVL 树插入节点后如果不满足其平衡条件，需要旋转树形。红黑树并不是基于 AVL 树的，它是在二叉查找树的基础上。 一条路径上不能出现连续的两个红色节点，必须有黑色节点间隔开来 红黑树的每条路径中所含黑色节点的数目必须相同，这样就限制每条路径之间的高度差，从而达到接近平衡的目的。 插入节点 同AVL树，红黑树的插入也要考虑以下几种情况，然后兼顾上面的着色法则。所有待插入节点初始着色为红色，最后将根节点重新设置为黑色。 ","date":"2020-06-28","objectID":"/posts/DS-12/:1:0","tags":["Leetcode-C++"],"title":"红黑树","uri":"/posts/DS-12/"},{"categories":["数据结构与算法"],"content":"空树 这是最简单的一种形式，直接添加，着色为黑色（规则2） ","date":"2020-06-28","objectID":"/posts/DS-12/:2:0","tags":["Leetcode-C++"],"title":"红黑树","uri":"/posts/DS-12/"},{"categories":["数据结构与算法"],"content":"仅存在根节点（黑色），或待插入节点 X 的父节点 P 为黑色 直接添加即可，无需任何旋转和调整颜色。这种情况下，直接添加满足所有的着色法则，不用理会其叔节点的特征。 ","date":"2020-06-28","objectID":"/posts/DS-12/:3:0","tags":["Leetcode-C++"],"title":"红黑树","uri":"/posts/DS-12/"},{"categories":["数据结构与算法"],"content":"待插入节点 X 的父节点 P 为红色，且该父节点 P 为X 祖父节点G 的左儿子 这种情况下，又分为几种情况： ","date":"2020-06-28","objectID":"/posts/DS-12/:4:0","tags":["Leetcode-C++"],"title":"红黑树","uri":"/posts/DS-12/"},{"categories":["数据结构与算法"],"content":"X 的叔节点 S 为红色，（X 的叔节点就是 X 的祖父节点的右儿子） 此时存在红- 红的情况，父子节点同时为红色，不满足着色法则3，需要作出调整。 调整策略就是：将X 节点的父节点和叔节点着黑色，将其祖父节点着红色，这样该局部满足着色法则，但是尚不清楚其曾祖父GG节点的颜色，如果GG为红色，由于G也为红色，这样就不满足着色法则3，仍需要调整；如果GG为黑色就不需要调整了，这里的调整策略便是向上迭代调整，就是向上更换当前位置（将原当前位置X，设置为X的祖父节点G），再进行同等判断调整。如下图： ","date":"2020-06-28","objectID":"/posts/DS-12/:4:1","tags":["Leetcode-C++"],"title":"红黑树","uri":"/posts/DS-12/"},{"categories":["数据结构与算法"],"content":"X 的叔节点 S 为黑色（NULL认为是黑色节点） 红黑树还有个规则就是NULL节点一律看作是黑节点，如某节点K 的右儿子不存在，即该右儿子看作是黑色节点，这个不影响着色法则。 叔节点S 为黑，这样就需要通过旋转和改变颜色来调整了，通过之前的 AVL 树，我们知道外侧插入和内侧插入的旋转不一样，外侧插入（这里的左左）只需单旋转，而内侧插入（左右）则需要双旋转。 外侧插入，即待插入节点X 为其父节点的左儿子 这种情况下，需要进行单旋转然后调整颜色。关于外侧插入的旋转已经在AVL树中介绍，这里是相似的，不再赘述。实现细节看图便知 调整前后局部根节点还是黑色，也就是这种情况下只需要局部调整颜色然后单旋转即可，不需要向上迭代 内侧插入，即待插入节点X 为其父节点的右儿子 该情况下，需要先进行左旋转，然后调整颜色，然后再次进行右旋转即可，前后局部根节点依旧为黑色节点，同样不需要考虑上一层的红-红问题，实现细节如下图： 上述第3点考虑的是待插入节点的父节点 P 为X 祖父节点G 的左儿子的情况，其作为右儿子也是类似的操作，差别在于旋转的先后顺序上，同AVL树的旋转调整。这里也顺便贴出来，见第4点 ","date":"2020-06-28","objectID":"/posts/DS-12/:4:2","tags":["Leetcode-C++"],"title":"红黑树","uri":"/posts/DS-12/"},{"categories":["数据结构与算法"],"content":"4、待插入节点 X 的父节点 P 为红色，且该父节点 P 为X 祖父节点G 的右儿子 同样分为以下几种情况，由于与第3点是对称性结构，这里就简单的贴图说明： ","date":"2020-06-28","objectID":"/posts/DS-12/:5:0","tags":["Leetcode-C++"],"title":"红黑树","uri":"/posts/DS-12/"},{"categories":["数据结构与算法"],"content":"X 的叔节点 S 为红色，（X 的叔节点就是 X 的祖父节点的左儿子） 此时同样需要解决红-红（父子节点同时为红色）的问题，调整位置向上迭代判断调整 ","date":"2020-06-28","objectID":"/posts/DS-12/:5:1","tags":["Leetcode-C++"],"title":"红黑树","uri":"/posts/DS-12/"},{"categories":["数据结构与算法"],"content":"X 的叔节点 S 为黑色（NULL认为是黑色节点） 需要考虑外侧插入和内侧插入的情况 外侧插入，即待插入节点X 为其父节点的右儿子 内侧插入，即待插入节点X 为其父节点的左儿子 参考blog 参考blog2 ","date":"2020-06-28","objectID":"/posts/DS-12/:5:2","tags":["Leetcode-C++"],"title":"红黑树","uri":"/posts/DS-12/"},{"categories":["C++"],"content":"第二部分: 面向对象-类 C++ 类成员函数 成员函数可以定义在类定义内部 class Box { public: double length; // 长度 double breadth; // 宽度 double height; // 高度 double getVolume(void) { return length * breadth * height; } }; 单独使用范围解析运算符 :: 来定义 double Box::getVolume(void) { return length * breadth * height; } ","date":"2020-06-28","objectID":"/posts/CPP-2/:0:0","tags":["C++基础语法"],"title":"C++ Part-2","uri":"/posts/CPP-2/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; class Box { public: double length; // 长度 double breadth; // 宽度 double height; // 高度 // 成员函数声明 double getVolume(void); void setLength( double len ); void setBreadth( double bre ); void setHeight( double hei ); }; // 成员函数定义 double Box::getVolume(void) { return length * breadth * height; } void Box::setLength( double len ) { length = len; } void Box::setBreadth( double bre ) { breadth = bre; } void Box::setHeight( double hei ) { height = hei; } // 程序的主函数 int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box double volume = 0.0; // 用于存储体积 // box 1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // box 2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // box 1 的体积 volume = Box1.getVolume(); cout \u003c\u003c \"Box1 的体积：\" \u003c\u003c volume \u003c\u003cendl; // box 2 的体积 volume = Box2.getVolume(); cout \u003c\u003c \"Box2 的体积：\" \u003c\u003c volume \u003c\u003cendl; return 0; } 类构造函数 #include \u003ciostream\u003eusing namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(); // 这是构造函数 private: double length; }; // 成员函数定义，包括构造函数 Line::Line(void) //在实例化时,构造函数自动执行 { cout \u003c\u003c \"Object is being created\" \u003c\u003c endl; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // 程序的主函数 int main( ) { Line line; // 设置长度 line.setLength(6.0); cout \u003c\u003c \"Length of line : \" \u003c\u003c line.getLength() \u003c\u003cendl; return 0; } ","date":"2020-06-28","objectID":"/posts/CPP-2/:1:0","tags":["C++基础语法"],"title":"C++ Part-2","uri":"/posts/CPP-2/"},{"categories":["C++"],"content":"带参数的构造函数 #include \u003ciostream\u003eusing namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(double len); // 这是构造函数 private: double length; }; // 成员函数定义，包括构造函数 Line::Line( double len) { cout \u003c\u003c \"Object is being created, length = \" \u003c\u003c len \u003c\u003c endl; length = len; } void Line::setLength( double len ) { length = len; } // 程序的主函数 int main( ) { Line line(10.0); line.setLength(6.0); return 0; } ","date":"2020-06-28","objectID":"/posts/CPP-2/:2:0","tags":["C++基础语法"],"title":"C++ Part-2","uri":"/posts/CPP-2/"},{"categories":["C++"],"content":"使用初始化列表来初始化字段 Line::Line( double len): length(len) { cout \u003c\u003c \"Object is being created, length = \" \u003c\u003c len \u003c\u003c endl; } 上面的语法等同于如下语法： Line::Line( double len) { length = len; cout \u003c\u003c \"Object is being created, length = \" \u003c\u003c len \u003c\u003c endl; } 假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示： C::C( double a, double b, double c): X(a), Y(b), Z(c) { .... } 类的析构函数 在每次删除所创建的对象时执行 #include \u003ciostream\u003eusing namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(); // 这是构造函数声明 ~Line(); // 这是析构函数声明 private: double length; }; // 成员函数定义，包括构造函数 Line::Line(void) { cout \u003c\u003c \"Object is being created\" \u003c\u003c endl; } Line::~Line(void) { cout \u003c\u003c \"Object is being deleted\" \u003c\u003c endl; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // 程序的主函数 int main( ) { Line line; // 设置长度 line.setLength(6.0); cout \u003c\u003c \"Length of line : \" \u003c\u003c line.getLength() \u003c\u003cendl; return 0; } /* 当上面的代码被编译和执行时，它会产生下列结果： Object is being created Length of line : 6 Object is being deleted */ C++ 拷贝构造函数 #include \u003ciostream\u003eusing namespace std; class Line { public: int getLength( void ); Line( int len ); // 简单的构造函数 Line( const Line \u0026obj); // 拷贝构造函数 ~Line(); // 析构函数 private: int *ptr; }; // 成员函数定义，包括构造函数 Line::Line(int len) { cout \u003c\u003c \"调用构造函数\" \u003c\u003c endl; // 为指针分配内存 ptr = new int; *ptr = len; } Line::Line(const Line \u0026obj) { cout \u003c\u003c \"调用拷贝构造函数并为指针 ptr 分配内存\" \u003c\u003c endl; ptr = new int; *ptr = *obj.ptr; // 拷贝值 } Line::~Line(void) { cout \u003c\u003c \"释放内存\" \u003c\u003c endl; delete ptr; } int Line::getLength( void ) { return *ptr; } void display(Line obj) { cout \u003c\u003c \"line 大小 : \" \u003c\u003c obj.getLength() \u003c\u003cendl; } // 程序的主函数 int main( ) { Line line(10); display(line); return 0; } /* 调用构造函数 调用拷贝构造函数并为指针 ptr 分配内存 line 大小 : 10 释放内存 释放内存 */ 由于在执行display函数时会产生一个临时变量 随后调用拷贝构造函数把line的值给临时变量 等待函数执行完成后, 析构掉原始变量以及临时变量 ","date":"2020-06-28","objectID":"/posts/CPP-2/:3:0","tags":["C++基础语法"],"title":"C++ Part-2","uri":"/posts/CPP-2/"},{"categories":["C++"],"content":"从一开始刷OJ,leetcode到PAT,一直用的C 晚上去听了两小时c++刷PAT题的教程,发现原来…c++这么爽! 我不行了,我是菜鸡,我用不起c,以我现在的实力,就一个char数组或者哈希我能玩玩,别的工具也太少了 第一部分: 基础概念 今天看了一半的简单教程,这一个个知识点也太熟悉了,跟c#,java差不多嘛(都是面向对象的,不然呢)找到了曾经初恋的感觉 废话不多说,今天把要点记下来,只记个人觉得重要的知识点 枚举类型 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; 如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。 例如，下面的代码定义了一个颜色枚举，变量c的类型为color。最后，c被赋值为 “blue”。 enum color { red, green, blue } c; c = blue; 默认情况下，第一个名称的值为0，第二个名称的值为1，第三个名称的值为2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green的值为5。 enum color { red, green=5, blue }; 在这里，blue的值为6，因为默认情况下，每个名称都会比它前面一个名称大1，但red的值依然为0。 有符号整数和无符号整数修饰符 #include \u003ciostream\u003eusing namespace std; int main() { short int i; // 有符号短整数 short unsigned int j; // 无符号短整数 j = 50000; i = j; cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c j; return 0; } 当上面的程序运行时，会输出下列结果： -15536 50000 //无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536 static 存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。 使用static修饰局部变量可以在函数调用之间保持局部变量的值。 当static修饰全局变量时，会使变量的作用域限制在声明它的文件内。 extern 存储类 这个之前在c中有,现在再记录一遍 extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ’extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。 可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 函数参数 ","date":"2020-06-27","objectID":"/posts/CPP-1/:0:0","tags":["C++基础语法"],"title":"C++ Part-1","uri":"/posts/CPP-1/"},{"categories":["C++"],"content":"\u0026引用 引用可以理解为: 为当前数据起了一个别名,在操纵这个别名时,就是在操作这个数据本身 另外引用的\u0026符号和取地址的\u0026区别很大,可以看作是两种功能的符号(这个需要特别注意) #include \u003ciostream\u003e using namespace std; int main () { // 声明简单的变量 int i; double d; // 声明引用变量 int\u0026 r = i; double\u0026 s = d; i = 5; cout \u003c\u003c \"Value of i : \" \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \"Value of i reference : \" \u003c\u003c r \u003c\u003c endl; d = 11.7; cout \u003c\u003c \"Value of d : \" \u003c\u003c d \u003c\u003c endl; cout \u003c\u003c \"Value of d reference : \" \u003c\u003c s \u003c\u003c endl; return 0; } /* 输出: Value of i : 5 Value of i reference : 5 Value of d : 11.7 Value of d reference : 11.7 */ ","date":"2020-06-27","objectID":"/posts/CPP-1/:1:0","tags":["C++基础语法"],"title":"C++ Part-1","uri":"/posts/CPP-1/"},{"categories":["C++"],"content":"引用调用 向函数传递参数的引用调用方法，把引用的地址复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。 修改形式参数会影响实际参数 按引用传递值，参数引用被传递给函数，就像传递其他值给函数一样。因此相应地，在下面的函数 swap() 中，您需要声明函数参数为引用类型，该函数用于交换参数所指向的两个整数变量的值。 #include \u003ciostream\u003eusing namespace std; void swap(int \u0026x, int \u0026y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u003c\u003c \"交换前，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换前，b 的值：\" \u003c\u003c b \u003c\u003c endl; /* 调用函数来交换值 */ swap(a, b); cout \u003c\u003c \"交换后，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换后，b 的值：\" \u003c\u003c b \u003c\u003c endl; return 0; } void swap(int \u0026x, int \u0026y) { int temp; temp = x; /* 保存地址 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return; } ","date":"2020-06-27","objectID":"/posts/CPP-1/:2:0","tags":["C++基础语法"],"title":"C++ Part-1","uri":"/posts/CPP-1/"},{"categories":["C++"],"content":"C++ 引用作为返回值 当函数返回一个引用时,则返回一个指向返回值的隐式指针,函数就可以放在赋值语句的左边 #include \u003ciostream\u003eusing namespace std; double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0}; double\u0026 setValues( int i ) { return vals[i]; // 返回第 i 个元素的引用 } // 要调用上面定义函数的主函数 int main () { setValues(1) = 20.23; // 改变第 2 个元素 setValues(3) = 70.8; // 改变第 4 个元素 return 0; } ","date":"2020-06-27","objectID":"/posts/CPP-1/:3:0","tags":["C++基础语法"],"title":"C++ Part-1","uri":"/posts/CPP-1/"},{"categories":["C++"],"content":"函数参数默认值 只需要在参数中进行初始化值就完事了 当调用函数时，如果实际参数的值留空，则使用这个默认值 int sum(int a, int b=20) { /*code*/ } C++ 随机数 生成随机数需要调用两个函数 srand()和rand() 下民使用time()函数来获取系统时间的秒数，并通过调用 rand() 函数来生成随机数： #include \u003ciostream\u003e#include \u003cctime\u003e#include \u003ccstdlib\u003e using namespace std; int main () { int i,j; // 设置种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i \u003c 10; i++ ) { // 生成实际的随机数 j= rand(); cout \u003c\u003c\"随机数： \" \u003c\u003c j \u003c\u003c endl; } return 0; } C++ 字符串 ","date":"2020-06-27","objectID":"/posts/CPP-1/:4:0","tags":["C++基础语法"],"title":"C++ Part-1","uri":"/posts/CPP-1/"},{"categories":["C++"],"content":"C-字符串 以下函数适用于char数组构成的字符串 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。 strlen(s1); 返回字符串 s1 的长度。 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1 \u003c s2 则返回值小于 0；如果 s1 \u003e s2 则返回值大于 0。 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 ","date":"2020-06-27","objectID":"/posts/CPP-1/:5:0","tags":["C++基础语法"],"title":"C++ Part-1","uri":"/posts/CPP-1/"},{"categories":["C++"],"content":"C++ 中的 String 类 在以后标准库中进行讲解 变量值的交换函数的优化 这里利用了数异或的性质，一个数与其本身异或等于 0，0 与一个数异或不改变该数。说到 swap int swap(int\u0026 a, int\u0026 b) { int temp; temp = a ^ b; a = temp ^ a; b = temp ^ b; return 0; } ","date":"2020-06-27","objectID":"/posts/CPP-1/:6:0","tags":["C++基础语法"],"title":"C++ Part-1","uri":"/posts/CPP-1/"},{"categories":["HEXO"],"content":"今天大部分时间在搞数学,所以更的有点少(哭…) 404页面 看了很多帖子,最后都不好使,结果在官方文档上找到了… 直接将404.html文件放在\"next/source\"下就行啦 移动端背景图片模糊 因为background-attachment属性在移动端上并不好使,所以移动端上的背景图片就糊成了一片 最后找到了一种妥协的方法,就是将图片进行repeat拼接 另外还有个知识点before标签 body:before { top: 1rem; left: 0; bottom: 0; right: 0; z-index: -1; } body { background: url(https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/Blog_sourse/images/bg-common.jpg); background-size: cover; background-repeat: repeat; //拼接 background-position: 50% 50%; } 增加对数学公式的支持 ","date":"2020-06-21","objectID":"/posts/hexo-3/:0:0","tags":["HEXO-NEXT"],"title":"NEXT Part-2","uri":"/posts/hexo-3/"},{"categories":["HEXO"],"content":"更换Hexo的markdown渲染引擎 hexo-renderer-kramed引擎是在默认的渲染引擎，hexo-renderer-marked的基础上修改了一些bug，两者比较接近，也比较轻量级。 npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save ","date":"2020-06-21","objectID":"/posts/hexo-3/:1:0","tags":["HEXO-NEXT"],"title":"NEXT Part-2","uri":"/posts/hexo-3/"},{"categories":["HEXO"],"content":"修改文件 为了解决语义冲突,找到文件 node_modules\\kramed\\lib\\rules\\inline.js 修改如下两处 //escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_\u003e])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_\u003e])/, //em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, ","date":"2020-06-21","objectID":"/posts/hexo-3/:2:0","tags":["HEXO-NEXT"],"title":"NEXT Part-2","uri":"/posts/hexo-3/"},{"categories":["HEXO"],"content":"开启mathJax 在next主题中开启mathJax开关 # Math Formulas Render Support math: per_page: true engine: mathjax mathjax: enable: true # 这个改为true mhchem: true # 这个改为true ","date":"2020-06-21","objectID":"/posts/hexo-3/:3:0","tags":["HEXO-NEXT"],"title":"NEXT Part-2","uri":"/posts/hexo-3/"},{"categories":["HEXO"],"content":"文章中添加头标签 --- ---title: Using-Machine-Learning-for-Data-Center-Cooling-Infrastructure-Efficiency-Prediction date: 2019-11-28 22:53:32 categories: [datacenter, machinelearning] category: DataCenter mathjax: true --- fancybox 进入next主题目录下执行 git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox 然后在主题配置的_config.yml中 fancybox: true ","date":"2020-06-21","objectID":"/posts/hexo-3/:4:0","tags":["HEXO-NEXT"],"title":"NEXT Part-2","uri":"/posts/hexo-3/"},{"categories":["计算机网络"],"content":"物理层 物理层下面的传输媒体 双绞线 屏蔽双绞线 STP 无屏蔽双绞线 UTP 同轴电缆 50 同轴电缆 用于数字传输，由于多用于基带传输，也叫基带同轴电缆； 75 同轴电缆用于模拟传输，即宽带同轴电缆。 ","date":"2020-06-20","objectID":"/posts/CN-2/:0:0","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"网线 ","date":"2020-06-20","objectID":"/posts/CN-2/:1:0","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"直通线 直通线应用最广泛，这种类型的以太网电缆用来实现下列连接: 主机到交换机或集线器 路由器到交换机或集线器 ","date":"2020-06-20","objectID":"/posts/CN-2/:1:1","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"交叉线 应用: 交换机到交换机 集线器到集线器 主机到主机 集线器到交换机 路由器直连到主机 ","date":"2020-06-20","objectID":"/posts/CN-2/:1:2","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"光纤 ","date":"2020-06-20","objectID":"/posts/CN-2/:2:0","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"折射 ","date":"2020-06-20","objectID":"/posts/CN-2/:2:1","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"工作原理 ","date":"2020-06-20","objectID":"/posts/CN-2/:2:2","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"单模光纤与多模光纤 ","date":"2020-06-20","objectID":"/posts/CN-2/:2:3","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"电磁波的频谱 ","date":"2020-06-20","objectID":"/posts/CN-2/:3:0","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"物理层设备—-集线器 工作特点：它在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力 最大传输距离：100m 集线器是一个大的冲突域 信道复用技术 ","date":"2020-06-20","objectID":"/posts/CN-2/:4:0","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"频分复用(FDM) Frequency Division Multiplexing 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率） 由于频率范围极为广泛,因此可进行多组整合 ","date":"2020-06-20","objectID":"/posts/CN-2/:5:0","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"时分复用(TDM) Time Division Multiplexing 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙 每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度对应的时间） TDM 信号也称为等时(isochronous)信号。 时分复用的所有用户是在不同的时间占用同样的频带宽度。 多组数据进行重组 在生成和解析过程中,使用了类似轮拨盘的算法 为了防止资源上的浪费,可进行不固定性的拼凑帧操作 ","date":"2020-06-20","objectID":"/posts/CN-2/:6:0","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["计算机网络"],"content":"波分复用(WDM) Wavelength Division Multiplexing ","date":"2020-06-20","objectID":"/posts/CN-2/:7:0","tags":["计网-课程"],"title":"计算机网络 Part-2","uri":"/posts/CN-2/"},{"categories":["HEXO"],"content":"18号刷PAT,19号改NEXT的bug,鸽了两天,今天全都补上 一直犹豫要不要换到NEXT,因为工作量很大,但是原来使用的主题拓展性实在太差了…我真的很想加个站内检索…因为经常需要找原来blog记录的某一个知识点 Version: NEXT-7.8 以下方法使用于scheme: Gemini 安装 仓库地址: NEXT 首页不显示全文 next默认首页文章不显示全,但需要在markdown中进行标注 在需要显示的文字下增加,进行截至标注 \u003c!--more--\u003e 页面元素设置 具体参考大佬的blog 另外config文件中已经注释的很清楚了,慢慢看就可以完全理解 文章目录的坑 之前的主题,为了在文章前面加上目录,安装了\"hexo-toc\"插件 但是我一直以为是hexo自带的…使用next之后,文章目录显示错误,目录上没有文章锚点,并且不可以跟随阅读进度进行实时更新 大晚上的…这个bug差点没给我送走 还好最后搜到了一个issue 万万没想到啊…这都可以,行吧,卸载就完事了 npm remove hexo-toc --save hexo g报错 出现如下错误: Cannot read property 'replace' of null 原因为文章头部格式出错 参考blog 引入自定义css NEXT-7取消了custom.styl文件,老版本的教程都无效 但是在config文件中进行了集成 custom_file_path: #head: source/_data/head.swig ...省略 #mixin: source/_data/mixins.styl style: themes/next/source/_data/styles.styl #取消注释 在路径\"themes/next/source\"创建\"_data\"文件夹 创建styles.styl文件 我加入了以下的样式,感觉效果还不错: 添加背景图片 标题栏背景颜色 透明度调整 增加圆角 // 添加背景图片 body { background: url(https://tronwei-1254020584.cos.ap-beijing.myqcloud.com/Blog_sourse/images/bg.jpg);//自己喜欢的图片地址 background-size: cover; background-repeat: no-repeat; background-attachment: fixed; background-position: 50% 50%; } // 标题栏背景 .site-meta { padding: 20px 0; color: #fff; background: $black; background-repeat: no-repeat; background-attachment:fixed; background-position:center; background-size:cover; } //文章内容的透明度设置 .content-wrap { opacity: 0.94; } //侧边框的透明度设置 .sidebar { opacity: 0.86; border-radius: 40px 40px 0px 0px; } .sidebar-inner{ border-radius: 40px 40px 0px 0px; } //菜单栏的透明度设置 .header-inner { background: rgba(255,255,255,0.9); border-radius 40px; } //搜索框（local-search）的透明度设置 .popup { opacity: 0.9; } 参考blog 标签页加入tagcloud 之前主题我在tag页中加入了文字云,感觉显示效果很棒! 然后就想在next中也加入,不过之前是pug模板,现在是swig模板,所以有点差别 然而最后为了省时间反而踩了个大坑(哭) 请不要使用\"hexo-tag-cloud\"插件 这里介绍我的方法,显示效果没问题,那个插件问题就很多…蜜汁默认300*150像素,我自适应大小后,云图直接糊了(我人傻了)…凌晨一点又差点给我送走,还好过了一晚上,今天决定用之前的了,之后就成功啦 但这个插件也能用,适合一个小块显示,不适用于整个页面显示参考blog ","date":"2020-06-20","objectID":"/posts/hexo-2/:0:0","tags":["HEXO-NEXT"],"title":"NEXT Part-1","uri":"/posts/hexo-2/"},{"categories":["HEXO"],"content":"增加css代码 在之前的style.styl文件中加入 //标签云图css .tag_box{ position: relative; width: 100%; } .leancloud-visitors-count{ margin-left: 5px; } .by_farbox { font-size: 10px; } .by_farbox a { color: #A6A6A6; } .by_farbox a:hover { color: #4786D6; } ","date":"2020-06-20","objectID":"/posts/hexo-2/:1:0","tags":["HEXO-NEXT"],"title":"NEXT Part-1","uri":"/posts/hexo-2/"},{"categories":["HEXO"],"content":"swig增加代码 在next/layout/page.swig中 {%- if page.type === 'tags' %} 后增加tag-cloud代码 \u003cdiv class=\"post-body{%- if page.direction and page.direction.toLowerCase() === 'rtl' %} rtl{%- endif %}\"\u003e {%- if page.type === 'tags' %} {# 新增加的云图显示标签页 #} \u003cstyle type=\"text/css\"\u003e #resCanvas { height: 100%; width: 100%; } \u003c/style\u003e \u003cscript type=\"text/javascript\" charset=\"utf-8\" src=\"../js/tagcloud.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" charset=\"utf-8\" src=\"../js/tagcanvas.js\"\u003e\u003c/script\u003e \u003cdiv class=\"tag_box\"\u003e \u003cdiv id=\"myCanvasContainer\" class=\"widget tagcloud\" style=\"text-align:center\"\u003e \u003ccanvas id=\"resCanvas\"\u003e {{ list_tags() }} \u003c/canvas\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2020-06-20","objectID":"/posts/hexo-2/:2:0","tags":["HEXO-NEXT"],"title":"NEXT Part-1","uri":"/posts/hexo-2/"},{"categories":["HEXO"],"content":"Html5中的Canvas宽度为100% 这里的canvas自适应大小,参照这个blog 参考blog 内容块圆角 我找了好久的post-block(内容块的class),最后在对应的scheme文件中找到了 文件路径: “next/source/css/_schemes/Gemini/index.styl” // Post \u0026 Comments blocks. .post-block { background: var(--content-bg-color); border-radius: $border-radius-inner; //border-radius-inner变量 box-shadow: $box-shadow-inner; padding: $content-desktop-padding; // When blocks are siblings (homepage). \u0026 + .post-block { border-radius: $border-radius; //border-radius变量 // Rewrite shadows \u0026 borders because all blocks have offsets. box-shadow: $box-shadow; margin-top: $sidebar-offset; } } 可以看到圆角值由两个css变量控制 打开文件: “next/source/css/_variables/Gemini.styl” 修改两个变量 $border-radius-inner = 30px; $border-radius = 30px; 最后完成圆角修改 增加站内搜索 ","date":"2020-06-20","objectID":"/posts/hexo-2/:2:1","tags":["HEXO-NEXT"],"title":"NEXT Part-1","uri":"/posts/hexo-2/"},{"categories":["HEXO"],"content":"安装插件: npm install hexo-generator-searchdb --save ","date":"2020-06-20","objectID":"/posts/hexo-2/:3:0","tags":["HEXO-NEXT"],"title":"NEXT Part-1","uri":"/posts/hexo-2/"},{"categories":["HEXO"],"content":"修改站点文件_config.yml 添加如下内容： # Search search: path: ./public/search.xml field: post format: html limit: 10000 path：索引文件的路径，相对于站点根目录 field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面 limit：限制搜索的条目数 hexo增加search(非next主题)参考blog ","date":"2020-06-20","objectID":"/posts/hexo-2/:4:0","tags":["HEXO-NEXT"],"title":"NEXT Part-1","uri":"/posts/hexo-2/"},{"categories":["HEXO"],"content":"修改主题配置文件_config.yml local_search: enable: true 文章字数统计、阅读时长 ","date":"2020-06-20","objectID":"/posts/hexo-2/:5:0","tags":["HEXO-NEXT"],"title":"NEXT Part-1","uri":"/posts/hexo-2/"},{"categories":["HEXO"],"content":"安装插件： npm install hexo-symbols-count-time --save ","date":"2020-06-20","objectID":"/posts/hexo-2/:6:0","tags":["HEXO-NEXT"],"title":"NEXT Part-1","uri":"/posts/hexo-2/"},{"categories":["HEXO"],"content":"修改主题配置文件_config.yml symbols_count_time: separated_meta: true # false会显示一行 item_text_post: true # 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_total: true # 底部footer是否显示字数统计属性文字 awl: 4 # 计算字数的一个设置,没设置过 wpm: 275 # 一分钟阅读的字数 ","date":"2020-06-20","objectID":"/posts/hexo-2/:7:0","tags":["HEXO-NEXT"],"title":"NEXT Part-1","uri":"/posts/hexo-2/"},{"categories":["HEXO"],"content":"站点配置文件_config.yml 增加以下内容 symbols_count_time: #文章内是否显示 symbols: true time: true #网页底部是否显示 total_symbols: true total_time: true 参考blog ","date":"2020-06-20","objectID":"/posts/hexo-2/:8:0","tags":["HEXO-NEXT"],"title":"NEXT Part-1","uri":"/posts/hexo-2/"},{"categories":["本科论文"],"content":"今天6.18,本科毕业答辩完成! 老师问的问题还挺简单的,并没有难为我,我都答上啦哈哈哈 四年大学算是一个完美的句号啦,以后再也不会被这个放射源那个反应堆所困扰 下一步开始狂刷数学题,继续学习计组和计网 然后准备7月份的PAT考试,拿乙级满分!(报名费肉疼…) 北京疫情越来越严重,希望老爸照顾好自己 上周老爸回家,整的现在我妈在家隔离了…这疫情 ","date":"2020-06-18","objectID":"/posts/paper-5/:0:0","tags":["论文"],"title":"答辩完啦!","uri":"/posts/paper-5/"},{"categories":["计算机组成原理"],"content":"计算机的运算方法 无符号数 有符号数 ","date":"2020-06-16","objectID":"/posts/CO-8/:0:0","tags":["计组-课程"],"title":"计算机组成原理 Part-8","uri":"/posts/CO-8/"},{"categories":["计算机组成原理"],"content":"机器数与真值 ","date":"2020-06-16","objectID":"/posts/CO-8/:1:0","tags":["计组-课程"],"title":"计算机组成原理 Part-8","uri":"/posts/CO-8/"},{"categories":["计算机组成原理"],"content":"原码表示法 ","date":"2020-06-16","objectID":"/posts/CO-8/:2:0","tags":["计组-课程"],"title":"计算机组成原理 Part-8","uri":"/posts/CO-8/"},{"categories":["计算机组成原理"],"content":"补码 正数的补数即为其本身 ","date":"2020-06-16","objectID":"/posts/CO-8/:3:0","tags":["计组-课程"],"title":"计算机组成原理 Part-8","uri":"/posts/CO-8/"},{"categories":["计算机组成原理"],"content":"补码的表示 ","date":"2020-06-16","objectID":"/posts/CO-8/:3:1","tags":["计组-课程"],"title":"计算机组成原理 Part-8","uri":"/posts/CO-8/"},{"categories":["计算机组成原理"],"content":"求补码的快捷方式 ","date":"2020-06-16","objectID":"/posts/CO-8/:3:2","tags":["计组-课程"],"title":"计算机组成原理 Part-8","uri":"/posts/CO-8/"},{"categories":["计算机组成原理"],"content":"反码表示法 ","date":"2020-06-16","objectID":"/posts/CO-8/:4:0","tags":["计组-课程"],"title":"计算机组成原理 Part-8","uri":"/posts/CO-8/"},{"categories":["计算机组成原理"],"content":"三种机器数的小结 ","date":"2020-06-16","objectID":"/posts/CO-8/:5:0","tags":["计组-课程"],"title":"计算机组成原理 Part-8","uri":"/posts/CO-8/"},{"categories":["计算机组成原理"],"content":"快捷变换 补码的补码是原码 原码 取反+1 -\u003e 补码 补码 取反+1 -\u003e 原码 补码-1 取反 -\u003e 原码 ","date":"2020-06-16","objectID":"/posts/CO-8/:6:0","tags":["计组-课程"],"title":"计算机组成原理 Part-8","uri":"/posts/CO-8/"},{"categories":["计算机组成原理"],"content":"DMA 今天做完了答辩的PPT!准备开吹了 DMA的特点 DMA 和程序中断两种方式的数据通路 DMA 与主存交换数据的三种方式 停止 CPU 访问主存 控制简单 CPU 处于不工作状态或保持状态 未充分发挥 CPU 对主存的利用率 周期挪用（或周期窃取） DMA 访问主存有三种可能 CPU 此时不访存 CPU 正在访存 CPU 与 DMA 同时请求访存 此时 CPU 将总线控制权让给 DMA DMA 与 CPU 交替访问 CPU 工作周期 C1 专供 DMA 访存 C2 专供 CPU 访存 不需要 申请建立和归还 总线的使用权 DMA 接口的功能和组成 ","date":"2020-06-16","objectID":"/posts/CO-7/:0:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"DMA 接口功能 向 CPU 申请 DMA 传送 处理总线 控制权的转交 管理 系统总线、控制数据传送 确定 数据传送的 首地址和长度 修正传送过程中的数据地址和长度 DMA 传送结束时，给出操作完成信号 ","date":"2020-06-16","objectID":"/posts/CO-7/:1:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"DMA 接口组成 DMA 的工作过程 ","date":"2020-06-16","objectID":"/posts/CO-7/:2:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"DMA 传送过程 预处理 数据传送 后处理 ","date":"2020-06-16","objectID":"/posts/CO-7/:3:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"预处理 通过几条输入输出指令预置如下信息 通知 DMA 控制逻辑传送方向（入/出） 设备地址 DMA 的 DAR 主存地址 DMA 的 AR 传送字数 DMA 的 WC ","date":"2020-06-16","objectID":"/posts/CO-7/:4:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"DMA 传送过程示意 ","date":"2020-06-16","objectID":"/posts/CO-7/:5:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"数据传送过程（输出） ","date":"2020-06-16","objectID":"/posts/CO-7/:6:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"后处理 校验送入主存的数是否正确 是否继续用 DMA 测试传送过程是否正确，错则转诊断程序 由中断服务程序完成 ","date":"2020-06-16","objectID":"/posts/CO-7/:7:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"DMA 接口与系统的连接方式 ","date":"2020-06-16","objectID":"/posts/CO-7/:8:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"具有公共请求线的 DMA 请求 ","date":"2020-06-16","objectID":"/posts/CO-7/:8:1","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"独立的 DMA 请求 ","date":"2020-06-16","objectID":"/posts/CO-7/:8:2","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"DMA 方式与程序中断方式的比较 DMA 接口的类型 ","date":"2020-06-16","objectID":"/posts/CO-7/:9:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"选择型 在物理上连接多个设备 在逻辑上只允许连接一个设备 ","date":"2020-06-16","objectID":"/posts/CO-7/:10:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"多路型 在物理上连接多个设备 在逻辑上允许连接多个设备同时工作 ","date":"2020-06-16","objectID":"/posts/CO-7/:11:0","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"多路型 DMA 接口的工作原理 传输速度更快的设备,其优先级越高 ","date":"2020-06-16","objectID":"/posts/CO-7/:11:1","tags":["计组-课程"],"title":"计算机组成原理 Part-7","uri":"/posts/CO-7/"},{"categories":["计算机组成原理"],"content":"今天论文交到院里,查重过啦 读书笔记还差10页没写,答辩PPT明天做…吼! 计组今天开始了I/O的学习 I/O 概述 ","date":"2020-06-15","objectID":"/posts/CO-6/:0:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"输入输出系统的发展概况 早期 分散连接: CPU和I/O设备串行工作程序查询方式 接口模块和 DMA 阶段 总线连接: CPU和I/O设备并行工作 具有通道结构的阶段 具有 I/O 处理机的阶段 ","date":"2020-06-15","objectID":"/posts/CO-6/:1:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"输入输出系统的组成 I/O 软件 I/O 指令: CPU指令的一部分 通道指令: 通道自身的指令 指出数组的首地址、传送字数、操作命令 如 IBM/370 通道指令为 64 位 I/O 硬件 I/O接口 设备控制器 通道 ","date":"2020-06-15","objectID":"/posts/CO-6/:2:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"I/O 设备与主机的联系方式 I/O 设备编址方式 统一编址: 用取数、存数指令 不统一编址: 有专门的 I/O 指令 设备选址: 用设备选择电路识别是否被选中 传送方式 串行 并行 ","date":"2020-06-15","objectID":"/posts/CO-6/:3:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"联络方式 立即响应 异步工作采用应答信号 同步工作采用同步时标 ","date":"2020-06-15","objectID":"/posts/CO-6/:4:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"I/O 设备与主机的连接方式 辐射式连接 总线连接 便于增删设备 ","date":"2020-06-15","objectID":"/posts/CO-6/:5:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"I/O设备与主机信息传送的控制方式 ","date":"2020-06-15","objectID":"/posts/CO-6/:6:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"程序查询方式 ","date":"2020-06-15","objectID":"/posts/CO-6/:6:1","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"程序中断方式 程序中断方式流程 ","date":"2020-06-15","objectID":"/posts/CO-6/:6:2","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"DMA 方式 ","date":"2020-06-15","objectID":"/posts/CO-6/:6:3","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"三种方式的 CPU 工作效率比较 I/O接口 ","date":"2020-06-15","objectID":"/posts/CO-6/:6:4","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"接口的功能和组成 ","date":"2020-06-15","objectID":"/posts/CO-6/:7:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"总线连接方式的 I/O 接口电路 ","date":"2020-06-15","objectID":"/posts/CO-6/:7:1","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"接口的功能 选址功能: 设备选择电路 传送命令的功能: 命令寄存器、命令译码器 传送数据的功能: 数据缓冲寄存器 反映设备状态的功能: 设备状态标记 完成触发器 D 工作触发器 B (设备是否进入工作状态) 中断请求触发器 INTR 屏蔽触发器 MASK ","date":"2020-06-15","objectID":"/posts/CO-6/:7:2","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"I/O 接口的基本组成 程序查询方式 ","date":"2020-06-15","objectID":"/posts/CO-6/:7:3","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"程序查询流程-单个设备 ","date":"2020-06-15","objectID":"/posts/CO-6/:8:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"程序查询流程-多个设备 ","date":"2020-06-15","objectID":"/posts/CO-6/:9:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"程序流程 ","date":"2020-06-15","objectID":"/posts/CO-6/:10:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"程序查询方式的接口电路 程序中断方式 ","date":"2020-06-15","objectID":"/posts/CO-6/:11:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"中断的概念 过程中部分并行工作 ","date":"2020-06-15","objectID":"/posts/CO-6/:12:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"程序中断方式的接口电路 ","date":"2020-06-15","objectID":"/posts/CO-6/:13:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"求触发器和中断屏蔽触发器 ","date":"2020-06-15","objectID":"/posts/CO-6/:13:1","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"排队器 设备 1#、2#、3#、4# 优先级按降序排列 INTRi = 1 有请求 即 INTRi的非 = 0 ","date":"2020-06-15","objectID":"/posts/CO-6/:13:2","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"中断向量地址形成部件 由硬件产生向量地址 再由向量地址找到入口地址 ","date":"2020-06-15","objectID":"/posts/CO-6/:13:3","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"程序中断方式接口电路的基本组成 ","date":"2020-06-15","objectID":"/posts/CO-6/:13:4","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"I/O 中断处理过程 条件 允许中断触发器 EINT = 1 用 开中断 指令将 EINT 置 “1” 用 关中断 指令将 EINT 置“ 0” 或硬件 自动复位 时间 当 D = 1（随机）且 MASK = 0 时 在每条指令执行阶段的结束前 CPU 发 中断查询信号（将 INTR 置“1”） 以输入为例: ","date":"2020-06-15","objectID":"/posts/CO-6/:14:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"中断服务程序流程 中断服务程序的流程 保护现场 程序断点的保护: 中断隐指令完成 寄存器内容的保护: 进栈指令 中断服务 对不同的 I/O 设备具有不同内容的设备服务 恢复现场: 出栈指令 中断返回: 中断返回指令 单重中断和多重中断 单重中断: 不允许中断 现行的 中断服务程序 多重中断: 允许级别更高的中断源,中断现行的中断服务程序 ","date":"2020-06-15","objectID":"/posts/CO-6/:15:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"主程序和服务程序抢占 CPU 示意图 ","date":"2020-06-15","objectID":"/posts/CO-6/:16:0","tags":["计组-课程"],"title":"计算机组成原理 Part-6","uri":"/posts/CO-6/"},{"categories":["计算机组成原理"],"content":"cache 辅助存储器 高速缓冲存储器 避免 CPU “空等” 现象,程序访问的局部性原理 ","date":"2020-06-14","objectID":"/posts/CO-5/:0:0","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"Cache 的工作原理 ","date":"2020-06-14","objectID":"/posts/CO-5/:1:0","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"主存和缓存的编址 主存和缓存都是按块存储,并且块内地址相同 ","date":"2020-06-14","objectID":"/posts/CO-5/:1:1","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"命中与未命中 缓存共有 C 块 主存共有 M 块 M » C 命中 主存块调入缓存 主存块与缓存块建立了对应关系 用标记记录与某缓存块建立了对应关系的主存块号 未命中 主存块未调入缓存 主存块与缓存块未建立对应关系 ","date":"2020-06-14","objectID":"/posts/CO-5/:1:2","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"Cache 的命中率 CPU 欲访问的信息在 Cache 中的 比率 命中率 与 Cache 的 容量 与 块长 有关 一般每块可取 4 ~ 8 个字 块长取一个存取周期内从主存调出的信息长度 ","date":"2020-06-14","objectID":"/posts/CO-5/:1:3","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"Cache –主存系统的效率 ","date":"2020-06-14","objectID":"/posts/CO-5/:1:4","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"Cache 的基本结构 ","date":"2020-06-14","objectID":"/posts/CO-5/:2:0","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"Cache 的读写操作 ","date":"2020-06-14","objectID":"/posts/CO-5/:3:0","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"读操作 ","date":"2020-06-14","objectID":"/posts/CO-5/:3:1","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"写操作 在写的过程中,需要保持Cache和主存的一致性,因此有两种方法 写直达法(Write – through) 写操作时数据既写入Cache又写入主存 写操作时间就是访问主存的时间 Cache块退出时,不需要对主存执行写操作,更新策略比较容易实现 写回法(Write – back) 写操作时只把数据写入 Cache 而不写入主存 当 Cache 数据被替换出去时才写回主存 写操作时间就是访问 Cache 的时间 Cache块退出时,被替换的块需写回主存,增加了Cache的复杂性 ","date":"2020-06-14","objectID":"/posts/CO-5/:3:2","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"Cache 的改进 增加 Cache 的级数 片载(片内)Cache 片外 Cache 目前的CPU一般有三层cache,单核内部 -\u003e 多核共用cache -\u003e cpu整体共用cache 统一缓存和分立缓存 指令 Cache 数据 Cache 与指令执行的控制方式有关 ","date":"2020-06-14","objectID":"/posts/CO-5/:4:0","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"Cache – 主存的地址映射 ","date":"2020-06-14","objectID":"/posts/CO-5/:5:0","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"直接映射 img 每个块区的固定位置 -\u003e Cache中的固定位置 每个缓存块 i 可以和若干个主存块对应 每个主存块 j 只能和一个缓存块对应 ","date":"2020-06-14","objectID":"/posts/CO-5/:5:1","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"全相联映射 主存中的任一块可以映射到缓存中的任一块 ","date":"2020-06-14","objectID":"/posts/CO-5/:5:2","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"组相联映射 两者的巧妙结合 每个cache块有多个列 每个cache块对应内存中的多个位置,但是这多个位置可以自由的存入对应cash块的任意一列,所以将其这些cache块看作是多个组 辅助存储器 特点 不直接与 CPU 交换信息 磁表面存储器的技术指标 记录密度:道密度:Dt,位密度:Db 存储容量 C = n × k × s 平均寻址时间: 寻道时间 + 等待时间 辅存的速度 寻址时间 磁头读写时间 数据传输率 Dr = Db × V 误码率:出错信息位数与读出信息的总位数之比 ","date":"2020-06-14","objectID":"/posts/CO-5/:5:3","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"磁记录原理和记录方式 ","date":"2020-06-14","objectID":"/posts/CO-5/:6:0","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"磁记录原理-写 ","date":"2020-06-14","objectID":"/posts/CO-5/:6:1","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"磁记录原理-读 ","date":"2020-06-14","objectID":"/posts/CO-5/:6:2","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"硬磁盘存储器 ","date":"2020-06-14","objectID":"/posts/CO-5/:7:0","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"硬磁盘存储器的类型 固定磁头和移动磁头 可换盘和固定盘 ","date":"2020-06-14","objectID":"/posts/CO-5/:7:1","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"硬磁盘存储器结构 ","date":"2020-06-14","objectID":"/posts/CO-5/:7:2","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"磁盘驱动器 ","date":"2020-06-14","objectID":"/posts/CO-5/:8:0","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"磁盘控制器 接收主机发来的命令,转换成磁盘驱动器的控制命令 实现主机和驱动器之间的数据格式转换 控制磁盘驱动器读写 磁盘控制器是主机与磁盘驱动器之间的接口 ","date":"2020-06-14","objectID":"/posts/CO-5/:8:1","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"盘片 由硬质铝合金材料制成 ","date":"2020-06-14","objectID":"/posts/CO-5/:8:2","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"光盘存储器 ","date":"2020-06-14","objectID":"/posts/CO-5/:9:0","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"概述 采用光存储技术 利用激光写入和读出 第一代光存储技术-采用非磁性介质-不可擦写 第二代光存储技术-采用磁性介质-可擦写 ","date":"2020-06-14","objectID":"/posts/CO-5/:9:1","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["计算机组成原理"],"content":"光盘的存储原理 只读型和只写一次型: 热作用(物理或化学变化) 可擦写光盘: 热磁效应 ","date":"2020-06-14","objectID":"/posts/CO-5/:9:2","tags":["计组-课程"],"title":"计算机组成原理 Part-5","uri":"/posts/CO-5/"},{"categories":["本科论文"],"content":"论文格式的问题主要集中在目录，页眉，页脚三大部分 这里分这三块来讲 版本: Office 365 Word 目录 目录很好生成，在引用中就可以一键生成，但生成的行距会有点问题，需要自己调整一下 参考文献引用 首先将参考文献加到文章末尾,然后使用交叉引用 文章分节 在论文中,我们会有不同的章节,而不同的章节会有不同的页眉 这就需要用到\"分隔符\" 在章节的末尾加上分隔符-下一页,这样就可以将论文分节 页眉 页眉有三个重要的属性 首页不同 奇偶页眉 链接上一节 ","date":"2020-06-14","objectID":"/posts/paper-4/:0:0","tags":["论文","Word"],"title":"Word论文格式","uri":"/posts/paper-4/"},{"categories":["本科论文"],"content":"首页不同: 首页特别为单独一节,页眉页脚独立 ","date":"2020-06-14","objectID":"/posts/paper-4/:1:0","tags":["论文","Word"],"title":"Word论文格式","uri":"/posts/paper-4/"},{"categories":["本科论文"],"content":"奇偶页眉: 奇偶页码的页眉有所不同,偶数页码的页眉为相同值,奇数页码页眉为相同值 以之前设置的分隔符所划分的节,进行章节区分 即每个章节可以设置单独的页眉 ","date":"2020-06-14","objectID":"/posts/paper-4/:2:0","tags":["论文","Word"],"title":"Word论文格式","uri":"/posts/paper-4/"},{"categories":["本科论文"],"content":"链接到上一节 即当前节的页眉与上一节的页眉相同 页脚 ","date":"2020-06-14","objectID":"/posts/paper-4/:3:0","tags":["论文","Word"],"title":"Word论文格式","uri":"/posts/paper-4/"},{"categories":["本科论文"],"content":"格式设置 设置页码,首先需要进行页码格式设置 选择样式 ","date":"2020-06-14","objectID":"/posts/paper-4/:4:0","tags":["论文","Word"],"title":"Word论文格式","uri":"/posts/paper-4/"},{"categories":["本科论文"],"content":"不同部分页码 在文章中,我们可能需要前一部分\"摘要,目录\"与后一部分\"正文,参考文献,致谢\"两部分的页码区分,即两套页码 这时就需要在第二部分的页码,设置为\"不链接到上一节\"将其设置为单独的一节 然后设置页码为第一页,这样该部分就完成了页码设置 加入页码 生成的目录中有多余横线 如果在页码格式中设置为 -i- 类型 那么最后生成pdf时,目录页码也会变成 -i- 类型 解决方法为: 页码格式选择 i,之后手动在每个页的页码左右上加上\"-\",这样生成目录的页码就没有问题 参考blog 三线表的制作 右键点击表格的左上角图表 调出菜单,选择\"表格属性\" 选择\"居中\",之后选择\"底纹\" 选择线段位置和粗细 选择第一行,调整三线表的第二条线 之后改变底边线段粗细,并应用于\"单元格\" 至此完成三线表 ","date":"2020-06-14","objectID":"/posts/paper-4/:5:0","tags":["论文","Word"],"title":"Word论文格式","uri":"/posts/paper-4/"},{"categories":["Ubuntu"],"content":"很久之前解决的这个问题,不过还是要记录下来(睡前水个贴) 设置系统语言为英文后,就会发现有些中文字体很难看,后来才知道原来那些丑丑的中文符号是日本语 呕…所以赶紧改回来吧 首先中文字体配置文件的位置 /etc/fonts/conf.avail/64-language-selector-prefer.conf 打开文件 \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE fontconfig SYSTEM \"fonts.dtd\"\u003e \u003cfontconfig\u003e \u003calias\u003e \u003cfamily\u003esans-serif\u003c/family\u003e \u003cprefer\u003e \u003cfamily\u003eNoto Sans CJK JP\u003c/family\u003e \u003cfamily\u003eNoto Sans CJK SC\u003c/family\u003e \u003cfamily\u003eNoto Sans CJK TC\u003c/family\u003e \u003c/prefer\u003e \u003c/alias\u003e \u003calias\u003e \u003cfamily\u003emonospace\u003c/family\u003e \u003cprefer\u003e \u003cfamily\u003eNoto Sans Mono CJK JP\u003c/family\u003e \u003cfamily\u003eNoto Sans Mono CJK SC\u003c/family\u003e \u003cfamily\u003eNoto Sans Mono CJK TC\u003c/family\u003e \u003c/prefer\u003e \u003c/alias\u003e \u003c/fontconfig\u003e 可以发现JP(日本)排在第一个,所以优先级要高。 这时就需要调整一下优先级 更改为: \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE fontconfig SYSTEM \"fonts.dtd\"\u003e \u003cfontconfig\u003e \u003calias\u003e \u003cfamily\u003esans-serif\u003c/family\u003e \u003cprefer\u003e \u003cfamily\u003eNoto Sans Mono CJK SC\u003c/family\u003e \u003cfamily\u003eNoto Sans Mono CJK TC\u003c/family\u003e \u003cfamily\u003eNoto Sans Mono CJK JP\u003c/family\u003e \u003c/prefer\u003e \u003c/alias\u003e \u003calias\u003e \u003cfamily\u003eserif\u003c/family\u003e \u003cprefer\u003e \u003cfamily\u003eNoto Sans Mono CJK SC\u003c/family\u003e \u003cfamily\u003eNoto Sans Mono CJK TC\u003c/family\u003e \u003cfamily\u003eNoto Sans Mono CJK JP\u003c/family\u003e \u003c/prefer\u003e \u003c/alias\u003e \u003calias\u003e \u003cfamily\u003emonospace\u003c/family\u003e \u003cprefer\u003e \u003cfamily\u003eNoto Sans Mono CJK SC\u003c/family\u003e \u003cfamily\u003eNoto Sans Mono CJK TC\u003c/family\u003e \u003cfamily\u003eNoto Sans Mono CJK JP\u003c/family\u003e \u003c/prefer\u003e \u003c/alias\u003e \u003c/fontconfig\u003e 最后重启生效 再见丑丑的日本语 ","date":"2020-06-13","objectID":"/posts/ubuntu-26/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu中文显示异常","uri":"/posts/ubuntu-26/"},{"categories":["本科论文"],"content":"介绍Getdata软件使用方法 ","date":"2020-06-13","objectID":"/posts/paper-3/:0:0","tags":["论文","GetData"],"title":"数据图取点方法","uri":"/posts/paper-3/"},{"categories":["本科论文"],"content":"GetData 软件名称为 GetData Graph Digitizer 使用方法简单粗暴,首先依次设置 X最小值 X最大值 Y最小值 Y最大值 然后进行第一条线的选点,菜单中可以增加数据线段(或快捷键CTRL+A) 取点完成后即可输出数据到xml文件 ","date":"2020-06-13","objectID":"/posts/paper-3/:1:0","tags":["论文","GetData"],"title":"数据图取点方法","uri":"/posts/paper-3/"},{"categories":["本科论文"],"content":"Origin 取点功能更加专业一点 设置坐标轴: X1为X最小值 X2为X最大值 Y1为Y最小值 Y2为Y最大值 这过程是通过移动线,所以相比Getdata更加人性化,之后进行选点操作 双击线段中的点即可记录,选点完成后,点击\"完成\",即可在文件中生成该数据表 即选点完成 ","date":"2020-06-13","objectID":"/posts/paper-3/:2:0","tags":["论文","GetData"],"title":"数据图取点方法","uri":"/posts/paper-3/"},{"categories":["本科论文"],"content":"论文完成啦,趁着现在还存有一些记忆(鱼的三秒记忆),记录一下 注意事项 本篇Origin版本为2018c Origin2019是不可以安装的,因为存在着坐标轴刻度消失等诸多bug 这里为了易于理解,所以放上几张做好的数据图进行讲解 由于作图的时候,会有很多窗口,所以务必要把工作区整理整齐 这样作图效率才会提高 新建数据表 因为是简单入手…所以模板选择最简单的那个就行 出来的表是这样的,只有X.Y列,我们在做表的时候,长单位,单位就是作图坐标轴的title,以及单位,但是我不推荐在这里填,这张表就填数据就好啦 插入数据 我们下面用这张图来讲解 插入数据很简单,直接从Excel中复制到这里就行 之后设置坐标轴,因为数据是两条线,所以要设置数据表格式为XYXY 选中四列,鼠标右键,选择set as 之后就可以输出表啦 选择四列,选择菜单中的绘图,之后选择折线图 可以看到图已经画好啦 但是发现图的元素很简单…跟预想的还差很远 这时就需要慢慢加东西了,之前看b站教程,很喜欢up的一句话\"这个软件很简单,因为你需要改什么,双击就行了\",后来的实践印证了这句话,简直真理啊哈哈哈 修改刻度 双击Y轴就可以调出设置选框,首先修改刻度 垂直代表Y轴,水平代表X轴 ","date":"2020-06-13","objectID":"/posts/paper-2/:0:0","tags":["论文","Origin"],"title":"Origin使用方法","uri":"/posts/paper-2/"},{"categories":["本科论文"],"content":"坐标轴加粗 修改坐标轴标题 ![img](修改曲线属性 双击图中的曲线,调出线属性设置窗口 软件默认所有曲线遵循默认的属性组,如果觉得预置的属性不好看(比如颜色区别不大),可以设置为独立,这样就可以单独的设置每条曲线的属性 ","date":"2020-06-13","objectID":"/posts/paper-2/:1:0","tags":["论文","Origin"],"title":"Origin使用方法","uri":"/posts/paper-2/"},{"categories":["本科论文"],"content":"曲线的粗细 修改曲线解释框 如果想移动这个,需要按住左键把他括起来,就像选择文件一样,然后再移动 之后双击调出属性设置框,填写文本 新建图层 在图框中右键新建图层 ","date":"2020-06-13","objectID":"/posts/paper-2/:2:0","tags":["论文","Origin"],"title":"Origin使用方法","uri":"/posts/paper-2/"},{"categories":["本科论文"],"content":"坐标轴更换颜色 双击新建的右坐标轴,更换颜色 之后调整坐标轴刻度 完成 示例 ","date":"2020-06-13","objectID":"/posts/paper-2/:3:0","tags":["论文","Origin"],"title":"Origin使用方法","uri":"/posts/paper-2/"},{"categories":["HEXO"],"content":"6.7-心情不太好,没学习新知识…但优化了一下静态网站的速度 6.8-今天改了一天论文,整体重复率降到了30嘿嘿,再稍微改一改,就可以快乐毕业啦(终于完成了毕业论文!) 昨天这篇blog也没写完,只好今天发了 需求背景 由于之前hexo博客的整体资源都挂在了GitHub上,由于其与生俱来的网络速度慢,导致blog中观看图片的体验极差,我的很多\"技术\"(辣鸡)blog都有很多图片…所以,还是赶紧尽早优化吧 首先我想到了blog挂在云服务器上,但是价格好贵啊…而且等于重新配置一个LinuxOS的环境,想想都头疼,所以pass,去网上搜了一下,发现现在很火的对象存储似乎不错嗷,去七牛云看了一眼,有了一点思路,因为之前域名是腾讯云上买的,索性就搞腾讯云COS了,以后方便一站式管理(虽然也没方便多少),并且腾讯云价格很便宜!(穷才是真正的原因) 对象存储 对象存储主要就是指存储互联网时代\"非结构化\"数据的平台,图片,视频,音乐这类的 基于云存储的概念，可以快速扩容，而且对于数据的容量的上限没有限制。这样就可以很好地应对爆发式的大量文件上传。 解决了个人服务器带宽小，处理能力有限，文件读取慢的弊端，将所有的有效资源都用于数据的交互。而把静态文件的请求交给了COS对象存储进行处理。 COS的带宽相较于个人服务器的带宽更大，在提升页面打开速度，文件资源下载时，以及应对高并发访问，用户体验有很大提升。 综上所述,对象存储是个好东西,以后很多项目都会用上 腾讯云COS ","date":"2020-06-08","objectID":"/posts/hexo-1/:0:0","tags":["腾讯云COS"],"title":"腾讯云COS加速静态资源","uri":"/posts/hexo-1/"},{"categories":["HEXO"],"content":"方案1-整体部署 首先第一种解决方案是最好的,就是将hexo整体部署在COS上,这样就完全是起飞的速度,但是唯一的难点就是绑定的域名需要备案…我查了好久得出了一个结论…2020年,域名备案难于上青天,不光时间周期长,还要有一个大于六个月的云服务器,并且备案网站不可以带有\"博客\"字样…我大中华真的各种迷惑操作 如果有备案域名就好说了,blog上传也方便 ","date":"2020-06-08","objectID":"/posts/hexo-1/:1:0","tags":["腾讯云COS"],"title":"腾讯云COS加速静态资源","uri":"/posts/hexo-1/"},{"categories":["HEXO"],"content":"安装插件 npm install hexo-deployer-qcloud-cos --save ","date":"2020-06-08","objectID":"/posts/hexo-1/:1:1","tags":["腾讯云COS"],"title":"腾讯云COS加速静态资源","uri":"/posts/hexo-1/"},{"categories":["HEXO"],"content":"配置文件 打开/_config.yml文件 deploy: type: qcloud-cos cosRegion: ap-chengdu cosSecretId: cosSecretKey: cosBucket: work-blog cosAppid: 1257072316 remotePath: 其中type：照填。 cosRegion：根据你选择的位置填写。（可从储存桶基本信息所属地域查看） cosSecretId：填写之前创建的密钥id cosSecretKey：填写id对应的key cosBucket：填写储存同的名称 cosAppid：填写空间名称中的数字 ","date":"2020-06-08","objectID":"/posts/hexo-1/:1:2","tags":["腾讯云COS"],"title":"腾讯云COS加速静态资源","uri":"/posts/hexo-1/"},{"categories":["HEXO"],"content":"Generate-Deploy hexo g \u0026\u0026 hexo d 然后最后绑定一下域名,就完事了 ","date":"2020-06-08","objectID":"/posts/hexo-1/:1:3","tags":["腾讯云COS"],"title":"腾讯云COS加速静态资源","uri":"/posts/hexo-1/"},{"categories":["HEXO"],"content":"坑 记录一下坑,一开始COS不让绑定域名,我想你这边不让未备案绑定,那我去用域名去解析你好啦,与此同时踩坑之旅也开始啦! 不得不说还是我想的太简单,域名配置解析之后,COS不让访问,报错未解析的CNAME,应该是COS那边做了防解析 并且ssl证书也对不上,ssl证书是对应于tencent的,而不是我自己的域名 所以…还是老老实实用GitHub Pages吧 ","date":"2020-06-08","objectID":"/posts/hexo-1/:1:4","tags":["腾讯云COS"],"title":"腾讯云COS加速静态资源","uri":"/posts/hexo-1/"},{"categories":["HEXO"],"content":"方案2-静态资源加速 像我这种没有备案域名的普通小辣鸡,只好另辟蹊径了 方法很简单,把图片文件都放到COS上,blog中图片放资源链接 最后我把js,css,images都放上了,并且把blog源码改了一下,就完事啦! ","date":"2020-06-08","objectID":"/posts/hexo-1/:2:0","tags":["腾讯云COS"],"title":"腾讯云COS加速静态资源","uri":"/posts/hexo-1/"},{"categories":["HEXO"],"content":"跨域访问 在COS中css等文件中一些路径可以继续使用相对地址 而在使用awesome-font时,可能会发生跨域访问错误 这时需要在\"基础设置\" -\u003e “跨域访问CORS设置” 中进行设置 来源 Origin: * (填写一个\"*\",下同) 操作 Methods: PUT GET POST DELETE HEAD(全部勾选) Allow-Headers: * Expose-Headers: * 超时 Max-Age: 0 就解决啦,最后blog的访问速度起飞!解决了困扰我好久的问题 ","date":"2020-06-08","objectID":"/posts/hexo-1/:2:1","tags":["腾讯云COS"],"title":"腾讯云COS加速静态资源","uri":"/posts/hexo-1/"},{"categories":["计算机组成原理"],"content":"存储器 汉明码 只读存储器(ROM) 掩模 ROM ( MROM ) 行列选择线交叉处有 MOS 管为“1” 行列选择线交叉处无 MOS 管为“0” PROM (一次性编程) EPROM (多次性编程 ) 通过紫外线来去除其中产生的浮动栅,以此来进行数据重置 EEPROM (多次性编程 ) 电可擦写 局部擦写 全部擦写 Flash Memory (闪速型存储器) EPROM: 价格便宜 集成度高 EEPROM: 电可擦洗重写 Flash 比 EEPROM快 具备 RAM 功能 存储器与 CPU 的连接 ","date":"2020-06-06","objectID":"/posts/CO-4/:0:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"存储器容量的扩展 ","date":"2020-06-06","objectID":"/posts/CO-4/:1:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"位扩展 (增加存储字长) ","date":"2020-06-06","objectID":"/posts/CO-4/:1:1","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"字扩展 在0-9位存在第一个存储器块中,当数据达到第10位时,需要第二个存储块来进行拓展空间 此时10号地址线通过信号处理器产生对第二个存储块的信号 ","date":"2020-06-06","objectID":"/posts/CO-4/:1:2","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"字、位扩展 10,11号线为拓展信号线,通过片选译码器来判断此时应该拓展到第几个存储块 ","date":"2020-06-06","objectID":"/posts/CO-4/:1:3","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"存储器与 CPU 的连接 地址线的连接 数据线的连接 读/写命令线的连接 片选线的连接 合理选择存储芯片 ","date":"2020-06-06","objectID":"/posts/CO-4/:2:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"例题 要求最小4K为系统程序区,相邻8K为用户程序区 写出对应的二进制地址码 确定芯片的数量及类型 分配地址线 确定片选信号 确定片选逻辑 由ABC三个位,来确定数据存储的位置 存储器的校验 ","date":"2020-06-06","objectID":"/posts/CO-4/:2:1","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"合法代码集合 {000,001,010,011,100,101,110,111} 检0位错、纠0位错 {000, 011,101,110} 检1位错,纠0位错 {000,111} 检1位错,纠1位错 {0000,1111} 检2位错,纠1位错 {00000,11111} 检2位错,纠2位错 ","date":"2020-06-06","objectID":"/posts/CO-4/:3:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"编码的最小距离 任意两组合法代码之间 二进制位数 的 最少差异 编码的纠错 、检错能力与编码的最小距离有关 L - 1 = D + C ( D \u003e= C ) L: 编码的最小距离 L = 3 D: 检测错误的位数 具有 一位 纠错能力 C: 纠正错误的位数 汉明码是具有一位纠错能力的编码 汉明码 ","date":"2020-06-06","objectID":"/posts/CO-4/:4:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"基本思想 汉明码采用奇偶检验 汉明码采用分组校验 For Example： 我们想传输10010这串码，那么在传输的时候，就传010010，其中在开头的0就是校验位 我们想传输10000这串码，那么在传输的时候，就传110000，其中在开头的1就是校验位 两个例子的1的个数都是**偶数**(凑奇数或偶数) 汉明码默认一串数据只错一位 假设想传这一列数据1234567，先把他分个组 P1组：1,2,3,4 P2组：2,4,5,7 P3组：3,4,6,7 接收方接到数据,对其中的分组数据进行奇偶判定,就可以得到出错的位,并进行纠错 汉明码的组成需增添?位检测位 2k \u003e= n + k + 1 检测位的位置 2i ( i = 0 , 1 , 2 , 3 , … ) ","date":"2020-06-06","objectID":"/posts/CO-4/:5:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"校验码的位置 汉明码的一串数据中，校验码放在2i的位置上， ","date":"2020-06-06","objectID":"/posts/CO-4/:6:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"数据分组 把表示位置的这个数，转化成二进制数。 第1个位置，变成第0001个位置； 第2个位置，变成第0010个位置； 第3个位置，变成第0011个位置； 第4个位置，变成第0100个位置； 第5个位置，变成第0101个位置； 第6个位置，变成第0110个位置； 位置符合这种形式的，XXX1，归到P1； 位置符合这种形式的，XX1X，归到P2； 位置符合这种形式的，X1XX，归到P3； 位置符合这种形式的，1XXX，归到P4； 例如 我们想传这一组码：XX1X101X011 一共11位。 标X的是校验码的位置，我们暂时不知道它的值是多少。 位置在1,3,5,7,9,11的数据进到P1组。 位置在2,3,6,7,10,11的数据进到P2组。（位置符合XX1X） 位置在4,5,6,7的数据进到P3组。（位置符合X1XX） 位置在8,9,10,11的数据进到P4组。（位置符合1XXX） 那么确定了分组，校验码的值也就顺便确定下来了。 这样整个串的码就确定下来了。 ","date":"2020-06-06","objectID":"/posts/CO-4/:7:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"检验汉明码 分组，分好P1，P2，P3…… 分别对每个组校验，没有错的给它0，有错的给0. 把P从大到小排列起来，得到一串1010 For Example: 组别： P5 P4 P3 P2 P1 标志： 1 0 1 0 1 从大到小排列起来，标志排成了一串一零串。这个数就是出错的数据的位置。 本例中，10101位置上的位错了，换成十进制是第21个位置上的数错了。 ","date":"2020-06-06","objectID":"/posts/CO-4/:8:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"例题 求 0101 按 “偶校验” 配置的汉明码 已知接收到的汉明码为 0100111 (按配偶原则配置)试问要求传送的信息是什么? 提高访存速度的措施 采用高速器件 采用层次结构 Cache –主存 调整主存结构 ","date":"2020-06-06","objectID":"/posts/CO-4/:9:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"单体多字系统 增加存储器的带宽 ","date":"2020-06-06","objectID":"/posts/CO-4/:10:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"多体并行系统 ","date":"2020-06-06","objectID":"/posts/CO-4/:11:0","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"高位交叉-顺序编址 ","date":"2020-06-06","objectID":"/posts/CO-4/:11:1","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"高位交叉-各个体并行工作 ","date":"2020-06-06","objectID":"/posts/CO-4/:11:2","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"低位交叉-各个体轮流编址 ","date":"2020-06-06","objectID":"/posts/CO-4/:11:3","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机组成原理"],"content":"低位交叉的特点 在不改变存取周期的前提下,增加存储器的带宽 设四体低位交叉存储器,存取周期为T,总线传输周期 为 τ ,为实现流水线方式存取,应满足 T = 4 τ 高性能存储芯片 SDRAM (同步 DRAM) 在系统时钟的控制下进行读出和写入 CPU无须等待 RDRAM 由Rambus开发,主要解决存储器带宽问题 带 Cache 的 DRAM 在DRAM的芯片内集成了一个由 SRAM 组成的 Cache ,有利于猝发式读取 ","date":"2020-06-06","objectID":"/posts/CO-4/:11:4","tags":["计组-课程"],"title":"计算机组成原理 Part-4","uri":"/posts/CO-4/"},{"categories":["计算机网络"],"content":"计算机网络概述 0202年了,今天家里终于装了大空调,大房子有了大空调嘿嘿 计算机网路概述 数据帧(数据包)： 包括数据+网站和请求端的IP地址；后两部分是目标mac地址和原mac地址，即物理地址，传播过程中一直在变化。 [数据]+[网站IP地址]+[请求端的IP]+[目标MAC]+[发送端MAC] ","date":"2020-06-05","objectID":"/posts/CN-1/:0:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"OSI参考模型： 应用层: 所有能产生网络流量的程序 表示层: 在传输之前是否进行加密 或 压缩 处理，二进制或ASCII码表示 会话层: (单个网页)需求端和网站之间的连接 传输层: 可靠传输，流量控制，不可靠传输(一个数据包即可，不需要建立会话，例如向DNS查询网站IP地址) 网络层: 负责选择最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层) 数据链路层: 帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决),MAC数据 物理层: 定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快 ","date":"2020-06-05","objectID":"/posts/CN-1/:1:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"五层模型 应用层: (应用层,表示层,会话层)HTTP, FTP, DNS 传输层: TCP, UDP 网络层: IP 数据链路层 物理层 FCS为数据校验段 ","date":"2020-06-05","objectID":"/posts/CN-1/:2:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"计算机网络的性能 速率 连接在计算机网络上的主机在数字信道上传送数据位数的速率，也称data rate或bit rate(比特率)，单位是b/s, kb/s, Mb/s, Gb/s。和正常理解的网速的关系是除以8. 带宽 数据通信领域中，数字信道所能传送的最高数据率，单位是b/s, kb/s, Mb/s, Gb/s。常见的是Mpbs。 吞吐量 在单位时间内通过某个网络的数据量，单位是b/s, Mb/s。 时延 包括发送时延，传播时延，处理时延，排队时延。发送时延等于数据块长度(bit)除以信道带宽(bit/s). 更快的发送速度意味着波长越短，链路上的数据量更大；更快的传播速度意味着在网线中更快的传播速度。 时延X带宽(时延带宽积) 有多少数据正在线路上。 往返时间(RTT, Round-Trip Time) 从发送方发送数据开始，到发送方收到接收方确认数据的时间。例如ping一下。 利用率 包括信道利用率：有数据通过的时间/总时间 网络利用率：信道利用率的加权平均 网络当前时延D = 网络空闲时时延D0 / (1-信道利用率U) 网关与子网俺码 ","date":"2020-06-05","objectID":"/posts/CN-1/:3:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"子网掩码 设置1号机的IP地址为192.168.0.1子网掩码为255.255.255.0,2号机的IP地址为192.168.0.200子网掩码为255.255.255.0,这来台计算机就能正常通讯. 如果1号机地址不变,将2号机的IP地址改为192.168.1.200子网掩码还是为255.255.255.0,那这两台就无法通讯. 设置1号机的IP地址为192.168.0.1子网掩码为255.255.255.192,2号机的IP地址为192.168.0.200子网掩码为255.255.255.192,注意和第1种情况的区别在于子网掩码,1为255.255.255.0本例是255.255.255.192。这台计算机就不能正常通讯. ","date":"2020-06-05","objectID":"/posts/CN-1/:4:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"计算方式 计算过程是这样的,将IP地址和子网掩码都换算成二进制,然后进行与运算,结果就是网络地址.与运算如下所示,上下对齐,1位1位的算,1与1=1 ,其余组合都为0 例如:计算IP地址为:202.99.160.50子网掩码是255.255.255.0的网络地址步骤如下: 将IP地址和子网掩码分别换算成二进制 202.99.160.50 换算成二进制为 11001010·01100011·10100000·00110010 255.255.255.0 换算成二进制为 11111111·11111111·11111111·00000000 与运算 将运算结果换算成十进制,这就是网络地址. 11001010·01100011·10100000·00000000换算成十进制就是202.99.160.0 ","date":"2020-06-05","objectID":"/posts/CN-1/:4:1","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"实例 对于第二种192.168.1.200情况,可以看出两台机器不在同一网段 网关 连接两个不同的网络的设备都可以叫网关设备；网关的作用就是实现两个网络之间进行通讯与控制。 网关设备可以是 交互机（三层及以上才能跨网络）、路由器、启用了路由协议的服务器、代理服务器、防火墙等 网关地址就是网关设备的IP地址。 假设我们有两个网络： 网络A的IP地址范围为“192.168.1.1~192.168.1.254”，子网掩码为255.255.255.0 网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0 要实现这两个网络之间的通信，则必须通过网关。 如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络A向网络B转发数据包的过程。 只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。 物理层 ","date":"2020-06-05","objectID":"/posts/CN-1/:4:2","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"物理层定义的标准 物理层解决如何在链接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层的主要任务：确定传输媒体的接口的一些特性，包括， 机械特性：接口形状，大小，引线数量 电气特性：例如规定电压范围(-5V-5V) 功能特性：例如规定-5V上0，+5V是1 过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤 ","date":"2020-06-05","objectID":"/posts/CN-1/:5:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"通信数据 数据(data)——运送消息的实体。 信号(signal)——数据的电气或电磁的表现。 模拟信号——代表信息的参数的取值是连续的。 数字信号——代表信息的参数的取值是离散的。 码元(code)——在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。 在数字通信中常常用时间间隔相同的符号表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。这个间隔称为码元长度，1 code可以携带n bit信息量(此时电压会有多个取值，例如1，2，…,7V，而不是只有2个取值)。 ","date":"2020-06-05","objectID":"/posts/CN-1/:6:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"信道 信道一般表示向一个方向传输信息的媒体。所以通信线路往往包含一条发送信息的信道和一条接收信息的信道。 单向通信(单工通信)——只能有一个方向的通信，没有反向交互。 双向交替通信(半双工通信)——通信的双方都可以发送信息，但是不能双方同时发送或接收。 双向同时通信(全双工通信)——通信的双发可以同时发送和接收。 ","date":"2020-06-05","objectID":"/posts/CN-1/:7:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"基带(baseband)和带通(base pass)信号 基带信号(基本频率信号) 来自信源的信号，例如计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如说我们说话的声波。 带通信号 把基带信号经过载波调制后，把信号的频率范围迁移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)。因此在传输距离较近时，采用基带传输方式(衰减不大，信号内容不会变化)例如从计算机到监视器，打印机等外设的信号。传输距离较远时，采用带通传输方式 ","date":"2020-06-05","objectID":"/posts/CN-1/:8:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"基本的调制方法 通过何种(模拟信号)带通信号形式来表示基带信号(数字信号) 调频(AM) 调频(FM) 调相(PM) ","date":"2020-06-05","objectID":"/posts/CN-1/:9:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"常用编码方式 单极性不归零编码：只使用一个电压值，高电平表示1，低电平表示0. 双极性不归零编码：用幅值相等的正负电平表示二进制数1和0. 单极性归零编码：发送码1时高电平在整个码元期间只持续一段时间，其余时间返回零电平。 双极性归零编码：正负零三个电平，信号本事携带同步信息。 ","date":"2020-06-05","objectID":"/posts/CN-1/:10:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"曼彻斯特编码 单极性编码的缺点是没有办法区分此时是没有信号，还是有信号，但是信号是0. 这种编码方式是bit中间有信号，低-高跳转表示0，高-低跳转表示1，一个时钟周期只可以表示一个bit，并且必须通过两次采样才能得到一个bit。它能携带时钟信号，而且能区分此时是没有信号还是信号为0. ","date":"2020-06-05","objectID":"/posts/CN-1/:10:1","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"差分曼彻斯特编码 抗干扰能力比曼彻斯特编码更强。bit与bit之间有信号跳变，表示下一个bit为0，bit与bit之间没有信号跳变，表示下一个bit为1。 ","date":"2020-06-05","objectID":"/posts/CN-1/:10:2","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"信道极限容量 信道极限容量取决于失真的大小，当失真过大时，接收信号无法还原发送信号。 ","date":"2020-06-05","objectID":"/posts/CN-1/:11:0","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"奈氏(Nyquist)准则 在理想条件下(无噪声/干扰/失真)，为了避免码间串扰，码元的传输速率是有上限的。如果信道的频带越宽(信号高频分量越多)，则用更高的速率传输码元也不会出现码间串扰。 即码元的频率不能过大,超过一定值,无法进行解析,发生串码 铜线虽然传输速度比光纤快(因为光纤内进行折射传输),但是铜线速度上限比光纤小很多,因为光纤高频率码元可进行解析,而铜线无法解析 ","date":"2020-06-05","objectID":"/posts/CN-1/:11:1","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"信噪比和香农(Shannon)公式 信道的极限信息传输速率C(带宽受限且有Gauss白噪声干扰时的信道极限且无差错时的信息传输速率)可表示为， C = W log2(1 + S / N) b/s W是信道的带宽(Hz)； S是信道内所传信号的平均功率； N是信道内的Gauss噪声的功率。 可以发现，减少速度和增大功率能提高准确度。 信道的带宽或信道中的信噪比(S/N)越大，则信息的极限传输速率C就越高； 只要信息传输速率小于信道的极限传输速率C，就一定能实现某种无差错传输； 若带宽W或信噪比(S/N)没有上限，则极限传输速率C也没有上限(虽然不可能)； 实际上，信道能达到的最高传输速率要比C低不少； ","date":"2020-06-05","objectID":"/posts/CN-1/:11:2","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["计算机网络"],"content":"奈氏(Nyquist)准则和香农公式的应用范围 ","date":"2020-06-05","objectID":"/posts/CN-1/:11:3","tags":["计网-课程"],"title":"计算机网络 Part-1","uri":"/posts/CN-1/"},{"categories":["Leetcode"],"content":"面试题29-顺时针打印矩阵 96-不同的二叉搜索树 ","date":"2020-06-05","objectID":"/posts/leetcode-26/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-26","uri":"/posts/leetcode-26/"},{"categories":["Leetcode"],"content":"面试题29-顺时针打印矩阵 题目: 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 解题思路: 暴力求解,一圈一圈往里遍历 int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){ if (matrix == NULL || matrixSize == 0) { *returnSize = 0; return NULL; } *returnSize = matrixSize * matrixColSize[0]; int *res = calloc(*returnSize, sizeof(int)); int i = 0; int urow, rcol, drow, lcol, r, c; urow = -1; lcol = -1; drow = matrixSize; rcol = matrixColSize[0]; while (i \u003c *returnSize) { //right r = urow + 1; for (c = lcol + 1; i \u003c *returnSize \u0026\u0026 c \u003c rcol; c++) { res[i] = matrix[r][c]; i++; } urow++; //down c = rcol - 1; for (r = urow + 1; i \u003c *returnSize \u0026\u0026 r \u003c drow; r++) { res[i] = matrix[r][c]; i++; } rcol--; //left r = drow - 1; for (c = rcol - 1; i \u003c *returnSize \u0026\u0026 c \u003e lcol; c--) { res[i] = matrix[r][c]; i++; } drow--; //up c = lcol + 1; for (r = drow - 1; i \u003c *returnSize \u0026\u0026 r \u003e urow; r--) { res[i] = matrix[r][c]; i++; } lcol++; } return res; } ","date":"2020-06-05","objectID":"/posts/leetcode-26/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-26","uri":"/posts/leetcode-26/"},{"categories":["Leetcode"],"content":"96-不同的二叉搜索树 题目: 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 输入: 3 输出: 5 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 解题思路: 这道题把我按地上摩擦了,神奇的动态规划…真的神奇官方思路 int numTrees(int n){ int i = 0; int j = 2; int* dpTable = malloc((n+1) * sizeof(int)); if(!dpTable) { return 0; } memset(dpTable,0,(n+1)*sizeof(int)); if(n == 1) { return 1; } dpTable[0] = 1; dpTable[1] = 1; for(int i = 2; i \u003c= n; i++) { for(int j = 0; j \u003c i; j++) { dpTable[i] += dpTable[j] * dpTable[i-j-1]; } } int res = dpTable[n]; free(dpTable); return res; } ","date":"2020-06-05","objectID":"/posts/leetcode-26/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-26","uri":"/posts/leetcode-26/"},{"categories":["计算机组成原理"],"content":"存储器 存储器分类 按存储介质分类 半导体存储器: TTL 、MOS -\u003e “数据易失” 磁表面存储器: 磁头、载磁体 磁芯存储器: 硬磁材料、环状元件 光盘存储器: 激光、磁光材料 按存取方式分类 存取时间与物理地址无关（随机访问） 随机存储器: 在程序的执行过程中可读可写 只读存储器: 在程序的执行过程中只读 存取时间与物理地址有关（串行访问） 顺序存取存储器 磁带 直接存取存储器 磁盘 按在计算机中的作用分类 主存储器 RAM 静态 RAM 动态 RAM ROM MROM PROM EPROM EEPROM Flash Memory 高速缓冲存储器（Cache） 辅助存储器: 磁盘、磁带、光盘 存储器的层次结构 ","date":"2020-06-04","objectID":"/posts/CO-3/:0:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"缓存 主存层次和主存 辅存层次 主存储器 ","date":"2020-06-04","objectID":"/posts/CO-3/:1:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"主存的基本组成 ","date":"2020-06-04","objectID":"/posts/CO-3/:2:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"主存和 CPU 的联系 ","date":"2020-06-04","objectID":"/posts/CO-3/:3:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"主存中存储单元地址的分配 分为大端和小端存储 ","date":"2020-06-04","objectID":"/posts/CO-3/:4:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"主存的技术指标 存储容量: 主存存放二进制代码的总位数 存储速度: 存取时间: 存储器的访问时间,读出时间,写入时间 存取周期: 连续两次独立的存储器操作,（读或写）所需的最小间隔时间,“读周期,写周期” 存储器的带宽: 位/秒 半导体芯片简介 ","date":"2020-06-04","objectID":"/posts/CO-3/:5:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"基本结构 ","date":"2020-06-04","objectID":"/posts/CO-3/:6:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"存储芯片片选线的作用 ","date":"2020-06-04","objectID":"/posts/CO-3/:7:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"半导体存储芯片的译码驱动方式 ","date":"2020-06-04","objectID":"/posts/CO-3/:8:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"线选法 通过地址译码器传入的数字,来选择存储数据矩阵中的行 ","date":"2020-06-04","objectID":"/posts/CO-3/:8:1","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"重合法 通过传入的x和y确定一个确定的数据块 随机存取存储器 ( RAM ) ","date":"2020-06-04","objectID":"/posts/CO-3/:8:2","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"静态 RAM (SRAM) ","date":"2020-06-04","objectID":"/posts/CO-3/:9:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"基本电路 静态RAM 的基本存储电路为触发器，每个触发器存放一位二进制信息，由若干个触发器组成一个存储单元，再由若干存储单元组成存储器矩阵，加上地址译码器和读／写控制电路就组成静态RAM。 存取速度快，只要不掉电即可持续保持内容不变。一般静态RAM 的集成度较低，成本较高。 ","date":"2020-06-04","objectID":"/posts/CO-3/:9:1","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"RAM的 读 操作 ","date":"2020-06-04","objectID":"/posts/CO-3/:9:2","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"RAM的 写 操作 ","date":"2020-06-04","objectID":"/posts/CO-3/:9:3","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"Intel 2114 RAM 矩阵 (64 × 64) 读 ","date":"2020-06-04","objectID":"/posts/CO-3/:9:4","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"Intel 2114 RAM 矩阵 (64 × 64) 写 ","date":"2020-06-04","objectID":"/posts/CO-3/:9:5","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"动态 RAM ( DRAM ) 动态RAM 的基本存储电路为带驱动晶体管的电容。电容上有无电荷状态被视为逻辑1和0。随着时间的推移，电容上的电荷会逐渐减少，为保持其内容必须周期性地对其进行刷新（对电容充电）以维持其中所存的数据，所以在硬件系统中也得设置相应的刷新电路来完成动态RAM 的刷新，这样一来无疑增加了硬件系统的复杂程度，因此在单片机应用系统中一般不使用动态RAM。 ","date":"2020-06-04","objectID":"/posts/CO-3/:10:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"基本电路 ","date":"2020-06-04","objectID":"/posts/CO-3/:10:1","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"三管动态 RAM 芯片 (Intel 1103) 读 ","date":"2020-06-04","objectID":"/posts/CO-3/:10:2","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"三管动态 RAM 芯片 (Intel 1103) 写 ","date":"2020-06-04","objectID":"/posts/CO-3/:10:3","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"动态 RAM 刷新-simple ","date":"2020-06-04","objectID":"/posts/CO-3/:11:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"集中刷新-simple 存取周期为 0.5 μs ","date":"2020-06-04","objectID":"/posts/CO-3/:11:1","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"分散刷新-simple 存取周期为 1 μs ","date":"2020-06-04","objectID":"/posts/CO-3/:11:2","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"分散刷新与集中刷新相结合（异步刷新)-simple 将刷新放在每个小分区内,每个小分区可以看作是集中刷新 ","date":"2020-06-04","objectID":"/posts/CO-3/:11:3","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"动态 RAM 刷新-complex 刷新的实质：先将原信息读出，再由刷新放大器形成原信息重新写入的再生成的过程 为什么要进行刷新：存储单元被访问是随机的，有些存储单元可能长时间的不被访问，不进行存储器的读写操作，其存储单元内的原信息就可能会丢失。 刷新是一行行进行的，必须在刷新周期内 刷新周期：对DRAM的所有存储单元恢复一次原状态的时间间隔 刷新间隔：两次刷新的起始时间差（某行从第一次刷新到第二次刷新的等待时间） 行刷新间隔：两行刷新的起始时间差 刷新时间：规定的一个周期内刷新的总时间 刷新一行的时间是等于存取周期的。因为刷新的过程与一次存取相同，只是没有在总线上输入输出。 集中刷新 ","date":"2020-06-04","objectID":"/posts/CO-3/:12:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"集中刷新 在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新（用专门的时间进行全部刷新） 例对128×128的矩阵的存储芯片进行刷新，存储周期为0.5s，刷新周期为2ms 2ms的刷新周期，占得存取周期个数为： 2000μs÷0.5μs=4000（个） 共有128行要进行刷新，则刷新占128个存取周期，则刷新的时间为： 128×0.5μs=64μs 读写或维持的时间： 2000μs-64μs=1936μs 读/写或维持的存储周期为： 4000-128=3872（个） 当用64μs进行集中刷新是，此时不能进行任何的读/写操作，故将这64μs称为“死区”或“死时间” “死时间”所占的比率也称为“死时间率” 则集中刷新的“死时间率为” 128÷4000×100%=3.2% 优点：速度高 缺点：存在死区，死时间长 ","date":"2020-06-04","objectID":"/posts/CO-3/:12:1","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"分散刷新 分散刷新：是指对每行存储单元的刷新分散到每个存储周期内完成（对某一行某芯片进行读写操作后，紧接着刷新） 例：对128×128的矩阵的存储芯片进行刷新，存储周期为0.5s， 将刷新分散到存储周期内完成 ，则存储周期就包含了刷新时间 此时，存储周期为 t=0.5μs+0.5μs=1μs 刷新（刷新以行算）一行的时间为1μs，全部刷新完的时间为： 128×1μs=128μs 此时比2ms小的多 优点：无死区 缺点：存取周期长，整个系统的速度降低了 ","date":"2020-06-04","objectID":"/posts/CO-3/:12:2","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"异步刷新 异步刷新：前两种方式的结合，缩短了死时间，充分利用了最大刷新间隔为2ms的特点（只要在2ms内对这一行刷新一遍就行） 例：对128×128的矩阵的存储芯片进行刷新，存储周期为0.5s，刷新周期为2ms 2ms内对每行刷新一遍： 2000μs÷128≈15.6μs 即每隔15.6μs刷新一行，每行的刷新时间仍然为0.5μs。刷新一行就停一个存储周期，“死时间缩短为0.5μs” 这种方案克服了分散刷新许独占0.5μs用于刷新，使存取周期加长且降低系统速度的缺点，又不会出现集中刷新的访问“死区”问题，从根本上提高了工作效率。 ","date":"2020-06-04","objectID":"/posts/CO-3/:12:3","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"动态 RAM 和静态 RAM 的比较 ","date":"2020-06-04","objectID":"/posts/CO-3/:13:0","tags":["计组-课程"],"title":"计算机组成原理 Part-3","uri":"/posts/CO-3/"},{"categories":["计算机组成原理"],"content":"总线 总线概念 总线是连接各个部件的信息传输线,分为串行和并行两种类型 串行 一条线路,数据只能进行排队发送,不存在时延问题,目前的主流,因为可以通过不断提升的频率来弥补单条线路发送速度低的问题,通常用于较长距离的传输,成本低,实现简单 并行: 多条线路可同时发送一条数据,由于需要去除并行中不同线路的时延,所以需要将较短的线路做成弯曲的形状,让并行线路中所有线路长度都相同,适用于较短距离的传输,目前已发展到速度瓶颈,因为越来越高的频率造成线路不同时到达的概率就越高,且解决成本高,实现复杂 总线结构 ","date":"2020-06-03","objectID":"/posts/CO-2/:0:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"单总线结构 ","date":"2020-06-03","objectID":"/posts/CO-2/:1:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"多总线结构 ","date":"2020-06-03","objectID":"/posts/CO-2/:2:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"双总线 ","date":"2020-06-03","objectID":"/posts/CO-2/:2:1","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"三总线 ","date":"2020-06-03","objectID":"/posts/CO-2/:2:2","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"三总线cache ","date":"2020-06-03","objectID":"/posts/CO-2/:2:3","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"四总线 ","date":"2020-06-03","objectID":"/posts/CO-2/:2:4","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"以cpu为中心的双总线 ","date":"2020-06-03","objectID":"/posts/CO-2/:2:5","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"以存储器为中心的双总线 ","date":"2020-06-03","objectID":"/posts/CO-2/:2:6","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"传统微型机总线结构 ","date":"2020-06-03","objectID":"/posts/CO-2/:2:7","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"VL-BUS局部总线结构 ","date":"2020-06-03","objectID":"/posts/CO-2/:2:8","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"PCI 总线结构 ","date":"2020-06-03","objectID":"/posts/CO-2/:2:9","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"多层总线结构 总线的分类 片内总线: 芯片内部的总线 系统总线: 计算机各部件之间的信息传输线 数据总线: 双向 与机器字长、存储字长有关 地址总线: 单向 与存储地址、 I/O地址有关 控制总线: (出)中断请求、总线请求,(入)存储器读、存储器写总线允许、中断确认 通信总线: 用于 计算机系统之间 或 计算机系统与其他系统(如控制仪表、移动通信等)之间的通信 串行通信总线 并行通信总线 总线特性 总线是主板的主要部分,负责各组件之间的数据传输 机械特性: 尺寸、形状、管脚数及排列顺序 电气特性: 传输方向和有效的电平范围 功能特性: 每根传输线的功能(地址,数据,控制) 时间特性: 信号的时序关系 ","date":"2020-06-03","objectID":"/posts/CO-2/:2:10","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"总线的性能指标 总线宽度: 数据线的根数 标准传输率: 每秒传输的最大字节数(MBps) 时钟同步/异步: 同步、不同步 总线复用: 地址线与数据线复用 信号线数: 地址线、数据线和控制线的 总和 总线控制方式: 突发、自动、仲裁、逻辑、计数 其他指标: 负载能力 ","date":"2020-06-03","objectID":"/posts/CO-2/:3:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"总线标准 总线控制 ","date":"2020-06-03","objectID":"/posts/CO-2/:4:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"总线判优控制 主设备(模块) 对总线有控制权 从设备(模块) 响应从主设备发来的总线命令 总线判优控制 集中式 链式查询 计数器定时查询 独立请求方式 分布式 ","date":"2020-06-03","objectID":"/posts/CO-2/:5:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"链式查询方式 通过BG线,在IO接口中逐个传递控制部件的数据 ","date":"2020-06-03","objectID":"/posts/CO-2/:6:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"计数器定时查询方式 将IO接口进行计数标号,控制部件的数据根据序号来传输 ","date":"2020-06-03","objectID":"/posts/CO-2/:7:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"独立请求方式 每一个IO接口都有BG和BR线,控制器进行单独控制 总线的通信控制 解决通信双方协调配合问题 ","date":"2020-06-03","objectID":"/posts/CO-2/:8:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"总线传输周期 申请分配阶段: 主模块申请,总线仲裁决定 寻址阶段: 主模块向从模块给出地址和命令 传数阶段: 主模块和从模块交换数据 结束阶段: 主模块撤消有关信息 ","date":"2020-06-03","objectID":"/posts/CO-2/:9:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"总线通信的四种方式 同步通信: 由统一时标控制数据传送 异步通信: 采用应答方式,没有公共时钟标准 半同步通信: 同步、异步结合 分离式通信: 充分挖掘系统总线每个瞬间的潜力 ","date":"2020-06-03","objectID":"/posts/CO-2/:10:0","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"同步式数据-输入 ","date":"2020-06-03","objectID":"/posts/CO-2/:10:1","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"同步式数据-输出 ","date":"2020-06-03","objectID":"/posts/CO-2/:10:2","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"异步通信 不互锁: 双方闭眼睛传数据 半互锁: 从设备对主设备进行数据确认 全互锁: 双方都对数据进行确认 ","date":"2020-06-03","objectID":"/posts/CO-2/:10:3","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"半同步通信 (同步、异步 结合) 同步 发送方用系统时钟前沿发信号 接收方用系统时钟后沿判断、识别 异步 允许不同速度的模块和谐工作,增加一条“等待”响应信号’WAIT' 以输入数据为例的半同步通信时序 T1主模块发地址 T2主模块发命令 Tw当’WAIT’为低电平时,等待一个 T Tw当’WAIT’为低电平时,等待一个 T T3从模块提供数据 T4从模块撤销数据,主模块撤销命令 上述三种通信的共同点 一个总线传输周期(以输入数据为例) 主模块发地址 、命令 占用总线 从模块准备数据 不占用总线 总线空闲 从模块向主模块发数据 占用总线 ","date":"2020-06-03","objectID":"/posts/CO-2/:10:4","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["计算机组成原理"],"content":"分离式通信 充分挖掘系统总线每个瞬间的潜力 总线传输周期 子周期1: 主模块申请占用总线,使用完后即放弃总线的使用权 子周期2: 从模块申请占用总线,将各种信息送至总线上 分离式通信特点 各模块有权申请占用总线 采用同步方式通信,不等对方回答 各模块准备数据时,不占用总线 总线被占用时,无空闲 充分提高了总线的有效占用 ","date":"2020-06-03","objectID":"/posts/CO-2/:10:5","tags":["计组-课程"],"title":"计算机组成原理 Part-2","uri":"/posts/CO-2/"},{"categories":["Leetcode"],"content":"面试题64-求1+2+…+n 9-回文数 22-括号生成 ","date":"2020-06-03","objectID":"/posts/leetcode-25/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-25","uri":"/posts/leetcode-25/"},{"categories":["Leetcode"],"content":"面试题64-求1+2+…+n 题目: 求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 输入: n = 3 输出: 6 解题思路: 巧妙使用 \u0026\u0026 运算符 逻辑运算符 \u0026\u0026 ，对于 A \u0026\u0026 B 这个表达式，如果 A 表达式返回 False ，那么 A \u0026\u0026 B 已经确定为 False，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回 True ，那么 A || B 已经确定为 True ，此时不会去执行表达式 B。 int sumNums(int n) { return n == 0 ? 0 : n + sumNums(n - 1); } ","date":"2020-06-03","objectID":"/posts/leetcode-25/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-25","uri":"/posts/leetcode-25/"},{"categories":["Leetcode"],"content":"9-回文数 题目: 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 输入: -121 输出: false 解题思路: 转成新的数,之后比较 bool isPalindrome(int x){ if ( x \u003c 0) return false; if ( x \u003e= 0 \u0026\u0026 x \u003c 10 ) return true; if ( (x % 10) == 0 ) return false; long res = 0 ; int tmp = x; while ( x != 0){ res = 10 * res + ( x % 10); x = x / 10; } if (res == tmp ) return true; return false; } ","date":"2020-06-03","objectID":"/posts/leetcode-25/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-25","uri":"/posts/leetcode-25/"},{"categories":["Leetcode"],"content":"22-括号生成 题目: 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。 解题思路: 这是一道好题,会帮助很好的理解回溯和经典排列组合问题 看完题解有些理解了回溯,我感觉这道题思想跟深度优先遍历有些相似 大佬画的递归树图 void generate(char *item,int index,int left,int right,char **result,int *count,int n) { if(left==0\u0026\u0026right==0){ //已经全部插满了 result[(*count)]=(char*)malloc(sizeof(char)*(2*n+1)); strcpy(result[(*count)++],item); return; } //result[(*count)++][]=item; item[index]='('; //插入左括号 item[index+1]='\\0'; if(left\u003e0){ generate(item,index+1,left-1,right,result,count,n); } if(right\u003eleft){ //待插入右括号的个数多余待插入左括号的个数 item[index]=')'; //插入右括号 generate(item,index+1,left,right-1,result,count,n); } } char ** generateParenthesis(int n, int* returnSize){ int left=n,right=n; int length=2*2*n; int count=0; //记录已经插入的个数 int index=0; //记录当前插入元素的下标 char **result=(char **)malloc(sizeof(char *)*(5000)); //创建二维数组 char *item=(char *)malloc(sizeof(char)*(2*n+1)); //创建存储数组 generate(item,index,left,right,result,\u0026count,n); *returnSize=count; return result; } ","date":"2020-06-03","objectID":"/posts/leetcode-25/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-25","uri":"/posts/leetcode-25/"},{"categories":["Ubuntu"],"content":"20.04竟然没有带护眼模式,我记得18.04有这个模式的…只好自己装一个软件啦 ","date":"2020-06-03","objectID":"/posts/ubuntu-25/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu护眼软件","uri":"/posts/ubuntu-25/"},{"categories":["Ubuntu"],"content":"安装 sudo apt-get install redshift-gtk ","date":"2020-06-03","objectID":"/posts/ubuntu-25/:1:0","tags":["Linux-Ubuntu"],"title":"Ubuntu护眼软件","uri":"/posts/ubuntu-25/"},{"categories":["Ubuntu"],"content":"配置参数 进入~/.config touch redshift.conf 之后填写配置文件 sudo vim redshift.conf 写入以下内容： [redshift] ; 白天屏幕温度 temp-day=5600 ; 夜晚屏幕温度 temp-night=4200 ; 昼夜是否平滑过度(1/0) transition=1 ; 位置提供方式(redshift -l list) location-provider=manual [manual] ; 位置提供方式设置 ; 经纬度(北京) lat=39 lon=116 ","date":"2020-06-03","objectID":"/posts/ubuntu-25/:2:0","tags":["Linux-Ubuntu"],"title":"Ubuntu护眼软件","uri":"/posts/ubuntu-25/"},{"categories":["计算机组成原理"],"content":"计算机基本体系结构 今天开始学习组成原理啦,由于ppt很好,就直接截图啦 计算机系统的层次结构 ","date":"2020-06-02","objectID":"/posts/CO-1/:0:0","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"计算机体系结构和计算机组成的关系 计算机体系结构: 程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理） 计算机组成: 实现计算机体系结构所体现的属性（具体指令的实现） ","date":"2020-06-02","objectID":"/posts/CO-1/:1:0","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"计算机的基本组成 冯·诺依曼计算机的特点 计算机由五大部件组成 指令和数据以同等地位存于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心 以运算器为中心 以存储器为中心 现代计算机的硬件框图 系统复杂性管理的方法-2（3’Y） 层次化（Hierachy）：将被设计的系统划分为多个模块或子模块 模块化（Modularity）：有明确定义 （well-defined）的功能和接口 规则性（regularity）：模块更容易被重用 ","date":"2020-06-02","objectID":"/posts/CO-1/:2:0","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"编程举例 计算 ax2 + bx + c = (ax + b)x + c 取x 至运算器中 乘以x 在运算器中 乘以a 在运算器中 存ax2 在存储器中 取b 至运算器中 乘以x 在运算器中 加ax2 在运算器中 加c 在运算器中 取x 至运算器中 乘以a 在运算器中 加b 在运算器中 乘以x 在运算器中 加c 在运算器中 指令格式 ","date":"2020-06-02","objectID":"/posts/CO-1/:3:0","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"计算 ax2 + bx + c 程序清单 存储器的基本组成 运算器的基本组成及操作过程 ","date":"2020-06-02","objectID":"/posts/CO-1/:4:0","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"加法操作过程 ","date":"2020-06-02","objectID":"/posts/CO-1/:5:0","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"减法操作过程 ","date":"2020-06-02","objectID":"/posts/CO-1/:6:0","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"乘法操作过程 ","date":"2020-06-02","objectID":"/posts/CO-1/:7:0","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"除法操作过程 控制器的基本组成 ","date":"2020-06-02","objectID":"/posts/CO-1/:8:0","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"完成指令过程 ","date":"2020-06-02","objectID":"/posts/CO-1/:9:0","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"取数操作 ","date":"2020-06-02","objectID":"/posts/CO-1/:9:1","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"存数操作 ","date":"2020-06-02","objectID":"/posts/CO-1/:9:2","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["计算机组成原理"],"content":"ax2 + bx + c 的运行过程 将程序通过输入设备送至计算机 程序首地址 启动程序运行 分析指令 OP(IR) CU 取指令 PC-\u003e MAR -\u003e M -\u003e MDR -\u003e IR, (PC )+ 1 -\u003e PC 执行指令 Ad(IR) -\u003e MAR -\u003e M -\u003e MDR -\u003e ACC … 打印结果 停机 计算机硬件的主要技术指标 机器字长: CPU一次能处理数据的位数,与CPU中的寄存器位数有关 运算速度 存储容量 其中b是bit, B是byte 1B = 8b ","date":"2020-06-02","objectID":"/posts/CO-1/:9:3","tags":["计组-课程"],"title":"计算机组成原理 Part-1","uri":"/posts/CO-1/"},{"categories":["Leetcode"],"content":"今天6.1!导员问我学院想让我当 优秀毕业生风采展的代表 可不可以,当然可以鸭嘿嘿 (虽然大学本专业成绩辣鸡的很,但是!找到了自己喜欢的行业和目标,不算太亏吧!) 前天gnome天气插件不好使了,没法刷新数据,困扰了好几天,最后在国外gitlab论坛上看到了(还好俺会点英语)果然国外的技术论坛干货多啊,英语是程序员必须的一项技能 废话不多说,今天的力扣暴力求解开始了哈哈哈哈 1431-拥有最多糖果的孩子 437-路径总和 III 234-回文链表 581-最短无序连续子数组 538-把二叉搜索树转换为累加树 ","date":"2020-06-01","objectID":"/posts/leetcode-24/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"1431-拥有最多糖果的孩子 题目: 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。 输入：candies = [2,3,5,1,3], extraCandies = 3 输出：[true,true,true,false,true] 解题思路: 暴力求解不多说,让俺去看看大佬们的操作(啊,方法跟我一样,没事了) bool* kidsWithCandies(int* candies, int candiesSize, int extraCandies, int* returnSize){ /*find max*/ *returnSize = candiesSize; int max = 0; bool* res = (bool*)malloc(sizeof(bool)*candiesSize); memset(res,false,candiesSize); int max_loc = 0; for(int i=0; i\u003ccandiesSize; i++){ if(candies[i]\u003emax){ max = candies[i]; max_loc = i; } } for(int j=0; j\u003ccandiesSize; j++){ if(candies[j]+extraCandies \u003e max){ res[j] = true; } else if(candies[j]+extraCandies == max){ res[max_loc] = true; res[j] = true; } } return res; } ","date":"2020-06-01","objectID":"/posts/leetcode-24/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"437-路径总和 III 题目: 给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -\u003e 3 2. 5 -\u003e 2 -\u003e 1 3. -3 -\u003e 11 解题思路: 标准dfs遍历,但是需要考虑起点的位置 int myPathSum(struct TreeNode *root, int sum) { int cnt = 0; if (root == NULL) { return 0; } if (root-\u003eval == sum) { cnt++; } cnt += myPathSum(root-\u003eleft, sum - root-\u003eval); cnt += myPathSum(root-\u003eright, sum - root-\u003eval); return cnt; } int pathSum(struct TreeNode* root, int sum){ int res = 0; if (!root) { return res; } /*这个return很奇妙,需要特别学习一下,要考虑起点的位置*/ return myPathSum(root, sum) + pathSum(root-\u003eleft, sum) + pathSum(root-\u003eright, sum); } ","date":"2020-06-01","objectID":"/posts/leetcode-24/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"234-回文链表 题目: 请判断一个链表是否为回文链表,回文就是反转以后和以前一样的就是回文结构 输入: 1-\u003e2-\u003e2-\u003e1 输出: true 解题思路: 本来我想用栈来解决,但是无法确定奇数和偶数的情况,最后发现没法用呀,只好逆置了 这道题有两种思路: 逆置整个链表,然后和原链表进行比较 首先利用双指针(快慢指针),找到中间点,然后将后半段链表进行逆置,与前半段进行比较 双指针大法好!一定要记住! ","date":"2020-06-01","objectID":"/posts/leetcode-24/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"逆置整个链表 bool isPalindrome(struct ListNode* head){ if(head==NULL)return 1; struct ListNode*ans=head; struct ListNode*ami=NULL; struct ListNode*transfer=NULL; while(ans!=NULL){ //生成新的逆序链表 ami=(struct ListNode*)malloc(sizeof(struct ListNode)); ami-\u003eval=ans-\u003eval; ami-\u003enext=transfer; transfer=ami; ans=ans-\u003enext; } while(head!=NULL){ //对比两个链表是不是相同 if(ami-\u003eval!=head-\u003eval) return false; head=head-\u003enext; ami=ami-\u003enext; } return true; } ","date":"2020-06-01","objectID":"/posts/leetcode-24/:3:1","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"双指针逆置半个链表 对奇数和偶数的情况要进行考虑 void cut(struct ListNode* head,struct ListNode* cutNode); struct ListNode* reverse(struct ListNode* head); bool IsEqual(struct ListNode* l1,struct ListNode* l2); bool isPalindrome(struct ListNode* head){ if(head==NULL || head-\u003enext==NULL) return true; struct ListNode* slow=head; struct ListNode* fast=head; while(fast!=NULL \u0026\u0026 fast-\u003enext!=NULL) { fast=fast-\u003enext-\u003enext; //慢指针走一步，快指针走两步，最后把单链表分为以慢指针分成两部分 slow=slow-\u003enext; } cut(head,slow); if(fast!=NULL) slow=slow-\u003enext; /*如果是奇数个结点，那么cut后将slow后移一位再reverse，就将中间的结点扔掉了，但其实不这么做也是可以的，因为在IsEqual函数中while的判断条件里是\u0026\u0026，即使不把中间的点扔掉，它也不会加入判断，结果是一样的*/ return IsEqual(head,reverse(slow)); } void cut(struct ListNode* head,struct ListNode* cutNode){ //在slow结点前砍断链表 while(head-\u003enext!=cutNode) head=head-\u003enext; head-\u003enext=NULL; } struct ListNode* reverse(struct ListNode* head) { struct ListNode* newHead=NULL; while(head!=NULL) { struct ListNode* nextNode=head-\u003enext; head-\u003enext=newHead; newHead=head; head=nextNode; } return newHead; } bool IsEqual(struct ListNode* l1,struct ListNode* l2){ while(l1!=NULL \u0026\u0026 l2 !=NULL) { if(l1-\u003eval != l2-\u003eval) return false; l1=l1-\u003enext; l2=l2-\u003enext; } return true; } ","date":"2020-06-01","objectID":"/posts/leetcode-24/:3:2","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"581-最短无序连续子数组 题目: 给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 输入: [2, 6, 4, 8, 10, 9, 15] 输出: 5 解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 解题思路: 这道简单题…我尝试用滑动窗口,没做出来,用单调栈,没做出来… 看了题解发现,是方法没找对,枯了 ","date":"2020-06-01","objectID":"/posts/leetcode-24/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"先排序后检查 先进行排序，让数组升序； 从前向后，寻找第一个与之前序列不同的元素所在位置begin 从后向前遍历 , ,end 相减返回begin-end+1。如果已经有序就返回0 int compare(const void *a,const void *b){ return *(int*)a-*(int*)b; } int findUnsortedSubarray(int* nums, int numsSize){ int begin=0;int end=0; int *numscpy=(int*)malloc(numsSize*sizeof(int)); memcpy(numscpy,nums,sizeof(int)*numsSize); qsort(numscpy,numsSize,sizeof(int),compare); for(int i=0;i\u003cnumsSize;i++){ if(numscpy[i]!=nums[i]){ begin=i; break; } } for(int i=numsSize-1;i\u003e=0;i--){ if(numscpy[i]!=nums[i]){ end=i; break; } } if(begin==end){ return 0; } return end-begin+1; } ","date":"2020-06-01","objectID":"/posts/leetcode-24/:4:1","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"在逆序内寻找最值 先找到发生逆序的起始元素，这里需要注意的是逆序是指a1,a2,如果a2小于a1，那么a1的下标的就是逆序的起始元素 在找到逆序的头尾之后，再寻找在逆序中的最大最小值。 利用子序列的最值再从两头开始寻找真正的下标。 这里发生了两次寻找下标，需要注意相同元素的判断。 int findUnsortedSubarray(int* nums, int numsSize){ int posi=0,posj=numsSize-1,i,j,min,max;//游标和定位 while(posj\u003eposi\u0026\u0026nums[posi]\u003c=nums[posi+1])posi++;//定位下标 while(posj\u003eposi\u0026\u0026nums[posj]\u003e=nums[posj-1])posj--; if(posi==posj) return 0; min=nums[posi],max=nums[posj]; for(i=posi;i\u003c=posj;i++)//找到子数组中最大最小值 { if(nums[i]\u003cmin) min=nums[i]; if(nums[i]\u003emax) max=nums[i]; } posi=0,posj=numsSize-1; while(nums[posi]\u003c=min)posi++; while(nums[posj]\u003e=max)posj--; return posj-posi+1; } ","date":"2020-06-01","objectID":"/posts/leetcode-24/:4:2","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"538-把二叉搜索树转换为累加树 题目: 给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 输入: 原始二叉搜索树: 5 / \\ 2 13 输出: 转换为累加树: 18 / \\ 20 13 解题思路:中序遍历的改造 ","date":"2020-06-01","objectID":"/posts/leetcode-24/:5:0","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"先右后左的中序遍历 void in_order(struct TreeNode* root); int g_sum; struct TreeNode* convertBST(struct TreeNode* root) { g_sum = 0; if (root == NULL) { return NULL; } in_order(root); return root; } void in_order(struct TreeNode* root) { if (root == NULL) { return; } in_order(root-\u003eright); root-\u003eval += g_sum; g_sum = root-\u003eval; in_order(root-\u003eleft); } ","date":"2020-06-01","objectID":"/posts/leetcode-24/:5:1","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Leetcode"],"content":"中序遍历结果存入数组 void cBST(struct TreeNode*root, struct TreeNode* arr[],int *count){ if(root!=NULL){ cBST(root-\u003eleft,arr,count); arr[*count]=root;(*count)++; cBST(root-\u003eright,arr,count); } } struct TreeNode* convertBST(struct TreeNode* root){ struct TreeNode* arr[20000]; int count=0; cBST(root,arr,\u0026count); for(int i=count-2;i\u003e=0;i--){ arr[i]-\u003eval=arr[i]-\u003eval+arr[i+1]-\u003eval; } return root; } ","date":"2020-06-01","objectID":"/posts/leetcode-24/:5:2","tags":["Leetcode-C++"],"title":"Leetcode Part-24","uri":"/posts/leetcode-24/"},{"categories":["Ubuntu"],"content":"前天gnome的openweather插件突然无法更新 在gitlab找到了解决方案 在这里记录一下方法 Download SectigoRSADomainValidationSecureServerCA.crt from Sectigo RSA Domain Validation Secure Server CA Drop the file to /usr/local/share/ca-certificates Run sudo update-ca-certificates Restart shell Alt + F2, press r, press Enter. 下载网址: Sectigo RSA Domain Validation Secure Server CA ps: 文件在页面的下面 可以在页面中搜索\"SectigoRSADomainValidationSecureServerCA\" ","date":"2020-06-01","objectID":"/posts/ubuntu-24/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu20.04修复openweather","uri":"/posts/ubuntu-24/"},{"categories":["Leetcode"],"content":"今天论文整到2.1w字了,降降重就完事啦 今天把apple music的 icloud研究明白了,上传了好多国区曲库没有的歌 听到了我最喜欢的\"Rolling Stone\"!!! 461-汉明距离 位运算符 ","date":"2020-05-31","objectID":"/posts/leetcode-23/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-23","uri":"/posts/leetcode-23/"},{"categories":["Leetcode"],"content":"461-汉明距离 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 示例: 输入: x = 1, y = 4 输出: 2 解释: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 解题思路: 异或运算(位运算) int hammingDistance(int x, int y){ int count = 0; int a = x^y; while(a!=0){ if(a%2==1){ count++; } a /=2; } return count; } ","date":"2020-05-31","objectID":"/posts/leetcode-23/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-23","uri":"/posts/leetcode-23/"},{"categories":["Leetcode"],"content":"位运算符 按位与运算符（\u0026） 参加运算的两个数据，按二进制位进行“与”运算。 运算规则： 0\u00260=0; 0\u00261=0; 1\u00260=0; 1\u00261=1; 按位或运算符（|） 参加运算的两个对象，按二进制位进行“或”运算。 运算规则： 0|0=0； 0|1=1； 1|0=1； 1|1=1； 取反运算符（~） 参加运算的一个数据，按二进制位进行“取反”运算。 运算规则： ~1=0； ~0=1； 异或运算符(^) 用于比较两个二进制数的相应位。在执行按位异或运算时 如果两个二进制数的相应位都位1或两个二进制数的相应位都位0，则返回 0； 如果两个二进制数的相应位其中一个为1，另一个为0，则返回 1； 位移运算符“«”和\"»\" 位移运算符分为左位移运算符“«”和右位移运算符“»”，分别用于向左和向右执行位移运算。 对于X«N 或 X»N 形式的运算，含义是将 X 向左或向右移动 N 位，X 的类型可以是 int，uint，long，ulong，byte，sbyte，short 和ushort 。需要注意的是，byte，sbyte，short，和 ushort 类型的值在进行位移操作后值的类型讲自动转换成 int 类型。 ","date":"2020-05-31","objectID":"/posts/leetcode-23/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-23","uri":"/posts/leetcode-23/"},{"categories":["Leetcode"],"content":"异或运算 异或运算符是指： 参与运算的两个值，如果两个相应位相同，则结果为0，否则为1。即：0^0=0， 1^0=1， 0^1=1， 1^1=0 例如：10100001^00010001=10110000 0^0=0,0^1=1 可理解为：0异或任何数，其结果=任何数 1^0=1,1^1=0 可理解为： 1异或任何数，其结果=任何数取反 任何数异或自己，等于把自己置0 按位异或可以用来使某些特定的位翻转，如对数10100001的第1位和第2位翻转，可以将数与00000110进行按位异或运算。 10100001^00000110=10100111 用十六进制表示：0xA1 ^ 0x06= 0xA7 通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。例如交换两个整数a，b的值，可通过下列语句实现： a=10100001, b=00000110 a=a^b； //a=10100111 b=b^a； //b=10100001 a=a^b； //a=00000110 异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a. ","date":"2020-05-31","objectID":"/posts/leetcode-23/:2:1","tags":["Leetcode-C++"],"title":"Leetcode Part-23","uri":"/posts/leetcode-23/"},{"categories":["Leetcode"],"content":"动态规划 滑动窗口 单调栈 ","date":"2020-05-29","objectID":"/posts/leetcode-22/:0:0","tags":["Leetcode-C++"],"title":"Leetcode算法 Part-22","uri":"/posts/leetcode-22/"},{"categories":["Leetcode"],"content":"动态规划 动态规划的核心思想是把原问题分解成子问题进行求解，也就是分治的思想。 去网上搜资料,竟然搜到曾学长的文章哈哈哈哈,并且讲的很棒! 一种可以用动态规划解决的情况就是会有反复出现的子问题，然后这些子问题还会包含更小的子问题。相比于不断尝试去解决这些反复出现的子问题，动态规划会尝试一次解决更小的子问题。之后可以将结果输出记录在表格中，在之后的计算中可以把这些记录作为问题的原始解。 对于经典的斐波那契数列就可以适用 0,1,1,2,3,5,8,13…它的每个数字都与前两个紧邻的数字相关。如果 F(n) 是第 n 个数字，那么我们会有 F(n) = F(n-1) + F(n-2)。这个在数学上称作递归方程或者递推关系。为了计算后面的项，它需要前面项的计算结果作为输入 大多数动态规划问题都能被归类成两种类型： 优化问题 组合问题 以下是两种不同的动态规划解决方案： 自上而下：你从最顶端开始不断地分解问题，直到你看到问题已经分解到最小并已得到解决，之后只用返回保存的答案即可。这叫做记忆存储。 自下而上：你可以直接开始解决较小的子问题，从而获得最好的解决方案。在此过程中，你需要保证在解决问题之前先解决子问题。 经典例题 198-打家劫舍 ","date":"2020-05-29","objectID":"/posts/leetcode-22/:1:0","tags":["Leetcode-C++"],"title":"Leetcode算法 Part-22","uri":"/posts/leetcode-22/"},{"categories":["Leetcode"],"content":"滑动窗口 滑动窗口法，可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。 核心思想是维护左右指针 滑动窗口的思想:先产生可行解,再优化 先寻求一个可行的解 在可行解的基础上，优化这个可行解 优化到不能优化，产生出一个可能的最优解 继续寻求新的可行解 继续优化这个可行解 ……循环 在可能的最优解中产生出最优解 典型例题 76-最小覆盖子串 ","date":"2020-05-29","objectID":"/posts/leetcode-22/:2:0","tags":["Leetcode-C++"],"title":"Leetcode算法 Part-22","uri":"/posts/leetcode-22/"},{"categories":["Leetcode"],"content":"单调栈 单调栈也是经常会用到的,这里记录一下 ","date":"2020-05-29","objectID":"/posts/leetcode-22/:3:0","tags":["Leetcode-C++"],"title":"Leetcode算法 Part-22","uri":"/posts/leetcode-22/"},{"categories":["Leetcode"],"content":"概念 单调栈中存放的数据应该是有序的，所以单调栈也分为单调递增栈和单调递减栈 单调递增栈：数据出栈的序列为单调递增序列 单调递减栈：数据出栈的序列为单调递减序列 ","date":"2020-05-29","objectID":"/posts/leetcode-22/:3:1","tags":["Leetcode-C++"],"title":"Leetcode算法 Part-22","uri":"/posts/leetcode-22/"},{"categories":["Leetcode"],"content":"例子 现在有一组数10，3，7，4，12。从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。 10入栈时，栈为空，直接入栈，栈内元素为10。 3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。 7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。 4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。 12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。 下面用一道例题来说明 ","date":"2020-05-29","objectID":"/posts/leetcode-22/:3:2","tags":["Leetcode-C++"],"title":"Leetcode算法 Part-22","uri":"/posts/leetcode-22/"},{"categories":["Leetcode"],"content":"单调栈例题-视野总和 题目: 有n个人站队，所有的人全部向右看，个子高的可以看到个子低的发型，给出每个人的身高，问所有人能看到其他人发现总和是多少。 输入：4 3 7 1 输出：2 解释：个子为4的可以看到个子为3的发型，个子为7可以看到个子为1的身高，所以1+1=2 解体思路： 观察题之后，我们发现实际上题目转化为找当前数字向右查找的第一个大于他的数字之间有多少个数字，然后将每个 结果累计就是答案，但是这里时间复杂度为O(N^2)，所以我们使用单调栈来解决这个问题。 int FieldSum(vector\u003cint\u003e\u0026 v) { v.push_back(INT_MAX);/这里可以理解为需要一个无限高的人挡住栈中的人，不然栈中元素最后无法完全出栈 stack\u003cint\u003e st; int sum = 0; for (int i = 0; i \u003c (int)v.size(); i++) { if (st.empty() || v[st.top()] \u003e v[i])//小于栈顶元素入栈 { st.push(i); } else { while (!st.empty() \u0026\u0026 v[st.top()] \u003c= v[i]) { int top = st.top();//取出栈顶元素 st.pop(); sum += (i - top - 1);//这里需要多减一个1 } st.push(i); } } return sum; } ","date":"2020-05-29","objectID":"/posts/leetcode-22/:3:3","tags":["Leetcode-C++"],"title":"Leetcode算法 Part-22","uri":"/posts/leetcode-22/"},{"categories":["Leetcode"],"content":"198-打家劫舍 121-买卖股票的最佳时机 76-最小覆盖子串 今天论文写了(复制粘贴)了5k,字数到1.5w了,嘿嘿,明天降重,论文越写越有感觉了 ","date":"2020-05-29","objectID":"/posts/leetcode-21/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-21","uri":"/posts/leetcode-21/"},{"categories":["Leetcode"],"content":"198-打家劫舍 题目: 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 解题思路: 偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 kkk 间房屋的金额之和。 不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。 在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。 用 dp[i]表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程： dp[i]=max⁡(dp[i−2]+nums[i],dp[i−1]) 最终的答案即为 dp[n−1]，其中 n 是数组的长度。 我太菜了…动态规划没想到,跟上台阶那道题很像,这方面做的题太少了,没啥感觉 简单一点说,这道题的动态规划就是,由于不能相邻取值,只能当前值和i-2节点,或者当前节点不选择,只选择上一个节点,而每个节点都是如此判断,所以可以进行for-max取值 int rob(int* nums, int numsSize) { if(!numsSize){ return 0; } int dp[numsSize][2]; dp[0][0] = 0; dp[0][1] = nums[0]; for(int i=1;i\u003cnumsSize;i++) { dp[i][1] = nums[i] + dp[i-1][0]; dp[i][0] = dp[i-1][0]\u003edp[i-1][1]?dp[i-1][0]:dp[i-1][1]; } return dp[numsSize-1][0]\u003edp[numsSize-1][1]?dp[numsSize-1][0]:dp[numsSize-1][1]; } ","date":"2020-05-29","objectID":"/posts/leetcode-21/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-21","uri":"/posts/leetcode-21/"},{"categories":["Leetcode"],"content":"121-买卖股票的最佳时机 题目: 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 解题思路: 滑动窗口解法 int maxProfit(int* a, int n) { if (a == NULL || n ==0) { return 0; // 参数有误 } int min = a[0]; // 暴力破解 int profit = 0; // 默认是0 for (int i = 1; i \u003c n; i++) { if (min \u003e a[i]) { // 最低价 min = a[i]; } int d1 = profit; // 之前卖 int d2 = a[i] - min; // 当天卖 profit = d1 \u003e d2 ? d1 : d2; } return profit; } ","date":"2020-05-29","objectID":"/posts/leetcode-21/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-21","uri":"/posts/leetcode-21/"},{"categories":["Leetcode"],"content":"76-最小覆盖子串 题目: 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。 输入: S = \"ADOBECODEBANC\", T = \"ABC\" 输出: \"BANC\" 解题思路: 滑动窗口! 在滑动窗口类型的问题中都会有两个指针。一个用于「延伸」现有窗口的 rrr 指针，和一个用于「收缩」窗口的 lll 指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 sss 上滑动窗口，通过移动 rrr 指针不断扩张窗口。当窗口包含 ttt 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。 如何判断当前的窗口包含所有 ttt 所需的字符呢？我们可以用一个哈希表表示 ttt 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 ttt 的哈希表中的所有字符，并且对应的个数都不小于 ttt 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。 此题推荐观看官方求解视频,良心的25min解体思路 #define LEN 125 char* minWindow(char* s, char* t) { int hash[LEN] = {0}; int start=0, end=0, tLen=strlen(t), sLen=strlen(s); int minStart=0, minLen=INT_MAX; for(int i = 0; t[i]; i++) hash[t[i]]++; //统计 t 串字母出现的次数 while(end \u003c sLen) { //若 s 串有 t 串的字母，则对应的哈希表减一，tlen 也减一 if(hash[s[end]]-- \u003e 0){ tLen--; } //不管啥,减就完事啦,统计是否t中元素都被减掉了 end++; //窗口前指针继续滑动 while(tLen == 0) //t完整啦! { if(end-start \u003c minLen) //更新最小串数的值 minStart = start, minLen = end-start; hash[s[start]]++;//开始缩小窗口 //若 s[start] 在 t 串中，则 tlen 要++,说明缩小之后，当前窗口不存在有效的子串了 if(hash[s[start]] \u003e 0){ tLen++; } start++; //接着移动 } } if(minLen != INT_MAX)//若找得到 { // 写法一： // char* t = (char*)malloc(sizeof(char)*(minLen+1)); // *t = '\\0'; // strncat(t, s+minStart, minLen); // return t; // 写法二：emmm~ 这个写法会小一丢丢的空间复杂度 s[minStart+minLen] = '\\0'; printf(\"%s\",s); return s+minStart; //很好的返回形式,blog之前说过这种方法 } return \"\";//那就找不到啦 } ","date":"2020-05-29","objectID":"/posts/leetcode-21/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-21","uri":"/posts/leetcode-21/"},{"categories":["Ubuntu"],"content":"强大的图片处理软件: imagemagick,optipng imagemagick 2020年5月28日更新 专业级别的图面处理软件-\u003e Imagemagick (我没有打错!) 官方网址 教程参考 ","date":"2020-05-28","objectID":"/posts/ubuntu-12/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu压缩图片","uri":"/posts/ubuntu-12/"},{"categories":["Ubuntu"],"content":"文件格式转换 ImageMagick 提供了 convert 命令用于接收图片文件并对其进行特定的操作后输出。其中最基本的用法即改变图片的格式。 如将 PNG 格式的图片转为 JPEG 格式： $ convert image.png image.jpg 对于 JPEG 图片，在转换时还可以指定压缩等级，如： $ convert image.png -quality 95 image.jpg 其中压缩等级（-quality）的值为 1-100，默认使用输入图片的压缩等级。如该值为空，则压缩等级默认为 92 。 改变图片大小 convert 命令还可以用来改变图片的大小。如下面的命令可以将原图片转成大小为 200x100 像素的图片： $ convert image.png -resize 200x100 out.png 需要注意的是，在上面的命令中，ImageMagick 会优先保持原图片的比例（否则图片会发生一定程度的变形）。这样的结果是，改变后的图片可以正好放进一个 200x100 大小的区域，但图片本身并不一定是精确的 200x100 像素。 如果就是需要将原图片转换为特定大小，而不用考虑形变的影响。可以使用如下命令： $ convert image.png -resize 200x100! out.png 当然更多的时候，指定输出图片的大小时并非一定需要“宽x高”这样的形式，其实只需要指定宽或者高中的一项即可。如指定输出图片的宽度： $ convert image.png -resize 200 out.png 或者指定输出图片的高度： $ convert image.png -resize x100 out.png ","date":"2020-05-28","objectID":"/posts/ubuntu-12/:1:0","tags":["Linux-Ubuntu"],"title":"Ubuntu压缩图片","uri":"/posts/ubuntu-12/"},{"categories":["Ubuntu"],"content":"旋转与翻转 将原图片旋转 90° 后输出： $ convert image.jpg -rotate 90 image-rotated.jpg 指定的角度为正时即顺时针旋转图片，为负时逆时针旋转。 左右翻转： $ convert image.png -flop out.png 上下翻转： $ convert image.png -flip out.png PS：包括前面的几种情况在内，如果输出图片的文件名和原图片相同，则改变后的图片会直接覆盖掉原图片。 ","date":"2020-05-28","objectID":"/posts/ubuntu-12/:2:0","tags":["Linux-Ubuntu"],"title":"Ubuntu压缩图片","uri":"/posts/ubuntu-12/"},{"categories":["Ubuntu"],"content":"裁剪与缩放 convert 命令支持等比例缩放图片，如将图片缩小为原来的一半： $ convert image.png -scale 50% out.png 同时 convert 也可以对图片进行裁剪，包括自动裁剪（剔除图片周围空白的部分或边框等）和自定义范围的裁剪。 自动裁剪： $ convert image.png -trim out.png OptiPNG ","date":"2020-05-28","objectID":"/posts/ubuntu-12/:3:0","tags":["Linux-Ubuntu"],"title":"Ubuntu压缩图片","uri":"/posts/ubuntu-12/"},{"categories":["Ubuntu"],"content":"简介 OptiPNG 是一个PNG优化器，可将图像文件重新压缩为更小的尺寸，而不会丢失任何信息。该程序还将外部格式（BMP，GIF，PNM和TIFF）转换为优化后的PNG，并执行PNG完整性检查和更正。 ","date":"2020-05-28","objectID":"/posts/ubuntu-12/:4:0","tags":["Linux-Ubuntu"],"title":"Ubuntu压缩图片","uri":"/posts/ubuntu-12/"},{"categories":["Ubuntu"],"content":"安装 $ sudo apt install optipng ","date":"2020-05-28","objectID":"/posts/ubuntu-12/:5:0","tags":["Linux-Ubuntu"],"title":"Ubuntu压缩图片","uri":"/posts/ubuntu-12/"},{"categories":["Ubuntu"],"content":"OptiPNG 的基本用法为 $ optipng filename.png $ optipng [options] filename.png 简单易用,快乐无损压缩 ","date":"2020-05-28","objectID":"/posts/ubuntu-12/:6:0","tags":["Linux-Ubuntu"],"title":"Ubuntu压缩图片","uri":"/posts/ubuntu-12/"},{"categories":["Git"],"content":"好奇心的收获! 好巧啊!上次写关于github的blog正好是两个月前 那么今天带来的是什么呢 是好奇心的收获! 经常看到我的blog地址前面有一个红色的划线(因为没有https)被浏览器判定为不安全网址 但我写的东西都这么正能量,哪里不安全了! 所以多次想整上https,但是鉴于之前倒腾微信小程序的经历,我内心深知这是一项无法完成的任务 因为据我(特指今晚之前的那个我)所知,申请证书的话,必须需要服务器对确认文件证书下发文件进行确认,机构才会下发证书 今天又是内心十分煎熬,想看看广大网友(大佬)是怎么解决的,首先看到国外公司的DNS反向代理,虽然免费…但是国内的情况大家也是知道(我爱大中华的防火长城) 但是我发现了一个…神奇的东西 啥时候github官方开这个功能了??? 进到仓库里一看,果然嗷! 一键开启,本以为会像网友所说,延迟很大,要等好几个小时,但是一分钟之后,点开我的blog 可爱的小锁头就出现在了我的域名前面,嗷~ 最后放上域名解析配置和github-page中的配置 ","date":"2020-05-28","objectID":"/posts/github-2/:0:0","tags":["Github"],"title":"GH-Blog开启Https","uri":"/posts/github-2/"},{"categories":["Leetcode"],"content":"394-字符串解码 1021-删除最外层的括号 面试题17.12-BiNode 700-二叉搜索树中的搜索 ","date":"2020-05-28","objectID":"/posts/leetcode-20/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"394-字符串解码 题目: 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 s = \"3[a]2[bc]\", 返回 \"aaabcbc\". s = \"3[a2[c]]\", 返回 \"accaccacc\". s = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\". 解题思路:这道题我想到了栈和递归,但是就是没法解决内存空间扩充的问题,看了题解学到了几个很好的小知识点 这是一道medium level的题,所以逻辑稍微稍微有点复杂 一开始我还想用hash来解,但是对于平行级别的字符无法解决… ","date":"2020-05-28","objectID":"/posts/leetcode-20/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"递归解法 #define STR_LEN 5000 char * decodeStringCore(char *s, char **e) { char *ret = (char*)malloc(sizeof(char) * STR_LEN); char *buf, *end = NULL; int count = 0, idx = 0; while(*s != '\\0') { if (isalpha(*s)) { ret[idx++] = *s; } else if (isdigit(*s)) { count = 10 * count + *s - '0'; } else if (*s == '[') { buf = decodeStringCore(s + 1, \u0026end); while (count) { strcpy(ret + idx, buf); idx += strlen(buf); count--; } s = end; } else if (*s == ']') { *e = s; ret[idx] = '\\0'; return ret; } s++; } ret[idx] = '\\0'; return ret; } char * decodeString(char * s){ char *end = NULL; return decodeStringCore(s, \u0026end); } ","date":"2020-05-28","objectID":"/posts/leetcode-20/:1:1","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"常规栈 char *decodeString(char *s) { if (s == NULL) { return NULL; } char *a = strdup(s); while (true) { int len = strlen(a); int left = 0, right = len; int i = len - 1, num = 0, w = 1; for (; i \u003e= 0; i--) { if (a[i] == ']') { right = i; } else if(a[i] == '[') { left = i; } else if (a[i] \u003e= '0' \u0026\u0026 a[i] \u003c= '9') { do { // 组合数字 num += w * (a[i] - '0'); w *= 10; i--; } while (i \u003e= 0 \u0026\u0026 (a[i] \u003e= '0' \u0026\u0026 a[i] \u003c= '9')); break; } } if (num == 0) { //没有[]了 return a; } else { int slen = (right - left - 1); int count = (i + 1) + (len - right - 1) + num * slen + 1; char *t = (char*)calloc(count, sizeof(char)); if (i + 1 \u003e 0) { // 左 memcpy(t, a, i + 1); } for (int k = 0; k \u003c num; k++) { // 中 memcpy(t + (i + 1) + k * slen, a + left + 1, slen); } if (len - right - 1 \u003e 0) { memcpy(t + (i + 1) + num * slen, a + right + 1, len - right - 1); } free(a); a = t; } } } ","date":"2020-05-28","objectID":"/posts/leetcode-20/:1:2","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"知识点总结 ","date":"2020-05-28","objectID":"/posts/leetcode-20/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"char转int 一个老生常谈的问题(但我忘记了…) char* s = \"12345\" int count = *s - '0'; ‘0’在ASCII表中是第48个，‘1’是第49个……以此类推. int i=‘0’ 所以int a = ch-‘0’; 也就是 int a = ch-48; 也就是把权 char 转成了 int。 ","date":"2020-05-28","objectID":"/posts/leetcode-20/:2:1","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"char指针的移动 在大佬的题解中,我发现对于对于char值的访问,有两种途径(例如 char* s) 第一种: 访问*s,访问下一个字符时 s++; 第二种: 访问s[i],访问下一个字符时 i++; 一个是地址相加访问,一个是地址下标访问 ","date":"2020-05-28","objectID":"/posts/leetcode-20/:2:2","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"strup函数 char *a = strdup(s); 将字符串s复制到一个新的地址空间,并且指针返回到a 说明：strdup不是标准的c函数。strdup()在内部调用了malloc()为变量分配内存，不需要使用返回的字符串时，需要用free()释放相应的内存空间，否则会造成内存泄漏。 ","date":"2020-05-28","objectID":"/posts/leetcode-20/:2:3","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"strdup和strcpy的对比 strdup不是标准的c函数，strcpy是标准的c函数，使用时注意场合。 strdup可以直接把要复制的内容复制给没有初始化的指针，因为它会自动分配空间给目的指针，strcpy的目的指针一定是已经分配内存的指针。 strdup用完要free()函数释放内存，否则内存泄露 。 使用strcpy必须事先确定src大小，可以先strlen判断src的大小，之后为dest申请空间，之后再strcpy就不会有问题了。 ","date":"2020-05-28","objectID":"/posts/leetcode-20/:2:4","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"1021-删除最外层的括号 题目: 输入：\"(()())(())\" 输出：\"()()()\" 解释： 输入字符串为 \"(()())(())\"，原语化分解得到 \"(()())\" + \"(())\"， 删除每个部分中的最外层括号后得到 \"()()\" + \"()\" = \"()()()\"。 解题思路: 不想一次一次移动,但最后也没想出来时间复杂度O(n)的方法 看了一眼题解…这记数法,大佬真强啊,我咋就没想到呢 char * removeOuterParentheses(char * S){ int cnt = 0,k = 0; for(int i = 0;i \u003c strlen(S);i++){ if(S[i] == '('){ if(cnt != 0) S[k++] = S[i]; cnt ++; } if(S[i] == ')'){ cnt--; if(cnt != 0) S[k++] = S[i]; } } S[k] = '\\0'; return S; } ","date":"2020-05-28","objectID":"/posts/leetcode-20/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"register int 还有一种方法,新建一个空间,但是用到了register int性能提升了很多 register int中的register 表示使用cpu内部寄存器（寄存器是中央处理器内的组成部分。寄存器是有限存贮容量的高速存贮部件）的变量 而平时的int是把变量放在内存中，存到寄存器中可以加快变量的读写速度 char * removeOuterParentheses(char * S){ int count = 0; char *out = (char*)malloc(strlen(S) + 1); register int j = 0, len = strlen(S); for (int i = 0; i \u003c len; i++){ if (S[i] == '('){ if(count++ != 0){ out[j++] = S[i]; } } else { if (--count != 0){ out[j++] = S[i]; } } } out[j] = 0; return out; } ","date":"2020-05-28","objectID":"/posts/leetcode-20/:3:1","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"面试题17.12-BiNode 题目: 二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求值的顺序保持不变，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。 返回转换后的单向链表的头节点。 输入： [4,2,5,1,3,null,6,0] 输出： [0,null,1,null,2,null,3,null,4,null,5,null,6] 解题思路: 快乐递归,但是一开始我没有把函数分开,但是一提交就报错,但是报错数据测试却能通过 所以以后涉及全局变量的函数,应该分开写 ","date":"2020-05-28","objectID":"/posts/leetcode-20/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"中序遍历-由左向右 struct TreeNode* pre = NULL; int flag = 0; struct TreeNode* res = NULL; void dfs(struct TreeNode* root) { if(root == NULL) { return; } dfs(root-\u003eleft); root-\u003eleft = NULL; if(flag == 0) { pre = root; flag = 1; res = pre; } else { pre-\u003eright = root; pre = pre-\u003eright; } dfs(root-\u003eright); return; } struct TreeNode* convertBiNode(struct TreeNode* root){ pre = NULL; res = NULL; flag = 0; if(root == NULL) { return NULL; } dfs(root); return res; } ","date":"2020-05-28","objectID":"/posts/leetcode-20/:4:1","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"中序遍历-由右向左 这个又右向左是我没想到的!感觉很棒,不用判断头节点了! struct TreeNode *pre; void inorder(struct TreeNode *root,struct TreeNode **r){ if(!root) return ; inorder(root-\u003eright,r); root-\u003eright=pre; if(pre) pre-\u003eleft=0; pre=root; *r=root; inorder(root-\u003eleft,r); } struct TreeNode* convertBiNode(struct TreeNode* root){ pre=0; inorder(root,\u0026root); return root; ","date":"2020-05-28","objectID":"/posts/leetcode-20/:4:2","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"700-二叉搜索树中的搜索 题目: 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 给定二叉搜索树: 4 / \\ 2 2 7 和值:2 -\u003e返回 / \\ / \\ 1 3 1 3 解题思路: 我就想到了一个递归 ","date":"2020-05-28","objectID":"/posts/leetcode-20/:5:0","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"传统递归 struct TreeNode* searchBST(struct TreeNode* root, int val) { if (root == NULL || val == root-\u003eval) return root; return val \u003c root-\u003eval ? searchBST(root-\u003eleft, val) : searchBST(root-\u003eright, val); } ","date":"2020-05-28","objectID":"/posts/leetcode-20/:5:1","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"非递归 struct TreeNode* searchBST(struct TreeNode* root, int val) { if (root == NULL || val == root-\u003eval) return root; while(root != NULL \u0026\u0026 root-\u003eval != val){ root = root-\u003eval \u003e val ? root-\u003eleft:root-\u003eright; } return root; } ","date":"2020-05-28","objectID":"/posts/leetcode-20/:5:2","tags":["Leetcode-C++"],"title":"Leetcode Part-20","uri":"/posts/leetcode-20/"},{"categories":["Leetcode"],"content":"今天降了一天的论文重复率,才降了10%多…枯了,感觉语文水平有了很大的提高,明天继续改 晚上来刷会快乐leetcode吧 974-和可被 K 整除的子数组 ","date":"2020-05-27","objectID":"/posts/leetcode-19/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-19","uri":"/posts/leetcode-19/"},{"categories":["Leetcode"],"content":"974-和可被 K 整除的子数组 题目: 给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 输入：A = [4,5,0,-2,-3,1], K = 5 输出：7 解释： 有 7 个子数组满足其元素之和可被 K = 5 整除： [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 解题思路: 连续子数组和，要用前缀和 前缀和：前n项和 sum[i] % K == sum[j] % K，说明 i 和 j 之间的子数组和是可以被K整除的 负数求余，是负数，要将其转化为正数，方法就是 (sum % K + K) % K map数组，下标为余数，即 (sum % K + K) % K，值为count，记录前缀和对K取余的个数 int subarraysDivByK(int* A, int ASize, int K){ int hash[K]; memset(hash,0,sizeof(hash)); for(int i=1;i\u003cASize;i++)//前缀和 { A[i]=A[i-1]+A[i]; } for(int i=0;i\u003cASize;i++)//余数为键的哈希表 { hash[(A[i]%K+K)%K]++;//消除负数 } int sum=0; for(int i=0;i\u003cK;i++)//统计相同余数满足要求的数目 { sum+=hash[i]*(hash[i]-1)/2; } return sum+hash[0];//加上单个满足余数为零的数目 } 因为昨天是睡觉前做的题,所以有点囫囵吞枣,今天又细品了品这道题,感觉还挺有东西的,首先需要明白的是,若两个前缀和的余数相同,那么这两个前缀之间的元素的余数就=0了,所以构建一个hash保存前缀和的余数,然后n = x*(x-1)/2 计算相同前缀和的组合次数,最后再加上单个余数为0的情况 ","date":"2020-05-27","objectID":"/posts/leetcode-19/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-19","uri":"/posts/leetcode-19/"},{"categories":["Leetcode"],"content":"这两天整论文,写读书笔记,刷题有点慢,刷到100题去看\"算法笔记\" 287-寻找重复数 27-二叉树的镜像 897-递增顺序查找树 ","date":"2020-05-26","objectID":"/posts/leetcode-18/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-18","uri":"/posts/leetcode-18/"},{"categories":["Leetcode"],"content":"287-寻找重复数 题目: 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 输入: [1,3,4,2,2] 输出: 2 解题思路: 用c自带的快排排序,再查,暴力求解 ","date":"2020-05-26","objectID":"/posts/leetcode-18/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-18","uri":"/posts/leetcode-18/"},{"categories":["Leetcode"],"content":"暴力求解 int comp(const void *a, const void *b) { return *(int*)a-*(int*)b; } int findDuplicate(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), comp); int pre = nums[0]; for(int i=1; i\u003cnumsSize; i++){ if(pre != nums[i]){ pre = nums[i]; } else{ break; } } return pre; } ","date":"2020-05-26","objectID":"/posts/leetcode-18/:1:1","tags":["Leetcode-C++"],"title":"Leetcode Part-18","uri":"/posts/leetcode-18/"},{"categories":["Leetcode"],"content":"快慢指针 这道题用双指针寻找环我是没想到的…算是一种思路的开拓吧(虽然下次也不知道怎么用) int findDuplicate(int* nums, int numsSize){ int fast, slow; slow = 0; fast = 0; do { slow = nums[slow]; fast = nums[nums[fast]]; }while(slow != fast); fast = 0; do { slow = nums[slow]; fast = nums[fast]; }while(slow != fast); return slow; } ","date":"2020-05-26","objectID":"/posts/leetcode-18/:1:2","tags":["Leetcode-C++"],"title":"Leetcode Part-18","uri":"/posts/leetcode-18/"},{"categories":["Leetcode"],"content":"27-二叉树的镜像 题目: 请完成一个函数，输入一个二叉树，该函数输出它的镜像。 4 4 / \\ / \\ 2 7 7 2 / \\ / \\ / \\ / \\ 1 3 6 9 9 6 3 1 解题思路: 快乐递归,简简单单 struct TreeNode* mirrorTree(struct TreeNode* root){ if(root != NULL){ struct TreeNode* temp = NULL; temp = root-\u003eleft; root-\u003eleft = root-\u003eright; root-\u003eright = temp; } else{ return; } mirrorTree(root-\u003eleft); mirrorTree(root-\u003eright); return root; } ","date":"2020-05-26","objectID":"/posts/leetcode-18/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-18","uri":"/posts/leetcode-18/"},{"categories":["Leetcode"],"content":"897-递增顺序查找树 题目: 给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。 5 1 / \\ \\ 3 6 2 / \\ \\ =\u003e \\ 2 4 8 3 / / \\ \\ 1 7 9 4 解题思路: 本题考察中序遍历的实现,是一道好题!核心思路是:保存上级节点pre,进行连接 收获: 递归很占用时间,非递归性能是很好的,以后多写非递归 ","date":"2020-05-26","objectID":"/posts/leetcode-18/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-18","uri":"/posts/leetcode-18/"},{"categories":["Leetcode"],"content":"递归构造新树 void iBST(struct TreeNode* root, struct TreeNode** newRoot, struct TreeNode** head) { struct TreeNode *leaf = NULL; if (root == NULL) { return; } iBST(root-\u003eleft, newRoot, head); leaf = (struct TreeNode*)calloc(sizeof(struct TreeNode), 1); if (leaf == NULL) { return; } leaf-\u003eval = root-\u003eval; if (*newRoot == NULL) { *head = leaf; } else { (*newRoot)-\u003eright = leaf; } *newRoot = leaf; iBST(root-\u003eright, newRoot, head); return; } struct TreeNode* increasingBST(struct TreeNode* root){ struct TreeNode* head = NULL; struct TreeNode* newRoot = NULL; iBST(root, \u0026newRoot, \u0026head); return head; } ","date":"2020-05-26","objectID":"/posts/leetcode-18/:3:1","tags":["Leetcode-C++"],"title":"Leetcode Part-18","uri":"/posts/leetcode-18/"},{"categories":["Leetcode"],"content":"递归修改原树 struct TreeNode* newRoot; void Find(struct TreeNode* root) { if (root == NULL) { return; } Find(root-\u003eleft); newRoot-\u003eright = root; newRoot-\u003eleft = NULL; newRoot = newRoot-\u003eright; Find(root-\u003eright); return; } struct TreeNode* increasingBST(struct TreeNode* root){ struct TreeNode* ans = (struct TreeNode*)malloc(sizeof(struct TreeNode)); ans-\u003eval = 0; ans-\u003eleft = NULL; ans-\u003eright = NULL; //newroot 保存上级结点 newRoot = ans; Find(root); return ans-\u003eright; } ","date":"2020-05-26","objectID":"/posts/leetcode-18/:3:2","tags":["Leetcode-C++"],"title":"Leetcode Part-18","uri":"/posts/leetcode-18/"},{"categories":["Leetcode"],"content":"非递归修改原树 #define max 1000 struct TreeNode* increasingBST(struct TreeNode* root){ struct TreeNode *stack[max],*t,*pre=NULL,*new_root=NULL; int top=-1; t=root; while(t||top\u003e=0){ while(t) { stack[++top]=t; t=t-\u003eleft; } if(top\u003e=0){ t=stack[top--]; //确定新的根结点 if(!new_root) new_root=t; else{ //前一点在序列中的位置已经确定 并且已经出栈了 所以可以修改left 和right 指针 而不会影响后续遍历 pre-\u003eright=t; pre-\u003eleft=NULL; } pre=t; //保存上级结点 t=t-\u003eright; } } //修改最后一个节点的left指针 pre-\u003eleft=NULL; return new_root; } ","date":"2020-05-26","objectID":"/posts/leetcode-18/:3:3","tags":["Leetcode-C++"],"title":"Leetcode Part-18","uri":"/posts/leetcode-18/"},{"categories":["Ubuntu"],"content":"软件管理命令汇总 软件更新 升级安装包相关的命令,刷新可安装的软件列表(但是不做任何实际的安装动作) sudo apt-get update 进行安装包的更新(软件版本的升级) sudo apt-get upgrade dist-upgrade会比upgrade更智能地处理需要更新的软件包的依赖关系(推荐) sudo apt-get dist-upgrade 进行系统版本的升级(Ubuntu版本的升级)，Ubuntu官方推荐的系统升级方式,若加参数-d还可以升级到开发版本,但会不稳定 sudo do-release-upgrade 清理旧版本的软件缓存 sudo apt-get autoclean 清理所有软件缓存 sudo apt-get clean 删除系统不再使用的孤立软件 sudo apt-get autoremove 删除软件 如果知道要删除软件的具体名称可以使用 sudo apt-get remove --purge 软件名称 sudo apt-get autoremove --purge 软件名称 如果不知道要删除软件的具体名称可以使用 dpkg --get-selections | grep ‘软件相关名称’ sudo apt-get purge 一个带core的package，如果没有带core的package，则是情况而定。 ","date":"2020-05-26","objectID":"/posts/ubuntu-23/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu20.04软件管理命令","uri":"/posts/ubuntu-23/"},{"categories":["Ubuntu"],"content":"今天想在ubuntu上装一个cajviewer,去下了一个deepin-wine版本的,但是缺少字体库装不上 去晚上找了很多帖子,都推荐去装wine,一开始疑惑wine和deepin-wine会不会发生依赖库冲突 后来去deepin的官方帖子看到管理员说不冲突,我才放心去折腾,嘿嘿 这里以ubuntu20.04版本作为基准,以下版本不适用 使用后发现,对于win的程序,deepin-wine体验会更好,wine可作为补充使用 安装wine 如果系统是64位，请启用32位体系结构（如果尚未安装）： sudo dpkg --add-architecture i386 下载并添加存储库密钥： wget -O - https://dl.winehq.org/wine-builds/winehq.key | sudo apt-key add - 添加存储库（按照ubuntu的版本执行相应的命令）： Ubuntu 20.04 sudo add-apt-repository 'deb https://dl.winehq.org/wine-builds/ubuntu/ focus main' 更新软件源 sudo apt update 安装wine5.0稳定版（winehq-stable稳定版，wine–devel开发版）： sudo apt install --install-recommends winehq-stable 打开终端，输入wine –version，如果出现“wine-5.0”，说明安装成功了！！ 安装winetricks 打开终端，先更新apt源 sudo apt update 然后安装winetricks： sudo apt winetricks wine的使用 wine运行exe软件，实际上有两种方法 一种是在终端上打开软件(不推荐) wine name.exe 第二种方法是直接用归档管理器或文件系统直接打开exe文件。如打开软件根目录，找到主执行程序文件，右键选择以\"Wine Windows Program Loader\"方式打开软件 解决软件乱码 下载以下链接文件，压缩包Fonts.zip里包含了所有Windows的字体。 链接: https://pan.baidu.com/s/1SWTe1Dj485FTJSdKqI6QCA 密码: 4abj 解压该压缩包 unzip Fonts.zip 把Fonts文件夹内所有字体复制到wine的映射目录内 cp Fonts/* ~/.wine/drive_c/windows/Fonts/ 解决软件输入框不显示字体的问题 winetricks riched20 最后感谢一个大佬的帖子 ","date":"2020-05-26","objectID":"/posts/ubuntu-22/:0:0","tags":["wine"],"title":"Ubuntu20.04安装wine","uri":"/posts/ubuntu-22/"},{"categories":["Leetcode"],"content":"20-有效的括号 70-爬楼梯 141-环形链表 14-最长公共前缀 ","date":"2020-05-25","objectID":"/posts/leetcode-17/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-17","uri":"/posts/leetcode-17/"},{"categories":["Leetcode"],"content":"20-有效的括号 题目: 给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串，判断字符串是否有效。 输入: \"([)]\" 输出: false 解题思路: 暴力栈 + switch ","date":"2020-05-25","objectID":"/posts/leetcode-17/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-17","uri":"/posts/leetcode-17/"},{"categories":["Leetcode"],"content":"暴力求解 没啥技术含量… 执行用时 :0 ms, 在所有 C 提交中击败了100.00% 的用户 内存消耗 :5.4 MB, 在所有 C 提交中击败了100.00%的用户 bool isValid(char * s){ int len = strlen(s); char* stack_list = (char*)malloc(sizeof(char)*len); int top = -1; int count = 0; for(int i=0; i\u003clen; i++){ switch(s[i]){ case '(': count++; stack_list[++top] = '('; break; case '[': count++; stack_list[++top] = '['; break; case '{': count++; stack_list[++top] = '{'; break; case ')': if(top != -1 \u0026\u0026 stack_list[top] == '('){ count--; top--; break; } else{ return false; } case ']': if(top != -1 \u0026\u0026 stack_list[top] == '['){ count--; top--; break; } else{ return false; } case '}': if(top != -1 \u0026\u0026 stack_list[top] == '{'){ count--; top--; break; } else{ return false; } } } if(count!= 0){ return false; } return true; } ","date":"2020-05-25","objectID":"/posts/leetcode-17/:1:1","tags":["Leetcode-C++"],"title":"Leetcode Part-17","uri":"/posts/leetcode-17/"},{"categories":["Leetcode"],"content":"简洁版 大佬的题解,简单优雅,让人羡慕 bool isValid(char * s){ if (s == NULL || s[0] == '\\0') return true; char *stack = (char*)malloc(strlen(s)+1); int top =0; for (int i = 0; s[i]; ++i) { if (s[i] == '(' || s[i] == '[' || s[i] == '{') stack[top++] = s[i]; else { if ((--top) \u003c 0) return false;//先减减，让top指向栈顶元素 if (s[i] == ')' \u0026\u0026 stack[top] != '(') return false; if (s[i] == ']' \u0026\u0026 stack[top] != '[') return false; if (s[i] == '}' \u0026\u0026 stack[top] != '{') return false; } } return (!top); //防止'('这种类似情况 } ","date":"2020-05-25","objectID":"/posts/leetcode-17/:1:2","tags":["Leetcode-C++"],"title":"Leetcode Part-17","uri":"/posts/leetcode-17/"},{"categories":["Leetcode"],"content":"70-爬楼梯 题目: 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 解题思路: 这道题我没想出来…看了题解才知道是动态规划 本问题其实常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和 爬上 n−1n-1n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶 爬上 n−2n-2n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶 所以我们得到公式 dp[n]=dp[n−1]+dp[n−2] 同时需要初始化 dp[0]=1 和 dp[1]=1 时间复杂度：O(n) 一道神奇的题,长见识了! ","date":"2020-05-25","objectID":"/posts/leetcode-17/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-17","uri":"/posts/leetcode-17/"},{"categories":["Leetcode"],"content":"递推 从下到上进行递推 int climbStairs(int n){ // f(n) = f(n-1) + f(n-2) if ( n \u003c 0 ) return 0; if (n \u003c=2) return n; int fn1 = 1, fn2 = 2; int fn3; for (int i = 2 ;i \u003c n; i++){ fn3 = fn2 + fn1; fn1 = fn2; fn2 = fn3; } return fn3; } ","date":"2020-05-25","objectID":"/posts/leetcode-17/:2:1","tags":["Leetcode-C++"],"title":"Leetcode Part-17","uri":"/posts/leetcode-17/"},{"categories":["Leetcode"],"content":"递归 从上到下进行递归 int _climb(int n, int *arr) { if (arr[n] != 0 ) return arr[n]; arr[n] = _climb(n-1, arr) + _climb(n-2, arr); return arr[n]; } int climbStairs(int n){ //终止情况 if ( n \u003c 0 ) return 0; if ( n \u003c= 2) return n; int *arr = (int*)calloc(n+1, sizeof(int)); arr[1] = 1; arr[2] = 2; return _climb(n , arr); } ","date":"2020-05-25","objectID":"/posts/leetcode-17/:2:2","tags":["Leetcode-C++"],"title":"Leetcode Part-17","uri":"/posts/leetcode-17/"},{"categories":["Leetcode"],"content":"141-环形链表 题目: 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 解题思路: 这道题跟之前撒狗粮的那道题都差不多,那道题是两个链表的相交点,这道题是判断环 快乐双指针就完事了 bool hasCycle(struct ListNode *head) { struct ListNode *fast_p=head,*slow_p=head; while(fast_p!=0 \u0026\u0026 fast_p-\u003enext!=0){ slow_p=slow_p-\u003enext; fast_p=fast_p-\u003enext-\u003enext; //注意这里的越界,需要在while中加上 p-\u003enext!=0 的额外判断 if(slow_p==fast_p) return 1; } return 0; } ","date":"2020-05-25","objectID":"/posts/leetcode-17/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-17","uri":"/posts/leetcode-17/"},{"categories":["Leetcode"],"content":"14-最长公共前缀 题目: 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “\"。 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 解题思路: 暴力法求解,取第一个字符串为初始结果,然后与第二个进行比较,确定结尾,之后依次遍历确定结尾 执行用时 :4 ms, 在所有 C 提交中击败了61.58% 的用户 内存消耗 :5.6 MB, 在所有 C 提交中击败了100.00%的用户 char * longestCommonPrefix(char ** strs, int strsSize){ if(strsSize == 0){ return \"\"; } int j; char* temp; char* res = strs[0]; for(int i=1; i\u003cstrsSize; i++){ j=0; temp = strs[i]; while(res[j] != '\\0' \u0026\u0026 temp[j] != '\\0'){ if(res[j] == temp[j]){ j++; } else{ break; } } res[j] = '\\0'; } return res; } ","date":"2020-05-25","objectID":"/posts/leetcode-17/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-17","uri":"/posts/leetcode-17/"},{"categories":["Leetcode"],"content":"114-二叉树展开为链表 856-括号的分数 ","date":"2020-05-24","objectID":"/posts/leetcode-16/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-16","uri":"/posts/leetcode-16/"},{"categories":["Leetcode"],"content":"114-二叉树展开为链表 题目: 给定一个二叉树，原地将它展开为一个单链表。 1 / \\ 2 5 / \\ \\ 3 4 6 将其展开为： 1 \\ 2 \\ 3 \\.... 解题思路:这道题的题解让我耳目一新,感觉二叉树操作也没那么难啊…(但是就是想不到) 所以不管怎么动,核心思想还是树的遍历 ","date":"2020-05-24","objectID":"/posts/leetcode-16/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-16","uri":"/posts/leetcode-16/"},{"categories":["Leetcode"],"content":"递归 void flatten(struct TreeNode* root) { if (root == NULL) { return; } flatten(root-\u003eleft); flatten(root-\u003eright); if (root-\u003eleft != NULL) { struct TreeNode* lr = root-\u003eleft; while (lr-\u003eright != NULL) { lr = lr-\u003eright; } lr-\u003eright = root-\u003eright; root-\u003eright = root-\u003eleft; root-\u003eleft = NULL; } } ","date":"2020-05-24","objectID":"/posts/leetcode-16/:1:1","tags":["Leetcode-C++"],"title":"Leetcode Part-16","uri":"/posts/leetcode-16/"},{"categories":["Leetcode"],"content":"迭代 void flatten(struct TreeNode* root){ while (root) { if (root-\u003eleft) { struct TreeNode* lr = root-\u003eleft; while (lr-\u003eright) { // 找左子树的最右节点 lr = lr-\u003eright; } lr-\u003eright = root-\u003eright; root-\u003eright = root-\u003eleft; root-\u003eleft = NULL; } root = root-\u003eright; } } ","date":"2020-05-24","objectID":"/posts/leetcode-16/:1:2","tags":["Leetcode-C++"],"title":"Leetcode Part-16","uri":"/posts/leetcode-16/"},{"categories":["Leetcode"],"content":"856-括号的分数 题目: 给定一个平衡括号字符串 S，按下述规则计算该字符串的分数： () 得 1 分。 AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。 (A) 得 2 * A 分，其中 A 是平衡括号字符串。 示例 输入： \"(()(()))\" 输出： 6 解题思路:分治递归是个神奇的东西…return就很巧妙 ","date":"2020-05-24","objectID":"/posts/leetcode-16/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-16","uri":"/posts/leetcode-16/"},{"categories":["Leetcode"],"content":"分治递归 int CalScore(char *S, int len) { int i; int j = 1; if (len == 2) { return 1; } for (i = 1; i \u003c len; i++) { if (S[i] == '(') { j++; } else { j--; } if (j == 0) { break; } } if (i == len - 1) { return CalScore(S + 1, len - 2) * 2; } else { return CalScore(S, i + 1) + CalScore(S + i + 1, len - i - 1); } } ","date":"2020-05-24","objectID":"/posts/leetcode-16/:2:1","tags":["Leetcode-C++"],"title":"Leetcode Part-16","uri":"/posts/leetcode-16/"},{"categories":["Leetcode"],"content":"从内到外递归 int GetScore(char **S) { int score = 0; while (**S != '\\0') { if (**S == '(') { *S += 1; score += GetScore(S); } else { *S += 1; score *= 2; return (score == 0) ? 1 : score; } } return score; } int scoreOfParentheses(char *S) { return GetScore(\u0026S); } ","date":"2020-05-24","objectID":"/posts/leetcode-16/:2:2","tags":["Leetcode-C++"],"title":"Leetcode Part-16","uri":"/posts/leetcode-16/"},{"categories":["C语言"],"content":"今天刷leetcode遇到一个神奇的函数,但是没看懂大佬怎么用的这个函数,查了一下发现大有用处!在此记录 排序方法有很多种：选择排序，冒泡排序，归并排序，快速排序等。 因为快排速度很快，所以系统也在库里实现这个算法，便于我们的使用。这就是qsort函数(全称quicksort)。其声明在stdlib.h文件中，是根据二分法写的，其时间复杂度为n*log(n) qsort函数 包含头文件为 stdlib.h qsort 函数原型： void qsort(voidbase, size_t num, size_t width, int(compare)(const void,const void)) 各参数： *base 待排序数组首地址 size_t num 数组中待排序元素数量 size_t width 各元素的占用空间大小 compare 指向函数的指针，用于确定排序的顺序，传入的是地址 qsort要求提供一个自己定义的比较函数。比较函数使得qsort通用性更好，有了比较函数qsort可以实现对数组、字符串、结构体等结构进行升序或降序排序。下面以compare函数举例 compare 函数 compare( (void *) \u0026 elem1, (void *) \u0026 elem2) 1. value \u003c0 elem1将被排在elem2之前 2. value =0 位置不变 3. value \u003e0 elem1将被排在elem2之后 升序or降序 取决于返回值的正负 // 由小到大排序 int comp(const void *a, const void *b) { return *(int*)a-*(int*)b; } // 由大到小排序 int comp(const void *a, const void *b) { return *(int*)b-*(int*)a; } 实例 ","date":"2020-05-23","objectID":"/posts/C-13/:0:0","tags":["Leetcode-C"],"title":"C语言-qsort函数","uri":"/posts/C-13/"},{"categories":["C语言"],"content":"对int型数组排序 int num[100]; int cmp_int(const void* _a , const void* _b)　//参数格式固定 { /* int* a = (int*)_a; //强制类型转换 int* b = (int*)_b; return *a - *b; */ return *(int*)a-*(int*)b; } qsort(num,100,sizeof(num[0]),cmp_int); ","date":"2020-05-23","objectID":"/posts/C-13/:1:0","tags":["Leetcode-C"],"title":"C语言-qsort函数","uri":"/posts/C-13/"},{"categories":["C语言"],"content":"对字符串进行排序 char word[100][10]; int cmp_string(const void* _a , const void* _b)　//参数格式固定 { char* a = (char*)_a;　//强制类型转换 char* b = (char*)_b; return strcmp(a,b); } qsort(word,100,sizeof(word[0]),cmp_string); ","date":"2020-05-23","objectID":"/posts/C-13/:2:0","tags":["Leetcode-C"],"title":"C语言-qsort函数","uri":"/posts/C-13/"},{"categories":["Leetcode"],"content":"783-二叉搜索树节点最小距离 169-多数元素 283-移动零 448-找到所有数组中消失的数字 ","date":"2020-05-23","objectID":"/posts/leetcode-15/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"783-二叉搜索树节点最小距离 题目: 给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。 解题思路: 二叉搜索树,中序遍历得到递增队列,最小值存在于相邻节点的差 跑的时候不知道为啥,本地测试跑示例没问题,提交测试用的同样的示例,但是结果不对,迷惑… #define MAX 20000 void inorderTrace(struct TreeNode* root, int* arr, int* count) { if (root == NULL) { return; } inorderTrace(root-\u003eleft, arr, count); arr[(*count)++] = root-\u003eval; inorderTrace(root-\u003eright, arr, count); return; } int minDiffInBST(struct TreeNode* root) { int arr[MAX] = {0}; int count = 0; int value; inorderTrace(root, arr, \u0026count); // 中序遍历后的结果，最小差值必定在相邻元素间 int min = arr[count - 1] - arr[0]; for (int i = 0; i \u003c count - 1; i++) { value = arr[i + 1] - arr[i]; min = min\u003cvalue? min:value; } return min; } ","date":"2020-05-23","objectID":"/posts/leetcode-15/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"169-多数元素 题目: 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 解题思路: 这道题我想用hash来解决,甚至感觉自己还挺机智的,没想到系统给我传这种东西… [-2147483648,0,0] 哇,我真的吐了…行吧 ","date":"2020-05-23","objectID":"/posts/leetcode-15/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"错误的hash int majorityElement(int* nums, int numsSize){ int* a = (int*)malloc(sizeof(int)*102400); memset(a, 0, 102400); if(numsSize == 1){ return nums[0]; } for(int i=0; i\u003cnumsSize; i++){ int loc = nums[i]; ++a[loc+1]; if(a[loc+1] \u003e numsSize/2){ return loc; } } return 0; } ","date":"2020-05-23","objectID":"/posts/leetcode-15/:2:1","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"摩尔投票法 摩尔投票法，通过一个计数变量s，来观察哪一个数最后不是0即为majority;相同加，不相同减，变为0后换下一个。 int majorityElement(int* nums, int numsSize){ int key = nums[0]; int count = 0; for (size_t i = 0; i \u003c numsSize; i++) { if(nums[i] == key) count++; else count--; if(count \u003c= 0) { key = nums[i+1]; } } return key; } ","date":"2020-05-23","objectID":"/posts/leetcode-15/:2:2","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"排序取中 如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为n/2的元素（下标从 0 开始）一定是众数。 int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int majorityElement(int *nums, int numsSize) { qsort(nums, numsSize, sizeof(nums[0]), cmpfunc); return nums[numsSize / 2]; } ","date":"2020-05-23","objectID":"/posts/leetcode-15/:2:3","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"283-移动零 题目: 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 解题思路: 暴力算法惨遭滑铁卢哈哈哈,空气中弥漫着尴尬的气息 执行用时 :32 ms, 在所有 C 提交中击败了15.59% 的用户 内存消耗 :7.2 MB, 在所有 C 提交中击败了100.00%的用户 ","date":"2020-05-23","objectID":"/posts/leetcode-15/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"暴力算法 void moveZeroes(int* nums, int numsSize){ for(int i=0; i\u003cnumsSize; i++){ if(nums[i] == 0){ for(int j=i; j\u003cnumsSize-1; j++){ nums[j] = nums[j+1]; } nums[numsSize-1] = 0; numsSize--; if(nums[i] == 0){ //判定下一个元素如果还是0,则从当前重新计算 --i; } } } } ","date":"2020-05-23","objectID":"/posts/leetcode-15/:3:1","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"一次for循环 一层for循环，直接进行非零数值移动，后尾补零 大佬大佬,学到了!是我把移动搞复杂了 //solution-1 void moveZeroes(int* nums, int numsSize){ int m = 0; for (int i = 0; i \u003c numsSize; i++) { if (nums[i] == 0) { m++; } else if (m \u003e 0) { nums[i - m] = nums[i]; nums[i] = 0; } } } //solution-2 void moveZeroes(int *nums, int numsSize) { int zeroCount = 0; for (int i = 0; i \u003c numsSize; i++){ if (nums[i] != 0){ nums[zeroCount++] = nums[i]; } } while (zeroCount \u003c numsSize){ nums[zeroCount++] = 0; } } ","date":"2020-05-23","objectID":"/posts/leetcode-15/:3:2","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"快慢指针 双指针i，j，i为快指针，j为慢指针。i遇到零继续移动，遇到非零元素时，则与j所指的零交换位置。 双指针创造奇迹…膜拜大佬 void swap(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } /* moveZeroes: 将非零元素移动到零的左边 */ void moveZeroes(int* nums, int numsSize) { int i, j; /* i为快指针，指向非零元素；j为慢指针，指向零 */ for (int i = 0, j = 0; i \u003c numsSize; ++i) if (nums[i] != 0) /* 遇到非零元素，与零交换。交换完毕，j后移一位 */ swap(\u0026nums[i], \u0026nums[j++]); } ","date":"2020-05-23","objectID":"/posts/leetcode-15/:3:3","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"448-找到所有数组中消失的数字 题目: 给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 输入: [4,3,2,7,8,2,3,1] 输出: [5,6] 解题思路: 暴力双指针,由于未知缺少元素的数量,所以只能先申请一个大的空间 执行用时 :148 ms, 在所有 C 提交中击败了40% 的用户 内存消耗 :18.9 MB, 在所有 C 提交中击败了100.00%的用户 ","date":"2020-05-23","objectID":"/posts/leetcode-15/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"暴力求解 int cmp_int(const void *a, const void *b) { return *(int*)a-*(int*)b; } int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){ qsort(nums,numsSize,sizeof(nums[0]),cmp_int); int* res = (int*)malloc(sizeof(int)*numsSize); memset(res, 0, sizeof(int) * (numsSize)); int j = 0,i = 0,k = 0; for(i=0; i\u003c numsSize; i++){ if(nums[i] == j+1){ j++; } else{ if(nums[i]\u003ej+1){ for(int h=j+1; h\u003cnums[i]; h++){ res[k++] = h; } j = nums[i]; } } } while(j\u003cnumsSize){ res[k++] = j+1; j++; } /*今天发现,并需要重建一个空间,之前memset初始化为0就可以了 int* res2 = (int*)malloc(sizeof(int)*(k)); for(int w=0; w\u003c k; w++){ res2[w] = res[w]; }*/ *returnSize = k; return res1; } ","date":"2020-05-23","objectID":"/posts/leetcode-15/:4:1","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"hash 快乐哈希,果然哈希还是神奇 int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){ int *hash = (int *)malloc(sizeof(int) * (numsSize + 1)); memset(hash, 0, sizeof(int) * (numsSize + 1)); for (int i = 0; i \u003c numsSize; i ++) { hash[nums[i]]++; } int cnt = 0; for (int i = 1; i \u003c numsSize + 1; i++) { if (hash[i] == 0) { hash[cnt++] = i; } } *returnSize = cnt; return hash; } ","date":"2020-05-23","objectID":"/posts/leetcode-15/:4:2","tags":["Leetcode-C++"],"title":"Leetcode Part-15","uri":"/posts/leetcode-15/"},{"categories":["Leetcode"],"content":"19-删除链表的倒数第N个节点 3-无重复字符的最长子串 19-删除链表的倒数第N个节点 ","date":"2020-05-22","objectID":"/posts/leetcode-14/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-14","uri":"/posts/leetcode-14/"},{"categories":["Leetcode"],"content":"105-从前序与中序遍历序列构造二叉树 题目: 根据一棵树的前序遍历与中序遍历构造二叉树。 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 解题思路: 在中序序列里寻找中间节点(先序遍历第一个节点),然后快乐递归 struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){ if (preorderSize \u003c= 0 || inorderSize \u003c= 0) { return NULL; } struct TreeNode* p = (struct TreeNode *)malloc(sizeof(struct TreeNode)); p-\u003eval = *preorder; p-\u003eleft = NULL; p-\u003eright = NULL; int pos = 0; for (pos = 0; pos \u003c inorderSize; pos++) { if (inorder[pos] == *preorder){ //*preorder = preorder[0] break; } } // left p-\u003eleft = buildTree(preorder + 1, pos, inorder, pos); //左子树递归 // right p-\u003eright = buildTree(preorder + pos + 1, inorderSize - pos - 1, inorder + pos + 1, inorderSize - pos - 1); //右子树递归 return p; } ","date":"2020-05-22","objectID":"/posts/leetcode-14/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-14","uri":"/posts/leetcode-14/"},{"categories":["Leetcode"],"content":"3-无重复字符的最长子串 题目:给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 解题思路:暴力求解,每次重构字符串…为什么我只会暴力求解 ","date":"2020-05-22","objectID":"/posts/leetcode-14/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-14","uri":"/posts/leetcode-14/"},{"categories":["Leetcode"],"content":"暴力求解 int lengthOfLongestSubstring(char * s){ int max = 1,count = 0; char* temp = (char*)malloc(sizeof(char)* 1024); int i = 0,j = 0; if(*s!= '\\0'){ count++; i = 1; temp[0] = s[0]; } else{ return 0; } while(s[i] != '\\0'){ for(j=0; j\u003c count; j++){ if(temp[j] == s[i]){ count = count-j-1; //剩余的数量 for(int k=0; k\u003ccount; k++){ temp[k] = temp[j+1+k]; //重建字符串 } break; } } ++count; temp[count-1] = s[i]; max = max \u003e count? max:count; i++; } return max; } ","date":"2020-05-22","objectID":"/posts/leetcode-14/:2:1","tags":["Leetcode-C++"],"title":"Leetcode Part-14","uri":"/posts/leetcode-14/"},{"categories":["Leetcode"],"content":"滑动窗口 i:窗口的第一个字符位置 j:窗口之外的第一个字符 k:用于遍历窗口 思路：当遇到窗口中的字符s[k]与窗口外的字符s[j]相等时，计算此时的长度并将窗口的首位置移到k处 如果s[j]字符与窗口内的字符都不相等，再次计算长度即可 class Solution { public: int lengthOfLongestSubstring(string s) { int max = 0; int i = 0; int size = s.size(); for(int j = 0; j \u003c size; j++) { for(int k = i; k \u003c j; k++) { if(s[k] == s[j]) { max = max \u003e (j-i) ? max : j-i; i = k+1; } } max = max \u003e (j-i+1) ? max : j-i+1; } return max; } }; ","date":"2020-05-22","objectID":"/posts/leetcode-14/:2:2","tags":["Leetcode-C++"],"title":"Leetcode Part-14","uri":"/posts/leetcode-14/"},{"categories":["Leetcode"],"content":"滑动窗口结合hash 这是真的大佬,这个题解让我顿悟到了哈希的nb!!! 哈希果然是空间换时间的绝佳秒法 真是\"妙蛙种子吃着妙脆角回到了米奇妙妙屋,妙到家了!\" int lengthOfLongestSubstring(char * s){ int i, j = 0, count = 0, max = 0, index[128] = {0}, start = 0; for(i=0;s[i]!='\\0';i++) { if(index[s[i]]\u003estart) //index用来储存出现重复字符时 { //子串起始下标应移动到的地方 count = i-start; if(count\u003emax) { max = count; } start = index[s[i]]; } index[s[i]] = i+1; } count = i-start; return count\u003emax?count:max; } ","date":"2020-05-22","objectID":"/posts/leetcode-14/:2:3","tags":["Leetcode-C++"],"title":"Leetcode Part-14","uri":"/posts/leetcode-14/"},{"categories":["Leetcode"],"content":"19-删除链表的倒数第N个节点 题目: 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 给定一个链表: 1-\u003e2-\u003e3-\u003e4-\u003e5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-\u003e2-\u003e3-\u003e5. 解题思路: 暴力求解:逆置链表-\u003e删除-\u003e逆置 我就不明白,我这暴力求解还能执行速度击败60%,内存击败100%…迷惑 然鹅这道题的精髓是!**快慢指针!!!**双指针总会产生奇迹,这道题也不例外哈哈哈 ","date":"2020-05-22","objectID":"/posts/leetcode-14/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-14","uri":"/posts/leetcode-14/"},{"categories":["Leetcode"],"content":"暴力求解 struct ListNode* reverse_list(struct ListNode* head){ struct ListNode* node = (struct ListNode*)malloc(sizeof(struct ListNode)); node-\u003enext = NULL; struct ListNode* p = head; struct ListNode* temp = NULL; while(p){ temp = p-\u003enext; p-\u003enext = node-\u003enext; node-\u003enext = p; p = temp; } return node-\u003enext; } struct ListNode* removeNthFromEnd(struct ListNode* head, int n){ if(head == NULL){ return NULL; } head = reverse_list(head); struct ListNode* p = head; if(n==1){ head = head-\u003enext; } else{ for(int i=0; i\u003cn-2; i++){ p = p-\u003enext; } struct ListNode* nex = p-\u003enext; p-\u003enext = nex-\u003enext; } return reverse_list(head); } ","date":"2020-05-22","objectID":"/posts/leetcode-14/:3:1","tags":["Leetcode-C++"],"title":"Leetcode Part-14","uri":"/posts/leetcode-14/"},{"categories":["Leetcode"],"content":"快慢指针 神奇的快慢指针!看完这个题解感觉自己甚至变聪明了一点点!!! struct ListNode* removeNthFromEnd(struct ListNode* head, int n){ struct ListNode*p=head,*q=head,*r; int i; for(i=0;i\u003cn;i++) p=p-\u003enext; if(p==NULL){ head=head-\u003enext; free(q); } else{ while(p){ r=q; p=p-\u003enext; q=q-\u003enext; } r-\u003enext=q-\u003enext; free(q); } return head; } ","date":"2020-05-22","objectID":"/posts/leetcode-14/:3:2","tags":["Leetcode-C++"],"title":"Leetcode Part-14","uri":"/posts/leetcode-14/"},{"categories":["Leetcode"],"content":"739-每日温度 53-最大子序和 104-二叉树的最大深度 malloc的使用时机 \u0026 指针数组 ","date":"2020-05-22","objectID":"/posts/leetcode-13/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"739-每日温度 题目: 根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 解题思路: 本来想用今天刚学到的那个算法,单向栈来解,然后光调试程序就花了一晚上,最后跑出来结果发现…方法不适用(哭) 因为单向栈在比较过程中pop了,然而这道题不能pop!要算路径上节点的数量 看了题解之后突然发现个妙招,核心思想也是单向栈,不过解决pop丢失数量的方法是,在节点本身加上index,保存节点此时对应的数量 ","date":"2020-05-22","objectID":"/posts/leetcode-13/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"我的错误代码 /* 错误代码,虽然错了,但是我一晚上的努力,好歹跑起来了!贴上! int* dailyTemperatures(int* T, int TSize, int* returnSize){ int i = TSize-1; *returnSize = TSize; int count; //int* res_array = (int*)malloc(sizeof(int)*1024); //init return_list int* stack = (int*)malloc(sizeof(int)*i); int top = -1; while (i \u003e -1) { if (top == -1) { //栈为空 stack[++top] = T[i]; T[i--] = 0; } else{ count = 0; while (top \u003e -1 \u0026\u0026 stack[top] \u003c= T[i]){ --top; //找到最近更大的值,并且一直出栈操作 ++count; } if (top == -1) { //没有找到更大值,栈为空,赋值为0 stack[++top] = T[i]; T[i--] = 0; }else{ //找到更大值,进栈,并且更改return_array的值 stack[++top] = T[i]; T[i--] = ++count; } } } return T; } */ ","date":"2020-05-22","objectID":"/posts/leetcode-13/:1:1","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"大佬的正确代码 struct Temp { int index; int temp; }; typedef struct Temp Temp; int* dailyTemperatures(int* T, int TSize, int* returnSize){ int *ans = (int *)malloc(sizeof(T[0])*TSize); Temp *stack = (Temp *)malloc(TSize*sizeof(Temp)); int i,top = -1; int n = 0; *returnSize = TSize; for(i=0;i\u003cTSize;i++) ans[i] = 0; i=0; while(i\u003c TSize) { if(top == -1 || T[i] \u003c= stack[top].temp) { top++; stack[top].index = i; stack[top].temp = T[i]; i++; } else if(top \u003e= 0 \u0026\u0026 T[i] \u003e stack[top].temp) { top++; for(;top \u003e= 0 \u0026\u0026 T[i] \u003e stack[top-1].temp ; ) { ans[stack[top-1].index] = i - stack[top-1].index ; top --; if(top == 0) break; } stack[top].index = i; stack[top].temp = T[i]; //n = 0; i++; } } return ans; } ","date":"2020-05-22","objectID":"/posts/leetcode-13/:1:2","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"53-最大子序和 题目: 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 解题思想: 简简单单,动态规划. int maxSubArray(int* nums, int numsSize){ int max = nums[0]; int temp = 0; for(int i=0; i\u003c numsSize; i++){ if(temp\u003c0){ temp = nums[i]; } else{ temp += nums[i]; } max = max \u003c temp ? temp : max; } return max; } ","date":"2020-05-22","objectID":"/posts/leetcode-13/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"104-二叉树的最大深度 题目: 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 解题思路: ","date":"2020-05-22","objectID":"/posts/leetcode-13/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"快乐递归 int maxDepth(struct TreeNode* root){ if(root == NULL){ return 0; } int left = maxDepth(root-\u003eleft); int right = maxDepth(root-\u003eright); return (left \u003e right? left:right)+1; } ","date":"2020-05-22","objectID":"/posts/leetcode-13/:3:1","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"层序遍历 ","date":"2020-05-22","objectID":"/posts/leetcode-13/:3:2","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"大佬的方法 struct TreeNode *g_queue[MAX_NODE_NUM]; int TreeDepthBfs(struct TreeNode* root) { int head = 0; int tail = 0; struct TreeNode *node = root; int deep = 0; int curtail; if (node == NULL) { return 0; } g_queue[tail++] = root; while (head \u003c tail \u0026\u0026 tail \u003c MAX_NODE_NUM) { deep++; curtail = tail; // 逐层遍历 for (int i = head; i \u003c curtail; i++) { node = g_queue[i]; if (node-\u003eleft != NULL \u0026\u0026 tail \u003c MAX_NODE_NUM) { g_queue[tail++] = node-\u003eleft; } if (node-\u003eright != NULL \u0026\u0026 tail \u003c MAX_NODE_NUM) { g_queue[tail++] = node-\u003eright; } } head = curtail; } return deep; } ","date":"2020-05-22","objectID":"/posts/leetcode-13/:3:3","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"我的方法 我是保存了每层的元素数量,然后动头指针,这样感觉更清晰一点 int maxDepth(struct TreeNode* root){ if(root == NULL){ return 0; } struct TreeNode* a[10240]; int front = 0, rear = 0, num = 1, deep = 0; int temp; struct TreeNode* node = NULL; a[rear++] = root; //printf(\"%d\\n\",rear); while(rear \u003e front){ temp = num; //printf(\"当前层有%d个元素\\n\",temp); num = 0; for(int i=0; i\u003ctemp; i++){ node = a[front++]; if(node!=NULL \u0026\u0026 node-\u003eleft!= NULL){ num++; a[rear++] = node-\u003eleft; } if(node!=NULL \u0026\u0026 node-\u003eright!= NULL){ num++; a[rear++] = node-\u003eright; } //printf(\"front:%d\\n\",front); //printf(\"rear:%d\\n\",rear); } ++deep; //printf(\"第%d层\\n\",deep); } return deep; } ","date":"2020-05-22","objectID":"/posts/leetcode-13/:3:4","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"malloc的使用时机 \u0026 指针数组 上一题层序遍历的时候,一开始想整一个指针数组,就malloc了一个,但是一直报错,查了才知道其实对于指针数组的初始化,直接声明就好 struct TreeNode* [MAX]; ","date":"2020-05-22","objectID":"/posts/leetcode-13/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"指向数组的指针和存放指针的数组 指向数组的指针： char (*array)[5];含义是一个指向存放5个字符的数组的指针 存放指针的数组： char *array[5];含义是一个数组中存放了5个指向字符型数据的指针 一个是字符的数组 一个是字符型的数据 ","date":"2020-05-22","objectID":"/posts/leetcode-13/:4:1","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"malloc() 如果临时需要一块内存，这块内存用来存储n个int的变量。就需要使用malloc为pMax分配一块内存。可以这样做： int* pMax; pMax = malloc(sizeof(int) * n); 这里malloc返回一个指向这块内存的首地址并将其赋给了int型指针变量pMax. 这时pMax已经可以使用了。我们需要对它进行初始化。这个可以使用memset函数 memset(pMax, 0 , sizeof(int) * n); 现在就可以像数组一样操作这块int型的内存了。 pMax[0] = iMax; pMax[1] = iMax + 1; pMax[2] = pMax[0]; malloc的返回值是一个指针，指向一段可用内存的起始地址 ","date":"2020-05-22","objectID":"/posts/leetcode-13/:4:2","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"malloc()和calloc() 当我们每次使用完malloc（）函数的时候都必须将指针赋予一个空指针 相对于malloc()函数，calloc()函数就不需要赋予NULL，这是因为在每次调用完calloc()函数的时候系统会自动将原先的指针赋予一个空指针，即归于“0”。 calloc()函数的原型是void calloc（count，sizeof（类型名称））；比如：p=（char）calloc（4，sizeof（char））；我们为p分配了指向char型指针的“4”个空间。 ","date":"2020-05-22","objectID":"/posts/leetcode-13/:4:3","tags":["Leetcode-C++"],"title":"Leetcode Part-13","uri":"/posts/leetcode-13/"},{"categories":["Leetcode"],"content":"203-移除链表元素 160-相交链表 1019-链表中的下一个更大节点 malloc与calloc的区别 ","date":"2020-05-21","objectID":"/posts/leetcode-12/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-12","uri":"/posts/leetcode-12/"},{"categories":["Leetcode"],"content":"203-移除链表元素 题目:删除链表中等于给定值 val 的所有节点。 解题思路:简简单单,常规操作,但是头结点要进行额外判断 struct ListNode* removeElements(struct ListNode* head, int val){ if(head == NULL){ return NULL; } struct ListNode* p = head; struct ListNode* temp = NULL; struct ListNode* pre = NULL; while(p != NULL){ if(p-\u003eval == val){ temp = p; if(pre == NULL){ head = head-\u003enext; p = head; } else{ pre-\u003enext = p-\u003enext; p = p-\u003enext; free(temp); } } else{ pre = p; p = p-\u003enext; } } return head; } ","date":"2020-05-21","objectID":"/posts/leetcode-12/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-12","uri":"/posts/leetcode-12/"},{"categories":["Leetcode"],"content":"160-相交链表 题目: 编写一个程序，找到两个单链表相交的起始节点。 解题思路: 一开始写了一个逆置链表,然后也能找到,但是解题说改变了链表结构…没通过 后来也没想出来,看到题解恍然大悟(还被撒了一脸狗粮…躲过了520,没躲过leetcode的花样题解…md) 定义两个指针p,q,分别从l1,l2出发,p到达l1链表末尾后,继续从l2头节点处继续遍历,q同理,从l1处继续遍历,直到p,q相等找到相交节点(或p,q = NULL) /*struct ListNode* reverse_list(struct ListNode* p){ struct ListNode* res = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* temp = NULL; res-\u003enext = NULL; while(p-\u003enext != NULL){ temp = p-\u003enext; p-\u003enext = res-\u003enext; res-\u003enext = p; p = temp; p = p-\u003enext; } return res-\u003enext; } struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { struct ListNode* l1 = reverse_list(headA); struct ListNode* l2 = reverse_list(headB); struct ListNode* res = NULL; while(l1!= NULL \u0026\u0026 l2!= NULL){ if(l1-\u003eval == l2-\u003eval){ l1 = l1-\u003enext; l2 = l2-\u003enext; } else{ res = l1; break; } } if(res!= NULL){ return res; } else{ return NULL; } }*/ struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { struct ListNode*p=headA; struct ListNode*q=headB; while(p!=q){ p=p!=NULL?p-\u003enext:headB; q=q!=NULL?q-\u003enext:headA; } return p; } ","date":"2020-05-21","objectID":"/posts/leetcode-12/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-12","uri":"/posts/leetcode-12/"},{"categories":["Leetcode"],"content":"1019-链表中的下一个更大节点 题目:示例输入 输入：[1,7,5,1,9,2,5,1] 输出：[7,9,9,9,0,5,0,0] 解题思路: 这题快给我搞崩溃了…初始化数组为链表的值,然后从右向左进行判断,入栈出栈比较操作(静态栈) 看了题解之后感觉实现起来并不是很难,就是…好绕啊,尤其那个栈给我绕进去了 int* nextLargerNodes(struct ListNode* head, int* returnSize){ if (head == NULL) return NULL; int *ret_arr = (int *)malloc(10240*sizeof(int)); struct ListNode* p1 = head; int i = 0,top = -1; while (p1){ //初始化返回数组,赋值,之后进行比较 ret_arr[i++] = p1-\u003eval; p1 = p1-\u003enext; } int *stack = (int*)calloc(i, sizeof(int));//申请栈空间 *returnSize = i--; //返回num值 while (i \u003e -1) { if (top == -1) { //栈为空 stack[++top] = ret_arr[i]; ret_arr[i--] = 0; } else{ while (top \u003e -1 \u0026\u0026 stack[top] \u003c= ret_arr[i]){ --top; //找到最近更大的值,并且一直出栈操作 } if (top == -1) { //没有找到更大值,栈为空,赋值为0 stack[++top] = ret_arr[i]; ret_arr[i--] = 0; } else{ //找到更大值,进栈,并且更改return_array的值 stack[top+1] = ret_arr[i]; ret_arr[i--] = stack[top++]; } } } return ret_arr; } ","date":"2020-05-21","objectID":"/posts/leetcode-12/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-12","uri":"/posts/leetcode-12/"},{"categories":["Leetcode"],"content":"malloc与calloc的区别 malloc函数：malloc(size_t size)函数有一个参数，即要分配的内存空间的大小。 calloc函数：calloc(size_t numElements,size_t sizeOfElement)有两个参数，分别为元素的数目和每个元素的大小，这两个参数的乘积就是要分配的内存空间的大小。 ","date":"2020-05-21","objectID":"/posts/leetcode-12/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-12","uri":"/posts/leetcode-12/"},{"categories":["Leetcode"],"content":"83-删除排序链表中的重复元素 257-二叉树的所有路径 ","date":"2020-05-20","objectID":"/posts/leetcode-11/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-11","uri":"/posts/leetcode-11/"},{"categories":["Leetcode"],"content":"83-删除排序链表中的重复元素 题目: 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例: 输入: 1-\u003e1-\u003e2 输出: 1-\u003e2 解题思路:我以为50%通过率是啥题呢,做题的时候一直想着是不是有啥坑啊…多虑了,打扰了 struct ListNode* deleteDuplicates(struct ListNode* head){ if(head == NULL){ return NULL; } struct ListNode* p = NULL; p = head; while(p-\u003enext != NULL){ if(p-\u003enext-\u003eval == p-\u003eval){ struct ListNode* q = p-\u003enext; p-\u003enext = q-\u003enext; free(q); } else{ p = p-\u003enext; } } return head; } ","date":"2020-05-20","objectID":"/posts/leetcode-11/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-11","uri":"/posts/leetcode-11/"},{"categories":["Leetcode"],"content":"257-二叉树的所有路径 题目: 给定一个二叉树，返回所有从根节点到叶子节点的路径。 输出: [\"1-\u003e2-\u003e5\", \"1-\u003e3\"] 解释: 所有根节点到叶子节点的路径为: 1-\u003e2-\u003e5, 1-\u003e3 解题思路: 静态数组+递归遍历,记录当前经过元素的数量(num),然后在数组中在下标(num)处开始添加新的元素 知道遇到叶子节点,打印当前数组 #define NUM 100 void dfs(char **path, char *temp, struct TreeNode *root, int cnt, int *size) { if (root == NULL) { return; } temp[cnt++] = root-\u003eval; //递归到当前元素的数量cnt if (root-\u003eleft == NULL \u0026\u0026 root-\u003eright == NULL) { int len = 0; for (int i = 0; i \u003c cnt - 1; i++) { len += sprintf(\u0026path[*size][len], \"%d-\u003e\", temp[i]); } sprintf(\u0026path[*size][len], \"%d\", temp[cnt - 1]); *size += 1; return; } dfs(path, temp, root-\u003eleft, cnt, size); dfs(path, temp, root-\u003eright, cnt, size); return; } char ** binaryTreePaths(struct TreeNode* root, int* returnSize){ char **path = (char **)malloc(NUM * sizeof(char *)); for (int i = 0; i \u003c NUM; i++) { path[i] = (char *)malloc(NUM * sizeof(char)); } char temp[NUM]; //用来保存临时变量 int cnt = 0; int size = 0; dfs(path, temp, root, cnt, \u0026size); *returnSize = size; return path; } ","date":"2020-05-20","objectID":"/posts/leetcode-11/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-11","uri":"/posts/leetcode-11/"},{"categories":["Leetcode"],"content":"sprintf函数 srpintf()函数的功能很强大：效率比一些字符串操作函数要高；而且更具灵活性；可以将想要的结果输出到指定的字符串中 头文件：stdio.h 函数功能：格式化字符串，将格式化的数据写入字符串中。 函数原型：int sprintf(char *buffer, const char *format, [argument]…) 参数： buffer：是char类型的指针，指向写入的字符串指针； format：格式化字符串，即在程序中想要的格式； argument：可选参数，可以为任意类型的数据； 函数返回值：buffer指向的字符串的长度； ","date":"2020-05-20","objectID":"/posts/leetcode-11/:2:1","tags":["Leetcode-C++"],"title":"Leetcode Part-11","uri":"/posts/leetcode-11/"},{"categories":["C语言"],"content":"今天被单链表排序那题卡了大半天,我一直想写冒泡…但是最后给我绕懵了,发现单链表的冒泡也太难写了(哭) 最后我还写了构造单链表和打印单链表的一套函数用来debug… 失败的收获:排序过程中其实并不用去交换节点,交换节点的value完全可以啊 过几天开始系统学查找排序算法 常见排序算法 快速排序 ","date":"2020-05-20","objectID":"/posts/C-12/:0:0","tags":["Leetcode-C"],"title":"单链表排序","uri":"/posts/C-12/"},{"categories":["C语言"],"content":"快排思想 对于一个数组A，选定一个基准元素 遍历剩余元素，并与基准元素进行比较 按比较结果的大小将剩余元素分成两组，一组全部比基准元素大，记为B，另外一组全部基准元素小，记为S 将基准元素的位置挪到比它小的那组元素的最后 分别对B和S重复以上4个步骤，直到所有的元素都已经排序成功 ","date":"2020-05-20","objectID":"/posts/C-12/:1:0","tags":["Leetcode-C"],"title":"单链表排序","uri":"/posts/C-12/"},{"categories":["C语言"],"content":"单链表快速排序 但是对于单链表我们没有前驱指针，怎么能使得后面的那个指针往前移动呢？所以这种快排思路行不通滴。 这时需要两个指针p和q，这两个指针均往next方向移动，移动的过程中保持p之前的key都小于选定的key，p和q之间的key都大于选定的key，那么当q走到末尾的时候便完成了一次支点的寻找。 ","date":"2020-05-20","objectID":"/posts/C-12/:2:0","tags":["Leetcode-C"],"title":"单链表排序","uri":"/posts/C-12/"},{"categories":["C语言"],"content":"示例图 ","date":"2020-05-20","objectID":"/posts/C-12/:2:1","tags":["Leetcode-C"],"title":"单链表排序","uri":"/posts/C-12/"},{"categories":["C语言"],"content":"代码实现 //指针交换辅助函数 void swap(int *a, int *b) { int t=*a; *a=*b; *b=t; } struct ListNode *partion(struct ListNode *left,struct ListNode *right) { if(left == right || left-\u003enext == right) //如果只有一个元素或者两个元素，则直接返回第一个指针 return left; int pivot = left-\u003eval; //选择头节点作为基准元素 struct ListNode *p1 = left ,*p2 = left-\u003enext; while(p2 != right) { //从left开始向后进行一次遍历，大于pivot值时，p1向前走一步，交换p1与p2的值 if(p2-\u003eval \u003c pivot) { p1 = p1-\u003enext; swap(\u0026p1-\u003eval, \u0026p2-\u003eval); } p2 = p2-\u003enext; } swap(\u0026p1-\u003eval, \u0026left-\u003eval); return p1; free(p2); //释放p2指针的内存 } void quick_sort(struct ListNode *left,struct ListNode *right) { if(left == right||left -\u003enext == right) return; struct ListNode *mid = partion(left, right); quick_sort(left, mid); quick_sort(mid-\u003enext, right); } struct ListNode* sortList(struct ListNode* head) { if(head==NULL||head-\u003enext==NULL) return head; quick_sort(head, NULL); return head; } 归并排序 ","date":"2020-05-20","objectID":"/posts/C-12/:2:2","tags":["Leetcode-C"],"title":"单链表排序","uri":"/posts/C-12/"},{"categories":["C语言"],"content":"归并思想 归并排序基于分治的思想，但是不同的是，分完了以后后面还需要从底层开始向上合并，主要思想如下： 遍历链表L，找到链表中间节点将链表分成两部分L1，L2 分别对L1、L2重复进行遍历并分组，直到每个链表近含有一个元素为止 然后调用合并两个有序链表的函数将链表两两合并，直到全部完成为止 ","date":"2020-05-20","objectID":"/posts/C-12/:3:0","tags":["Leetcode-C"],"title":"单链表排序","uri":"/posts/C-12/"},{"categories":["C语言"],"content":"单链表归并算法实现 struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { struct ListNode *head = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode *cur = head; while(l1 \u0026\u0026 l2) { if(l1-\u003eval \u003e l2-\u003eval) { cur-\u003enext = l2; l2 = l2-\u003enext; } else { cur-\u003enext = l1; l1 = l1-\u003enext; } cur = cur-\u003enext; } cur-\u003enext = l1 ? l1:l2; return head-\u003enext; } struct ListNode* sortList(struct ListNode* head) { if(!head || !head-\u003enext) return head; struct ListNode *slow = head, *fast = head, *pre = head; while(fast \u0026\u0026 fast-\u003enext) { pre = slow; slow = slow-\u003enext; fast = fast-\u003enext-\u003enext; } pre-\u003enext = NULL; return mergeTwoLists(sortList(head), sortList(slow));//slow为原链表的中间节点 } ","date":"2020-05-20","objectID":"/posts/C-12/:4:0","tags":["Leetcode-C"],"title":"单链表排序","uri":"/posts/C-12/"},{"categories":["Leetcode"],"content":"今天忙了一天的论文,晚上开会老师还表扬我辣,拿我的目录做模板! 晚上刷一会快乐leetcode 1441-用栈操作构建数组 ","date":"2020-05-19","objectID":"/posts/leetcode-10/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-10","uri":"/posts/leetcode-10/"},{"categories":["Leetcode"],"content":"1441-用栈操作构建数组 给你一个目标数组 target 和一个整数 n,每次迭代，需要从 list = {1,2,3…, n} 中依序读取一个数字。 请使用下述操作来构建目标数组 target ： Push：从 list 中读取一个新元素， 并将其推入数组中。 Pop：删除数组中的最后一个元素。 如果目标数组构建完成，就停止读取更多元素。 实例: 输入：target = [2,3,4], n = 4 输出：[\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\"] 解题思路: 用数组下标解决…就是走着走着有点懵了,一直超内存,最后才发现是最后那步判断res_len没有-1…行8,以后注意了 char ** buildArray(int* target, int targetSize, int n, int* returnSize){ int res_len = target[targetSize-1]+(target[targetSize-1]-targetSize); char** res = (char**)malloc(sizeof(char*)*res_len); for(int j=0; j\u003cres_len; j++){ res[j] = (char*)malloc(sizeof(char)*5); } int count = 0; int step1 = 0; for(int i=0; i\u003cres_len; i++){ if(target[step1] != i+1){ res[count] = \"Push\"; res[++count] = \"Pop\"; ++count; } else{ res[count] = \"Push\"; ++count; step1++; } if(count \u003e res_len-1){ break; } } *returnSize = res_len; return res; } ","date":"2020-05-19","objectID":"/posts/leetcode-10/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-10","uri":"/posts/leetcode-10/"},{"categories":["Leetcode"],"content":"993-二叉树的堂兄弟节点 ","date":"2020-05-18","objectID":"/posts/leetcode-9/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-9","uri":"/posts/leetcode-9/"},{"categories":["Leetcode"],"content":"993-二叉树的堂兄弟节点 题目: 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。 解题思路: 从这道题里我学到了好多!感觉现在只要想到思路了,代码就都能写出来,不像一开始写代码磕磕巴巴的,一开始就想到层序遍历,然后暴力求解,所以思路也没啥解释的,一直没看题解的我感觉很开心(虽然只是一道简单题) ","date":"2020-05-18","objectID":"/posts/leetcode-9/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-9","uri":"/posts/leetcode-9/"},{"categories":["Leetcode"],"content":"暴力求解 struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; typedef struct List_node { struct TreeNode* data; struct TreeNode* father; struct List_node* next; }listnode; typedef struct{ listnode* head; int count; listnode* next; }listhead; bool isCousins(struct TreeNode* root, int x, int y){ listhead* head = (listhead*)malloc(sizeof(listhead)); head-\u003ecount = 1; listnode* firstnode = (listnode*)malloc(sizeof(listnode)); firstnode-\u003edata = root; head-\u003enext = firstnode; int num = 0; listnode* flag1 = NULL; listnode* flag2 = NULL; while(head-\u003ecount != 0){ num = head-\u003ecount; listnode* visinode = head-\u003enext; for(int i=0; i\u003cnum; i++){ if(visinode-\u003edata-\u003eval == x){ flag1 = visinode; } if(visinode-\u003edata-\u003eval == y){ flag2 = visinode; } if(visinode-\u003edata-\u003eleft){ head-\u003ecount++; listnode* newnode = (listnode*)malloc(sizeof(listnode)); newnode-\u003edata = visinode-\u003edata-\u003eleft; newnode-\u003efather = visinode; newnode-\u003enext = head-\u003enext; head-\u003enext = newnode; } if(visinode-\u003edata-\u003eright){ head-\u003ecount++; listnode* newnode = (listnode*)malloc(sizeof(listnode)); newnode-\u003edata = visinode-\u003edata-\u003eright; newnode-\u003efather = visinode; newnode-\u003enext = head-\u003enext; head-\u003enext = newnode; } visinode = visinode-\u003enext; head-\u003ecount--; } if(flag1 \u0026\u0026 flag2 \u0026\u0026 flag1-\u003efather != flag2-\u003efather){ return true; } else{ flag1 = NULL; flag2 = NULL; } } return false; } ","date":"2020-05-18","objectID":"/posts/leetcode-9/:1:1","tags":["Leetcode-C++"],"title":"Leetcode Part-9","uri":"/posts/leetcode-9/"},{"categories":["Leetcode"],"content":"递归 题解中大佬的递归算法,大佬大佬…学到了 struct TreeNode* parent(struct TreeNode* root, int x,int *hx){ if(root==NULL) return NULL; /*判断左右节点的值是否为x,y如果为真,则当前节点为父节点,返回*/ if((root-\u003eleft\u0026\u0026root-\u003eleft-\u003eval==x)||(root-\u003eright\u0026\u0026root-\u003eright-\u003eval==x)) return root; //找到结点 x,y else{ (*hx)++; //hx为层数 int t=*hx; //保存当前递归开始的层数,等待回溯 struct TreeNode *p=parent(root-\u003eleft,x,hx); //递归左子树,计算层数 if(p) return p; else{ *hx=t; //递归右子树,赋值之前保存的层数,回溯 return parent(root-\u003eright,x,hx); //计算层数 } } } bool isCousins(struct TreeNode* root, int x, int y){ if(root==NULL) return 0; if(root-\u003eval==x||root-\u003eval==y) return 0; struct TreeNode *p,*q; int *hx,*hy; //两个int变量 hx=(int*)malloc(sizeof(int)); hy=(int*)malloc(sizeof(int)); *hx=0,*hy=0; p=parent(root,x,hx); q=parent(root,y,hy); if(p!=q\u0026\u0026*hx==*hy) return 1; return 0; } 看着周围的同学都陆续被录取了,心里有些不是滋味,但还是清楚的明白,是自己没下工夫 羡慕别人,痛恨自己,后悔过去,继续前行 今天早睡,明天继续快乐刷题 ","date":"2020-05-18","objectID":"/posts/leetcode-9/:1:2","tags":["Leetcode-C++"],"title":"Leetcode Part-9","uri":"/posts/leetcode-9/"},{"categories":["C语言"],"content":"方便leetcode本地调试 ","date":"2020-05-18","objectID":"/posts/C-11/:0:0","tags":["Leetcode-C"],"title":"C-打印层序遍历构造的二叉树","uri":"/posts/C-11/"},{"categories":["C语言"],"content":"通过层序遍历数组构造二叉树 /*树的节点*/ struct node { int val; struct node *left, *right; }; /*构造二叉树*/ void insert(struct node *p, int *a,int t, int num){ //int length = sizeof(a)/sizeof(int); //printf(\"this is the length:%d\",length); if(t\u003e=num)return; p-\u003eval = a[t]; if((2 * (t+1)) \u003c= num){ if(a[2 * (t+1) -1]!=0){ struct node *l; l = (struct node*)malloc(sizeof(struct node)); l-\u003eleft = NULL; l-\u003eright = NULL; p-\u003eleft = l; insert(p-\u003eleft, a, 2 * (t+1) -1,num); printf(\"建立节点\"); } if((2 * (t+1) +1) \u003c= num){ if(a[2 * (t+1)]!=0){ struct node *r; r = (struct node*)malloc(sizeof(struct node)); r-\u003eleft = NULL; r-\u003eright = NULL; p-\u003eright = r; insert(p-\u003eright, a, 2 * (t+1),num); printf(\"建立节点\"); } } } } struct node* createFromArray(int* a, int num){ struct node *p; p = (struct node*)malloc(sizeof(struct node)); p-\u003eleft = NULL; p-\u003eright = NULL; insert(p,a,0,num); return p; } ","date":"2020-05-18","objectID":"/posts/C-11/:1:0","tags":["Leetcode-C"],"title":"C-打印层序遍历构造的二叉树","uri":"/posts/C-11/"},{"categories":["C语言"],"content":"打印二叉树 int vec_left[100] = {0}; // 显示二叉树的函数，只要调用Display(root, 0)即可 void Display(struct node* root, int ident) { if(ident \u003e 0) { for(int i = 0; i \u003c ident - 1; ++i) { printf(vec_left[i] ? \"│ \" : \" \"); } printf(vec_left[ident-1] ? \"├── \" : \"└── \"); } if(! root) { printf(\"gg啦\\n\"); return; } printf(\"%d\\n\", root-\u003eval); if(!root-\u003eleft \u0026\u0026 !root-\u003eright) { return; } vec_left[ident] = 1; Display(root-\u003eleft, ident + 1); vec_left[ident] = 0; Display(root-\u003eright, ident + 1); } ","date":"2020-05-18","objectID":"/posts/C-11/:2:0","tags":["Leetcode-C"],"title":"C-打印层序遍历构造的二叉树","uri":"/posts/C-11/"},{"categories":["C语言"],"content":"main函数 int main(){ int temp[] = {1,2,3,4,8,9,10,11,14,24,13}; int length = sizeof(temp)/sizeof(temp[0]); struct node* root = createFromArray(temp,length); Display(root,0); return 1; } ","date":"2020-05-18","objectID":"/posts/C-11/:3:0","tags":["Leetcode-C"],"title":"C-打印层序遍历构造的二叉树","uri":"/posts/C-11/"},{"categories":["C语言"],"content":"刷leetcode的时候,由于报错显示的很简单,想调试程序的话有些困难,所以就想在c环境下断点调试代码,今天做一道关于树的题的时候,遇到了这个问题,就是数组形参的长度永远都是8字节,就很离谱…后来才发现了缘故 原来在字符型的数组中我们可以使用 strlen() 来获取当前数组的长度，对于其他类型的数组，这个方法就不适用了. C-数组形参获得长度 # include\u003cstdio.h\u003e int main(int argc, char * argv[]) { int a[] = {2, 6, 3, 5, 9}; p = a; printf(\"The length is: %d\\n\",length(a)); printf(\"The length is: %d\\n\",sizeof(a)/sizeof(int)); printf(\"The length of pointer is: %d\\n\", sizeof(p)); return 0; } int length(int a) { int length; length = sizeof(a)/ sizeof(int); return length; } 执行结果： The length is: 2 The length is: 5 The length of pointer is: 8 a[]是长度计算的形式参数，在 main()函数中调用时，a是一个指向数组第一个元素的指针。在执行main() 函数时，不知道a所表示的地址有多大的数据存储空间，只是告诉函数：一个数据存储空间首地址。 sizeof(a)的结果是指针变量a占内存的大小，一般在64位机上是8个字节。 a[0]是 int 类型，sizeof a[0]是4个字节，结果是2。 所以,形参中只是指针,无法通过计算得到数组的长度,只有提前将长度算好传入函数 ","date":"2020-05-18","objectID":"/posts/C-10/:0:0","tags":["C-语法基础"],"title":"C-数组形参的长度","uri":"/posts/C-10/"},{"categories":["vscode"],"content":"建立Linux下的C环境 2020.6.22更新 ","date":"2020-05-18","objectID":"/posts/vscode-3/:0:0","tags":["vscode"],"title":"VScode配置C环境","uri":"/posts/vscode-3/"},{"categories":["vscode"],"content":"关于math.h等头文件出现链接错误 修改task.json文件 \"args\": [ \"-g\", \"${file}\", \"-lm\", //新增项 \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\" ], ","date":"2020-05-18","objectID":"/posts/vscode-3/:1:0","tags":["vscode"],"title":"VScode配置C环境","uri":"/posts/vscode-3/"},{"categories":["vscode"],"content":"安装环境 gcc/g++编译程序和gdb调试程序 sudo apt-get install gcc sudo apt-get install g++ sudo apt-get install gdb ","date":"2020-05-18","objectID":"/posts/vscode-3/:2:0","tags":["vscode"],"title":"VScode配置C环境","uri":"/posts/vscode-3/"},{"categories":["vscode"],"content":"插件法 安装插件 C++ Intellisense C/C++ Compile Run F6或F7即可编译运行 ","date":"2020-05-18","objectID":"/posts/vscode-3/:3:0","tags":["vscode"],"title":"VScode配置C环境","uri":"/posts/vscode-3/"},{"categories":["vscode"],"content":"配置法 在代码界面F5运行，vscode提示选择调试程序，选择gdb 然后选择模板,这里我选择的是\"gcc-9\" 此时自动生成 launch.json文件 之后继续F5,自动生成 task.json文件 至此配置完成 ","date":"2020-05-18","objectID":"/posts/vscode-3/:4:0","tags":["vscode"],"title":"VScode配置C环境","uri":"/posts/vscode-3/"},{"categories":["Leetcode"],"content":"328-奇偶链表 ","date":"2020-05-17","objectID":"/posts/leetcode-8/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-8","uri":"/posts/leetcode-8/"},{"categories":["Leetcode"],"content":"328-奇偶链表 题目:给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 示例 输入: 2-\u003e1-\u003e3-\u003e5-\u003e6-\u003e4-\u003e7-\u003eNULL 输出: 2-\u003e3-\u003e6-\u003e7-\u003e1-\u003e5-\u003e4-\u003eNULL 解题思路:我还是只想到了暴力法…先建立一个奇数链表,再搞一个偶数链表,然后相连,但是一开始总是超时,后来把 b-\u003enext = NULL;就好了,感觉有些离谱,不过以后注意数据封口和销毁就好啦 ","date":"2020-05-17","objectID":"/posts/leetcode-8/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-8","uri":"/posts/leetcode-8/"},{"categories":["Leetcode"],"content":"暴力法 struct ListNode* oddEvenList(struct ListNode* head){ if (head == NULL || head-\u003enext == NULL){ return head; } int count = 0; struct ListNode* single_head = (struct ListNode*)malloc(sizeof(struct ListNode)),*a = single_head; struct ListNode* nosingke_head = (struct ListNode*)malloc(sizeof(struct ListNode)),*b = nosingke_head; while(head){ if(++count%2){ //single a = head = a-\u003enext = head; } else{ b = head = b-\u003enext = head; } head = head-\u003enext; } a-\u003enext = nosingke_head-\u003enext; b-\u003enext = NULL; a = single_head-\u003enext; free(single_head); free(nosingke_head); return single_head-\u003enext; } ","date":"2020-05-17","objectID":"/posts/leetcode-8/:1:1","tags":["Leetcode-C++"],"title":"Leetcode Part-8","uri":"/posts/leetcode-8/"},{"categories":["Leetcode"],"content":"指针跳跃(带头节点) struct ListNode* oddEvenList(struct ListNode* head){ if (head == NULL || head-\u003enext == NULL) return head; struct ListNode *l1 = (struct ListNode *)malloc(sizeof(struct ListNode)), *rear1 = l1; struct ListNode *l2 = (struct ListNode *)malloc(sizeof(struct ListNode)), *rear2 = l2; while (head \u0026\u0026 head-\u003enext) { rear1 = rear1-\u003enext = head; rear2 = rear2-\u003enext = head-\u003enext; head = head-\u003enext-\u003enext; } rear1 = head? rear1-\u003enext = head: rear1; rear1-\u003enext = l2-\u003enext; rear2-\u003enext = NULL; rear1 = l1-\u003enext; free(l1); free(l2); return rear1; } ","date":"2020-05-17","objectID":"/posts/leetcode-8/:1:2","tags":["Leetcode-C++"],"title":"Leetcode Part-8","uri":"/posts/leetcode-8/"},{"categories":["Leetcode"],"content":"指针跳跃(不带头节点) struct ListNode* oddEvenList(struct ListNode* head){ if(head == NULL){ return NULL; } struct ListNode* oddHeah = head; // 保存奇数u偶数链表头部 struct ListNode* oddNode = oddHeah; struct ListNode* evenHeah = head -\u003e next; struct ListNode* evenNode = evenHeah; while(evenNode != NULL \u0026\u0026 evenNode -\u003e next != NULL){ oddNode -\u003e next = oddNode -\u003e next -\u003e next; evenNode -\u003e next = evenNode -\u003e next -\u003e next; oddNode = oddNode -\u003e next; evenNode = evenNode -\u003e next; } oddNode -\u003e next = evenHeah; // 拼接链表， 循环结束时 oddNode 指向奇数链表最后一个元素 return oddHeah; } ","date":"2020-05-17","objectID":"/posts/leetcode-8/:1:3","tags":["Leetcode-C++"],"title":"Leetcode Part-8","uri":"/posts/leetcode-8/"},{"categories":["Leetcode"],"content":"2-两数相加 7-整数反转 用两个栈实现队列 110-平衡二叉树 543-二叉树的直径 ","date":"2020-05-16","objectID":"/posts/leetcode-7/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-7","uri":"/posts/leetcode-7/"},{"categories":["Leetcode"],"content":"2-两数相加 题目: 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 输入：(2 -\u003e 4 -\u003e 3) + (5 -\u003e 6 -\u003e 4) 输出：7 -\u003e 0 -\u003e 8 原因：342 + 465 = 807 解题思路:我的思路就是暴力求解… ","date":"2020-05-16","objectID":"/posts/leetcode-7/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-7","uri":"/posts/leetcode-7/"},{"categories":["Leetcode"],"content":"暴力求解 struct ListNode* reverse_list(struct ListNode* l){ struct ListNode* a = l; struct ListNode* b = NULL; struct ListNode* r = NULL; while(a){ r = a; a = a-\u003enext; r-\u003enext = b; b = r; } return r; } struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){ struct ListNode* p = l1; struct ListNode* q = l2; struct ListNode* nex = NULL; int flag = 0; while(1){ int value = 0; int cur = 0; if(p == NULL \u0026\u0026 q == NULL \u0026\u0026 flag == 0){ break; } if(p \u0026\u0026 q){ value = p-\u003eval + q-\u003eval; p = p-\u003enext; q = q-\u003enext; } else if(p == NULL \u0026\u0026 q != NULL){ value = q-\u003eval; q = q-\u003enext; } else if(q == NULL \u0026\u0026 p != NULL){ value = p-\u003eval; p = p-\u003enext; } if(flag == 1){ ++value; } if(value \u003e= 10){ flag = 1; cur = value % 10; } else{ flag = 0; cur = value; } struct ListNode* s = (struct ListNode*)malloc(sizeof(struct ListNode)); s-\u003eval = cur; s-\u003enext = nex; nex = s; } struct ListNode* res = reverse_list(nex); return res; } ","date":"2020-05-16","objectID":"/posts/leetcode-7/:1:1","tags":["Leetcode-C++"],"title":"Leetcode Part-7","uri":"/posts/leetcode-7/"},{"categories":["Leetcode"],"content":"递归求解 #define TEN 10 static int g_carry = 0; struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2) { struct ListNode *result = NULL; int a = 0; int b = 0; if ((!l1) \u0026\u0026 (!l2) \u0026\u0026 (!g_carry)) { return NULL; } result = (struct ListNode *)malloc(sizeof(struct ListNode)); l1 = (l1) ? (g_carry += l1-\u003eval, l1-\u003enext) : (l1); l2 = (l2) ? (g_carry += l2-\u003eval, l2-\u003enext) : (l2); result-\u003eval = g_carry % TEN; g_carry /= TEN; result-\u003enext = addTwoNumbers(l1, l2); return result; } ","date":"2020-05-16","objectID":"/posts/leetcode-7/:1:2","tags":["Leetcode-C++"],"title":"Leetcode Part-7","uri":"/posts/leetcode-7/"},{"categories":["Leetcode"],"content":"7-整数反转 题目:给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 输入: 123 输出: 321 解题思路:一开始想到取余,但是没想明白怎么处理未知位数的整数,原来一个while再加上乘10就能解决,不错的思路 int reverse(int x){ long count=0; while(x!=0){ count=count*10+x%10; x=x/10; } return count\u003e2147483647||count\u003c-2147483648?0:count; } ","date":"2020-05-16","objectID":"/posts/leetcode-7/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-7","uri":"/posts/leetcode-7/"},{"categories":["Leetcode"],"content":"用两个栈实现队列 ","date":"2020-05-16","objectID":"/posts/leetcode-7/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-7","uri":"/posts/leetcode-7/"},{"categories":["Leetcode"],"content":"链栈 typedef struct Node { int val; struct Node* next; }Node; Node* newNode(int Val) { Node* n=(Node*)malloc(sizeof(Node)); n-\u003eval=Val; n-\u003enext= NULL; return n; } void push(Node* Head,int Val) { Node* n = newNode(Val); n-\u003enext = Head-\u003enext; Head-\u003enext=n; } int pop(Node* Head) { Node* n=Head-\u003enext; Head-\u003enext=n-\u003enext; int result=n-\u003eval; free(n); return result; } void del(Node* Head) { while(Head!=NULL) { Node* n=Head; Head=Head-\u003enext; free(n); } } typedef struct { Node* stackIn; //两个头结点,value = NULL Node* stackOut; } CQueue; CQueue* cQueueCreate() { CQueue* q=(CQueue*)malloc(sizeof(CQueue)); q-\u003estackIn=newNode(NULL); q-\u003estackOut=newNode(NULL); return q; } void cQueueAppendTail(CQueue* obj, int value) { push(obj-\u003estackIn,value); } int cQueueDeleteHead(CQueue* obj) { if(obj-\u003estackOut-\u003enext==NULL \u0026\u0026 obj-\u003estackIn-\u003enext==NULL) return -1; if(obj-\u003estackOut-\u003enext == NULL) while(obj-\u003estackIn-\u003enext != NULL) push(obj-\u003estackOut,pop(obj-\u003estackIn)); return pop(obj-\u003estackOut); } void cQueueFree(CQueue* obj) { del(obj-\u003estackIn); del(obj-\u003estackOut); free(obj); } ","date":"2020-05-16","objectID":"/posts/leetcode-7/:3:1","tags":["Leetcode-C++"],"title":"Leetcode Part-7","uri":"/posts/leetcode-7/"},{"categories":["Leetcode"],"content":"静态栈实现 #define MAX_SIZE 1000 typedef struct { int top; int arr[MAX_SIZE]; } Stack; Stack *createStack() { Stack *stack = (Stack *)malloc(sizeof(Stack)); if (stack == NULL) { return NULL; } stack-\u003etop = -1; memset(stack-\u003earr, 0x0, sizeof(int) * MAX_SIZE); return stack; } void push(Stack *stack, int val) { if ((stack == NULL) || (stack-\u003etop \u003e= MAX_SIZE)) { return; } stack-\u003earr[++stack-\u003etop] = val; return; } int pop(Stack *stack) { if ((stack == NULL) || (stack-\u003etop == -1)) { return INT_MAX; } return stack-\u003earr[stack-\u003etop--]; } int isEmpty(Stack *stack) { if (stack == NULL) { return 1; // 1表示栈为空 } return stack-\u003etop == -1 ? 1 : 0; } typedef struct { Stack *dataStack; Stack *helpStack; } CQueue; CQueue* cQueueCreate() { CQueue *queue = (CQueue *)malloc(sizeof(CQueue)); if (queue == NULL) { return NULL; } queue-\u003edataStack = createStack(); queue-\u003ehelpStack = createStack(); return queue; } void cQueueAppendTail(CQueue* obj, int value) { if (obj == NULL) { return; } push(obj-\u003edataStack, value); return; } int cQueueDeleteHead(CQueue* obj) { if (obj == NULL) { return -1; } int tmp; if (isEmpty(obj-\u003ehelpStack) == 1) { while (isEmpty(obj-\u003edataStack) != 1) { tmp = pop(obj-\u003edataStack); push(obj-\u003ehelpStack, tmp); } } return isEmpty(obj-\u003ehelpStack) == 1 ? -1 : pop(obj-\u003ehelpStack); } void cQueueFree(CQueue* obj) { if (obj == NULL) { return; } if (obj-\u003edataStack != NULL) { free(obj-\u003edataStack); } if (obj-\u003ehelpStack != NULL) { free(obj-\u003ehelpStack); } free(obj); return; } ","date":"2020-05-16","objectID":"/posts/leetcode-7/:3:2","tags":["Leetcode-C++"],"title":"Leetcode Part-7","uri":"/posts/leetcode-7/"},{"categories":["Leetcode"],"content":"110-平衡二叉树 题目: 判断一个数是否为平衡二叉树 解题思路: 首先递归求每个节点的深度,然后递归将左右子数深度进行比较 int Depth(struct TreeNode* root){ if(!root) return 0; int lren=Depth(root-\u003eleft); int rlen=Depth(root-\u003eright); return lren\u003erlen?(lren+1):(rlen+1); } bool isBalanced(struct TreeNode* root){ if(root==NULL)return true; if(abs(Depth(root-\u003eleft)-Depth(root-\u003eright))\u003e1) //绝对值大于1,非平衡 return false; return (isBalanced(root-\u003eleft)\u0026\u0026isBalanced(root-\u003eright)); } ","date":"2020-05-16","objectID":"/posts/leetcode-7/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-7","uri":"/posts/leetcode-7/"},{"categories":["Leetcode"],"content":"543-二叉树的直径 题目: 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 解题思路: 深度优先遍历,在节点遍历过程中,进行比较max以及left+right的值 int diameterOfBinaryTree(struct TreeNode* root){ int max = 0; if(root == NULL){ return 0; } depth(root, \u0026max); //max取地址,递归遍历过程一直比较 return max; } int depth(struct TreeNode* root, int *max){ if(root == NULL){ return 0; } else{ int depthleft = depth(root-\u003eleft,max); int depthright = depth(root-\u003eright,max); int sum = depthleft + depthright; if(sum \u003e *max){ *max = sum; } return depthleft \u003e depthright ? depthleft+1 : depthright+1; } } ","date":"2020-05-16","objectID":"/posts/leetcode-7/:5:0","tags":["Leetcode-C++"],"title":"Leetcode Part-7","uri":"/posts/leetcode-7/"},{"categories":["C语言"],"content":"史上最全 标准库\u003cstdlib.h\u003e ","date":"2020-05-15","objectID":"/posts/C-9/:0:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"calloc void *calloc(unsigned n,unsigned size) 功能:分配n个数据项的内存空间，每个数据项的大小为size个字节 返回:分配内存单元的起始地址；如不成功，返回0 ","date":"2020-05-15","objectID":"/posts/C-9/:1:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"free void *free(void *p) 功能:释放p所指的内存区 返回:无 ","date":"2020-05-15","objectID":"/posts/C-9/:2:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"malloc void *malloc(unsigned size) 功能:分配size个字节的存储空间 返回:分配内存空间的地址；如不成功，返回0 ","date":"2020-05-15","objectID":"/posts/C-9/:3:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"realloc void *realloc(void *p,unsigned size) 功能:把p所指内存区的大小改为size个字节 返回:新分配内存空间的地址；如不成功，返回0 ","date":"2020-05-15","objectID":"/posts/C-9/:4:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"rand int rand(void) 功能:产生0～32767的随机整数 返回:返回一个随机整数 ","date":"2020-05-15","objectID":"/posts/C-9/:5:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"exit void exit(int state) 功能:程序终止执行，返回调用过程，state为0正常终止，非0非正常终止 返回:无 字符串库\u003cstring.h\u003e ","date":"2020-05-15","objectID":"/posts/C-9/:6:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"字符串操作 ","date":"2020-05-15","objectID":"/posts/C-9/:7:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"strcat char *strcat(char *s1,char *s2) 功能:把字符串s2接到s1后面 返回:s1所指地址 ","date":"2020-05-15","objectID":"/posts/C-9/:7:1","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"strchr char *strchr(char *s,int ch) 功能:在s所指字符串中，找出第一次出现字符ch的位置 返回:返回找到的字符的地址，找不到返回NULL ","date":"2020-05-15","objectID":"/posts/C-9/:7:2","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"strcmp int strcmp(char *s1,char *s2) 功能:对s1和s2所指字符串进行比较 返回:s1小于s2,返回负数；s1相等s2,返回0；s1大于s2,返回正数 ","date":"2020-05-15","objectID":"/posts/C-9/:7:3","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"strcpy char *strcpy(char *s1,char *s2) 功能:把s2指向的串复制到s1指向的空间 返回:s1 所指地址 ","date":"2020-05-15","objectID":"/posts/C-9/:7:4","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"strlen unsigned strlen(char *s) 功能:求字符串s的长度 返回:返回串中字符（不计最后的’\\0’）个数 ","date":"2020-05-15","objectID":"/posts/C-9/:7:5","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"strstr char *strstr(char *s1,char *s2) 功能:在s1所指字符串中，找出字符串s2第一次出现的位置 返回:返回找到的字符串的地址，找不到返回NULL ","date":"2020-05-15","objectID":"/posts/C-9/:7:6","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"存储区操作 参数s的类型是(void *)，cs和ct的类型是(const void *)，n的类型是size_t，c的类型是int（转换为unsigned char）。 ","date":"2020-05-15","objectID":"/posts/C-9/:8:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"memset void *memset(s,c,n) 将s的前n个字符设置为c，返回s ","date":"2020-05-15","objectID":"/posts/C-9/:8:1","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"memcpy void *memcpy(s,ct,n) 从ct处复制n个字符到s处，返回s ","date":"2020-05-15","objectID":"/posts/C-9/:8:2","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"memcmp int memcmp(cs,ct,n) 比较由cs和ct开始的n个字符，返回值定义同strcmp ","date":"2020-05-15","objectID":"/posts/C-9/:8:3","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"memmove void *memmove(s,ct,n) 从ct处复制n个字符到s处，返回s，这里的两个段允许重叠 ","date":"2020-05-15","objectID":"/posts/C-9/:8:4","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"memchr void *memchr(cs,c,n) 在n个字符的范围内查寻c在cs中的第一次出现，如果找到，返回该位置的指针值，否则返回NULL ","date":"2020-05-15","objectID":"/posts/C-9/:8:5","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"memcmp与strcmp的区别 ","date":"2020-05-15","objectID":"/posts/C-9/:9:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"memcmp原型 int memcmp(const void *buf1, const void *buf2, unsigned int count); 功能:比较内存区域buf1和buf2的前count个字节。 返回值 当buf1 \u003c buf2时，返回值\u003c0 当buf1==buf2时，返回值=0 当buf1 \u003e buf2时，返回值\u003e0 说明 该函数是按字节比较的。 举例: s1,s2为字符串时候memcmp(s1,s2,1)就是比较s1和s2的第一个字节的ascII码值； memcmp(s1,s2,n)就是比较s1和s2的前n个字节的ascII码值； 如:char *s1=“abc”; char *s2=“acd”; int r=memcmp(s1,s2,3); 就是比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了。所以r=-1 ","date":"2020-05-15","objectID":"/posts/C-9/:9:1","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"区别 对于memcmp()，如果两个字符串相同而且count大于字符串长度的话，memcmp不会在\\0处停下来，会继续比较\\0后面的内存单元，直到_res不为零或者达到count次数。 对于strncmp()，由于((__res = *cs - *ct++) != 0 || !*cs++)的存在，比较必定会在最短的字符串的末尾停下来，即使count还未为零。 具体的例子： char a1[]=“ABCD”; char a2[]=“ABCD”; 对于memcmp(a1,a2,10)，memcmp在两个字符串的\\0之后继续比较 对于strncmp(a1,a2,10），strncmp在两个字符串的末尾停下，不再继续比较。 所以，如果想使用memcmp比较字符串，要保证count不能超过最短字符串的长度，否则结果有可能是错误的。 ","date":"2020-05-15","objectID":"/posts/C-9/:9:2","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"strcpy和memcpy的区别 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符\"\\0\"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy 输入输出函数\u003cstdio.h\u003e ","date":"2020-05-15","objectID":"/posts/C-9/:10:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"文件操作 ","date":"2020-05-15","objectID":"/posts/C-9/:11:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fopen FILE *fopen(char *filename,char *mode) 功能:以mode指定的方式打开名为filename的文件 返回:成功，返回文件指针（文件信息区的起始地址），否则返回NULL ","date":"2020-05-15","objectID":"/posts/C-9/:11:1","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fclose int fclose(FILE *fp) 功能:关闭fp所指的文件，释放文件缓冲区 返回:出错返回非0，否则返回0 ","date":"2020-05-15","objectID":"/posts/C-9/:11:2","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"feof int feof (FILE *fp) 功能:检查文件是否结束 返回:遇文件结束返回非0，否则返回0 ","date":"2020-05-15","objectID":"/posts/C-9/:11:3","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"clearer void clearer(FILE *fp) 功能:清除与文件指针fp有关的所有出错信息 返回:无 ","date":"2020-05-15","objectID":"/posts/C-9/:11:4","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"rename int rename(char *oldname,char *newname) 功能:把oldname所指文件名改为newname所指文件名 返回:成功返回0，出错返回-1 ","date":"2020-05-15","objectID":"/posts/C-9/:11:5","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"GET ","date":"2020-05-15","objectID":"/posts/C-9/:12:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"getc int getc (FILE *fp) 功能:从fp所指文件中读取一个字符 返回:返回所读字符，若出错或文件结束返回EOF ","date":"2020-05-15","objectID":"/posts/C-9/:12:1","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fgetc int fgetc (FILE *fp) 功能:从fp所指的文件中取得下一个字符 返回:出错返回EOF，否则返回所读字符 ","date":"2020-05-15","objectID":"/posts/C-9/:12:2","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fgets char *fgets(char *buff,int n, FILE *fp) 功能:从fp所指的文件中读取一个长度为n-1的字符串，将其存入buff所指存储区 返回:返回buf所指地址，若遇文件结束或出错返回NULL ","date":"2020-05-15","objectID":"/posts/C-9/:12:3","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"getchar int getchar(void) 功能:从标准输入设备读取下一个字符 返回:返回所读字符，若出错或文件结束返回-1 ","date":"2020-05-15","objectID":"/posts/C-9/:12:4","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"gets char *gets(char *s) 功能:从标准设备读取一行字符串放入s所指存储区，用’\\0’替换读入的换行符 返回:返回s,出错返回NULL ","date":"2020-05-15","objectID":"/posts/C-9/:12:5","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"PUT ","date":"2020-05-15","objectID":"/posts/C-9/:13:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"putc int putc (int ch, FILE *fp) 功能:同fputc 返回:同fputc ","date":"2020-05-15","objectID":"/posts/C-9/:13:1","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fputc int fputc(char ch, FILE *fp) 功能:把ch中字符输出到fp指定的文件中 返回:成功返回该字符，否则返回EOF ","date":"2020-05-15","objectID":"/posts/C-9/:13:2","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fputs int fputs(char *str, FILE *fp) 功能:把str所指字符串输出到fp所指文件 返回:成功返回非负整数，否则返回-1（EOF） ","date":"2020-05-15","objectID":"/posts/C-9/:13:3","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"putchar int putchar(char ch) 功能:把ch输出到标准输出设备 返回:返回输出的字符，若出错则返回EOF ","date":"2020-05-15","objectID":"/posts/C-9/:13:4","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"puts int puts(char *str) 功能:把str所指字符串输出到标准设备，将’\\0’转成回车换行符 返回:返回换行符，若出错，返回EOF ","date":"2020-05-15","objectID":"/posts/C-9/:13:5","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"输入 ","date":"2020-05-15","objectID":"/posts/C-9/:14:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"scanf int scanf(char *format,args,…) 功能:从标准输入设备按format指定的格式把输入数据存入到args,…所指的内存中 返回:已输入的数据的个数 ","date":"2020-05-15","objectID":"/posts/C-9/:14:1","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fscanf int fscanf (FILE *fp, char *format,args,…) 功能:从fp所指的文件中按format指定的格式把输入数据存入到args,…所指的内存中 返回:已输入的数据个数，遇文件结束或出错返回0 ","date":"2020-05-15","objectID":"/posts/C-9/:14:2","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"输出 ","date":"2020-05-15","objectID":"/posts/C-9/:15:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"printf int printf(char *format,args,…) 功能:把args,…的值以format指定的格式输出到标准输出设备 返回:输出字符的个数 ","date":"2020-05-15","objectID":"/posts/C-9/:15:1","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fprintf int fprintf(FILE *fp, char *format, args,…) 功能:把args,…的值以format指定的格式输出到fp指定的文件中 返回:实际输出的字符数 ","date":"2020-05-15","objectID":"/posts/C-9/:15:2","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"文件读写 ","date":"2020-05-15","objectID":"/posts/C-9/:16:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fread int fread(char *pt,unsigned size,unsigned n, FILE *fp) 功能:从fp所指文件中读取长度size为n个数据项存到pt所指文件 返回:读取的数据项个数 ","date":"2020-05-15","objectID":"/posts/C-9/:16:1","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fwrite int fwrite(char *pt,unsigned size,unsigned n, FILE *fp) 功能:把pt所指向的n*size个字节输入到fp所指文件 返回:输出的数据项个数 ","date":"2020-05-15","objectID":"/posts/C-9/:16:2","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"文件指针操作 ","date":"2020-05-15","objectID":"/posts/C-9/:17:0","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"fseek int fseek (FILE *fp,long offer,int base) 功能:移动fp所指文件的位置指针 返回:成功返回当前位置，否则返回非0 ","date":"2020-05-15","objectID":"/posts/C-9/:17:1","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"ftell long ftell (FILE *fp) 功能:求出fp所指文件当前的读写位置 返回:读写位置，出错返回 -1L ","date":"2020-05-15","objectID":"/posts/C-9/:17:2","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"rewind void rewind(FILE *fp) 功能:将文件位置指针置于文件开头 返回:无 ","date":"2020-05-15","objectID":"/posts/C-9/:17:3","tags":["C-语法基础"],"title":"C常用库函数整理","uri":"/posts/C-9/"},{"categories":["C语言"],"content":"C内存管理,C命令行参数 C内存管理 void calloc(int num, int size); 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 numsize 个字节长度的内存空间，并且每个字节的值都是0。 void free(void *address); 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 void *malloc(int num); 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 void *realloc(void *address, int newsize); 该函数重新分配内存，把内存扩展到 newsize。 void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。 ","date":"2020-05-15","objectID":"/posts/C-8/:0:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-5","uri":"/posts/C-8/"},{"categories":["C语言"],"content":"重新调整内存的大小和释放内存 当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 free() 来释放内存。 或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e int main() { char name[100]; char *description; strcpy(name, \"Zara Ali\"); /* 动态分配内存 */ description = (char *)malloc( 30 * sizeof(char) ); if( description == NULL ) { fprintf(stderr, \"Error - unable to allocate required memory\\n\"); } else { strcpy( description, \"Zara ali a DPS student.\"); } /* 假设您想要存储更大的描述信息 */ description = (char *) realloc( description, 100 * sizeof(char) ); if( description == NULL ) { fprintf(stderr, \"Error - unable to allocate required memory\\n\"); } else { strcat( description, \"She is in class 10th\"); } printf(\"Name = %s\\n\", name ); printf(\"Description: %s\\n\", description ); /* 使用 free() 函数释放内存 */ free(description); } 当上面的代码被编译和执行时，它会产生下列结果： Name = Zara Ali Description: Zara ali a DPS student.She is in class 10th C命令行参数 执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。 命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作： #include \u003cstdio.h\u003e int main( int argc, char *argv[] ) { if( argc == 2 ) { printf(\"The argument supplied is %s\\n\", argv[1]); } else if( argc \u003e 2 ) { printf(\"Too many arguments supplied.\\n\"); } else { printf(\"One argument expected.\\n\"); } } 使用一个参数，编译并执行上面的代码，它会产生下列结果： $./a.out testing The argument supplied is testing 使用两个参数，编译并执行上面的代码，它会产生下列结果： $./a.out testing1 testing2 Too many arguments supplied. 不传任何参数，编译并执行上面的代码，它会产生下列结果： $./a.out One argument expected 应当指出的是，argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2。 多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 \"\" 或单引号 ’’ 内部。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号\"\"\"\"。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数： #include \u003cstdio.h\u003e int main( int argc, char *argv[] ) { printf(\"Program name %s\\n\", argv[0]); if( argc == 2 ) { printf(\"The argument supplied is %s\\n\", argv[1]); } else if( argc \u003e 2 ) { printf(\"Too many arguments supplied.\\n\"); } else { printf(\"One argument expected.\\n\"); } } 使用一个用空格分隔的简单参数，参数括在双引号中，编译并执行上面的代码，它会产生下列结果： $./a.out \"testing1 testing2\" Progranm name ./a.out The argument supplied is testing1 testing2 ","date":"2020-05-15","objectID":"/posts/C-8/:1:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-5","uri":"/posts/C-8/"},{"categories":["C语言"],"content":"C头文件,C强制类型转换,C错误处理,C可变参数 C头文件 头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。 在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。前面我们已经看过 stdio.h 头文件，它是编译器自带的头文件。 引用头文件相当于复制头文件的内容 使用预处理指令 #include 可以引用用户和系统头文件。它的形式有以下两种： #include \u003cfile\u003e 这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。 #include \"file\" 这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。 ","date":"2020-05-15","objectID":"/posts/C-7/:0:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"引用头文件的操作 #include 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 #include 指令之后的文本输出。例如，如果您有一个头文件 header.h，如下： char *test (void); 和一个使用了头文件的主程序 program.c，如下： int x; #include \"header.h\" int main (void) { puts (test ()); } 编译器会看到如下的代码信息： int x; char *test (void); int main (void) { puts (test ()); } ","date":"2020-05-15","objectID":"/posts/C-7/:1:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"只引用一次头文件 如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下： #ifndef HEADER_FILE #define HEADER_FILE #endif 这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。 ","date":"2020-05-15","objectID":"/posts/C-7/:2:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"有条件引用 有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下： #if SYSTEM_1 # include \"system_1.h\" #elif SYSTEM_2 # include \"system_2.h\" #elif SYSTEM_3 ... #endif C强制类型转换 (type_name) expression #include \u003cstdio.h\u003eint main() { int sum = 17, count = 5; double mean; mean = (double) sum / count; printf(\"Value of mean : %f\\n\", mean ); } 当上面的代码被编译和执行时，它会产生下列结果： Value of mean : 3.400000 这里要注意的是强制类型转换运算符的优先级大于除法，因此 sum 的值首先被转换为 double 型，然后除以 count，得到一个类型为 double 的值。 类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用强制类型转换运算符来指定。在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。 ","date":"2020-05-15","objectID":"/posts/C-7/:3:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"整数提升 整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。请看下面的实例，在 int 中添加一个字符： #include \u003cstdio.h\u003eint main() { int i = 17; char c = 'c'; /* ascii 值是 99 */ int sum; sum = i + c; printf(\"Value of sum : %d\\n\", sum ); } 当上面的代码被编译和执行时，它会产生下列结果： Value of sum : 116 在这里，sum 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 ‘c’ 的值转换为对应的 ascii 值。 C错误处理 C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。 所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。 ","date":"2020-05-15","objectID":"/posts/C-7/:4:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"errno、perror() 和 strerror() C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。 perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。 strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。 让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用stderr 文件流来输出所有的错误。 #include \u003cstdio.h\u003e#include \u003cerrno.h\u003e#include \u003cstring.h\u003eextern int errno ; int main () { FILE * pf; int errnum; pf = fopen (\"unexist.txt\", \"rb\"); if (pf == NULL) { errnum = errno; fprintf(stderr, \"错误号: %d\\n\", errno); perror(\"通过 perror 输出错误\"); fprintf(stderr, \"打开文件错误: %s\\n\", strerror( errnum )); } else { fclose (pf); } return 0; } ","date":"2020-05-15","objectID":"/posts/C-7/:5:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"sprintf、fprintf和printf 都是把格式好的字符串输出，但是输出的目标不一样： printf就是标准输出，在屏幕上打印出一段字符串来。 sprintf就是把格式化的数据写入到某个字符串中。返回值字符串的长度。 fprintf是用于文件操作。 原型：int fprintf(FILE *stream,char *format,[argument])； 功能：fprintf()函数根据指定的format(格式)发送信息(参数)到由stream(流)指定的文件.因此fprintf()可以使得信息输出到指定的文件。 ","date":"2020-05-15","objectID":"/posts/C-7/:5:1","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"stderr和stdout的区别 stdout – 标准输出设备。 stderr – 标准错误输出设备 两者默认向屏幕输出,但如果用转向标准输出到磁盘文件，stdout输出到磁盘文件，stderr在屏幕。 stdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出 int main(){ fprintf(stdout,\"Hello \"); fprintf(stderr,\"World!\"); return0; } 输出结果为: World!Hello printf(stdout, “xxxx”) 和 printf(stdout, “xxxx\\n”)，前者会憋住，直到遇到新行才会一起输出。而printf(stderr, “xxxxx”)，不管有么有’\\n’，都输出。 ","date":"2020-05-15","objectID":"/posts/C-7/:5:2","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"exit()和return exit（0）：正常运行程序并退出程序； exit（1）：非正常运行导致退出程序； return（）：返回函数，若在主函数中，则会退出函数并返回一值。 return返回函数值，是关键字;exit 是一个函数。 return是C语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示了一个进程的结束。 return是函数的退出(返回)；exit是进程的退出。 return是C语言提供的，exit是操作系统提供的（或者函数库中给出的）。 return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出，非0 为非正常退出。 非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。 ","date":"2020-05-15","objectID":"/posts/C-7/:5:3","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"程序退出状态 通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。 如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。 (个人认为这是一种增加代码可读性的行为) 上面的程序可以写成： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003emain() { int dividend = 20; int divisor = 5; int quotient; if( divisor == 0){ fprintf(stderr, \"除数为 0 退出运行...\\n\"); exit(EXIT_FAILURE); } quotient = dividend / divisor; fprintf(stderr, \"quotient 变量的值为: %d\\n\", quotient ); exit(EXIT_SUCCESS); } C可变参数 int func(int, ... ) { ... } int main() { func(2, 2, 3); func(3, 2, 3, 4); } 函数 func() 最后一个参数写成省略号，即三个点号（…），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用stdarg.h头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下： 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。 在函数定义中创建一个va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。 使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是 在 stdarg.h 头文件中定义的。 使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。 使用宏 va_end 清理赋予 va_list 变量的内存。 va_start宏，获取可变参数列表的第一个参数的地址（list是类型为va_list的指针，param1是可变参数最左边的参数）： #define va_start(list,param1) ( list = (va_list)\u0026param1+ sizeof(param1) ) va_arg宏，获取可变参数的当前参数，返回指定类型并将指针指向下一参数（mode参数描述了当前参数的类型）： #define va_arg(list,mode) ( (mode *) ( list += sizeof(mode) ) )[-1] va_end宏，清空va_list可变参数列表： #define va_end(list) ( list = (va_list)0 ) ","date":"2020-05-15","objectID":"/posts/C-7/:6:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"实例 ","date":"2020-05-15","objectID":"/posts/C-7/:7:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"传入int #include \u003cstdio.h\u003e#include \u003cstdarg.h\u003e double average(int num,...) { va_list valist; double sum = 0.0; int i; /* 为 num 个参数初始化 valist */ va_start(valist, num); /* 访问所有赋给 valist 的参数 */ for (i = 0; i \u003c num; i++) { sum += va_arg(valist, int); } /* 清理为 valist 保留的内存 */ va_end(valist); return sum/num; } int main() { printf(\"Average of 2, 3, 4, 5 = %f\\n\", average(4, 2,3,4,5)); printf(\"Average of 5, 10, 15 = %f\\n\", average(3, 5,10,15)); } 输出以下结果 Average of 2, 3, 4, 5 = 3.500000 Average of 5, 10, 15 = 10.000000 ","date":"2020-05-15","objectID":"/posts/C-7/:7:1","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"传入字符串 #include \u003cstdio.h\u003e#include \u003cstdarg.h\u003e void var_test(char *format, ...) { va_list list; va_start(list,format); char *ch; while(1) { ch = va_arg(list, char *); if(strcmp(ch,\"\") == 0) { printf(\"\\n\"); break; } printf(\"%s \",ch); } va_end(list); } int main() { var_test(\"test\",\"this\",\"is\",\"a\",\"test\",\"\"); return 0; } ","date":"2020-05-15","objectID":"/posts/C-7/:7:2","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["C语言"],"content":"可变参数应用实例 printf实现 #include \u003cstdarg.h\u003eint printf(char *format, ...) { va_list ap; int n; va_start(ap, format); n = vprintf(format, ap); va_end(ap); return n; } ","date":"2020-05-15","objectID":"/posts/C-7/:8:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-4","uri":"/posts/C-7/"},{"categories":["Ubuntu"],"content":"昨天折腾了一晚上,过程很是艰难,不过还好最后配置成功了,将onedrive挂载上了 使用到一个开源的软件\"rclone\",英文文档好难读…而且感觉写的还很复杂,最后在一些大佬写的blog帮助下终于配置成功 rclone官网 版本号: Ubuntu20.04 rclone v1.51.0 onedrive 个人版 命令行安装 官方安装文档 sudo curl https://rclone.org/install.sh | sudo bash 也可以下载deb安装包 配置 ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"获得onedrive授权 weixusheng@weixusheng-ThinkPad-S5:~$ sudo rclone authorize \"onedrive\" 2020/05/14 19:55:04 NOTICE: Config file \"/home/weixusheng/.config/rclone/rclone.conf\" not found - using defaults If your browser doesn't open automatically go to the following link: http://127.0.0.1:53682/auth?state=1PaeHX9ECA6DpqWDET_6Gw Log in and authorize rclone for access Waiting for code... Got code Paste the following into your remote machine ---\u003e {\"access_token\":\"*****\"} #得到授权码 \u003c---End paste ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:1:0","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"填写配置文件 ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:2:0","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"新建 weixusheng@weixusheng-ThinkPad-S5:~$ sudo rclone config No remotes found - make a new one n) New remote s) Set configuration password q) Quit config n/s/q\u003e n ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:2:1","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"命名 name\u003e one-drive ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:2:2","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"选择类型 Type of storage to configure. Enter a string value. Press Enter for the default (\"\"). Choose a number from below, or type in your own value 1 / 1Fichier \\ \"fichier\" 2 / Alias for an existing remote \\ \"alias\" 3 / Amazon Drive \\ \"amazon cloud drive\" .....省略..... 23 / Microsoft OneDrive \\ \"onedrive\" Storage\u003e 23 ** See help for onedrive backend at: https://rclone.org/onedrive/ ** ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:2:3","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"填写client_id和client_secret 直接enter跳过 Microsoft App Client Id Leave blank normally. Enter a string value. Press Enter for the default (\"\"). client_id\u003e Microsoft App Client Secret Leave blank normally. Enter a string value. Press Enter for the default (\"\"). client_secret\u003e ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:2:4","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"advanced config及auto config 选择no Edit advanced config? (y/n) y) Yes n) No (default) y/n\u003e n Remote config Use auto config? * Say Y if not sure * Say N if you are working on a remote or headless machine y) Yes (default) n) No y/n\u003e n ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:2:5","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"填写token For this to work, you will need rclone available on a machine that has a web browser available. Execute the following on your machine (same rclone version recommended) : rclone authorize \"onedrive\" Then paste the result below: result\u003e {\"access_token\":\"*****\"} ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:2:6","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"选择onedrive中的服务 Choose a number from below, or type in an existing value 1 / OneDrive Personal or Business \\ \"onedrive\" 2 / Root Sharepoint site \\ \"sharepoint\" 3 / Type in driveID \\ \"driveid\" 4 / Type in SiteID \\ \"siteid\" 5 / Search a Sharepoint site \\ \"search\" Your choice\u003e 1 Found 1 drives, please select the one you want to use: 0: (personal) id=22994754919d54cc Chose drive to use:\u003e 0 Found drive 'root' of type 'personal', URL: https://onedrive.live.com/?cid=22994754919d54cc Is that okay? y) Yes (default) n) No y/n\u003e y ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:2:7","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"成功生成配置文件 -------------------- [tronwei] type = onedrive token = {\"*****\"} drive_id = 22994754919d54cc drive_type = personal -------------------- y) Yes this is OK (default) e) Edit this remote d) Delete this remote y/e/d\u003e y 完成配置 挂载 ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:2:8","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"新建文件夹(挂载的目标文件夹) #新建本地文件夹，路径自己定，即下面的LocalFolder sudo mkdir /root/OneDrive ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:3:0","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"挂载为磁盘 #DriveName、Folder、LocalFolder参数根据说明自行替换 sudo rclone mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000 DriveName为初始化配置填的name Folder为OneDrive里的文件夹(可以为根目录’/') LocalFolder为本地文件夹。 举例 sudo rclone mount one-drive:/ /home/onedrive --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000 挂载成功后，输入df -h命令查看即可！ weixusheng@weixusheng-ThinkPad-S5:~$ df -h 文件系统 容量 已用 可用 已用% 挂载点 /dev/sdb8 123G 34G 83G 30% / one-drive: 1.1T 113G 927G 11% /home/onedrive systemctl开机自启rclone挂载 ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:4:0","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"安装systemctl sudo apt install systemd-sysv \u0026\u0026 reboot ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:5:0","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"新建service文件 进入systemd目录(/etc/systemd/system)，创建文件rclone.service sudo gedit rclone.service 填写以下 [Unit] Description=rclone [Service] User=root ExecStart=sudo rclone mount one-drive:/ /home/onedrive --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000 Restart=on-abort [Install] WantedBy=multi-user.target 保存退出 ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:6:0","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Ubuntu"],"content":"systemctl命令 开机自启： systemctl enable rclone 启动： systemctl start rclone 重启： systemctl restart rclone 停止： systemctl stop rclone 状态： systemctl status rclone 上传与下载 将文件复制到网盘中为上传 从网盘复制文件到本地为下载 至此重启电脑就会发现,网盘已挂载 rclone还有很多命令,由于现在是图形界面环境,所以先解决了能不能用的问题 命令慢慢学,以后再更新 参考blog-1 参考blog-2 ","date":"2020-05-15","objectID":"/posts/ubuntu-21/:7:0","tags":["Linux-Ubuntu"],"title":"Ubuntu挂载Onedrive","uri":"/posts/ubuntu-21/"},{"categories":["Leetcode"],"content":"136-只出现一次的数字 ","date":"2020-05-14","objectID":"/posts/leetcode-6/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-6","uri":"/posts/leetcode-6/"},{"categories":["Leetcode"],"content":"136-只出现一次的数字 题目: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 解题思路: 使用数组建立哈希表,线性时间复杂度-\u003e初始化哈希表,赋值哈希表,查找哈希表 int singleNumber(int* nums, int numsSize){ if(numsSize == 1) return nums[0]; int i = 0; int max = nums[0]; int min = nums[0]; for(i = 0; i\u003cnumsSize; i++) //找到最大最小的元素,作为哈希表的开头和结尾 { max = max \u003e nums[i]? max:nums[i]; min = min \u003c nums[i]? min:nums[i]; } max = max-min+1; int a[max]; //建立哈希表 memset(a,0,sizeof(int)*(max)); //初始化哈希表为0 for(i = 0; i\u003cnumsSize; i++) { a[nums[i]-min] += 1; //将nums中元素的值作为a中的下标,并且将其+1 } for(i = 0; i \u003c numsSize; i++) { if(a[nums[i]-min] == 1) //寻找只为1的元素,该元素为出现一次的元素 { return nums[i]; } } return 0; } ","date":"2020-05-14","objectID":"/posts/leetcode-6/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-6","uri":"/posts/leetcode-6/"},{"categories":["vscode"],"content":"今天学c的时候,看到预处理命令#pragma,想起来之前用的代码折叠 既然创建了vscode专区,就把之前的技巧放在这里,方便查找 ","date":"2020-05-14","objectID":"/posts/vscode-2/:0:0","tags":["vscode"],"title":"VScode代码折叠","uri":"/posts/vscode-2/"},{"categories":["vscode"],"content":"vscode构造折叠块 #pragma region \"折叠块的名字\" //your code here #pragma endregion ","date":"2020-05-14","objectID":"/posts/vscode-2/:1:0","tags":["vscode"],"title":"VScode代码折叠","uri":"/posts/vscode-2/"},{"categories":["vscode"],"content":"vscode 代码折叠 1. 折叠所有区域代码的快捷： ctrl + k ctrl + 0 ; 先按下 ctrl 和 K，再按下 ctrl 和 0 ; ( 注意这个是零，不是欧 ) 2. 展开所有折叠区域代码的快捷： ctrl +k ctrl + J ; 先按下 ctrl 和 K，再按下 ctrl 和 J ","date":"2020-05-14","objectID":"/posts/vscode-2/:2:0","tags":["vscode"],"title":"VScode代码折叠","uri":"/posts/vscode-2/"},{"categories":["C语言"],"content":"typedef与#define,C输入\u0026输出,C文件读写,C预处理器 typedef 与 #define typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。 typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。 #include \u003cstdio.h\u003e#define TRUE 1 #define FALSE 0 int main( ) { printf( \"TRUE 的值: %d\\n\", TRUE); printf( \"FALSE 的值: %d\\n\", FALSE); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： TRUE 的值: 1 FALSE 的值: 0 C 输入 \u0026 输出 值得注意的是: %f和%lf分别是float类型和double类型用于格式化输入输出时对应的格式符号。 其中： float，单精度浮点型，对应%f。 double,双精度浮点型，对应%lf。 ","date":"2020-05-14","objectID":"/posts/C-6/:0:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"getchar() \u0026 putchar() 函数 int getchar(void) 函数 从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。 int putchar(int c) 函数 把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。 ","date":"2020-05-14","objectID":"/posts/C-6/:1:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"ets() \u0026 puts() 函数 char *gets(char *s) 函数 从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或EOF。 int puts(const char *s) 函数 把字符串 s 和一个尾随的换行符写入到 stdout。 #include \u003cstdio.h\u003eint main( ) { char str[100]; printf( \"Enter a value :\"); gets( str ); printf( \"\\nYou entered: \"); puts( str ); return 0; } 当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下： $./a.out Enter a value :runoob You entered: runoob C 文件读写 ","date":"2020-05-14","objectID":"/posts/C-6/:2:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"打开文件 您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。 FILE *fopen( const char * filename, const char * mode ); filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个： r 打开一个已有的文本文件，允许读取文件。 w 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 a 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 r+ 打开一个文本文件，允许读写文件。 w+ 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 a+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式： \"rb\", \"wb\", \"ab\", \"rb+\", \"r+b\", \"wb+\", \"w+b\", \"ab+\", \"a+b\" ","date":"2020-05-14","objectID":"/posts/C-6/:3:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"关闭文件 为了关闭文件，请使用 fclose( ) 函数。函数的原型如下： int fclose( FILE *fp ); 如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。 C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。 ","date":"2020-05-14","objectID":"/posts/C-6/:4:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"写入文件 下面是把字符写入到流中的最简单的函数： int fputc( int c, FILE *fp ); 函数 fputc() 把参数c的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中： int fputs( const char *s, FILE *fp ); 函数 fputs() 把字符串s写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中 ","date":"2020-05-14","objectID":"/posts/C-6/:5:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"实例 #include \u003cstdio.h\u003eint main() { FILE *fp = NULL; fp = fopen(\"/tmp/test.txt\", \"w+\"); fprintf(fp, \"This is testing for fprintf...\\n\"); fputs(\"This is testing for fputs...\\n\", fp); fclose(fp); } ","date":"2020-05-14","objectID":"/posts/C-6/:5:1","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"读取文件 下面是从文件读取单个字符的最简单的函数： int fgetc( FILE * fp ); fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。 char *fgets( char *buf, int n, FILE *fp ); 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。 如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。 int fscanf(FILE *fp, const char *format, …) 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。 ","date":"2020-05-14","objectID":"/posts/C-6/:6:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"实例 #include \u003cstdio.h\u003eint main() { FILE *fp = NULL; char buff[255]; fp = fopen(\"/tmp/test.txt\", \"r\"); fscanf(fp, \"%s\", buff); printf(\"1: %s\\n\", buff ); fgets(buff, 255, (FILE*)fp); printf(\"2: %s\\n\", buff ); fgets(buff, 255, (FILE*)fp); printf(\"3: %s\\n\", buff ); fclose(fp); } 首先，fscanf() 方法只读取了 This，因为它在后边遇到了一个空格(遇到空格停止读取)。其次，调用 fgets() 读取剩余的部分，直到行尾。(遇到换行符结束读取) 最后调用 fgets() 完整地读取第二行。 ","date":"2020-05-14","objectID":"/posts/C-6/:6:1","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"EOF的定义 EOF为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。通常在文本的最后存在此字符表示资料结束。 从一个终端的输入从来不会真的“结束”（除非设备被断开），但把从终端输入的数据分区成多个“文件”却很有用，因此一个关键的序列被保留下来来指明输入结束。 在UNIX和AmigaDOS中，将击键翻译为EOF的过程是由终端的驱动程序完成的，因此应用程序无需将终端和其它输入文件区分开来。Unix平台的驱动程序在行首传送一个传输结束字符（Control-D，ASCII编码为为04）来指明文件结束。 在微软的DOS和Windows（以及CP/M和许多DEC操作系统）中，读取数据时终端不会产生EOF。此时，应用程序知道数据源是一个终端（或者其它“字符设备”），并将一个已知的保留的字符或序列解释为文件结束的指明；最普遍地说，它是ASCII码中的替换字符（Control-Z，代码26） C 预处理器 C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP(然而我并没有看懂)。 所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令： #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else #if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器中 ","date":"2020-05-14","objectID":"/posts/C-6/:7:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"预处理器实例 #define MAX_ARRAY_LENGTH 20 这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 #define 定义常量来增强可读性。 #include \u003cstdio.h\u003e#include \"myheader.h\" 这些指令告诉 CPP 从系统库中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 myheader.h，并添加内容到当前的源文件中。 #undef FILE_SIZE #define FILE_SIZE 42 这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。 #ifndef MESSAGE #define MESSAGE \"You wish!\" #endif 这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。 #ifdef DEBUG /* Your debugging statements here */ #endif 这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。 ","date":"2020-05-14","objectID":"/posts/C-6/:8:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"预定义宏 ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。 DATE 当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。 TIME 当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。 FILE 这会包含当前文件名，一个字符串常量。 LINE 这会包含当前行号，一个十进制常量。 STDC 当编译器以 ANSI 标准编译时，则定义为 1。 ","date":"2020-05-14","objectID":"/posts/C-6/:9:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"实例 #include \u003cstdio.h\u003emain() { printf(\"File :%s\\n\", __FILE__ ); printf(\"Date :%s\\n\", __DATE__ ); printf(\"Time :%s\\n\", __TIME__ ); printf(\"Line :%d\\n\", __LINE__ ); printf(\"ANSI :%d\\n\", __STDC__ ); } 当上面的代码（在文件 test.c 中）被编译和执行时，它会产生下列结果： File :test.c Date :Jun 2 2012 Time :03:36:24 Line :8 ANSI :1 ","date":"2020-05-14","objectID":"/posts/C-6/:9:1","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"预处理器运算符 ","date":"2020-05-14","objectID":"/posts/C-6/:10:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"宏延续运算符（\\） 一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\\）。例如： #define message_for(a, b) \\ printf(#a \" and \" #b \": We love you!\\n\") ","date":"2020-05-14","objectID":"/posts/C-6/:10:1","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"字符串常量化运算符（#） 在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如： #include \u003cstdio.h\u003e#define message_for(a, b) \\ printf(#a \" and \" #b \": We love you!\\n\") int main(void) { message_for(Carole, Debra); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Carole and Debra: We love you! ","date":"2020-05-14","objectID":"/posts/C-6/:10:2","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"标记粘贴运算符（##） 宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如： #include \u003cstdio.h\u003e#define tokenpaster(n) printf (\"token\" #n \" = %d\", token##n) int main(void) { int token34 = 40; tokenpaster(34); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： token34 = 40 这是怎么发生的，因为这个实例会从编译器产生下列的实际输出： printf (\"token34 = %d\", token34); 这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。 ","date":"2020-05-14","objectID":"/posts/C-6/:10:3","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"defined() 运算符 预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法： #include \u003cstdio.h\u003e#if !defined (MESSAGE) #define MESSAGE \"You wish!\" #endif int main(void) { printf(\"Here is the message: %s\\n\", MESSAGE); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Here is the message: You wish! ","date":"2020-05-14","objectID":"/posts/C-6/:10:4","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"参数化的宏 CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方： int square(int x) { return x * x; } 我们可以使用宏重写上面的代码，如下： #define square(x) ((x) * (x)) 在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如： #include \u003cstdio.h\u003e#define MAX(x,y) ((x) \u003e (y) ? (x) : (y)) int main(void) { printf(\"Max between 20 and 10 is %d\\n\", MAX(10, 20)); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Max between 20 and 10 is 20 ","date":"2020-05-14","objectID":"/posts/C-6/:11:0","tags":null,"title":"C语言程序设计 Part-3","uri":"/posts/C-6/"},{"categories":["C语言"],"content":"指针,字符串,结构体,位域,共用体 C 中的 NULL 指针 在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。 NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序： #include \u003cstdio.h\u003eint main () { int *ptr = NULL; printf(\"ptr 的地址是 %p\\n\", ptr ); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： ptr 的地址是 0x0 在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。 如需检查一个空指针，您可以使用 if 语句，如下所示： if(ptr) /* 如果 p 非空，则完成 */ if(!ptr) /* 如果 p 为空，则完成 */ 函数指针 函数指针是指向函数的指针变量。 通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。 函数指针可以像一般函数一样，用于调用函数、传递参数。 函数指针变量的声明： typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型 实例 #include \u003cstdio.h\u003eint max(int x, int y) { return x \u003e y ? x : y; } int main(void) { /* p 是函数指针 */ int (* p)(int, int) = \u0026 max; // \u0026可以省略 int a, b, c, d; printf(\"请输入三个数字:\"); scanf(\"%d %d %d\", \u0026 a, \u0026 b, \u0026 c); /* 与直接调用函数等价，d = max(max(a, b), c) */ d = p(p(a, b), c); printf(\"最大的数字是: %d\\n\", d); return 0; } 输出结果: 请输入三个数字:1 2 3 最大的数字是: 3 回调函数 函数指针作为某个函数的参数 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。 简单讲：回调函数是由别人的函数执行时调用你实现的函数。 通俗理解 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。 官方定义: 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 形象解释: 比如，我们写A B C D 四个函数，封装成一个库文件，然后我们的主函数里面要写一个功能函数，这个功能要用到函数A，假如不用函数指针，这个功能函数就要调用函数A，下次如果用到函数B，那么我们得删掉A，调用函数B，每次都要修改这个函数很麻烦，但如果使用回调函数就不一样了，我们可以定义4个函数指针，把4个函数的地址分别赋给4个函数指针，然后将函数指针当作参数传递给功能函数，功能函数就可以通过修改参数来调用对应的函数，而它本身不用做任何的修改。这样的话，功能函数就可以根据不同的情况，通过函数指针去调用不同的函数，代码如下 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003efloat ADD(float a, float b) { return a + b; } float SUB(float a, float b) { return a - b; } float MUL(float a, float b) { return a * b; } float DIV(float a, float b) { return a / b; } float (*A)(float x, float y) = ADD; float (*B)(float x, float y) = SUB; float (*C)(float x, float y) = MUL; float (*D)(float x, float y) = DIV; float fun(float x, float y, float(*p)(float x, float y)) { return p(x, y); } int main() { printf(\"%f\", fun(2, 3, A)); } C 字符串 在 C 语言中，字符串实际上是使用 null 字符 ‘\\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 ","date":"2020-05-14","objectID":"/posts/C-5/:0:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-2","uri":"/posts/C-5/"},{"categories":["C语言"],"content":"C 中操作字符串的函数 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。 strlen(s1); 返回字符串 s1 的长度。 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1\u003cs2 则返回小于 0；如果 s1\u003es2 则返回大于 0。 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 C 结构体 ","date":"2020-05-14","objectID":"/posts/C-5/:1:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-2","uri":"/posts/C-5/"},{"categories":["C语言"],"content":"定义结构 为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： struct tag { member-list member-list member-list ... } variable-list ; tag 是结构体标签。 member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。 variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。 声明的结构变量,即已经实例化的变量 ","date":"2020-05-14","objectID":"/posts/C-5/:2:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-2","uri":"/posts/C-5/"},{"categories":["C语言"],"content":"结构体变量的初始化 和其它类型变量一样，对结构体变量可以在定义时指定初始值 #include \u003cstdio.h\u003estruct Books { char title[50]; char author[50]; char subject[100]; int book_id; } book = {\"C 语言\", \"RUNOOB\", \"编程语言\", 123456}; int main() { printf(\"title : %s\\nauthor: %s\\nsubject: %s\\nbook_id: %d\\n\", book.title, book.author, book.subject, book.book_id); } C位域 有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为\"位域\"或\"位段\"。 所谓\"位域\"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。 典型的实例： 用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。 读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。 ","date":"2020-05-14","objectID":"/posts/C-5/:3:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-2","uri":"/posts/C-5/"},{"categories":["C语言"],"content":"位域的定义和位域变量的说明 在结构内声明位域的形式如下： struct { type [member_name] : width ; }; type只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。 member_name 位域的名称。 width 位域中位的数量。宽度必须小于或等于指定类型的位宽度。 带有预定义宽度的变量被称为位域。位域可以存储多于 1 位的数，例如，需要一个变量来存储从0到7的值，您可以定义一个宽度为 3 位的位域，如下： struct { unsigned int age : 3; } Age; 上面的结构定义指示 C 编译器，age 变量将只使用 3 位来存储这个值，如果您试图使用超过 3 位，则无法完成 include \u003cstdio.h\u003e #include \u003cstring.h\u003estruct { unsigned int age : 3; } Age; int main( ) { Age.age = 4; printf( \"Sizeof( Age ) : %d\\n\", sizeof(Age) ); printf( \"Age.age : %d\\n\", Age.age ); Age.age = 7; printf( \"Age.age : %d\\n\", Age.age ); Age.age = 8; // 二进制表示为 1000 有四位，超出 printf( \"Age.age : %d\\n\", Age.age ); return 0; } 当上面的代码被编译时，它会带有警告，当上面的代码被执行时，它会产生下列结果： Sizeof( Age ) : 4 Age.age : 4 Age.age : 7 Age.age : 0 ","date":"2020-05-14","objectID":"/posts/C-5/:4:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-2","uri":"/posts/C-5/"},{"categories":["C语言"],"content":"实例: struct bs{ int a:8; int b:2; int c:6; }data; 说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。 ","date":"2020-05-14","objectID":"/posts/C-5/:4:1","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-2","uri":"/posts/C-5/"},{"categories":["C语言"],"content":"对于位域的定义尚有以下几点说明： 一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如： struct bs{ unsigned a:4; unsigned :4; /* 空域 */ unsigned b:4; /* 从下一单元开始存放 */ unsigned c:4 } 在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。 位域可以是无名位域，这时它只用来作填充或调整位置,无名的位域是不能使用的,例如： struct k{ int a:1; int :2; /* 该 2 位不能使用 */ int b:3; int c:2; }; 从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e/* 定义简单的结构 */ struct { unsigned int widthValidated; unsigned int heightValidated; } status1; /* 定义位域结构 */ struct { unsigned int widthValidated : 1; unsigned int heightValidated : 1; } status2; int main( ) { printf( \"Memory size occupied by status1 : %d\\n\", sizeof(status1)); printf( \"Memory size occupied by status2 : %d\\n\", sizeof(status2)); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Memory size occupied by status1 : 8 Memory size occupied by status2 : 4 C 共用体 共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。 ","date":"2020-05-14","objectID":"/posts/C-5/:4:2","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-2","uri":"/posts/C-5/"},{"categories":["C语言"],"content":"定义共用体 为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下： union [union tag] { member definition; member definition; ... member definition; } [one or more union variables]; union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str： union Data { int i; float f; char str[20]; } data; 现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。 共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。 ","date":"2020-05-14","objectID":"/posts/C-5/:5:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-2","uri":"/posts/C-5/"},{"categories":["C语言"],"content":"访问共用体成员 为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 union 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法： #include \u003cstdio.h\u003e#include \u003cstring.h\u003eunion Data { int i; float f; char str[20]; }; int main( ) { union Data data; data.i = 10; printf( \"data.i : %d\\n\", data.i); data.f = 220.5; printf( \"data.f : %f\\n\", data.f); strcpy( data.str, \"C Programming\"); printf( \"data.str : %s\\n\", data.str); return 0; } 产生以下结果 data.i : 10 data.f : 220.500000 data.str : C Programming ","date":"2020-05-14","objectID":"/posts/C-5/:6:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-2","uri":"/posts/C-5/"},{"categories":["C语言"],"content":"今天补习了一下c语言(重新再学习一遍c),毕竟基础要牢靠 也为了下一步刷PAT做基础,这里记录新得 今天心态又崩了…感觉一直以来自己就是一个快乐与崩溃的结合体 无尽的失落和失望,像是一个深渊,不过明天醒来又是新的一天 void 类型 函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。 小数类型 ","date":"2020-05-13","objectID":"/posts/C-4/:0:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"float类型 ","date":"2020-05-13","objectID":"/posts/C-4/:1:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"double类型 C 中的变量声明-extern声明 变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 变量的声明有两种情况： 一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。 另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。 除非有extern关键字，否则都是变量的定义。 extern int i; //声明，不是定义 int i; //声明，也是定义 实例 尝试下面的实例，其中，变量在头部就已经被声明，但是定义与初始化在主函数内： #include \u003cstdio.h\u003e// 函数外定义变量 x 和 y int x; int y; int addtwonum() { // 函数内声明变量 x 和 y 为外部变量 extern int x; extern int y; // 给外部变量（全局变量）x 和 y 赋值 x = 1; y = 2; return x+y; } int main() { int result; // 调用函数 addtwonum result = addtwonum(); printf(\"result 为: %d\",result); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： result 为: 3 如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。 addtwonum.c 文件代码： #include \u003cstdio.h\u003e/*外部变量声明*/ extern int x ; extern int y ; int addtwonum() { return x+y; } test.c 文件代码： #include \u003cstdio.h\u003e/*定义两个全局变量*/ int x=1; int y=2; int addtwonum(); int main(void) { int result; result = addtwonum(); printf(\"result 为: %d\\n\",result); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： $ gcc addtwonum.c test.c -o main $ ./main result 为: 3 C 常量 ","date":"2020-05-13","objectID":"/posts/C-4/:2:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"整数常量 整数常量可以是十进制、八进制或十六进制的常量。 前缀指定基数： 0x 或 0X 表示十六进制 0表示八进制 不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 85 /* 十进制 */ 0213 /* 八进制 */ 0x4b /* 十六进制 */ 30 /* 整数 */ 30u /* 无符号整数 */ 30l /* 长整数 */ 30ul /* 无符号长整数 */ ","date":"2020-05-13","objectID":"/posts/C-4/:3:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 3.14159 /* 合法的 */ 314159E-5L /* 合法的 */ C 存储类 存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类： auto register static extern ","date":"2020-05-13","objectID":"/posts/C-4/:4:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"auto 存储类 auto 存储类是所有局部变量默认的存储类。 { int mount; auto int month; } 上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。 ","date":"2020-05-13","objectID":"/posts/C-4/:5:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"static 存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。 以下实例演示了 static 修饰全局变量和局部变量的应用： #include \u003cstdio.h\u003e/* 函数声明 */ void func1(void); static int count=10; /* 全局变量 - static 是默认的 */ int main() { while (count--) { func1(); } return 0; } void func1(void) { /* 'thingy' 是 'func1' 的局部变量 - 只初始化一次 * 每次调用函数 'func1' 'thingy' 值不会被重置。 */ static int thingy=5; thingy++; printf(\" thingy 为 %d ， count 为 %d\\n\", thingy, count); } 实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。产生结果 thingy 为 6 ， count 为 9 thingy 为 7 ， count 为 8 thingy 为 8 ， count 为 7 thingy 为 9 ， count 为 6 thingy 为 10 ， count 为 5 thingy 为 11 ， count 为 4 thingy 为 12 ， count 为 3 thingy 为 13 ， count 为 2 thingy 为 14 ， count 为 1 thingy 为 15 ， count 为 0 ","date":"2020-05-13","objectID":"/posts/C-4/:6:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"extern 存储类 extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示： 第一个文件：main.c 实例 #include \u003cstdio.h\u003eint count ; extern void write_extern(); int main() { count = 5; write_extern(); } 第二个文件：support.c #include \u003cstdio.h\u003eextern int count; void write_extern(void) { printf(\"count is %d\\n\", count); } 在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示： $ gcc main.c support.c 这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果： count is 5 位运算符 位运算符作用于位，并逐位执行操作。\u0026、 | 和 ^ 的真值表如下所示： 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 ----------------- A\u0026B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 ","date":"2020-05-13","objectID":"/posts/C-4/:7:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"举例说明 假设变量 A 的值为 60，变量 B 的值为 13 ","date":"2020-05-13","objectID":"/posts/C-4/:8:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"运算符-按位与\u0026 运算规则 0\u00260=0; 0\u00261=0; 1\u00260=0; 1\u00261=1; (A \u0026 B) 将得到 12，即为 0000 1100 ","date":"2020-05-13","objectID":"/posts/C-4/:8:1","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"运算符-按位或| 0|0=0; 0|1=1; 1|0=1; 1|1=1; (A | B) 将得到 61，即为 0011 1101 ","date":"2020-05-13","objectID":"/posts/C-4/:8:2","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"运算符-异或^ 0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 49，即为 0011 0001 ","date":"2020-05-13","objectID":"/posts/C-4/:8:3","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"运算符-取反~ ~1=0; ~0=1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 ","date":"2020-05-13","objectID":"/posts/C-4/:8:4","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"运算符-二进制左移« A « 2 将得到 240，即为 1111 0000 ","date":"2020-05-13","objectID":"/posts/C-4/:8:5","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"运算符-二进制右移» A » 2 将得到 15，即为 0000 1111 ","date":"2020-05-13","objectID":"/posts/C-4/:8:6","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"实例 #include \u003cstdio.h\u003e int main() { unsigned int a = 60; /* 60 = 0011 1100 */ unsigned int b = 13; /* 13 = 0000 1101 */ int c = 0; c = a \u0026 b; /* 12 = 0000 1100 */ printf(\"Line 1 - c 的值是 %d\\n\", c ); c = a | b; /* 61 = 0011 1101 */ printf(\"Line 2 - c 的值是 %d\\n\", c ); c = a ^ b; /* 49 = 0011 0001 */ printf(\"Line 3 - c 的值是 %d\\n\", c ); c = ~a; /*-61 = 1100 0011 */ printf(\"Line 4 - c 的值是 %d\\n\", c ); c = a \u003c\u003c 2; /* 240 = 1111 0000 */ printf(\"Line 5 - c 的值是 %d\\n\", c ); c = a \u003e\u003e 2; /* 15 = 0000 1111 */ printf(\"Line 6 - c 的值是 %d\\n\", c ); } 输出结果 Line 1 - c 的值是 12 Line 2 - c 的值是 61 Line 3 - c 的值是 49 Line 4 - c 的值是 -61 Line 5 - c 的值是 240 Line 6 - c 的值是 15 switch case 如果在case语句中没有break; 会一直执行到下条语句,直到遇到break; switch(int value){ case 1: 表达式1; case 2: 表达式2; break; case 3: 表达式3; break; } 此时如果value=1,则会一直执行到表达式2,遇到break跳出 变量作用域 全局变量与局部变量 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用 形式参数 函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用局部变量。下面是一个实例： 全局变量与局部变量在内存中的区别： 全局变量保存在内存的全局存储区中，占用静态的存储单元； 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。 C enum(枚举) 枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。 枚举语法定义格式为： enum　枚举名　{枚举元素1,枚举元素2,……}; 比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名： #define MON 1 #define TUE 2 #define WED 3 #define THU 4 #define FRI 5 #define SAT 6 #define SUN 7 这个看起来代码量就比较多，接下来我们看看使用枚举的方式： enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; 注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。 可以在定义枚举类型时改变枚举元素的值： enum season {spring, summer=3, autumn, winter}; 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5 ","date":"2020-05-13","objectID":"/posts/C-4/:9:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"枚举变量的定义 我们可以通过以下三种方式来定义枚举变量 ","date":"2020-05-13","objectID":"/posts/C-4/:10:0","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"先定义枚举类型，再定义枚举变量 enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; enum DAY day; ","date":"2020-05-13","objectID":"/posts/C-4/:10:1","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"定义枚举类型的同时定义枚举变量 enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN } day; ","date":"2020-05-13","objectID":"/posts/C-4/:10:2","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"省略枚举名称，直接定义枚举变量 enum { MON=1, TUE, WED, THU, FRI, SAT, SUN } day; ","date":"2020-05-13","objectID":"/posts/C-4/:10:3","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["C语言"],"content":"实例: #include \u003cstdio.h\u003e enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; int main() { enum DAY day; day = WED; printf(\"%d\",day); return 0; } 以上实例输出结果为： 3 在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。 不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。 以下实例使用 for 来遍历枚举的元素： #include \u003cstdio.h\u003eenum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN } day; int main() { // 遍历枚举元素 for (day = MON; day \u003c= SUN; day++) { printf(\"枚举元素：%d \\n\", day); } } 以上实例输出结果为： 枚举元素：1 枚举元素：2 枚举元素：3 枚举元素：4 枚举元素：5 枚举元素：6 枚举元素：7 ","date":"2020-05-13","objectID":"/posts/C-4/:10:4","tags":["C-语言程序设计"],"title":"C语言程序设计 Part-1","uri":"/posts/C-4/"},{"categories":["Leetcode"],"content":"链队列的实现方法 102-二叉树的层序遍历 ","date":"2020-05-12","objectID":"/posts/leetcode-5/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-5","uri":"/posts/leetcode-5/"},{"categories":["Leetcode"],"content":"链队列的实现方法 做题经常会遇到要自己写一个链队列,在此记录一下 struct QueueNode struct LinkQueue initQueue enqueue dequeue destroyQueue emptyQueue 一定要熟背鸭 typedef struct QueueNode { struct TreeNode *data; struct QueueNode *next; } QueueNode_t; typedef struct LinkQueue { int count; QueueNode_t *front; QueueNode_t *rear; } LinkQueue_t; int initQueue(LinkQueue_t *queue) { queue-\u003efront = queue-\u003erear = malloc(sizeof(QueueNode_t)); if (NULL == queue-\u003efront) return -1; queue-\u003efront-\u003enext = NULL; queue-\u003ecount = 0; return 0; } int enqueue(LinkQueue_t *queue, struct TreeNode *data) { QueueNode_t *newNode = malloc(sizeof(QueueNode_t)); if (NULL == newNode) { return -1; } newNode-\u003edata = data; newNode-\u003enext = NULL; queue-\u003erear-\u003enext = newNode; queue-\u003erear = newNode; queue-\u003ecount++; return 0; } int dequeue(LinkQueue_t *queue, struct TreeNode **data) { if (queue-\u003efront == queue-\u003erear) { return -1; } QueueNode_t *denode = queue-\u003efront-\u003enext; *data = denode-\u003edata; queue-\u003efront-\u003enext = denode-\u003enext; if (denode == queue-\u003erear) { queue-\u003erear = queue-\u003efront; } free(denode); queue-\u003ecount--; return 0; } void destroyQueue(LinkQueue_t *queue) { /*q-\u003efront 指向头node, queue-\u003erear指向下一个节点，这里当临时指针用*/ while (queue-\u003efront) { queue-\u003erear = queue-\u003efront-\u003enext; free(queue-\u003efront); queue-\u003efront = queue-\u003erear; } } int emptyQueue(LinkQueue_t *queue) { return queue-\u003efront == queue-\u003erear ? 1 : 0; } ","date":"2020-05-12","objectID":"/posts/leetcode-5/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-5","uri":"/posts/leetcode-5/"},{"categories":["Leetcode"],"content":"102-二叉树的层序遍历 题目:给你一个二叉树，请你返回其按层序遍历得到的节点值。即逐层地，从左到右访问所有节点 解题思路:目前想到的是记录每一层的结点数,然后while(size–)循环,每次层节点访问后输出,本质就是广度优先搜索 以下题解使用顺序队列实现,这道题是中等题,对于我来说写出完整实现有些困难,但大体思想知道,要继续锻炼代码能力了 #define MAX_SIZE 1000 typedef struct { int front; int rear; int size; struct TreeNode* data[MAX_SIZE]; } Queue; void Init(Queue *q) { q-\u003efront = -1; q-\u003erear = -1; q-\u003esize = 0; memset(q-\u003edata, 0, sizeof(struct TreeNode*) * MAX_SIZE); } int Push(Queue *q, struct TreeNode* node) { assert(q \u0026\u0026 node \u0026\u0026 q-\u003esize != MAX_SIZE); if (q == NULL || node == NULL || q-\u003esize == MAX_SIZE) return -1; q-\u003erear++; q-\u003erear %= MAX_SIZE; q-\u003edata[q-\u003erear] = node; q-\u003esize++; return 0; } int Pop(Queue *q, struct TreeNode** node) { assert(q \u0026\u0026 node \u0026\u0026 q-\u003esize != 0); if (q == NULL || node == NULL || q-\u003esize == 0) return -1; q-\u003efront++; q-\u003efront %= MAX_SIZE; *node = q-\u003edata[q-\u003efront]; q-\u003esize--; return 0; } int GetTreeDepth(const struct TreeNode* root) { if (root == NULL) return 0; int left = GetTreeDepth(root-\u003eleft); int right = GetTreeDepth(root-\u003eright); return left \u003e right ? left + 1 : right + 1; } int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) { if (root == NULL || returnSize == NULL || returnColumnSizes == NULL) { *returnSize = 0; *returnColumnSizes = (int *)malloc(sizeof(int) * 1); (*returnColumnSizes)[0] = 0; return NULL; } Queue q; Init(\u0026q); Push(\u0026q, root); int depth = GetTreeDepth(root); *returnSize = depth; int **matrix = (int **)malloc(sizeof(int *) * depth); *returnColumnSizes = (int *)malloc(sizeof(int) * depth); if (matrix == NULL || returnColumnSizes == NULL) return NULL; int cur_depth = 0; while(q.size != 0) { int level_size = q.size; /* create raw */ (*returnColumnSizes)[cur_depth] = level_size; matrix[cur_depth] = (int *)malloc(sizeof(int) * level_size); int cur = 0; while (level_size--) { struct TreeNode* node; Pop(\u0026q, \u0026node); /* add node-\u003eval to res */ matrix[cur_depth][cur] = node-\u003eval; if (node-\u003eleft) Push(\u0026q, node-\u003eleft); if (node-\u003eright) Push(\u0026q, node-\u003eright); cur++; } cur_depth++; } return matrix; } ","date":"2020-05-12","objectID":"/posts/leetcode-5/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-5","uri":"/posts/leetcode-5/"},{"categories":["vscode"],"content":"VScode虽然很棒,但是配置文件无法同步,这点有些麻烦,还好有插件支持同步 插件名字: Settings Sync 下面开始说配置过程 上传设置 ","date":"2020-05-11","objectID":"/posts/vscode-1/:0:0","tags":["vscode"],"title":"VScode同步设置","uri":"/posts/vscode-1/"},{"categories":["vscode"],"content":"生成 Github gist Token 在Settings页面点击进入 Developer settings （开发者设置）进入Personal access tokens（个人授权令牌）页面生成一个令牌 点击 Generate new token 令牌的作用能帮助我们就在VSCode中使用自己的私有令牌访问自己的保存在Gist上的配置,勾选Gist，点击生成。 ","date":"2020-05-11","objectID":"/posts/vscode-1/:1:0","tags":["vscode"],"title":"VScode同步设置","uri":"/posts/vscode-1/"},{"categories":["vscode"],"content":"创建Gist 创建一个新Gist,输入创建的Gist描述和片段内容(“vscode-setting-sync”)保存即可。 手动复制刚才创建的Gist仓库的ID：gist冒号后面的字符串,将其保存 ","date":"2020-05-11","objectID":"/posts/vscode-1/:2:0","tags":["vscode"],"title":"VScode同步设置","uri":"/posts/vscode-1/"},{"categories":["vscode"],"content":"配置VScode ","date":"2020-05-11","objectID":"/posts/vscode-1/:3:0","tags":["vscode"],"title":"VScode同步设置","uri":"/posts/vscode-1/"},{"categories":["vscode"],"content":"填写Gist Token 回到VSCode编辑器中 使用快捷键Ctrl+P 输入命令 \u003esync 点击 同步：高级选项 然后选择同步：“编辑配置设置” 输入你在github上创建的 gist token ,Ctrl+S保存更改 ","date":"2020-05-11","objectID":"/posts/vscode-1/:3:1","tags":["vscode"],"title":"VScode同步设置","uri":"/posts/vscode-1/"},{"categories":["vscode"],"content":"填写Gist ID 进入Settings Sync扩展设置页面设置 输入创建的Gist仓库ID 输入自动保存设置 ","date":"2020-05-11","objectID":"/posts/vscode-1/:3:2","tags":["vscode"],"title":"VScode同步设置","uri":"/posts/vscode-1/"},{"categories":["vscode"],"content":"上传 然后 ctrl shift p 调出快捷命令 sync upload 新的环境下下载设置 ","date":"2020-05-11","objectID":"/posts/vscode-1/:3:3","tags":["vscode"],"title":"VScode同步设置","uri":"/posts/vscode-1/"},{"categories":["vscode"],"content":"填写Gist ID 在新的环境下直接填写 gist id 即可 ","date":"2020-05-11","objectID":"/posts/vscode-1/:4:0","tags":["vscode"],"title":"VScode同步设置","uri":"/posts/vscode-1/"},{"categories":["vscode"],"content":"下载 然后调用 sync download 命令 ","date":"2020-05-11","objectID":"/posts/vscode-1/:5:0","tags":["vscode"],"title":"VScode同步设置","uri":"/posts/vscode-1/"},{"categories":["操作系统"],"content":"设备管理,文件系统 设备管理 物理设备: I/O系统中实际安装的设备 物理名: ID或字符串 逻辑设备 应用软件使用的设备 逻辑名:友好名(Friendly Name) 设备映射功能 设备管理模块将逻辑设备映射到物理设备的功能 从应用软件的角度看,逻辑设备是一类物理设备的抽象 从设备管理程序的角度看,物理设备时逻辑设备的实例 设备驱动程序的特点 设备驱动程序与硬件密切相关 每类设备都要配置特定的驱动设备 驱动程序一般由设备厂商根据操作系统要求编写 操作系统仅对与设备驱动的接口提出要求 Spooling系统 ","date":"2020-05-11","objectID":"/posts/OS-4/:0:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"独占型设备 任意时间段内最多只能被一个进程占用 使用时,进程首先向系统申请,可能进入阻塞状态 当设备可用时,唤醒一个等待进程 使用完毕以后,进程必须释放设备 ","date":"2020-05-11","objectID":"/posts/OS-4/:1:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"共享型设备 I/O传输单位-\u003e块 宏观上,一个共享型设备可以被多个进程同时占用 微观上,多个进程交替使用同一设备 进程使用这类设备时,无需申请或释放设备,也不存在某个进程占用设备的问题 ","date":"2020-05-11","objectID":"/posts/OS-4/:2:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"虚拟分配 ","date":"2020-05-11","objectID":"/posts/OS-4/:3:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"虚拟技术 在一类物理设备上模拟另一类物理设备的技术 借助辅存部分区域模拟独占设备,将独占设备转换为共享设备 ","date":"2020-05-11","objectID":"/posts/OS-4/:3:1","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"虚拟设备 用来模拟独占设备的部分辅存称为虚拟设备,虚拟独占设备 输入井:模拟输入设备的辅存区域 输出井:模拟输出设备的辅存区域 ","date":"2020-05-11","objectID":"/posts/OS-4/:3:2","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"分配 当进程需要与独占设备交换信息时,就采用虚拟技术将与该独占设备所对应的虚拟设备(部分辅存)分配给他 Spooling兄同时虚拟技术和虚拟分配的实现 Simultanesus Periphernal Operations Online 外部设备同时联机操作(假脱机输入/输出操作) ","date":"2020-05-11","objectID":"/posts/OS-4/:3:3","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"Spooling结构 输入井和输出井 磁盘开辟的两个存储区域 输入井模拟脱机输入时的磁盘 输出井模拟脱机输出时的磁盘 输入缓冲区和输出缓冲区 内存中开辟的存储区域 输入缓冲区:暂存输入数据,以后再传送到输入井 输出缓冲区:暂存输出数据,以后再传送到输出井 输入监控进程和输出监控进程 输入监控进程模拟脱机输入的卫星机,将用户要求的数据从输入设备通过输入缓冲区再传送到输入井,当用户进程需要数据时,直接从输入井读入所需数据 输出监控进程模拟脱机输出的卫星机,用户进程将输出数据从内存先传送到输出井,当输出设备空闲时,再将输出井的数据传送到输出设备上 文件系统 ","date":"2020-05-11","objectID":"/posts/OS-4/:4:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"文件属性 指定文件的类型,操作特性和存取保护等一组信息 文件属性存放在文件所在目录的目录文件中 MS-DOS系统中,文件属性占目录项的一个字节 00000001:只读属性 00000010:隐藏属性 ","date":"2020-05-11","objectID":"/posts/OS-4/:5:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"文件的结构 ","date":"2020-05-11","objectID":"/posts/OS-4/:6:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"逻辑结构 用户的观点 为用户提供罗技结构清晰,使用方便的文件 强调文件信息项的构成方式和用户的存取方式 ","date":"2020-05-11","objectID":"/posts/OS-4/:6:1","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"物理结构 系统的观点 文件在存储设备上的存储结构 强调合理利用存储空间,缩短I/O存取时间 ","date":"2020-05-11","objectID":"/posts/OS-4/:6:2","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"文件的逻辑结构 记录式文件 信息项式记录,结构化数据 文件中需要保存记录长度和数量等说明信息 浪费存储空间 流式文件 信息项是字节,文件长度是字节的数量 文件无需额外的说明信息或控制信息 节省存储空间 ","date":"2020-05-11","objectID":"/posts/OS-4/:7:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"物理存取结构 ","date":"2020-05-11","objectID":"/posts/OS-4/:8:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"顺序存取 按文件信息项排列顺序来依次存取 读写指针 文件打开时,读写指针指向第一个信息项(字节) 每存取一个信息项,读写指针自动加1,而指向下一个信息项 ","date":"2020-05-11","objectID":"/posts/OS-4/:8:1","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"随机存取 直接存取,存取操作时指定存取的位置 对流式文件或记录为定长的记录式文件容易确定存取位置 对记录不定长的记录式文件定位较为麻烦 FAT文件系统 File Allocation Table 串联文件:存储块next域指向下一个存储块 文件分配表的缺点 读文件时,先读FAT,影响使用效率 FAT要占用存储空间 存储容量越大,存储块就多,FAT元素就越多,且元素位宽越长,占用额外的存储空间就越多 若存储块有2N,FAT就有2个元素,每项至少需要N位的位宽 扇区:磁盘上最小可寻址存储单元(512字节) 簇(cluster) = 存储块: 设备的最小存取单元,固定数量的扇区 簇的例子: 360KB磁盘:簇 = 2个扇区(1024字节) 10MB磁盘: 簇 = 8个扇区(4096字节) 2GB磁盘: 簇 = 64个扇区簇(32KB) 磁盘容量 = FAT * 簇容量 = FAT长度 * 簇扇区数 * 512字节 若N = 16, 簇扇区数 = 64 磁盘容量 = 216簇 * 64扇区 * 512字节 = 2GB N越大,能识别的簇越多,能支持的磁盘容量越大 ","date":"2020-05-11","objectID":"/posts/OS-4/:8:2","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"FAT16 FAT元素宽度2字节,即16Bit 每簇最大64扇区,磁盘分区最大(2G) 存储空间管理 记录磁盘空闲块的方法 ","date":"2020-05-11","objectID":"/posts/OS-4/:9:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"空闲文件管理 ","date":"2020-05-11","objectID":"/posts/OS-4/:10:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"空闲文件目录 空闲文件 将连续空闲分区看成一个特殊文件,由多个连续空闲块组成 空闲文件目录 所有空闲文件代表存储空间设备全部空闲空间 为空闲文件建立的专门目录:空闲文件目录 每个表项对应一个空闲文件,包括一个空闲块号,空闲块个数等信息 ","date":"2020-05-11","objectID":"/posts/OS-4/:10:1","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"空闲块链 把所有空闲块链接在一起 当申请者需要空闲块时,链头开始搜索所需空闲块 当回收空闲块时,把释放的空闲块逐个加在链尾 ","date":"2020-05-11","objectID":"/posts/OS-4/:10:2","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"位示图 ","date":"2020-05-11","objectID":"/posts/OS-4/:10:3","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"文件目录管理 文件目录 文件名址录,记录文件名和存放地址的目录表 具有将文件名转换为外存物理地址的功能 文件属性也记录在目录中 目录文件 文件目录以文件形式存于外存,这个文件叫目录文件 ","date":"2020-05-11","objectID":"/posts/OS-4/:11:0","tags":["操作系统-课程"],"title":"OS总结 Part-4","uri":"/posts/OS-4/"},{"categories":["操作系统"],"content":"存储管理 存储管理 多道程序并行带来的问题： 共享：代码和数据共享，节省内存 保护：不允许内存中的程序相互间非法访问 ","date":"2020-05-11","objectID":"/posts/OS-3/:0:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"地址映射 ","date":"2020-05-11","objectID":"/posts/OS-3/:1:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"固定地址映射 编程或编译时确定逻辑地址和物理地址映射关系 特点： 程序加载时必须放在指定的区域 容易发生地址冲突，运行失败 程序占用连续空间 程序装入后不能移动 ","date":"2020-05-11","objectID":"/posts/OS-3/:1:1","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"静态地址映射 程序装入时由操作系统完成逻辑地址到物理地址的映射 逻辑地址：VA(Virtual Addr) 装入基址：BA(Base Addr) 物理地址：MA(Memory Addr) MA = BA+VA 特点： 程序运行前确定映射关系 程序装入后不能移动（如果移动必须放回原来的位置） 程序占用连续的内存空间 ","date":"2020-05-11","objectID":"/posts/OS-3/:1:2","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"动态地址映射 程序占用的内存空间可动态变化,要求及时更新基质BA 程序不要求占用连续的内存空间 便于多个进程共享代码,共享代码作为独立的一段存放 缺点: 硬件支持(MMU:内存管理单元) 软件复杂 如果程序有移动，BA可能会发生改变，自动计算新的MA ","date":"2020-05-11","objectID":"/posts/OS-3/:1:3","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"存储管理的功能-虚拟内存 虚拟内存的目标 使得大的程序能在较小的内存中运行 是的多个程序能在较小的内存中运行 使得多个程序迸发运行时地址不冲突 使得内存利用效率高，无碎片，共享方便 ","date":"2020-05-11","objectID":"/posts/OS-3/:1:4","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"存储管理的功能-内存分配功能 为程序分配足够的内存空间 需要解决的问题： 放置策略：程序调入内存是将其放置在哪个分区 调入策略：何时把运行的代码和要访问的数据调入内存 淘汰策略:内存不够时，迁出哪些代码或数据以腾出内存空间 ","date":"2020-05-11","objectID":"/posts/OS-3/:1:5","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"存储管理的功能-存储保护功能 保证在内存中的多道程序只能在给定的存储区域内活动互不干扰 防止访问越界 防止访问越权 方法：界址寄存器 在CPU中设置一对下限寄存器和上限寄存器存放程序在内存中的下限地址和上限地址 基址寄存器和限长寄存器 分区内存管理 单一区存储管理 分区存储管理 固定分区 动态分区 ","date":"2020-05-11","objectID":"/posts/OS-3/:1:6","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"单一存储管理（不分区存储管理） ","date":"2020-05-11","objectID":"/posts/OS-3/:2:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"定义 用户区不分区，完全被一个程序占用 例如 DOS ","date":"2020-05-11","objectID":"/posts/OS-3/:2:1","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"优点 简单，不需要复杂的硬件支持，适用于单用户单任务OS ","date":"2020-05-11","objectID":"/posts/OS-3/:2:2","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"缺点 程序运行占用整个内存，即使小程序也是如此，内存浪费，利用率低 ","date":"2020-05-11","objectID":"/posts/OS-3/:2:3","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"分区存储管理 ","date":"2020-05-11","objectID":"/posts/OS-3/:3:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"定义 把用户区内存划分若干大小不等的分区，供不同程序使用 分类 固定分区 动态分区 ","date":"2020-05-11","objectID":"/posts/OS-3/:3:1","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"空闲分区使用策略 分配过程(假定用户要求空间大小为s) 从空闲区表的第一个区开始,寻找\u003e=s的空闲区 找到后从分区中分割出大小为s的部分给用户使用 分割后的剩余部分作为空闲区仍然登记在空闲区表中 注意:分割空闲区时一般从底部分割 ","date":"2020-05-11","objectID":"/posts/OS-3/:4:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"空闲分区算法 按空闲区位置(首址)递增排序 首次适应算法 尽可能先使用低地址空间 当需要较大分区时在高地址空间有较大的满足可能性 按空闲区大小的递增排序 最佳适应算法 尽可能地使用较小的空闲区,保留大的空闲区 当需要较大分区时又较大的满足可能性 按空闲区大小的递减排序 最坏适应算法 大空闲区分割后剩下部分还是很大,还能装下较大的程序 仅作一次检查就能找到所要分区 ","date":"2020-05-11","objectID":"/posts/OS-3/:4:1","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"分区的回收 回收程序释放分区,登记到空闲区表 回收算法: 要考虑释放区与现有空闲区是否相邻 若释放区与现有空闲区不相邻,则直接插入空闲区表 若释放区与现有空闲区相邻,则与空闲区合并后更新空闲区表 ","date":"2020-05-11","objectID":"/posts/OS-3/:5:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"覆盖 在较小的内存空间中运行较大的程序 常驻区:被某段单独且独立的占用,可划分多个 覆盖区:能被多段共用(覆盖),可划分多个 覆盖的缺点: 编程复杂,需要程序员划分程序模块并确定覆盖关系 程序执行时间长,从外村装入内存耗时 ","date":"2020-05-11","objectID":"/posts/OS-3/:6:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"交换技术 内存不够时将进程写入磁盘(swap out) 当进程要运行时重新写回内存(swap in) 优点: 增加进程并发数 不考虑程序结构 缺点: 换入换出增加cpu开销 交换单位太大(整个进程) 需要考虑的问题: 减少交换传送的信息量(模块/段) 外存交换空间的管理方法 程序换入时的地址重定位 ","date":"2020-05-11","objectID":"/posts/OS-3/:7:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"内存碎片 过小的空闲区,难实际使用 内存碎片会降低内存有效利用率 ","date":"2020-05-11","objectID":"/posts/OS-3/:8:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"动态分区的缺点 容易产生内存碎片:内存反复分配和分割 首次适应法,最佳适应法,最坏适应法 解决碎片的方法 规定门限值,分割空闲区时若剩余部分小于门限值,则此空闲区不进行分割,而是全分配给用户 内存拼接技术:将所有空闲区集中构成一个大的空闲区 拼接技术的缺点:消耗系统的资源,离线拼接,重新定义作业 解除程序占用连续内存才能运行的限制 虚拟内存管理 目标:使得大的程序能在较小的内存中运行 使得多个程序并发运行时地址不冲突 使得内存利用率提高,无碎片,共享方便 程序运行的局部性: 程序在有限的时间段内访问的代码和数据往往在有限的范围内 典型的虚拟内存管理方式: 页式虚拟存储管理 段式虚拟存储管理 段页式虚拟存储管理 将进程空间(虚拟)和内存空间划分成等大小的片 片的典型大小:1k,2k,4k 进程的片-页(虚拟页) 内存的片-页框(物理页) 内存以页框的单位分配使用 进程以页为单位装入内存 只把程序部分页装入内存便可运行 页在内存中占用的页框不必相邻 需要新页时,按需从硬盘中调入内存 不再运行的页及时删除,腾出空间 ","date":"2020-05-11","objectID":"/posts/OS-3/:8:1","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"页式系统中的地址 虚拟地址(VA)可以分解为页号p和页内偏移w 页号p = va/页的大小 页内偏移w = va%页的大小 p和w的另一种算法,已知页的大小2n p = VA»n w = VA \u0026\u0026 (2n-1) 记录页和页框之间的对应关系-\u003e页表 快表机制 快表的特点: 容量小,访问快 快表是慢表部分内容的复制 若在快表中找到所需内容,则称为\"命中\",若没有命中则访问慢表,更新快表 页面的共享 在不同进程的页表上填上相同的页框号,多个进程能访问相同的内存空间,从而实现页面共享 共享页面在内存上只有一份真实存储,节省内存 缺页中断 ","date":"2020-05-11","objectID":"/posts/OS-3/:9:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"页表的扩充 即页表中有中断位和辅存地址 中断位i-标识该页是否在内存 i =1 不在内存 i =0 在内存 辅存地址:该页在辅存上的地址 修改位-\u003e标识该页的数据是否已被修改 0-\u003e该页未被修改 1-\u003e该页已被修改 ","date":"2020-05-11","objectID":"/posts/OS-3/:10:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"缺页中断定义 在地址映射过程中,当所要访问的目的页不在内存时,则系统产生异常中断-\u003e缺页中断 却也中断处理程序:中断处理程序将所缺的页从页表指出的辅存地址调入内存的某个页框中,并更新页表中该页对应的页框号以及修改中断位为0 ","date":"2020-05-11","objectID":"/posts/OS-3/:11:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"缺页(中断)率 缺页率f = 缺页次数/访问页面次数 命中率= 1-f 页面淘汰 淘汰策略 选择淘汰哪一页的规则称为淘汰策略 页面抖动 页面在内存和辅存间频繁交换的现象 “抖动\"会导致系统效率下降 好的淘汰策略 具有较低的缺页率(高命中率) 页面抖动较少 ","date":"2020-05-11","objectID":"/posts/OS-3/:12:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"常用的淘汰算法 最佳算法(OPT-optimal) 淘汰以后不再需要或最远的未来才会使用到的页面 理论上最佳,但实践中算法无法实现 先进先出算法(FIFO) 淘汰在内存中停留时间最长的页面 实现简单,但只有进程按顺序访问时命中率才是最理想的,对于指定的访问序列,随着分配页框的增多,缺页率反而增加 最久未使用淘汰算法(LRU) 淘汰最长时间未被使用的页面 实现方法: 页面设置一个移位寄存器R,每当页面访问时将其重置为1 周期性的将所有页面的R左移一位(右边补0),当需要淘汰时选择R值最大的页 R的位数越多(移位周期越小)就越精确,但是硬件成本实现较高 近似算法 利用页表访问位,页被访问时将其值由硬件置为1 软件周期性(T)将所有访问位置0 当淘汰页面时根据该页访问位来判断是否淘汰 访问位为1时:在T时间内,该页被访问过 访问位为0时:在T时间内,该页未被访问过 缺点 周期T难定 最不经常使用算法(LFU) 选择到当前时间位置被访问次数最少的页面 每页设置访问计数器,每当页面被访问时,该页的访问器上计数器+1 发生缺页中断时,淘汰计数器最小的页面,并将所有计数器清零 段式存储器 进程分段:把进程按逻辑意义划分为多个段,每段有段名,长度不定,进程由多段组成 ","date":"2020-05-11","objectID":"/posts/OS-3/:13:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"段式存储的内存分配 程序以段为单位装入,每段分配连续的内存 但是段和段不要求相邻 ","date":"2020-05-11","objectID":"/posts/OS-3/:14:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"段式内存的虚拟地址 段式虚拟地址VA包含段号s和段内偏移w 段表: 段号:段的编号 段长:段的长度 基地址:该段在内存中的首地址 ","date":"2020-05-11","objectID":"/posts/OS-3/:15:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"段的共享 共享段在内存中只有一份存储 共享段被多个进程映射到各自的段 需要共享的模块可以设置为单独的段 ","date":"2020-05-11","objectID":"/posts/OS-3/:16:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["操作系统"],"content":"段的缺点 段需要连续的存储空间 段的最大尺寸收到内存大小的限制 在辅存中管理可变尺寸的段比较困难 段式系统和页式系统的比较 页式系统:一维空间 段式系统:二维空间 段长可变-页面大小固定 段的划分有意义-页面无意义 段方便共享-页面不方便共享 段用户可见-页面用户不可见 段偏移有溢出-页面偏移无溢出 段页式存储 系统为每个进程建立一个段表 每个段有一个页表 段表给出每段的页表基址及页表长度(段长) 页表给出每页对应的页框 ","date":"2020-05-11","objectID":"/posts/OS-3/:17:0","tags":["操作系统-课程"],"title":"OS总结 Part-3","uri":"/posts/OS-3/"},{"categories":["Leetcode"],"content":"今天母亲节,做了锅包肉和蜜汁鸡排嘿嘿(没想到锅包肉做的还蛮好吃的),晚上家里的仙人球还开花了!今天还第一次通过了leetcode,好开心嗷,做题好像有感觉了! 明天更操作系统,不拖了不拖了… 1047-删除字符串中的所有相邻重复项 617-合并二叉树 226-翻转二叉树 101-对称二叉树 236-二叉树的最近公共祖先 1-两数之和(哈希散列法) ","date":"2020-05-10","objectID":"/posts/leetcode-4/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-4","uri":"/posts/leetcode-4/"},{"categories":["Leetcode"],"content":"1047-删除字符串中的所有相邻重复项 题目: 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。 解题思路: 我竟然上来先写了一个栈(以后不要这样了…)下次碰到字符串要注意了,字符串本身加一个int top就可以实现栈 char * removeDuplicates(char * s){ int sl = strlen(s); char *stack = (char *)malloc(sizeof(char) * sl); // 申请一个栈 返回也用它 int top = -1; // 栈顶 for(int i = 0; i \u003c sl; i++) { if(0 \u003e top) { // 空的栈 直接加 stack[++top] = s[i]; } else { if(stack[top] == s[i]) { // 栈顶元素与当前元素相同则出栈 top--; } else { // 不同则入栈 stack[++top] = s[i]; } } } // 封口 stack[++top] = 0; return stack; } ","date":"2020-05-10","objectID":"/posts/leetcode-4/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-4","uri":"/posts/leetcode-4/"},{"categories":["Leetcode"],"content":"617-合并二叉树 题目: 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 解题思路: 基于二叉树的递归遍历,这道题是我自己写出来的!没看题解,感觉现在做题有手感了!!! struct TreeNode* mergeTrees(struct TreeNode* t1, struct TreeNode* t2){ if(t1 == NULL){ return t2; } if(t2 == NULL){ return t1; } if(t1 \u0026\u0026 t2){ t1-\u003eval = t1-\u003eval+t2-\u003eval; } t1-\u003eleft = mergeTrees(t1-\u003eleft, t2-\u003eleft); t1-\u003eright = mergeTrees(t1-\u003eright, t2-\u003eright); return t1; } ","date":"2020-05-10","objectID":"/posts/leetcode-4/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-4","uri":"/posts/leetcode-4/"},{"categories":["Leetcode"],"content":"226-翻转二叉树 题目: 翻转一棵二叉树 解题思路: 快乐递归二叉树 struct TreeNode* invertTree(struct TreeNode* root){ if(root == NULL){ return NULL; } struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode)); node = root-\u003eright; root-\u003eright = root-\u003eleft; root-\u003eleft = node; invertTree(root-\u003eleft); invertTree(root-\u003eright); return root; } ","date":"2020-05-10","objectID":"/posts/leetcode-4/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-4","uri":"/posts/leetcode-4/"},{"categories":["Leetcode"],"content":"101-对称二叉树 题目: 给定一个二叉树，检查它是否是镜像对称的 解题思路: 左右子树的分别遍历,但是遍历路径是镜像路径 //我一开始写错的代码,错在于没有进行镜像遍历 /*bool isSymmetric(struct TreeNode* root){ struct TreeNode* root_left = root-\u003eleft; struct TreeNode* root_right = root-\u003eright; if(root_left == NULL \u0026\u0026 root_right == NULL){ return true; } if(root_left-\u003eval == root_right-\u003eval){ return true; } else{ return false; } isSymmetric(root-\u003eleft); isSymmetric(root_right); }*/ static bool Symmetric(struct TreeNode* leftNode, struct TreeNode* rightNode) { if (NULL == leftNode \u0026\u0026 NULL == rightNode) { return true; } if (NULL == leftNode || NULL == rightNode) { return false; } return (leftNode-\u003eval == rightNode-\u003eval) \u0026\u0026 \\ Symmetric(leftNode-\u003eright, rightNode-\u003eleft) \u0026\u0026 \\ Symmetric(leftNode-\u003eleft, rightNode-\u003eright); } bool isSymmetric(struct TreeNode* root){ return Symmetric(root, root); } ","date":"2020-05-10","objectID":"/posts/leetcode-4/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-4","uri":"/posts/leetcode-4/"},{"categories":["Leetcode"],"content":"236-二叉树的最近公共祖先 题目:寻找二叉树两个节点的最近公共祖先 解题思路:这个题我一开始没想出来…看了题解才想明白,使用dfs即可,豁然开朗,dfs在判定时是从下向上的顺序进行的所以即可得到最近的公共结点 ","date":"2020-05-10","objectID":"/posts/leetcode-4/:5:0","tags":["Leetcode-C++"],"title":"Leetcode Part-4","uri":"/posts/leetcode-4/"},{"categories":["Leetcode"],"content":"官方解法 解法地址 /*由于判定条件有些技巧,所以还是看官方解释吧*/ class Solution { public: TreeNode* ans; bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr) return false; bool lson = dfs(root-\u003eleft, p, q); bool rson = dfs(root-\u003eright, p, q); if ((lson \u0026\u0026 rson) || ((root-\u003eval == p-\u003eval || root-\u003eval == q-\u003eval) \u0026\u0026 (lson || rson))) { ans = root; } return lson || rson || (root-\u003eval == p-\u003eval || root-\u003eval == q-\u003eval); } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, p, q); return ans; } }; ","date":"2020-05-10","objectID":"/posts/leetcode-4/:5:1","tags":["Leetcode-C++"],"title":"Leetcode Part-4","uri":"/posts/leetcode-4/"},{"categories":["Leetcode"],"content":"DFS递归判定 解答地址 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == NULL) return NULL; if(root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-\u003eleft, p, q); TreeNode* right = lowestCommonAncestor(root-\u003eright, p, q); if(left == NULL) return right; if(right == NULL) return left; if(left \u0026\u0026 right) // p和q在两侧 return root; return NULL; // 必须有返回值 } }; ","date":"2020-05-10","objectID":"/posts/leetcode-4/:5:2","tags":["Leetcode-C++"],"title":"Leetcode Part-4","uri":"/posts/leetcode-4/"},{"categories":["Leetcode"],"content":"1-两数之和(哈希散列法) 之前用暴力求解,今天带着好奇来看看哈希表怎么做,果然c的哈希还要自己写,很麻烦,但是看到这个解法很新颖,直接把数组的值和数组下标进行哈希表的key和value 解体地址 #define MAX_SIZE 2048 int *twoSum(int *nums, int numsSize, int target, int *returnSize) { int i, hash[MAX_SIZE], *res = (int *)malloc(sizeof(int) * 2); memset(hash, -1, sizeof(hash)); for (i = 0; i \u003c numsSize; i++) { if (hash[(target - nums[i] + MAX_SIZE) % MAX_SIZE] != -1) { res[0] = hash[(target - nums[i] + MAX_SIZE) % MAX_SIZE]; res[1] = i; *returnSize = 2; return res; } hash[(nums[i] + MAX_SIZE) % MAX_SIZE] = i; //将数组中的值放入哈希数组中,因为一开始都是-1,所以都在执行该行代码,直到遇到和为目标值的另一个数,才执行if中的结果语句 //防止负数下标越界，循环散列 } free(hash); *returnSize = 0; return res; } ","date":"2020-05-10","objectID":"/posts/leetcode-4/:6:0","tags":["Leetcode-C++"],"title":"Leetcode Part-4","uri":"/posts/leetcode-4/"},{"categories":["C语言"],"content":"typedef的用法,typedef与const ","date":"2020-05-09","objectID":"/posts/C-3/:0:0","tags":["C-语法基础"],"title":"C语言的类型定义","uri":"/posts/C-3/"},{"categories":["C语言"],"content":"typedef的用法 typedef关键字可以用于给数据类型定义一个别名，比如说你本名叫关谷神奇，我嫌弃这个名字太长了，所以给你取一个别名，叫关谷，以后我叫关谷的时候你就知道在叫你了。 当你定义了一个结构体时，每次创建一个结构体都要使用struct+结构体名的方式，而用了typedef之后，只要一个结构体别名就可以创建了。 struct Color{ //本名 unsigned char RED; unsigned char GREEN; unsigned char BLUE; }; struct Clolor color1; //此时声明需要struct typedef struct { //本名可以忽略 unsigned char RED; unsigned char GREEN; unsigned char BLUE; }Color; //结构体别名 Color color1； //此时声明不需要struct ","date":"2020-05-09","objectID":"/posts/C-3/:1:0","tags":["C-语法基础"],"title":"C语言的类型定义","uri":"/posts/C-3/"},{"categories":["C语言"],"content":"typedef与const 在和const一起使用的时候，本想定义一个指向的字符为常量的变量指针，但因为typedef的特殊性，不是简单的替换，所以最终的定义的是指向的字符为变量的常量指针。 typedef char* pcha; //定义字符指针的别名 int str(const pchar, const pchar) /*想定义 指针为变量， 指向的字符为常量的参数 但实际上 指针为常量， 指向的字符为变量*/ 解决的方法，在typedef中加入const typedef const char* pchar; int str(pchar, pchar); ","date":"2020-05-09","objectID":"/posts/C-3/:2:0","tags":["C-语法基础"],"title":"C语言的类型定义","uri":"/posts/C-3/"},{"categories":["C语言"],"content":"指针指南 指针创建 为了避免出现野指针，通常我们需要将指针初始化为NULL，用完后也为其赋值为NULL。 结构体成员指针往往会被我们忽视，注意它也需要初始化，且需要为结构体指针分配足够的内存，真是就用到了malloc这个宏，使用方法如下： ","date":"2020-05-09","objectID":"/posts/C-2/:0:0","tags":["C-语法基础"],"title":"C中的野指针","uri":"/posts/C-2/"},{"categories":["C语言"],"content":"给指针变量赋初值： 方法一：char * p = (char * )malloc(sizeof(char)); 方法二：char * p = NULL; ","date":"2020-05-09","objectID":"/posts/C-2/:1:0","tags":["C-语法基础"],"title":"C中的野指针","uri":"/posts/C-2/"},{"categories":["C语言"],"content":"给数组赋初值： 方法一： int a[10] = {0}; 方法二： memset(a, 0, sizeof(a)); memset函数有3个参数：第一个是要被设置的内存起始地址；第二个是要被设置的值；第三个是要被设置的内存大小，单位为字节； ","date":"2020-05-09","objectID":"/posts/C-2/:2:0","tags":["C-语法基础"],"title":"C中的野指针","uri":"/posts/C-2/"},{"categories":["C语言"],"content":"给结构体指针赋初值： pstu = (struct student *)malloc(sizeof(struct student)); 常见错误： pstu = (struct student *)malloc(sizeof(struct student *)); 野指针在debug中的处理 为了避免出现野指针，在程序的debug版本里可以如下处理： 在函数的入口处使用assert(NULL != p)对参数进行校验。或者用if(NULL != p)来校验。它会提醒我们有没有初始化指针，起到定位错误的功能。 assert是个宏，它后面括号里的条件若不满足，则程序终止运行并提示出错。 指针销毁 使用完指针后务必记得释放指针所指向的内存，否则不知道什么时候我们又改变了指针的值，使其变成了野指针！ 这里就需要**free(p)**这个函数了，它可以切断指针与指向内存的联系。但是需要注意的是free对于同一指针变量只能使用一次。不然会导致出错或者内存泄漏。 释放完内存后另指针的值变为NULL! free(p); p = NULL; ","date":"2020-05-09","objectID":"/posts/C-2/:3:0","tags":["C-语法基础"],"title":"C中的野指针","uri":"/posts/C-2/"},{"categories":["C语言"],"content":"这几天发现自己的指针学的有些糊涂,经常写懵,所以决定补习一下指针的概念和用法 在这里记录一下知识点和心得 通俗理解 ","date":"2020-05-09","objectID":"/posts/C-1/:0:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"指针的概念 指针变量是一种变量类型,所有的指针变量都是无符号整型变量(unsigned int),其字节数为4个字节 所以可以得出 sizeof(char*) = 4 sizeof(int*) = 4... 指针的声明 int* a 即声明a为(int*)类型的指针变量,存储一个指向int类型变量的内存地址 *a 即地址a所指向的变量 int b = 4; int* a = NULL; //申请指针变量的好习惯 a = \u0026b; printf(\"%d\",*a); /*结果输出 4*/ ","date":"2020-05-09","objectID":"/posts/C-1/:1:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"结构体指针 结构体指针变量有特殊用法，即 结构体-\u003e成员 即可访问结构体中的变量 typedef struct { char name[31]; int age; float score; }Student; int main(void) { Student stu = {\"Bob\" , 19, 98.0}; Student*ps = \u0026stu; ps-\u003eage = 20; ps-\u003escore = 99.0; printf(\"name:%s age:%d\\n\",ps-\u003ename,ps-\u003eage); /*等价于 printf(\"name:%s age:%d\\n\",(*ps).name,(*ps).age)*/ /*等价于 printf(\"name:%s age:%d\\n\",stu.name,stu.age)*/ return 0; } ","date":"2020-05-09","objectID":"/posts/C-1/:2:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"野指针 指针在使用的过程中，要注意野指针 野指针的概念： 指向已销毁的变量 指向无权访问的内存空间 如何避免野指针： 指针初始化的好习惯： int*p = NULL； free（p）销毁p的内存后，要 p = NULL; 令其指针变量为NULL 参考其他Blog ","date":"2020-05-09","objectID":"/posts/C-1/:3:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"指针的用处? 指针解决了一些编程中基本的问题。 指针的使用使得不同区域的代码可以轻易的共享内存数据。当然你也可以通过数据的复制达到相同的效果，但是这样往往效率不太好，因为诸如结构体等大型数据，占用的字节数多，复制很消耗性能。但使用指针就可以很好的避免这个问题，因为任何类型的指针占用的字节数都是一样的（根据平台不同，有4字节或者8字节或者其他可能）。 指针使得一些复杂的链接性的数据结构的构建成为可能，比如链表，链式二叉树等等。 有些操作必须使用指针。如操作申请的堆内存。 还有一点：C语言中的一切函数调用中，实参传递给形参的机理都是“按值传递(pass by value)”的，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成。 ","date":"2020-05-09","objectID":"/posts/C-1/:4:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"指针是什么 我们指知道：C语言中的数组是指 一类 类型，数组具体区分为 int 类型数组，double类型数组,char数组 等等。同样指针 这个概念也泛指 一类 数据类型，int指针类型，double指针类型，char指针类型等等。 通常，我们用int类型保存一些整型的数据，如 int num = 97 ， 我们也会用char来存储字符： char ch = ‘a’。 我们也必须知道：任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。 因此：指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。 ","date":"2020-05-09","objectID":"/posts/C-1/:5:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"程序的地址 而作为一个程序员，我们不需要了解内存的物理结构，操作系统将DRAM等硬件和软件结合起来，给程序员提供的一种对物理内存使用的抽象。这种抽象机制使得程序使用的是虚拟存储器,而不是直接操作物理存储器。所有的虚拟地址形成的集合就是虚拟地址空间。 也就是说，虚拟存储器是一个很大的，线性的字节数组（平坦寻址）。每一个字节都是固定的大小，由8个二进制位组成。最关键的是，每一个字节都有一个唯一的编号,编号从0开始，一直到最后一个字节。如上图中，这是一个4GB的虚拟存储器的模型，它一共有4x1024x1024x1024 个字节，那么它的虚拟地址范围就是 0 ~ 4x1024x1024x1024-1 。 由于内存中的每一个字节都有一个唯一的编号，因此，在程序中使用的变量，常量，甚至数函数等数据，当他们被载入到内存中后，都有自己唯一的一个编号，这个编号就是这个数据的地址。指针就是这样形成的。 #include \u003cstdio.h\u003eint main(void) { char ch = 'a'; int num = 97; printf(\"ch 的地址:%p\\n\",\u0026ch); //ch 的地址:0028FF47 printf(\"num的地址:%p\\n\",\u0026num); //num的地址:0028FF40 return 0; } 指针的值实质是内存单元（即字节）的编号，所以指针 单独从数值上看，也是整数，他们一般用16进制表示。指针的值（虚拟地址值）使用一个机器字的大小来存储,也就是说,对于一个机器字为w位的电脑而言,它的虚拟地址空间是0~2w － 1 ,程序最多能访问2w个字节。这就是为什么xp这种32位系统最大支持4GB内存的原因了。 我们可以大致画出变量ch和num在内存模型中的存储。（假设 char占1个字节，int占4字节） ","date":"2020-05-09","objectID":"/posts/C-1/:6:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"操作系统为什么提供虚拟地址空间而不是让直接使用物理地址空间？ 提高物理内存的利用效率。 你可能会困惑，这怎么就提高物理内存使用效率了呢？我这里举个共享单车的例子：假如一个国家有10个人，而只生产了2辆自行车(国家小，资源有限嘛~)，这2辆车被2个人买了。把你自己想象为那8个没有自行车的人之一，你的思维是什么——“我没有自行车，我只能步行外出”。倘若是那2个有车的人呢——“我每次外出都可以骑车去，但是大部分时间，我的车是空闲的，没其他人用”。后来，这个国家回收了这仅有的2辆车，把车刷成了统一的颜色，贴上二维码，引入了共享单车系统，然后发出公告：只要车停在路边没人用，任何人都可以刷开骑走。那现在这10个人怎么想呢——“只要我看到有空闲的单车，我就可以使用它”。 抽象的东西更加简单稳定。 从古至今，我们对于“去饭馆吃饭”这个抽象社会行为没有太大的变化——进入饭馆，点菜，付钱，享用，走人。但是人们烹饪的方法却发生了具大的改变，烹饪的器材、食材、食谱一直都在更新改进，如果你经常烹饪，你就需要不断的学习，因为你需要掌握做一道菜的每个细节。 回到内存相关的话题来：无论机器的内存用的是ddr3还是ddr4，是4G物理内存还是8G物理内存，程序员都似乎无需太过关心，因为他们在编程时面向的是虚拟内存，而虚拟内存的模型到目前为止都是固定的。这给程序员带来非常大的便利，他们无需为快速更新的计算机设备而改变自己的编程思维。 这并不意味着抽象的东西就一定不会改变。例如从“到饭馆吃饭”到“点外卖”；从32位操作系统到64位操作系统。都属于抽象的更新换代。 总结： 资产有限的情况下，使用合理的资产使用管理机制，可以使有限的资产服务于更多的人。 抽象的事物更加简单稳定，特定的事物更加复杂易变。 底层通过给上层提供抽象服务来获得利益，上层通过使用底层的抽象来获得便利。 ","date":"2020-05-09","objectID":"/posts/C-1/:7:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"指针变量 和 指向关系 用来保存 指针(地址) 的变量，就是指针变量。如果指针变量p1保存了变量 num的地址，则就说：p1指向了变量num，也可以说p1指向了num所在的内存块 ，这种指向关系，在图中一般用 箭头表示。 上图中，指针变量p1指向了num所在的内存块 ，即从地址0028FF40开始的4个byte 的内存块。 ","date":"2020-05-09","objectID":"/posts/C-1/:8:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"定义指针变量 C语言中，定义变量时，在变量名 前 写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题。 引申：C语言中，定义变量时，在定义的最前面写上typedef ，那么这个变量名就成了一种类型，即这个类型的同义词。 int a ; //int类型变量 a int* p ; //int* 变量p int arr[3]; //arr是包含3个int元素的数组 int (* parr )[3]; //parr是一个指向【包含3个int元素的数组】的指针变量 //-----------------各种类型的指针------------------------------ int* p_int; //指向int类型变量的指针 double* p_double; //指向double类型变量的指针 struct Student *p_struct; //结构体类型的指针 int(*p_func)(int,int); //指向返回类型为int，有2个int形参的函数的指针 int(*p_arr)[3]; //指向含有3个int元素的数组的指针 int** p_pointer; //指向 一个整形变量指针的指针 ","date":"2020-05-09","objectID":"/posts/C-1/:8:1","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"取地址 既然有了指针变量，那就得让他保存其它变量的地址，使用\u0026 运算符取得一个变量的地址。 int add(int a , int b) { return a + b; } int main(void) { int num = 97; float score = 10.00F; int arr[3] = {1,2,3}; //----------------------- int* p_num = \u0026num; float* p_score = \u0026score; int (*p_arr)[3] = \u0026arr; int (*fp_add)(int ,int ) = \u0026add; //p_add是指向函数add的函数指针 /* 等同于 int (*fp_add)(int ,int ) = add; */ return 0; } 特殊的情况，他们并不一定需要使用\u0026取地址： 数组名的值就是这个数组的第一个元素的地址。 函数名的值就是这个函数的地址。 字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名称,也就是这个字符串在内存中的地址。 ","date":"2020-05-09","objectID":"/posts/C-1/:8:2","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"解地址 我们需要一个数据的指针变量干什么？当然使用通过它来操作（读/写）它指向的数据啦。对一个指针解地址，就可以取到这个内存数据，解地址 的写法，就是在指针的前面加一个*号。 解指针的实质是：从指针指向的内存块中取出这个内存数据。 int main(void) { int age = 19; int*p_age = \u0026age; *p_age = 20; //通过指针修改指向的内存数据 printf(\"age = %d\\n\",*p_age); //通过指针读取指向的内存数据 printf(\"age = %d\\n\",age); return 0; } ","date":"2020-05-09","objectID":"/posts/C-1/:8:3","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"指针之间的赋值 指针赋值和int变量赋值一样，就是将地址的值拷贝给另外一个。指针之间的赋值是一种浅拷贝，是在多个编程单元之间共享内存数据的高效的方法。 int* p1 = \u0026 num; int* p3 = p1; /*通过指针 p1 、 p3 都可以对内存数据 num 进行读写，如果2个函数分别使用了p1 和p3，那么这2个函数就共享了数据num。*/ ","date":"2020-05-09","objectID":"/posts/C-1/:8:4","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"空指针 指向空，或者说不指向任何东西。在C语言中，我们让指针变量赋值为NULL表示一个空指针，而C语言中，NULL实质是 ((void*)0) ， 在C++中，NULL实质是0。 换种说法：任何程序数据都不会存储在地址为0的内存块中，它是被操作系统预留的内存块。 stddef.h 源程序代码 #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif ","date":"2020-05-09","objectID":"/posts/C-1/:8:5","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"坏指针 指针变量的值是NULL，或者未知的地址值，或者是当前应用程序不可访问的地址值，这样的指针就是坏指针，不能对他们做解指针操作，否则程序会出现运行时错误，导致程序意外终止。 任何一个指针变量在做 解地址操作前，都必须保证它指向的是有效的，可用的内存块，否则就会出错。坏指针是造成C语言Bug的最频繁的原因之一。 void opp() { int*p = NULL; *p = 10; //Oops! 不能对NULL解地址 } void foo() { int*p; *p = 10; //Oops! 不能对一个未知的地址解地址 } void bar() { int*p = (int*)1000; *p =10; //Oops! 不能对一个可能不属于本程序的内存的地址的指针解地址 } ","date":"2020-05-09","objectID":"/posts/C-1/:8:6","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"指针的2个重要属性 指针也是一种数据，指针变量也是一种变量，因此指针 这种数据也符合前面 变量和内存 主题中的特性。 这里我只想强调2个属性： 指针的类型 指针的值。 int main(void) { int num = 97; int *p1 = \u0026num; char* p2 = (char*)(\u0026num); printf(\"%d\\n\",*p1); //输出 97 putchar(*p2); //输出 a return 0; } 由于num的地址是0028FF40，因此p1和p2的值都是0028FF40 *p1 : 将从地址0028FF40 开始解析，因为p1是int类型指针，int占4字节，因此向后连续取4个字节，并将这4个字节的二进制数据解析为一个整数 97。 *p2 : 将从地址0028FF40 开始解析，因为p2是char类型指针，char占1字节，因此向后连续取1个字节，并将这1个字节的二进制数据解析为一个字符，即’a’。 同样的地址，因为指针的类型不同，对它指向的内存的解释就不同，得到的就是不同的数据。 ","date":"2020-05-09","objectID":"/posts/C-1/:9:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"结构体和指针 结构体指针有特殊的语法： -\u003e 符号 如果p是一个结构体指针，则可以使用 p -\u003e【成员】 的方法访问结构体的成员。p-\u003emember 等价于 (*p).member。 typedef struct { char name[31]; int age; float score; }Student; int main(void) { Student stu = {\"Bob\" , 19, 98.0}; Student*ps = \u0026stu; ps-\u003eage = 20; ps-\u003escore = 99.0; printf(\"name:%s age:%d\\n\",ps-\u003ename,ps-\u003eage); return 0; } ","date":"2020-05-09","objectID":"/posts/C-1/:10:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"数组和指针 数组名作为右值的时候，就是第一个元素的地址。 int main(void) { int arr[3] = {1,2,3}; int*p_first = arr; printf(\"%d\\n\",*p_first); //1 return 0; } 2.指向数组元素的指针 支持 递增 递减 运算。（实质上所有指针都支持递增递减 运算 ，但只有在数组中使用才是有意义的） int main(void) { int arr[3] = {1,2,3}; int*p = arr; for(;p!=arr+3;p++){ printf(\"%d\\n\",*p); } return 0; } p= p+1 意思是： 让p指向原来指向的内存块的下一个相邻的相同类型的内存块。 同一个数组中，元素的指针之间可以做减法运算，此时，指针之差等于下标之差。 用指针指向数组中的元素 p[n] == *(p+n) p[n][m] == *( *(p+n)+ m ) 当对数组名使用sizeof时，返回的是整个数组占用的内存字节数。当把数组名赋值给一个指针后，再对指针使用sizeof运算符，返回的是指针的大小。 这就是为什么我么将一个数组传递给一个函数时，需要另外用一个参数传递数组元素个数的原因了。 int main(void) { int arr[3] = {1,2,3}; int*p = arr; printf(\"sizeof(arr)=%d\\n\",sizeof(arr)); //sizeof(arr)=12 printf(\"sizeof(p)=%d\\n\",sizeof(p)); //sizeof(p)=4 return 0; } ","date":"2020-05-09","objectID":"/posts/C-1/:11:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"函数和指针 ","date":"2020-05-09","objectID":"/posts/C-1/:12:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"函数的参数和指针 C语言中，实参传递给形参，是按值传递的，也就是说，函数中的形参是实参的拷贝份，形参和实参只是在值上面一样，而不是同一个内存数据对象。这就意味着：这种数据传递是单向的，即从调用者传递给被调函数，而被调函数无法修改传递的参数达到回传的效果。 void change(int a) { a++; //在函数中改变的只是这个函数的局部变量a，而随着函数执行结束，a被销毁。age还是原来的age，纹丝不动。 } int main(void) { int age = 19; change(age); printf(\"age = %d\\n\",age); // age = 19 return 0; } 有时候我们可以使用函数的返回值来回传数据，在简单的情况下是可以的，但是如果返回值有其它用途（例如返回函数的执行状态量），或者要回传的数据不止一个，返回值就解决不了了。 传递变量的指针可以轻松解决上述问题。 复制代码 void change(int* pa) { (*pa)++; //因为传递的是age的地址，因此pa指向内存数据age。当在函数中对指针pa解地址时， //会直接去内存中找到age这个数据，然后把它增1。 } int main(void) { int age = 19; change(\u0026age); printf(\"age = %d\\n\",age); // age = 20 return 0; } 再来一个老生常谈的，用函数交换2个变量的值的例子： #include\u003cstdio.h\u003evoid swap_bad(int a,int b); void swap_ok(int*pa,int*pb); int main() { int a = 5; int b = 3; swap_bad(a,b); //Can`t swap; swap_ok(\u0026a,\u0026b); //OK return 0; } //错误的写法 void swap_bad(int a,int b) { int t; t=a; a=b; b=t; } //正确的写法：通过指针 void swap_ok(int*pa,int*pb) { int t; t=*pa; *pa=*pb; *pb=t; } 有的时候，我们通过指针传递数据给函数不是为了在函数中改变他指向的对象，相反，我们防止这个目标数据被改变。 传递指针只是为了避免拷贝大型数据。 考虑一个结构体类型Student。我们通过show函数输出Student变量的数据。 typedef struct { char name[31]; int age; float score; }Student; //打印Student变量信息 void show(const Student * ps) { printf(\"name:%s , age:%d , score:%.2f\\n\",ps-\u003ename,ps-\u003eage,ps-\u003escore); } 我们只是在show函数中取读Student变量的信息，而不会去修改它，为了防止意外修改，我们使用了常量指针去约束。另外我们为什么要使用指针而不是直接传递Student变量呢？ 从定义的结构看出，Student变量的大小至少是39个字节，那么通过函数直接传递变量，实参赋值数据给形参需要拷贝至少39个字节的数据，极不高效。而传递变量的指针却快很多，因为在同一个平台下，无论什么类型的指针大小都是固定的：X86指针4字节，X64指针8字节，远远比一个Student结构体变量小。 ","date":"2020-05-09","objectID":"/posts/C-1/:12:1","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"函数的指针 每一个函数本身也是一种程序数据，一个函数包含了多条执行语句，它被编译后，实质上是多条机器指令的合集。在程序载入到内存后，函数的机器指令存放在一个特定的逻辑区域：代码区。既然是存放在内存中，那么函数也是有自己的指针的。 C语言中，函数名作为右值时，就是这个函数的指针。 void echo(const char *msg) { printf(\"%s\",msg); } int main(void) { void(*p)(const char*) = echo; //函数指针变量指向echo这个函数 p(\"Hello \"); //通过函数的指针p调用函数，等价于echo(\"Hello \") echo(\"World\\n\"); return 0; } ","date":"2020-05-09","objectID":"/posts/C-1/:12:2","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["C语言"],"content":"const 和 指针 如果const 后面是一个类型，则跳过最近的原子类型，修饰后面的数据。（原子类型是不可再分割的类型，如int, short , char，以及typedef包装后的类型） 如果const后面就是一个数据，则直接修饰这个数据。 int main() { int a = 1; int const *p1 = \u0026a; //const后面是*p1，实质是数据a，则修饰*p1，通过p1不能修改a的值 const int*p2 = \u0026a; //const后面是int类型，则跳过int ，修饰*p2， 效果同上 int* const p3 = NULL; //const后面是数据p3。也就是指针p3本身是const . const int* const p4 = \u0026a; // 通过p4不能改变a 的值，同时p4本身也是 const int const* const p5 = \u0026a; //效果同上 return 0; } 深拷贝和浅拷贝 如果2个程序单元（例如2个函数）是通过拷贝 他们所共享的数据的 指针来工作的，这就是浅拷贝，因为真正要访问的数据并没有被拷贝。如果被访问的数据被拷贝了，在每个单元中都有自己的一份，对目标数据的操作相互 不受影响，则叫做深拷贝。 指针和引用这个2个名词的区别 指针和引用这个2个名词的区别。他们本质上来说是同样的东西。指针常用在C语言中，而引用，则用于诸如Java，C#等 在语言层面封装了对指针的直接操作的编程语言中。引用是编程语言提供给程序员的抽象机制，而指针是操作系统提供给软件开发模型的抽象机制。 大端模式和小端模式 Little-Endian就是数据的低字节排放在内存的低地址端，高字节排放在内存的高地址端。个人PC常用，Intel X86处理器是小端模式。 Big-Endian就是数据的高字节排放在内存的低地址端，低字节排放在内存的高地址端。 采用大端方式 进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。有些机器同时支持大端和小端模式。 假如 short类型占用2个字节，且存储的地址为0x30。 short a = 1; ","date":"2020-05-09","objectID":"/posts/C-1/:13:0","tags":["C-语法基础"],"title":"C语言-指针","uri":"/posts/C-1/"},{"categories":["Leetcode"],"content":"232-用栈实现队列 662-二叉树最大宽度 21-合并两个有序链表 1-两数之和 ","date":"2020-05-08","objectID":"/posts/leetcode-3/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-3","uri":"/posts/leetcode-3/"},{"categories":["Leetcode"],"content":"232-用栈实现队列 使用栈实现队列的下列操作： push(x) -- 将一个元素放入队列的尾部。 pop() -- 从队列首部移除元素。 peek() -- 返回队列首部的元素。 empty() -- 返回队列是否为空。 一开始我是想到用两个栈的，但竟然傻到…要用链栈去实现…我鲨我自己 这道题用静态栈很棒，因为两个栈元素来回移动，不用malloc啊 #define MAXSIZE 100 //创建栈 struct Stack{ int Data[MAXSIZE]; int TOP; }; typedef struct Stack MyStack; //队列定义为双栈 typedef struct { MyStack S1; //S1为主栈 MyStack S2; //S2为用来反转的栈 } MyQueue; /** Initialize your data structure here. */ MyQueue* myQueueCreate() { MyQueue* TempQueue=(MyQueue*)malloc(sizeof(MyQueue)); TempQueue-\u003eS1.TOP=-1; TempQueue-\u003eS2.TOP=-1; return TempQueue; } /** Push element x to the back of queue. */ void myQueuePush(MyQueue* obj, int x) { if(obj-\u003eS1.TOP\u003cMAXSIZE){ //栈是否满 while(obj-\u003eS1.TOP!=-1){ obj-\u003eS2.Data[++(obj-\u003eS2.TOP)]=obj-\u003eS1.Data[(obj-\u003eS1.TOP)--]; //把S1栈中元素压入S2实现反转 } obj-\u003eS1.Data[++(obj-\u003eS1.TOP)]=x; //把push的元素压入S1栈（此时S1为空栈，因为它的元素已经全部给S2啦） while(obj-\u003eS2.TOP!=-1){ obj-\u003eS1.Data[++(obj-\u003eS1.TOP)]=obj-\u003eS2.Data[(obj-\u003eS2.TOP)--]; //再把S2栈中的元素全部反转压入S1 } } } /** Removes the element from in front of queue and returns that element. */ int myQueuePop(MyQueue* obj) { if(obj-\u003eS1.TOP!=-1) return obj-\u003eS1.Data[(obj-\u003eS1.TOP)--]; return NULL; } /** Get the front element. */ int myQueuePeek(MyQueue* obj) { if(obj-\u003eS1.TOP!=-1) return obj-\u003eS1.Data[obj-\u003eS1.TOP]; return NULL; } /** Returns whether the queue is empty. */ bool myQueueEmpty(MyQueue* obj) { if(obj-\u003eS1.TOP==-1) return true; return false; } void myQueueFree(MyQueue* obj) { free(obj); } ","date":"2020-05-08","objectID":"/posts/leetcode-3/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-3","uri":"/posts/leetcode-3/"},{"categories":["Leetcode"],"content":"662-二叉树最大宽度 问题描述： 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。 解题思路： 本题有两种思路，分别是层次遍历和深度遍历 由于层次遍历还要构造一个队列…算了算了 这里提供一个好的方法，递归深度遍历，用一个数组存储每层第一个元素的position，这样每次访问元素时，就和当前层的第一个元素进行position-a[index]+1运算，得到宽度 int max = 1; void func(struct TreeNode *node, int index, double pos, int *a) { if (node == NULL) { return; } if (a[index] == 0) { //如果当前值为0，则为第一次访问该层 a[index] = pos; } else { max = max \u003e (pos - a[index] + 1) ? max : (pos - a[index] + 1); } func(node-\u003eleft, index + 1, 2 * pos, a); func(node-\u003eright, index + 1, 2 * pos + 1, a); } int widthOfBinaryTree(struct TreeNode* root){ int index = 0; int a[1000000] = {0}; //将静态数组的值都初始化为0 if (root == NULL) { return 0; } max = 1; func(root, 1, 1, a); return max; } ","date":"2020-05-08","objectID":"/posts/leetcode-3/:2:0","tags":["Leetcode-C++"],"title":"Leetcode Part-3","uri":"/posts/leetcode-3/"},{"categories":["Leetcode"],"content":"21-合并两个有序链表 常规算法 struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ if(!l1){ return l2; } if(!l2){ return l1; } struct ListNode *head = (struct ListNode*)malloc(sizeof(struct ListNode)),*p = head; //head node while(l1 \u0026\u0026 l2){ if(l1-\u003eval \u003e l2-\u003eval){ p-\u003enext = l2; l2 = l2-\u003enext; } else{ p-\u003enext = l1; l1 = l1-\u003enext; } p = p-\u003enext; } if(l1){ p-\u003enext = l1; } else if(l2){ p-\u003enext = l2; } return head-\u003enext; } 递归算法 struct ListNode * mergeTwoLists(struct ListNode * l1, struct ListNode * l2) { if (!l1) return l2; if (!l2) return l1; if (l1 - \u003e val \u003c l2 - \u003e val) { l1 - \u003e next = mergeTwoLists(l1 - \u003e next, l2); return l1; } else { l2 - \u003e next = mergeTwoLists(l1, l2 - \u003e next); return l2; } } ","date":"2020-05-08","objectID":"/posts/leetcode-3/:3:0","tags":["Leetcode-C++"],"title":"Leetcode Part-3","uri":"/posts/leetcode-3/"},{"categories":["Leetcode"],"content":"1-两数之和 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 打扰了，我只会暴力算法… int* twoSum(int* nums, int numsSize, int target, int* returnSize){ int *res = (int*)malloc(sizeof(int)*2); *returnSize = 0; for(int i=0; i\u003cnumsSize; i++){ for(int j=i+1; j\u003cnumsSize; j++){ if(nums[i]+nums[j] == target){ res[0] = i; res[1] = j; *returnSize = 2; return res; } } } return res; } ","date":"2020-05-08","objectID":"/posts/leetcode-3/:4:0","tags":["Leetcode-C++"],"title":"Leetcode Part-3","uri":"/posts/leetcode-3/"},{"categories":["物联网"],"content":"物联网数据检索 文本检索 基于文字的检索 基于结构的检索 基于用户信息的检索 ","date":"2020-05-08","objectID":"/posts/IOT-12/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["物联网"],"content":"基于文字的检索(根据文字内容计算查询和文本的相似度) 布尔模型(计算机 AND 文化)检索的相关度0,或者1 向量空间模型 关键字和权重组成向量 概率模型-查询中的关键字在相关和不相关文档中的概率 统计语言模型-通过语言的方法将查询和文档联系起来 ","date":"2020-05-08","objectID":"/posts/IOT-12/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["物联网"],"content":"布尔模型 在布尔检索模型中, 将用户提问表示成布尔表达式, 使用逻辑运算符将提问词连接起来, 其中每个提问词表达了用户的一个兴趣。 检索时, 检索系统将提问式与文档进行逻辑匹配操作, 得出命中文献集合为检索结果。检索结果一般不进行相关性排序。 在检索策略的使用方面, 以布尔逻辑为基础的文本检索系统可能提供位置检索、截断检索以及自然语言检索等检索手段。 ","date":"2020-05-08","objectID":"/posts/IOT-12/:1:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["物联网"],"content":"向量空间模型 向量空间模型用检索项的高维向量空间来表示用户的检索和文本集信息,其中每一维为一个特征。一个用户检索向量或文本向量的第i 个元素表示用户检索或文本的第i 个特征的重要度, 或称权值。用户检索向量的权值由用户指定; 文本向量的权值则根据特征在文本或文本集中的出现频率决定。 检索向量与文本向量间的余弦角通常用来测定该文本与该用户提问词之间的匹配程度。向量空间模型不仅可以方便地产生有效的检索结果,而且能提供相关文档的文摘,并进行检索结果分类, 为用户提供准确定位所需的信息。 ","date":"2020-05-08","objectID":"/posts/IOT-12/:1:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["物联网"],"content":"概率模型 在概率模型中, 检索是根据概率排序规则进行的。基本的文本检索推理网络包括文本网络和用户检索网络。文本网络使用不同的文本表示框架来表示文本集,对每一个文本集,文本网络只建立一次,且在检索过程中不改变其结构。用户提问网络则只有一个表示用户检索信息的节点及一个或多个查询表达式。 文本网络与用户检索之间的连接则由文本概念表示节点与提问概念表示节点之间的链来表示。不论是文本网络还是用户检索,每一节点有一个概率值。节点与节点之间的因果关系表示为:给定文本节点的先验概率及中间节点的条件概率,就能得到每一节点的后验概率。原始文本集与用户检索集经过概率计算,得到文本与用户提问的匹配程度。 ","date":"2020-05-08","objectID":"/posts/IOT-12/:1:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["物联网"],"content":"基于结构的检索 文档结构 包括内部结构和外部结构 内部结构-文档为文字的位置,格式等信息 外部结构-文档之间的关联(如引用) 通常不会单独使用,结合基于文字的检索联合使用 ","date":"2020-05-08","objectID":"/posts/IOT-12/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["物联网"],"content":"基于用户信息的检索 使用用户本身的信息参与检索 用户是第一位的(查询由用户提出,结果要用户认可) 用户的性别,职业,阅读习惯,爱好等 基于单个用户的和基于群体用户的 图像检索 ","date":"2020-05-08","objectID":"/posts/IOT-12/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["物联网"],"content":"基于内容的图像检索 将视觉特征,例如颜色、纹理结构和形状等,作为图像内容抽取出来进行匹配查找 特征提取(颜色、纹理、形状) 查询方式:示例查询和草图查询 ","date":"2020-05-08","objectID":"/posts/IOT-12/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["物联网"],"content":"基于语义的图像检索 如何获取图像的语义? 利用系统知识的语义提取(特定应用领域) 利用系统的交互(人工标注) 基于外部信息 音频检索 ","date":"2020-05-08","objectID":"/posts/IOT-12/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["物联网"],"content":"音频检索系统结构 原始音频预处理(语音处理、音频分隔、特征提取) 用户查询模块 元数据库和音频媒体数据库 长音频分割,获得结构关系;特征提取记入特征数据库;分类,建立分类目录;转换成文本,记入文本库 用户查询(提交查询的音频信号,返回结果;或者浏览库) ","date":"2020-05-08","objectID":"/posts/IOT-12/:6:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["物联网"],"content":"音频检索概念 自动分类中常用的特征(带宽、响度、过零率) 音频信号流的分隔(分层分割算法;压缩域窗分割算法、模板分割算法) 音频内容的描述和索引 音频检索方法(主观描述查询、示例查询、拟声查询、表格查询) 视频检索 关键帧提取 图像特征提取 相似性度量 查询方式 视频片段匹配 数据的可视化技术 数据可视化,是指将结构或非结构化的数据转换成适当的可视化图表,然后将隐藏在数据中的信息直接展现在人们面前,是一种关于数据视觉表现形式的科学技术研究。 根据不同的数据挖掘方法,可以采用不同的数据可视化技术 ","date":"2020-05-08","objectID":"/posts/IOT-12/:7:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-12","uri":"/posts/IOT-12/"},{"categories":["Leetcode"],"content":"11-栈中保存最小值 ","date":"2020-05-07","objectID":"/posts/leetcode-2/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-2","uri":"/posts/leetcode-2/"},{"categories":["Leetcode"],"content":"11-栈中保存最小值 题目:设计一个支持push,pop,top操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 此题求解有两个思路,分别是双栈和单栈 双栈中一个栈记录栈中元素,另一个栈记录最小元素(似乎有种似曾相识的感觉) 单栈即在栈结构中保存最小元素的值 我只想到了第二种方法,然后还没写明白…第一种压根没想到,算法还是要奇思广义啊 ","date":"2020-05-07","objectID":"/posts/leetcode-2/:1:0","tags":["Leetcode-C++"],"title":"Leetcode Part-2","uri":"/posts/leetcode-2/"},{"categories":["Leetcode"],"content":"方法一 typedef struct tagNode{ //定义链栈节点 int val; struct tagNode *next; }LinkList, *Node_ptr; typedef struct { //定义链栈 LinkList* stk; int min_val; } MinStack; MinStack* minStackCreate() { MinStack *p = (MinStack*)malloc(sizeof(MinStack)); p-\u003estk = (LinkList*)malloc(sizeof(LinkList)); p-\u003estk-\u003enext = NULL; return p; } void minStackPush(MinStack* obj, int x) { if(!obj-\u003estk-\u003enext || (obj-\u003estk-\u003enext \u0026\u0026 x \u003c obj-\u003emin_val)) obj-\u003emin_val = x; Node_ptr p = (Node_ptr)malloc(sizeof(LinkList)); p-\u003eval = x; p-\u003enext = obj-\u003estk-\u003enext; obj-\u003estk-\u003enext = p; } void findMinVal(MinStack *obj)　//遍历链表找最小值节点 { Node_ptr p = obj-\u003estk-\u003enext; if(p){ obj-\u003emin_val = p-\u003eval; while(p){ if(p-\u003eval \u003c obj-\u003emin_val) obj-\u003emin_val = p-\u003eval; p = p-\u003enext; } } } void minStackPop(MinStack* obj) { if(obj-\u003estk-\u003enext){ Node_ptr p = obj-\u003estk-\u003enext; obj-\u003estk-\u003enext = p-\u003enext; if(p-\u003eval == obj-\u003emin_val){ //若要pop的节点为最小值节点，需要找到新的最小值节点 findMinVal(obj); } free(p); } } int minStackTop(MinStack* obj) { if(obj-\u003estk-\u003enext){ return obj-\u003estk-\u003enext-\u003eval; } return; } int minStackGetMin(MinStack* obj) { if(obj-\u003estk-\u003enext){ return obj-\u003emin_val; } return; } void minStackFree(MinStack* obj) { free(obj); } ","date":"2020-05-07","objectID":"/posts/leetcode-2/:1:1","tags":["Leetcode-C++"],"title":"Leetcode Part-2","uri":"/posts/leetcode-2/"},{"categories":["Leetcode"],"content":"方法二 使用了静态栈 #define STACK_MAX 1000 typedef struct { int top; int data[STACK_MAX]; } MyStack; typedef struct { MyStack stackAll; MyStack stackMin; } MinStack; MinStack *minStackCreate() { MinStack *stack = malloc(sizeof(MinStack)); stack-\u003estackAll.top = -1; stack-\u003estackMin.top = -1; return stack; } void minStackPush(MinStack *obj, int x) { //只判断stackAll即可，stackMin的数据小于等于stackAll if (obj-\u003estackAll.top == (STACK_MAX - 1)) return; //stackAll保存所有数据，都要入栈 obj-\u003estackAll.data[++obj-\u003estackAll.top] = x; //stackMin保存最小数据，入栈前需要判断栈顶值 if (-1 == obj-\u003estackMin.top || x \u003c= obj-\u003estackMin.data[obj-\u003estackMin.top]) { obj-\u003estackMin.data[++obj-\u003estackMin.top] = x; } } void minStackPop(MinStack *obj) { if (obj-\u003estackAll.top == -1) return; if (obj-\u003estackAll.data[obj-\u003estackAll.top] == obj-\u003estackMin.data[obj-\u003estackMin.top]) { obj-\u003estackMin.top--; } obj-\u003estackAll.top--; } int minStackTop(MinStack *obj) { return obj-\u003estackAll.data[obj-\u003estackAll.top]; } int minStackGetMin(MinStack *obj) { return obj-\u003estackMin.data[obj-\u003estackMin.top]; } void minStackFree(MinStack *obj) { free(obj); } ","date":"2020-05-07","objectID":"/posts/leetcode-2/:1:2","tags":["Leetcode-C++"],"title":"Leetcode Part-2","uri":"/posts/leetcode-2/"},{"categories":["物联网"],"content":"MapReduce,Spark框架 MapReduce MapReduce是一种分布式并行编程框架 ","date":"2020-05-07","objectID":"/posts/IOT-11/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"Handoop的概念 Hadoop是一个能够对大量数据进行分布式处理的软件框架，实现了Google的MapReduce编程模型和框架，能够把应用程序分割成许多的小的工作单元，并把这些单元放到任何集群节点上执行。在MapReduce中，一个准备提交执行的应用程序称为“作业（job）”，而从一个作业划分出 得、运行于各个计算节点的工作单元称为“任务（task）”。此外，Hadoop提供的分布式文件系统（HDFS）主要负责各个节点的数据存储，并实现了高吞吐率的数据读写。 其中HDFS在Part-9的最后有所介绍 ","date":"2020-05-07","objectID":"/posts/IOT-11/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"数据处理能力提升的两种方式 单机情况下的纵向扩展 分布式并行的横向扩展 ","date":"2020-05-07","objectID":"/posts/IOT-11/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"MapReduce核心思想 ","date":"2020-05-07","objectID":"/posts/IOT-11/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"分而治之的策略 当我们在做大规模数据处理的时候,MapReduce会把非常庞大的数据集切分成很多个小分片 然后为每一个分片单独地启动一个Map任务 最终通过多个Map任务,并行地在多个机器上去处理,从而实现分而治之 ","date":"2020-05-07","objectID":"/posts/IOT-11/:3:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"理念 计算向数据靠拢 ","date":"2020-05-07","objectID":"/posts/IOT-11/:3:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"基本原理 ","date":"2020-05-07","objectID":"/posts/IOT-11/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"Map函数 ","date":"2020-05-07","objectID":"/posts/IOT-11/:4:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"Reduce函数 ","date":"2020-05-07","objectID":"/posts/IOT-11/:4:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"MapReduce处理流程 ","date":"2020-05-07","objectID":"/posts/IOT-11/:4:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"应用实例 ","date":"2020-05-07","objectID":"/posts/IOT-11/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"任务目标 ","date":"2020-05-07","objectID":"/posts/IOT-11/:5:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"执行过程 物联网并行处理 Spark框架 ","date":"2020-05-07","objectID":"/posts/IOT-11/:5:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"概念 Spark最初是由美国加州伯克利大学(UCBerkeley)的AMP实验室于2009年开发的,它是一个基于内存计算的大数据并行计算框架,可用于构建大型的、低延迟的数据分析应用程序 2013年加入Apache孵化器项目后发展迅猛,已成为Apache软件基金会最重要的三大分布式计算系统开源项目之一(Hadoop,Spark,Storm) ","date":"2020-05-07","objectID":"/posts/IOT-11/:6:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"Scala语言 Scala 是一门现代的多范式编程语言 函数式编程:Lisp语言,Haskell语言 面向对象编程:Java 面向过程编程:C语言 多范式: 集成了面向对象和函数式编程两种风格,可以运行于Java平台,并兼容现有的Java程序 Scala具备强大的并发性,支持函数式编程,可以更好地支持分布式系统 Scala语法简洁,能提供优雅的API Scala兼容Java,运行速度快,且能融合到Hadoop生态圈中 ","date":"2020-05-07","objectID":"/posts/IOT-11/:7:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"Spark与Hadoop对比 2014年,Spark打破了Hadoop保持的基准排序记录 Spark: 23分钟,206个节点,100TB数据 Hadoop:72分钟,2000个节点,100TB数据 Spark用十分之一的计算资源获得了比Hadoop快3倍的速度 ","date":"2020-05-07","objectID":"/posts/IOT-11/:8:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"计算过程对比 ","date":"2020-05-07","objectID":"/posts/IOT-11/:9:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"Spark组成 ","date":"2020-05-07","objectID":"/posts/IOT-11/:10:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"运算过程 ","date":"2020-05-07","objectID":"/posts/IOT-11/:11:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"Spark的优点 利用多线程来执行具体的任务,减少了任务的启动开销 Executor中有一个BlockManager存储模块,会将内存和磁盘共同作为存储设备,有效减少IO开销 ","date":"2020-05-07","objectID":"/posts/IOT-11/:12:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-11","uri":"/posts/IOT-11/"},{"categories":["物联网"],"content":"物联网云计算和虚拟化,数据的预处理 今天物联网撒花啦！开心 但是最后部分知识点有些多,可能最后要分多个Blog来记录 物联网云计算和虚拟化 ","date":"2020-05-07","objectID":"/posts/IOT-10/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"云计算 2006年时任Google首席执行官，在搜索引擎大会上首次提出“云计算”的概念 云计算是一种无处不在，便携且按需对一个共享的可配置计算资源（网络，服务器，存储，应用，服务）进行网络访问的模式，它通过最少量的管理以及与服务提供商的互动实现计算机资源的迅速供给和释放 ","date":"2020-05-07","objectID":"/posts/IOT-10/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"云计算技术 ","date":"2020-05-07","objectID":"/posts/IOT-10/:1:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"虚拟化概述 虚拟化技术的核心思想是利用软件或固件管理程序构成虚拟化层，把物理资源映射为虚拟资源，在虚拟资源上可以安装和部署多个虚拟机，实现多用户共享物力资源 随着云计算的发展，传统的数据中心逐渐过渡为虚拟化数据中心 利用虚拟化技术将原来数据中心的物理资源进行抽象整合 数据中心的虚拟化可以实现资源的动态分配和调度，提高现有资源的利用率和服务的可靠性 可以提供自动化的服务，降低运维成本 具有有效的安全机制和可靠性机制，满足公众客户和企业客户的安全需求 方便系统升级，迁移和改造 ","date":"2020-05-07","objectID":"/posts/IOT-10/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"物联网云计算和虚拟化 将一个或多个物理服务器虚拟成多个逻辑上的服务器,集中管理,能跨越物理平台不受限制。 一个物理服务器虚拟成多个独立的逻辑服务器 把多个分散的物理服务器虚拟为一个大的逻辑服务器 ","date":"2020-05-07","objectID":"/posts/IOT-10/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"根据解决x86体系缺陷的不同进行分类 ","date":"2020-05-07","objectID":"/posts/IOT-10/:3:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"虚拟存储技术 ","date":"2020-05-07","objectID":"/posts/IOT-10/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"传统存储技术 RAID磁盘阵列 NAS网络连接存储 SAN存储区域网络 ","date":"2020-05-07","objectID":"/posts/IOT-10/:4:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"存储虚拟化概述 存储虚拟化就是指将存储网络中各个分散且异构的存储设备按照一定的策略映射成一个统一的连续编址的逻辑存储空间,称为虚拟存储池,并将虚拟存储池的访问接口提供给应用系统。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:4:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"存储虚拟化优势 存储虚拟化将系统中分散的存储资源整合起来 在虚拟层通过使用数据镜像、数据校验和多路径等技术提高了数据的可靠性及系统的可用性 利用负载均衡、数据迁移、数据块重组等技术提升系统的潜在性能 整合和重组低层物理资源 存储系统已成为数据中心的核心平台 ","date":"2020-05-07","objectID":"/posts/IOT-10/:4:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"网络虚拟化 ","date":"2020-05-07","objectID":"/posts/IOT-10/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"传统数据中心网络 数据网络 存储网络 高性能计算网络 服务器之间操作系统和上层软件异构、接口和数据格式不统一 拥塞丢包 数据冗余 数据中心网络传输效率低 ","date":"2020-05-07","objectID":"/posts/IOT-10/:5:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"网络虚拟化及SDN 网络虚拟化是让一个物理网络能够支持多个逻辑网络,虚拟化保留了网络设计中原有的层次结构、数据通道和所能提供的服务,使得最终用户的体验和独享物理网络一样,同时网络虚拟化技术还可以高效的利用网络资源如空间、能源、设备容量等。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:5:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"SDN概念 软件定义网络(Software Defined Network,SDN)是由美国斯坦福大学CLean State课题研究组提出的一种新型网络创新架构,是网络虚拟化的一种实现方式。其核心技术OpenFlow通过将网络设备的控制面与数据面分离开来,从而实现了网络流量的灵活控制,使网络作为管道变得更加智能,为核心网络及应用的创新提供了良好的平台。 将网络分为控制层(Control Plane)和数据层(Data Plane) 控制层的控制器软件,通过特定传输通道,统一下达命令给数据层设备 数据层设备仅依靠控制层的命令转发数据包 SDN不等于网络虚拟化,只是SDN这种技术非常适合实现网络虚拟化 网络虚拟化可以在现有网络中运作,因为它们在服务器运行,并与发送到它们的流量进行交互 而SDN则需要一种新的网络架构,从而分离数据层和控制层 数据的预处理 ","date":"2020-05-07","objectID":"/posts/IOT-10/:5:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"数据的预处理原因 在现实生活中存在大量的“脏数据” 不完整性 缺少感兴趣的属性 感兴趣的属性缺少部分属性值 仅包含聚合数据，没有详细数据 噪音数据 数据中包含错误数据 存在着部分偏离期望值的孤立点 不一致性 数据结构的不一致性 Label（数据特点）的不一致性 数据值的不一致性 ","date":"2020-05-07","objectID":"/posts/IOT-10/:6:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"数据清洗 数据清洗主要是删去数据中重复的记录,消除数据中的噪声数据,纠正不完整和不一致的数据。 噪声数据是指数据中存在着错误或异常的数据 不完整数据是指数据中缺乏某些属性值 不一致数据是指数据内涵出现不一致情况 ","date":"2020-05-07","objectID":"/posts/IOT-10/:7:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"作用 填补遗漏的数据值 平滑有噪声的数据 识别或除去异常值 解决不一致问题 ","date":"2020-05-07","objectID":"/posts/IOT-10/:7:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"数据集成 数据集成是将这些数据源中的数据集中存放在一个统一的数据存储(如数据仓库)中。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:8:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"数据转换 数据转换指将一种格式的数据转换为另外一种格式的数据,其目的就是为了使数据和将来要建立的模型拟合得更好,形成适合挖掘的形式。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:9:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"数据归约 数据归约是指在尽可能保持数据原貌的情况下,最大限度地精简数据量,因此也称为数据消减。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:10:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"知识发现 知识发现是一个选择和提取数据的过程,它能自动地发现新的、精确的、有用的模式以及现实世界现象。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:11:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"广义知识发现 数据立方体:数据立方体是实现某些常用的、代价较高的聚集函数的计算,如计数、求和、平均、最大值等,并将这些实现视图存储在多维数据库中。 面向属性的归约:面向属性的归约则是以类SQL语言表示数据挖掘查询,收集数据库中的相关数据集,然后在相关数据集上应用一系列数据推广计数进行数据推广。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:11:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"狭义知识发现 关联知识发现:关联知识发现是反映一个事件和其他事件之间依赖或关联。如果两项或多项属性之间存在关联,那么其中一项的属性值就可以依赖其他属性值进行预测。 分类知识发现:分类知识发现是反映同类事物共同性质的特征型知识和不同事物之间的差异型特征。 预测知识发现:预测型知识发现是有历史的和当前的数据去推测未来的数据,也可以认为是以时间为关键属性的关联知识发现。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:11:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"数据挖掘 二十世纪末以来,全球信息量以惊人的速度急剧增长——据估计,每二十个月将增加一倍。为了充分利用现有信息资源,从海量数据中找出隐藏的知识,数据挖掘技术应运而生并并显示出强大的生命力。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:12:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"定义 技术角度的定义 数据挖掘是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中,提取隐含在其中的、人们事先不知道的、但又是潜在有用的信息和知识的过程。与数据挖掘相近的同义词包括:数据融合、数据分析和决策支持等。 商业角度的定义 数据挖掘是一种新的商业信息处理技术,其主要特点是对商业数据库中的大量业务数据进行抽取、转换、分析和其他模型化处理,从中提取辅助商业决策的关键性信息。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:12:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"数据挖掘的方法 分类(Classification) 聚类(Clustering) 相关规划(Association Rule) 回归(Regression) 其他 ","date":"2020-05-07","objectID":"/posts/IOT-10/:13:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"关联分析 若两个或多个变量的取值之间存在某种规律性,就称为关联。 从一个项目集中发现关联规则,该规则显示了给定数据集中经常一起出现的属性-值条件元组。 算法实现(看不懂…先写上) ","date":"2020-05-07","objectID":"/posts/IOT-10/:13:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"分类分析 分类指通过分析一个类别己知的数据集的特征来建立一组模型,该模型可用以预测类别未知的数据项的类别。该分类模型可以表现为多种形式:分类规则,决策树或者数学公式,乃至神经网络。 ","date":"2020-05-07","objectID":"/posts/IOT-10/:13:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["物联网"],"content":"聚类分析 聚类分析又称为“同质分组”或者“无监督的分类”,指把一组数据分成不同的“簇”,每簇中的数据相似而不同簇间的数据则距离较远。相似性可以由用户或者专家定义的距离函数加以度量。 基于划分的聚类分析 基于层次的聚类分析 基于密度的聚类分析 基于网格的聚类分析 基于模型的聚类分析 ","date":"2020-05-07","objectID":"/posts/IOT-10/:13:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-10","uri":"/posts/IOT-10/"},{"categories":["Ubuntu"],"content":"在亲密接触Ubuntu这两个月中,一直在美化,安装各种插件来提升生产和学习效率,现在系统给我的体验就是,除了在一些专业软件(Adobe全家桶)的欠缺之外,ubunut已经完全超越了我的预期,并且效率和自由度比windows强了很多,让我完全沉浸于Ubuntu中,并且深深的爱上了她,所以在这里记录一下 慢慢更,先挖个坑 1.美化以及插件网站 1. Gnome美化 2. 插件安装网站 这里不再多说gnome-tweek的安装过程,参考以下bolg即可 参考Blog 2.插件推荐 Applications Menu topbar会显示一个快捷\"应用程序\"按钮 Clipboard Indicator 复制粘贴的历史记录 Dash to Dock 智能显示dock Hide Activities Button 隐藏topbar上的鸡肋active OpenWeather 天气插件,显示在topbar上 Recent Items 打开文件的历史记录 TopIcons Plus 将正在运行的程序图标移至topbar User Themes 可以改变shell主题的插件 Add Username to Top Panel 在topbar中增加用户名 Bing Wallpaper Changer 每日更新bing壁纸 Bluetooth quick connect 蓝牙快速连接 Coverflow Alt-Tab 魔幻任务切换界面 control+tab Desktop Icons 在任务界面增加icon Drop Down Terminal terminal快捷键召唤 Poweroff Button on Topbar 在topbar增加关机键 ","date":"2020-05-07","objectID":"/posts/ubuntu-20/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu优化总结","uri":"/posts/ubuntu-20/"},{"categories":["物联网"],"content":"物联网与大数据 物联网与大数据 ","date":"2020-05-06","objectID":"/posts/IOT-9/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"大数据概念 无法在可承受的时间范围内用常规软件工具进行捕捉、管理和处理的数据集合 是需要新处理模式才能具有更强的决策力、洞察发现力和流程化能力 海量、高增长和多样化的信息资产 ","date":"2020-05-06","objectID":"/posts/IOT-9/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"数据特点 ","date":"2020-05-06","objectID":"/posts/IOT-9/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"海量(Volume) 物联网数据来源海量异构的感知设备,描述着物理世界对象的各种状态及变化 海量感知设备 海量节点 传感器节点多数处于全时工作状态 物联网数据由TB跃升到PB ","date":"2020-05-06","objectID":"/posts/IOT-9/:2:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"多样(Variety) 物联网应用范围广泛,在不同领域、不同行业面对不同类型、不同格式的数据,如网络日志、视频、图像、地理位置信息 物联网数据有明显的颗粒性,数据通常是多维的甚至是高维的。集成多个感知设备,同时感知某一对象的多个属性 物联网数据具有多源异构的特征。数据多来源于不同的传感器,由于感知对象和感知目的的不同,这些设备产生的数据多具有不同的结构和语义 ","date":"2020-05-06","objectID":"/posts/IOT-9/:2:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"高速(Velocity) 数据增长速度快,处理速度也快,时效性要求高。 物联网与真实世界直接关联,很多情况下需要实时访问控制,同时需要更高的数据传输速率来支持这种实时性 决策,检索,通信都需要高速(如检索新闻,如智能交通) ","date":"2020-05-06","objectID":"/posts/IOT-9/:2:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"真实(Veracity) 指数据的质量和保真性。大数据环境下的数据最好具有较高的信噪比。 ","date":"2020-05-06","objectID":"/posts/IOT-9/:2:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"价值(Value) 即低价值密度。随着数据量的增长,数据中有意义的信息却没有成相应比例增长。而价值同时与数据的真实性和数据处理时间相关 ","date":"2020-05-06","objectID":"/posts/IOT-9/:2:5","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"大数据(5V) ","date":"2020-05-06","objectID":"/posts/IOT-9/:2:6","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"储存角度的划分 ","date":"2020-05-06","objectID":"/posts/IOT-9/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"结构化数据 指遵循一个标准的模式和结构(conform to adata model or schema),以二维表格的形式存储在关系型数据库里的行数据。结构化数据是先有结构、后产生数据。 结构化数据简单的说,就是关系型数据库里的数据 由于关系型数据库发展较为成熟,因此结构化数据的存储、分析方法也发展的较为全面,有大量的工具支持结构化数据分析,分析方法大部门以统计分析和数据挖掘为主。 其中,关系型数据库(Relational Database)是创建在关系模型基础上的数据库,关系模型即二维表格模型,因此一个关系型数据库包括一些二维表且这些表之间的具有一定关联。关系型数据库可运用SQL语言通过固有键值提取相应信息。 ","date":"2020-05-06","objectID":"/posts/IOT-9/:3:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"非结构化数据 是指不遵循统一的数据结构或模型的数据(如文本、图像、视频、音频等),不方便用二维逻辑表来表现。这部分数据在企业数据中占比大,且增长速率更快。 非结构化数据更难被计算机理解,不能直接被处理或用SQL语句进行查询。非结构化数据常以二进制大型对象(BLOB,将二进制数据存储为一个单一个体的集合)形式,整体存储在关系型数据库中中;或存储在非关系型数据库中(NoSQL数据库)。其处理分析过程也更为复杂。 半结构化数据,是指有一定的结构性,但本质上不具有关系性,介于完全结构化数据和完全非结构化数据之间的数据。 它可以说是结构化数据的一种,但是结构变化很大。因此,为了了解数据的细节,不能将数据简单按照非结构化数据或结构化数据进行处理,需要特殊的存储(化解为结构化数据/用XML格式来组织)和处理技术。 半结构化数据包含相关标记,用来分隔语义元素以及对记录和字段进行分层。因此,它也被称为自描述的结构(以树或者图的数据结构存储的数据)。先有数据,再有结构。两种常见的半结构化数据:XML文件和JSON文件。常见来源包括电子转换数据(EDI)文件、扩展表、RSS源、传感器数据。 物联网数据存储 ","date":"2020-05-06","objectID":"/posts/IOT-9/:3:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"特点 海量存储空间;多源异构,数据的表达需要细致考虑 支持多粒度分级存储和检索,改善资源利用率,提高资源获取率 具有实时性的多维检测 冗余数据需要压缩 ","date":"2020-05-06","objectID":"/posts/IOT-9/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"满足的条件 开放兼容。接口与交互协议必须便于物联网信息的发现,定位和获取;屏蔽接口的复杂性,兼容多源异构的物联网 动态扩展。包括存储能力的动态扩展和数据结构动态可扩展。 可靠高效。支持高并发性,具有高容错能力 安全可信。 ","date":"2020-05-06","objectID":"/posts/IOT-9/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"关系模型 ","date":"2020-05-06","objectID":"/posts/IOT-9/:6:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"特点 每一列不可再分 同一关系中属性(字段)不允许重名 关系中不允许有完全相同的元组 关系中任意交换两行位置不影响数据实际含义 关系中任意交换两列位置不影响数据实际含义 关系数据库 关系数据库是建立在关系模型基础上的数据库 关系数据结构 关系数据操作 关系完整性约束 目前实际使用的数据库系统大多是关系数据库 关系数据库的相关概念: 域(Domain):相同类型数据元素值的集合 比如自然数集合、小写字母集合 笛卡尔积:一组域D1, D2,…, Dn ,则笛卡尔乘积为 D1×D2×…×Dn ={( d1, d2,…, dn)| di ∈Di,i=1,2,…,n} 元组(Tuple): 笛卡尔乘积中每一个元素( d1, d2,…, dn)称为一个元组 ","date":"2020-05-06","objectID":"/posts/IOT-9/:6:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"笛卡尔积 ","date":"2020-05-06","objectID":"/posts/IOT-9/:7:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"关系数据结构 \u003c关系名\u003e(属性名1,属性名2, …… 属性名N) shop(店名,地址,法人名,经营者名,电话) fruit(水果名,价格,库存量,质量等级) book(书名,著者名, 出版社,价格,页数,开本,ISBN,版本) student(姓名,学号,性别,宿舍,电话) 电话号码簿(电话号码,姓名) ","date":"2020-05-06","objectID":"/posts/IOT-9/:8:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"关系数据操作 查询操作:选择、投影、连接、并、交、差 更新操作:增加、删除、修改数据的操作 ","date":"2020-05-06","objectID":"/posts/IOT-9/:9:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"常用三种关系运算 选择运算 投影运算 连接运算 ","date":"2020-05-06","objectID":"/posts/IOT-9/:10:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"完整性约束 完整性约束=实体完整性+参照完整性+用户定义完整性 实体完整性主要指关系中关键字不为空且唯一 例如公民数据表中身份证号不为空且唯一 参照完整性指外码的删除,出现数据不完整性 例如院系表中院系名称被删,导致学生表中院系取值错 用户定义完整性指针对某一具体数据的约束条件 教师表中教龄不能大于年龄 ","date":"2020-05-06","objectID":"/posts/IOT-9/:11:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"SQL(structured query language)结构化查询语言 SQL(Structured Query Language),是目前关系数据库的标准结构化查询语言,1974年制订。目前流行的是SQL-92标准,它是由ANSI(美国国家标准局)颁布的。 结构化查询语言包括三部分: 数据定义语言DDL 数据操纵语言DML 数据控制语言DCL 非关系型数据库 键值存储数据库 列存储数据库 文档型数据库 图形数据库 感知数据库 ","date":"2020-05-06","objectID":"/posts/IOT-9/:12:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"键值存储数据库 使用一个哈希表,有一个特定的键值和一个指针指向特定的数据 简单,容易部署 针对部分值更新查询的效率低下 ","date":"2020-05-06","objectID":"/posts/IOT-9/:13:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"列存储数据库 应对分布式存储的海量数据 键指向多个列,列由列家族安排 ","date":"2020-05-06","objectID":"/posts/IOT-9/:14:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"文档型数据库 数据是版本化的文档,半结构化的文档,如Json; 和键值存储是类似的,是键值存储的升级版 ","date":"2020-05-06","objectID":"/posts/IOT-9/:15:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"图形数据库 使用图形模型的数据库 ","date":"2020-05-06","objectID":"/posts/IOT-9/:16:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"感知数据库 面向工业自动化,物联网等领域 既可以进行关系数据管理,也可以在线存储实时特性的时序数据 提供SQL标准接口,也提供实时数据的发布订阅,历史查询,历史数据分析等服务 定位于满足企业级应用的数据库 本地文件系统和分布式文件系统 ","date":"2020-05-06","objectID":"/posts/IOT-9/:17:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"本地文件系统 物理存储资源直接连接在本地节点上,处理器通过系统总线可以直接访问 物联网使用本地文件系统的方案较少,由于: 功能有限,仅有基本的存储和索引功能,无法很好的支持大规模数据处理 不同设备上的本地文件系统难以协同 通常运行与独立的设备;容易丢失 ","date":"2020-05-06","objectID":"/posts/IOT-9/:18:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"分布式文件系统 通常使用分布式文件系统存储物联网数据 建立于本地文件系统之上 通过网络将若干节点相连 逻辑上将独立的存储节点聚合为一个整体,统一管理 提供并发处理; 解决I/O瓶颈、空间动态扩展等问题 ","date":"2020-05-06","objectID":"/posts/IOT-9/:19:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"分布式优点 简单配置即可轻松扩展集群 并发控制,提高效率 节点失效视为常态,容错性高; 健全的数据恢复与备份,可靠性高; 吞吐量大,适合大规模数据应用 支持大数据处理工具 ","date":"2020-05-06","objectID":"/posts/IOT-9/:19:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"GFS(Google File System) GFS集群由一个主服务器(Master)和大量的块伺服器构成,并被许多客户(Client)访问。 文件被分为固定大小的块,并分配一个全局唯一的块句柄(chunk-handle)标识。块伺服器将块做为本地文件存储,处于可靠性的考虑,一个块被复制到多个块伺服器上,默认是3个。 主服务器维护数据所有的元数据,如块租约,孤儿块收集,块迁移等;主服务器通过心跳指令和块伺服器联系,传达指令,收集信息以及伺服器的状态。 应用程序通过客户端使用文件系统,客户端和主服务器只交换元数据;数据通信直接和伺服器联系。 ","date":"2020-05-06","objectID":"/posts/IOT-9/:19:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"FastDFS 类似Google FS的开源轻量级分布式文件系统 文件存储、同步、访问特别适合以文件为载体的在线服务(相册) 系统内有Tracker server和Storage server2个角色 不分块,直接存储文件 ","date":"2020-05-06","objectID":"/posts/IOT-9/:19:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"TFS(Taobao File System) 面向互联网服务,针对海量非结构化数据 扁平化数据组织结构 扩容 提供海量小文件存储(每个文件通常不超过1M) ","date":"2020-05-06","objectID":"/posts/IOT-9/:19:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"MogileFS 主要由调度器、数据库、存储节点和客户端组成 2个服务进程 MogileFS Mogstored 调度器是MogileFS的核心部分,负责复制、删除、查询、获取监控等多种任务的处理 数据库存放MogileFS的元数据,由调度器来操作和管理 ","date":"2020-05-06","objectID":"/posts/IOT-9/:19:5","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"MooseFS 容错的分布式文件系统 一个支持随机读写的GFS实现 由管理服务器、存储服务器、元数据备份服务器、客户端组成 需要标准文件系统、较高的可扩展性顺序读写大量数据 较少的随机写,可用性和数据一致性要求不高 ","date":"2020-05-06","objectID":"/posts/IOT-9/:19:6","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"HDFS HDFS是一个主从结构, 一个名字节点,管理文件命名空间和客户端访问文件的主服务器, 若干数据节点,通常是一个节点一个机器,它来管理对应节点的存储。HDFS对外开放文件命名空间并允许用户数据以文件形式存储 内部机制是将一个文件分割成一个或多个块,这些块被存储在一组数据节点中。 名字节点用来操作文件命名空间的文件或目录操作,如打开,关闭,重命名等等。它同时确定块与数据节点的映射。数据节点负责来自文件系统客户的读写请求。 数据节点同时还要执行块的创建,删除,和来自名字节点的块复制指令 ","date":"2020-05-06","objectID":"/posts/IOT-9/:19:7","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"HDFS实现过程 ","date":"2020-05-06","objectID":"/posts/IOT-9/:20:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"读取过程： 客户端请求文件系统打开文件 DFS获取文件最开始的几个块的datanode地址。Namenode会根据网络拓扑结构决定返回哪些节点;客户端读取数据(调用read方法) 第一个块读取完毕之后,寻找下一个块的最佳datanode,读取数据。如果有必要,会联系Namenode获取下一批块的节点信息这些寻址过程对客户端都是不可见的。 数据读取完毕,客户端调用close方法关闭流对象 在读数据过程中,如果与Datanode的通信发生错误,则会尝试从下一个最佳节点读取数据,并且记住该失败节点, 后续块的读取不会再连接该节点读取一个块之后,会进行检验和验证,如果块损坏,尝试从其他节点读取数据,并且将损坏的块汇报给Namenode。客户端连接哪个datanode获取数据,是由namenode来指导的,这样可以支持大量并发的客户端请求,namenode尽可能将流量均匀分布到整个集群。块的位置信息是存储在namenode的内存中,因此相应位置请求非常高效,不会成为瓶颈。 ","date":"2020-05-06","objectID":"/posts/IOT-9/:20:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"写入过程 客户端写入,创建新的文件(块); Namenode在文件系统的命名空间中创建一个新文件,此时该文件没有关联到任何block。 这个过程中,Namenode会做很多校验工作,例如是否已经存在同名文件,是否有权限,如果验证不通过,抛出异常到客户端。 客户端写入数据的时候,分解为packets(数据包),并写入到一个数据队列中,请求Namenode分配新的block存放的数据节点。这些节点存放同一个Block的副本,构成一个管道。 将packet写入到管道的第一个节点,第一个节点存放好packet之后,转发给下一个节点,下一个节点存放 之后继续往下传递。 同时维护一个ack queue队列,等待来自datanode确认消息。当管道上的所有datanode都确认之后,packet从ack队列中移除。 数据写入完毕,客户端close输出流。将所有的packet刷新到管道中,然后安心等待来自datanode的确认消息。全部得到确认之后告知Namenode文件是完整的。Namenode此时已经知道文件的所有Block信息(只需等待达到最小副本数要求,然后返回成功信息给客户端。 ","date":"2020-05-06","objectID":"/posts/IOT-9/:20:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"HDFS副本存放策略 Namenode如何决定副本存在哪个Datanode?默认策略如下: 第一个副本放在客户端相同的机器上,如果机器在集群之外,随机选择一个(但是会尽可能选择容量不是太慢或者当前操作太繁忙的) 第二个副本随机放在不同于第一个副本的机架上。 第三个副本放在跟第二个副本同一机架上,但是不同的节点上,满足条件的节点中随机选择。 更多的副本在整个集群上随机选择,虽然会尽量避免太多副本在同一机架上。 ","date":"2020-05-06","objectID":"/posts/IOT-9/:20:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"HDFS数据去重 将旧数据的MD5值排序,新数据MD5值排序,运行MapReduce去重; 使用MD5和SHA-1计算文件的哈希值,比较新旧数据的哈希值去重; 将数据指纹(存储系统中文件块经过计算后的哈希索引)由存储控制器迁移到HDFS;生成数据指纹数据库,并在HDFS上永久存储该数据库 ;使用MapReduce从数据指纹记录集中筛选出重复记录,并将去重复后的数据指纹表保存回存储控制器。 ","date":"2020-05-06","objectID":"/posts/IOT-9/:20:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-9","uri":"/posts/IOT-9/"},{"categories":["物联网"],"content":"网络体系结构 网络体系结构 ","date":"2020-05-05","objectID":"/posts/IOT-8/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"OSI七层参考模型 ","date":"2020-05-05","objectID":"/posts/IOT-8/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"接口与协议 每个分层负责为自己的上一层提供特定的服务,上下层之间进行交互所遵循的约定叫做“接口” 同一层之间的交互所遵循的约定叫做“协议” ","date":"2020-05-05","objectID":"/posts/IOT-8/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"网络分层的形象类比 网络协议 协议是为进行网络中的数据交换(通信)而建立的规则、标准或约定。 两个通信对象对等层之间使用同样的协议才能互相交流。网络体系结构的每个层次都有各自的协议。例如: 应用层协议有http(万维网)、ftp(文件传输)、smtp(邮件)等; 物理层协议有IEEE 802.3(以太网)、IEEE 802.11(WIFI)、IEEE 802.15.4 (Zigbee) 等。 ","date":"2020-05-05","objectID":"/posts/IOT-8/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"TCP/IP 在实际应用中,由于OSI七层结构过于复杂,人们一般都使用TCP/IP的四层结构。 应用层:为用户的应用进程提供服务。制定了各种软件应用的协议。 传输层:为两台主机之间提供端到端的通信。它是一个逻辑通道,负责传输的可靠性。 网络层:处理分组交换网上的不同节点间的数据传输工作。主要是提供了地址管理、路由选择服务。 网络接口层:提供物理层面上不同节点间的连接和数据传送服务。制定了各种网络设备的传输协议。 ","date":"2020-05-05","objectID":"/posts/IOT-8/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"数据封装与解封 主机A中数据包向下传递时逐层封装,达到主机B后,向上传递时逐层解封。通信双方对等层要遵循同样协议。 ","date":"2020-05-05","objectID":"/posts/IOT-8/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"分层网络体系的优点 各层之间是独立的。某一层并不需要知道它的下一层是怎样实现的,仅需要知道该层通过层间的接口所提供的服务。 灵活性好。当某一层发生变化时,只要层间接口关系保持不变,则在这层以上或者以下各层均不受影响。 易于实现和维护。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理,因为整个系统已被分解为若干个相对独立的子系统。 传输层和网络层重要协议 ","date":"2020-05-05","objectID":"/posts/IOT-8/:6:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"TCP/IP 协议族 TCP/IP是一个协议族,它是ARP,IP,ICMP,IGMP,UDP,TCP等多个协议的集合。 传输层的TCP和UDP协议,网络层的IP协议最具有代表性。 ","date":"2020-05-05","objectID":"/posts/IOT-8/:7:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"TCP - 传输控制协议 用于面向连接的服务 传输前需建立连接 可靠的,有序的字节流传输 支持流量控制与拥塞控制 连接只是一种逻辑形式,它关心的是端点。 与在网络上寻求一条实际的物理路径相比,这条信道更关心的是保持两个端点的联系。 每个数据包的传递都需要对方确认,无确认就认为失败。 ","date":"2020-05-05","objectID":"/posts/IOT-8/:8:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"UDP - 用户数据报协议 用于无连接的服务 是不可靠的数据传输 无流量控制 无拥塞控制 源端和终端不建立连接,当传送时就简单地去抓取数据,并尽可能快地把它扔到网络上。 UDP传送数据的速度仅仅受应用程序生成数据的速度、计算机的能力和传输带宽的限制 ","date":"2020-05-05","objectID":"/posts/IOT-8/:9:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"TCP 和 UDP 的应用范围 使用TCP服务的应用 : HTTP(WWW) FTP (file transfer) Telnet (remote login) SMTP (email) 使用UDP服务的应用 : 流媒体,视频会议,因特网电话 IP 协议 ","date":"2020-05-05","objectID":"/posts/IOT-8/:10:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"概念 IP协议的作用是将数据包从源传送到目的地。 实现了在互联网络间进行寻址和分组转发 。 IP数据包中含有发送它的主机的地址(源地址)和接收它的主机的地址(目的地址),这些地址就是IP地址。 它不提供可靠的传输服务,它不提供端到端的确认,对数据没有差错控制,不提供重发和流量控制。 ","date":"2020-05-05","objectID":"/posts/IOT-8/:11:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"IPv4 网络中每台主机都必须有一个惟一的IP地址; 因特网上的IP地址具有全球唯一性; IP地址是一个逻辑地址; IP是层次性地址:网络号+主机号 32位,4个字节,常用点分的十进制标记法: 如 00001010 00000010 00000000 00000001记为 10.2.0.1 ","date":"2020-05-05","objectID":"/posts/IOT-8/:12:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"IPv4 地址分类 ","date":"2020-05-05","objectID":"/posts/IOT-8/:12:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"IPv4 存在的问题 地址空间使用效率较低,IPv4 资源即将耗尽 Internet迅速发展,越来越多的设备需要IP地址:手机、家电、… IPv4地址大约有40多亿个,即将被分配完毕 资源分配不均 IPv4对于移动特性并没有很好的支持 对于某些因特网应用,需要能够对数据进行加密和鉴别,但IPv4不提供数据的加密和鉴别 ","date":"2020-05-05","objectID":"/posts/IOT-8/:12:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"IPv6 更大的地址空间,地址扩大到128bit; 减少路由选择表的长度; 简化协议,使路由器处理分组更迅速; 提供比当前IP更好的安全性(含鉴别和保密) ","date":"2020-05-05","objectID":"/posts/IOT-8/:13:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"IPv6 地址格式 IPv6地址 = 前缀 + 接口标识 前缀:相当于v4地址中的网络ID 接口标识:相当于v4地址中的主机ID 128位长,用冒号将128比特分割成8个16比特的部分,每个部分是一个4位的16进制数字。 地址前缀长度用“/xx”来表示 举例: 3ffe:3700:1100:0001:d9e6:0b9d:14c6:45ee/64 ","date":"2020-05-05","objectID":"/posts/IOT-8/:13:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"IP 路由选择 IP数据包在Internet上传递时,由路由器决定其传递路线。 路由器构成了Internet的主体脉络。它们会为数据包选择一条合适的数据传递路径。 路由 ","date":"2020-05-05","objectID":"/posts/IOT-8/:14:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"路由种类 静态路由 由网络管理员在路由器上手工添加的路由信息 不随网络拓扑变化而自动变化 适合于端网络等小型网络 动态路由 路由器运行路由协议与邻居路由器相互动态学习得到 路由信息自动更新 优点:自动适应网络拓扑变化 ","date":"2020-05-05","objectID":"/posts/IOT-8/:15:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"各类路由的特点 静态路由 无论代价如何都固定路径 发生故障网络即中断 动态路由 自动选择最低代价的路径 当前路径发生故障可自动转到其他可用路径 ","date":"2020-05-05","objectID":"/posts/IOT-8/:16:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"典型路由算法 最短路由选择算法 这种技术的主要思想是建立一个子网图,图中的每个节点代表一个路由器,每条弧线表示一条通信线路。本算法要在图中找出源节点到目标节点间的最短路径。 扩散法 把收到的每一个分组信息,从除了分组到来的线路外的所有输出线路上发出。最终信息可以从源节点到达目标节点。显然扩散要产生大量的重复分组,事实上有可能是无穷多个分组,除非采用一些措施抑制这种过程。 选择性扩散法 与扩散法不同的是各个节点仅向少量预先设定的邻接点发出信息。从而降低数据冗余,减少网络拥塞。 ","date":"2020-05-05","objectID":"/posts/IOT-8/:17:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-8","uri":"/posts/IOT-8/"},{"categories":["物联网"],"content":"卫星通信技术,有线网络 卫星通信技术 ","date":"2020-05-04","objectID":"/posts/IOT-7/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"概念 卫星通信是指利用人造地球卫星作为中继站转发无线电波,在两个或多个地球站之间进行的通信。其无线电波频率使用微波频段(300 MHz~300 GHz)。 卫星通信是地面微波中继通信的继承和发展,是微波接力向太空的延伸。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"系统组成 卫星通信系统由通信卫星、地球站、跟踪遥测及指令分系统、监控管理分系统四大功能部分组成。 空间设备也就是通信卫星是由若干转发器、数副天线、位置和姿态控制系统、遥测和指令系统、电源分系统组成,其主要作用是转发各地球站信号。 地球站由天线、发射系统、接收系统、以及电源、监控等设备组成。主要功能是将需要发射的信号传至卫星和从卫星接收信号。 地面的跟踪遥测及指令分系统并不直接用于通信,而是用来保障通信的正常进行。 监控管理分系统对在轨卫星的通信性能及参数进行监测与控制。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"通信链路 ","date":"2020-05-04","objectID":"/posts/IOT-7/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"单卫星 ","date":"2020-05-04","objectID":"/posts/IOT-7/:3:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"双卫星 ","date":"2020-05-04","objectID":"/posts/IOT-7/:3:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"通信卫星的分类 按照卫星的结构: 可分为有源卫星和无源卫星。 按照卫星的运动方式: 可分为静止卫星(同步卫星)和运动卫星(非同步卫星),包括相位卫星和随机卫星等类型。 按照卫星离地面的高度(h): 通信卫星可分为低轨道(h\u003c5000 km)卫星、中轨道(5000\u003ch\u003c20000 km)卫星、高轨道(h\u003e20000 km)卫星和地球同步轨道(h=35786 km)卫星。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"卫星轨道的分类 ","date":"2020-05-04","objectID":"/posts/IOT-7/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"同步卫星通信 运行轨道在赤道平面内 高度约为35786 km, 运行方向和周期与地球相同; ","date":"2020-05-04","objectID":"/posts/IOT-7/:6:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"卫星通信的特点 ","date":"2020-05-04","objectID":"/posts/IOT-7/:7:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"优势 覆盖面积大,通信距离远,建站成本与通信距离基本无关 组网灵活,便于多址连接 不受地理条件的限制,不管是固定站还是移动站,不同种类的业务可组网在同一个卫星通信网内。 通信容量大 卫星通信工作在微波频段,可用带宽范围很大。 通信质量好可靠性高 电磁波主要在接近真空的外层空间传播 经济效益、社会效益好 卫星通信不受地理和环境条件的限制,具有建设快,投资少,经济效益高的优点。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:7:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"局限性 通信卫星使用寿命较短。 部件故障导致的不可修复 推进剂携带量有限(作用:控制卫星入轨,轨道位置保持,姿态保持) 存在日凌中断和星蚀现象。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:7:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"卫星移动通信系统 ","date":"2020-05-04","objectID":"/posts/IOT-7/:8:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"海事卫星通信系统 INMARSAT(高轨道) 最 早 的 海 事 卫 星 移 动 系 统 , 由 美 国 COMSAT 公 司 利 用Marisat卫星进行卫星通信,是一个军用的卫星通信系统。 70年代中期为增强海上船只的安全保障,将部分内容提供给远洋船只使用。1982年形成了以国际海事卫星组织管理的INMARSAT系统,开始提供全球海事卫星通信服务。 如今已发展为INMARSAT-4 移动通信卫星以及INMARSAT-5宽带通信卫星,管理着135个国家的大量通信服务。 运行在地球静止轨道上,为除南北极75度以上的级区外的全球区域提供通信服务。 按发展顺序由INMARSAT-1、INMARSAT-2、INMARSAT-3、INMARSAT-4、INMARSAT-5代卫星组成。当前主要用后三代,共有11颗GEO卫星在轨运行。 INMARSAT-4 BGAN系统 BGAN是宽带全球区域网络(broadband global area network)的简称,是国际海事卫星组织主导的第四代卫星通信系统。 BGAN具有全球无缝隙宽带网络接入、移动实时视频直播、兼容3G等多种通信的能力,它的出现给海事、航空以及陆地偏远地区移动信息化带来革命性的变化。 INMARSAT-5 是由 3 颗卫星组成全球高速移动网络Global Xpress,最高上下行速率可分别达 5Mbit/s和 50Mbit/s,而用户终端仅为iPad大小。 Global Xpress 现已建成,总的吞吐率超过100Gbit/s,信息传输速率将达 50Gbit/s,相当于以前的BGAN业务量的10倍。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:8:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"铱星通信系统 概念 铱(Iridium)系统是一个基于低轨道卫星群的全球移动通信系统,由美国Motorola公司牵头、多个国家(包括我国)的19个公司或单位投资57亿美元创建。 特点 基本上能做到用手机实现任何人在任何时间、任何地方用任何方式与任何人进行通信。 铱星系统最显著的特点就是 星际链路和极地轨道,最大的优势是达到真正的全球覆盖。 与静止轨道卫星通信系统相比,铱星系统轨道低,传播损耗小,时延小,通信质量大大提高 组成及发展 铱星系统空间段是由66颗卫星构成的低轨移动通信卫星星座,“第二代铱星”铱星系统除了66颗工作星,还包括6颗在轨备份星和9颗地面备份星。 66颗在轨卫星分布在6个极地圆轨道上,每个轨道面11颗卫星,轨道高度780km,倾角86.4o, 每个轨道周期大约101min,设计寿命15年。 2007启动的第二代铱星计划的目标是:提高数据传输速率,改善话音质量,支持频带的灵活分配,采用端到端的IP 技术,以及提供更强的业务和设备。届时手持终端的数据业务最高速率达1.5Mbit/s,便携式、运输式终端速率分别可达 10Mbit/s、30Mbit/s。 有线网络传输介质 电子设备之间进行有线通信,首先需要在它们之间建立物理连接。所有的连接材料都可以称为介质。 有线网络通信的传输介质有很多种,包括电话线、双绞线、同轴电缆、光纤等。 和物联网关系最为密切的有线网络是局域网。用于局域网组网的传输媒介主要有两种:双绞线和光纤。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:8:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"双绞线 双绞线是目前使用最广的一种传输介质,它价格便宜、易于安装,适用于多种网络拓扑结构。 由4对扭在一起且相互绝缘的铜导线组成,两条线扭绞在一起可以减少对邻近线对的电子干扰。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:9:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"双绞线的分类 按结构分类,双绞线可分为非屏蔽双绞线(UTP,Unshielded Twisted Pair)和屏蔽双绞线(STP,Shielded Twisted Pair)两类。 按性能指标分类,双绞线可分为1类,2类,3类,4类,5类,超5类,6类等双绞线。 3类双绞线的最高传输频率为16MHz,最高传输速率为10Mbps,最大网段长度为100m。 4类双绞线的最高传输频率为20MHz,最高传输速率为16Mbps,最大网段长度为100m。 5类双绞线增加了绕线密度,外套使用高质量的绝缘材料。其最高传输频率达到100MHz,最高传输速率达100Mbps,最大网段长度为100m。 超5类双绞线是增强型的5类双绞线,实际最高的传输频率往往可达200MHz,在工作于全双工通信时,实际最高传输速率可以达到近1000Mbps。 6类的性能超过超5类,标准规定其带宽为250MHz。是1000 Mbps 数据传输的最佳选择,其最大网段长度也是100m。 目前局域网中最常见的双绞线是超5类、6类双绞线 双绞线多数用于局域网的构建。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:9:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"屏蔽和非屏蔽双绞线 屏蔽双绞线 屏蔽双绞线中的缠绕线对被一种金属制成的屏蔽层所包围,而且每个线对中的电线也是相互绝缘的。 非屏蔽双绞线 非屏蔽双绞线包括一对或多对由塑料封套包裹的绝缘电线对。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:9:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"双绞线接头 双绞线与网络设备的接口是RJ-45,根据连接的双绞线的类型,有不同类型的RJ-45连接头。 双绞线的8根导线需要插入RJ-45接头的8个位置然后固定。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:9:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"双绞线线序 完整的网线由一定长度的双绞线和两个RJ45水晶头组成。根据双绞线两端导线连接水晶头方式的不同,可以将网线分为三种形式:直连线、交叉线、翻转线。 直连线 主要用于计算机与网络设备(不同设备)连接等场合; 交叉线 主要用于连接同种设备; 翻转线 主要用在对网络设备进行初始设置等场合。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:9:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"光纤 光纤通信的基本特征: 使用发光器件产生的光作为信息载体,使用光导纤维作为传输光波信号的通信介质。 光导纤维简称为光纤。 在它的中心部分包括了一根或多根玻璃纤维,通过从激光器或发光二极管发出的光波穿过中心纤维来进行数据传输。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:10:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"光纤通信的特点 光纤通信的优点 传输频带宽,通信容量大。 传输衰减小,传输距离长。 抗电磁干扰,传输质量好。 体积小、重量轻、便于施工。 原材料丰富,节约有色金属,有利于环保。 光纤的缺点: 质地较脆、机械强度低是它的致命弱点,容易折断。 光纤的安装需要专门设备,以保证光纤的端面平整,以便光能透过,施工人员要有比较好的切断、连接、分路和耦合技术。 当一根光纤在护套中断裂(如被弯成直角),要确定其位置非常困难。 修复断裂光纤也很困难,需要专门的设备联结二根光纤以确保光能透过结合部。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:10:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"光纤的分类 按照光纤中光的传输模式来分: 单模光纤 单模光纤只能传输一种模式的光。 多模光纤 多模光纤,即发散为多路光波,每一路光波走一条通路。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:10:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"光缆 光缆是实现光信号传输的通信线路,由一定数量的光纤按照一定方式组成缆心,外面包有护层. 光缆与电缆在结构上的主要不同点在于光缆必须设有加强构件,以承受机械拉伸负荷. 光缆比电缆具有更大的传输容量,中继段距离长,体积小,重量轻,无电磁干扰. 光缆已经发展成长途干线、市内中继、近海及跨洋海底通信,以及局域网、专用网等有线传输线路的骨干 ","date":"2020-05-04","objectID":"/posts/IOT-7/:10:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"光纤通信系统构成 光纤通信系统主要包括:电发射机、光发射机、光中继器、光接收机、电接收机。 电发射机:将模拟信号转换成适合光端机处理的数字信号。 电接收机:将数字信号时分解复用,还原成模拟信号。 光发射机:是把从电端机送来的电信号转变成光信号,并送入光纤线路进行传输。 光接收机:是将收到的光信号变换为电信号,并对电信号进行放大、整形、再生后,再生成与发送端相同的电信号,输入到电接收端机。 光中继器:一个是补偿光信号在光纤中传输时受到的衰减;另一个是对波形失真的脉冲进行整形。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:10:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"光纤、双绞线应用场合 双绞线:广泛应用于小范围的以太网中。 光纤:主要应用在长途通信干线,城域网、局域网的的骨干线路中。 有线网络技术—以太网 ","date":"2020-05-04","objectID":"/posts/IOT-7/:10:5","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"概念 以太网是一种计算机局域网技术。IEEE组织的IEEE802.3标准制定了以太网的技术标准,它规定了包括物理层的连线、电子信号和介质访问层协议的内容 。 局域网是覆盖较小地理范围的计算机网络。局域网一般在一组楼房内或一座楼房内或在同一房间内。 以太网是目前应用最普遍的局域网技术,基本取代了其他局域网标准如令牌环、FDDI等技术。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:11:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"以太网的发展 标准以太网 传输速率:10M 传输介质:同轴电缆、非屏蔽3类、5类双绞线。 拓扑结构:总线型、星形 快速以太网 传输速率:100M 传输介质:主要是双绞线。 拓扑结构:星形 千兆以太网 传输速率达到1000M,传输介质是超5类、6类双绞线、 光纤等。拓扑结构以星形为主。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:12:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"以太网拓扑结构 总线型 所有互连的对等设备使用一条开放终端的电缆,该电缆只能支持一条信道 。 优点: 没有外部添加设备,简单便宜。 缺点: 一条电缆只传输一个信号。一个人传输,其他人等待。 星形拓扑结构（主流） 从一个公共点“辐射”出多个与设备的连接。 优点:每个设备都是相互独立的,任何一个出问题,都不影响其他设备使用。 缺点:所有设备共享带宽。中心设备出问题,所有设备不能通信。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:13:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"以太网通信方式 以太网解决多台主机共享信道的方法是载波侦听多路存取(Carrier Sense Multi Access,CSMA)。信道中只能有一个信号在传递 CSMA协议概要: CSMA规定,当主机发送数据时,它首先侦听信道上是否有载波。 若没有载波,则表明信道上没有数据在传输,主机便将数据发送到信道上。 若有载波,主机按某种方式继续监听信道,直到确认信道空闲后发送数据。 CSMA不能完全避免冲突的原因 当主机A认为信道空闲时,主机B也可能认为信道空闲,因此,两台主机差不多同时发送数据,导致冲突发生。 解决方案 CSMA/CD —带冲突检测的载波监听多点访问 原理:发送前先监听信道是否空闲,若空闲则立即发送数据。在发送时,边发边继续监听。若监听到冲突,则立即停止发送。等待一段随机时间(称为退避)以后,再重新尝试。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:14:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"以太网中常用设备 集线器(HUB): 多个网络电缆的中间转接设备,在星形结构的网络中作为中心节点。 其带宽由它的端口平均分配,如总带宽为100Mb/s的集线器连接4台工作站时,每台工作站平均带宽为100/4=25Mb/s。 交换机(Switch): 又称交换式集线器,是工作于数据链路层、能完成封装转发数据包功能的网络设备。交换机的所有端口均有独享的信道带宽,以保证每个端口上的数据快速有效传输。 路由器(Router)是Internet中最为重要的互联设备,它处于网络层,能够跨越不同的物理网络类型,连接多个逻辑上分开的网络。 基本功能为“为到达的数据包选择一条最佳路径”。还有对IP数据包进行差错处理及简单的拥塞控制等功能。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:15:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"集线器工作方式 从A发送信息到B的方式: A的信息到达Hub,Hub向每个端口转发信息,只有到达B的信息被接收,其他被丢弃。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:15:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"交换机工作方式 从A发送信息到B的方式: A的信息到达交换机,交换机根据信息内的目标地址只选择一个适当的端口发出信息。 ","date":"2020-05-04","objectID":"/posts/IOT-7/:15:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["物联网"],"content":"典型以太网结构 ","date":"2020-05-04","objectID":"/posts/IOT-7/:16:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-7","uri":"/posts/IOT-7/"},{"categories":["Leetcode"],"content":"今天是blog记录leetcode刷题的第一天!努力做到每天打卡!加油!!! 206-单链表反转 225-队列实现栈 100-判断两棵相同的树 111-求树叶子节点所处在的最小深度 206-单链表反转 输入 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003enull 输出 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003enull /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* reverseList(struct ListNode* head){ struct ListNode* nextTmp = NULL; struct ListNode* cur = head; struct ListNode* prv = NULL; while(NULL != cur){ nextTmp = cur-\u003enext; cur-\u003enext = prv; prv = cur; cur = nextTmp; } return prv; } 225-队列实现栈 使用队列实现栈的下列操作： push(x) -- 元素 x 入栈 pop() -- 移除栈顶元素 top() -- 获取栈顶元素 empty() -- 返回栈是否为空 思路:使用两个队列来实现栈 队列A、B 入栈：入队列A 出栈：把队列A的前n-1个元素倒到队列B，把第n个元素去掉。此时数据在B中，下次操作，则对B操作。 栈顶：把队列A的前n-1个元素倒到队列B，把第n个元素作为栈顶。 stdlib头文件 即standard library标准库函数头文件 包含了C、C++语言的最常用的系统函数 常用的函数如malloc()、calloc()、realloc()、free()、system()、atoi()、atol()、rand()、srand()、exit() #include \u003cstdlib.h\u003e#define LEN 20 typedef struct queue{ //定义queue结构 int *data; int head; int rear; int size; }Queue; typedef struct { //定义栈结构-包含两个队列指针 Queue *q1, *q2; } MyStack; Queue *initQueue(int k){ //队列初始化 Queue *obj=(Queue *)malloc(sizeof(Queue)); obj-\u003edata=(int *)malloc(k*sizeof(int)); obj-\u003ehead=-1; obj-\u003erear=-1; obj-\u003esize=k; return obj; } void enQueue(Queue *obj,int e){ //入队的时候，此题不必考虑队列满状态情形 //队列为空的情形 if(obj-\u003ehead==-1){ obj-\u003ehead=0; } //队列一般情形 obj-\u003erear=(obj-\u003erear+1)%obj-\u003esize; obj-\u003edata[obj-\u003erear]=e; } int deQueue(Queue *obj){ //出队的时候，此题不必考虑队列为空的情形 int a=obj-\u003edata[obj-\u003ehead]; //特殊情形，队列中只有一个元素 if(obj-\u003ehead==obj-\u003erear){ obj-\u003erear=-1; obj-\u003ehead=-1; return a; } //队列一般情形 obj-\u003ehead=(obj-\u003ehead+1)%obj-\u003esize; return a; } int isEmpty(Queue *obj){ return obj-\u003ehead==-1; } /** Initialize your data structure here. */ MyStack* myStackCreate() { MyStack *obj=(MyStack *)malloc(sizeof(MyStack)); obj-\u003eq1=initQueue(LEN); obj-\u003eq2=initQueue(LEN); return obj; } /** Push element x onto stack. */ void myStackPush(MyStack* obj, int x) { //只要我找到一个队列为非空，我就向里面添加元素，如果两个都是空的，那随便哪一个都可以 if(isEmpty(obj-\u003eq1)){ enQueue(obj-\u003eq2,x); }else{ enQueue(obj-\u003eq1,x); } } /** Removes the element on top of the stack and returns that element. */ //栈弹出的时候，有且只有一个队列为非空 int myStackPop(MyStack* obj) { //q2为非空的时候，q2出列直到q2中只有一个元素 if(isEmpty(obj-\u003eq1)){ while(obj-\u003eq2-\u003ehead != obj-\u003eq2-\u003erear){ //q2出列的元素，入列q1 enQueue(obj-\u003eq1,deQueue(obj-\u003eq2)); } return deQueue(obj-\u003eq2); } //反之q1非空 while(obj-\u003eq1-\u003ehead != obj-\u003eq1-\u003erear){ enQueue(obj-\u003eq2,deQueue(obj-\u003eq1)); } return deQueue(obj-\u003eq1); } /** Get the top element. */ //取栈顶元素，有且只有一个队列为非空，我直接取非空队列的尾部即可 int myStackTop(MyStack* obj) { if(isEmpty(obj-\u003eq1)){ return obj-\u003eq2-\u003edata[obj-\u003eq2-\u003erear]; } return obj-\u003eq1-\u003edata[obj-\u003eq1-\u003erear]; } /** Returns whether the stack is empty. */ //当且仅当两个队列都是空的情形 bool myStackEmpty(MyStack* obj) { if(obj-\u003eq1-\u003ehead==-1 \u0026\u0026 obj-\u003eq2-\u003ehead==-1){ return true; } return false; } void myStackFree(MyStack* obj) { //释放两个队列以及栈 free(obj-\u003eq1-\u003edata); obj-\u003eq1-\u003edata=NULL; free(obj-\u003eq1); obj-\u003eq1=NULL; free(obj-\u003eq2-\u003edata); obj-\u003eq2-\u003edata=NULL; free(obj-\u003eq2); obj-\u003eq2=NULL; free(obj); obj=NULL; } 100-判断两棵相同的树 这道题太简单啦! bool isSameTree(struct TreeNode* p, struct TreeNode* q){ if (NULL == p \u0026\u0026 NULL == q) { return true; } if (NULL == p || NULL == q) { return false; } if (p-\u003eval != q-\u003eval) { return false; } return isSameTree(p-\u003eleft, q-\u003eleft) \u0026\u0026 isSameTree(p-\u003eright, q-\u003eright); } 111-求树叶子节点所处在的最小深度 这道题在队列的操作上有些难度,需要自己写队列的实现 想了好久,没想起来队列操作咋写了… 看到题解我傻了…用c是真的爽鸭,用个队列要写60多行代码 typedef struct QueueNode { struct TreeNode *data; struct QueueNode *next; } QueueNode_t; typedef struct LinkQueue { int count; QueueNode_t *front; QueueNode_t *rear; } LinkQueue_t; int initQueue(LinkQueue_t *queue) { queue-\u003efront = queue-\u003erear = malloc(sizeof(QueueNode_t)); if (NULL == queue-\u003efront) return -1; queue-\u003efront-\u003enext = NULL; queue-\u003ecount = 0; return 0; } int enqueue(LinkQueue_t *queue, struct TreeNode *data) { QueueNode_t *newNode = malloc(sizeof(QueueNode_t)); if (NULL == newNode) { return -1; } newNode-\u003edata = data; newNode-\u003enext = NULL; queue-\u003erear-\u003enext = newNode; queue-\u003erear = newNode; queue-\u003ecount++; return 0; } //出栈的特别之处,使用了双指针 ","date":"2020-05-04","objectID":"/posts/leetcode-1/:0:0","tags":["Leetcode-C++"],"title":"Leetcode Part-1","uri":"/posts/leetcode-1/"},{"categories":["Ubuntu"],"content":"Apple Music Web上线啦 ","date":"2020-05-04","objectID":"/posts/ubuntu-19/:0:0","tags":["Linux-Ubuntu"],"title":"Linux上的Apple生态圈","uri":"/posts/ubuntu-19/"},{"categories":["Ubuntu"],"content":"AppleMusic 今天是2020年5月4号 一个值得纪念的一天 因为意外的发现 AppleMusic的网页端上线了！ 原来一直都处于测试状态，而且仅限美国地区 现在国区正式上线了，我的Linux生态完整啦！！！ 我好开心呜呜呜 我的运气也太好了呜呜呜 感谢命运女神一次次的眷顾我 ","date":"2020-05-04","objectID":"/posts/ubuntu-19/:1:0","tags":["Linux-Ubuntu"],"title":"Linux上的Apple生态圈","uri":"/posts/ubuntu-19/"},{"categories":["Ubuntu"],"content":"AppleMusic客户端 晚上逛github,发现有大佬做了一个snap-web打包出来的AM软件 好奇心!没错又是好奇心!让我下载了体验一下 在40kb下载速度的等待下,我安装好了! 体验尚可!流畅度提升了很多 github项目地址 ","date":"2020-05-04","objectID":"/posts/ubuntu-19/:2:0","tags":["Linux-Ubuntu"],"title":"Linux上的Apple生态圈","uri":"/posts/ubuntu-19/"},{"categories":["Ubuntu"],"content":"安装 sudo snap install apple-music-for-linux ","date":"2020-05-04","objectID":"/posts/ubuntu-19/:2:1","tags":["Linux-Ubuntu"],"title":"Linux上的Apple生态圈","uri":"/posts/ubuntu-19/"},{"categories":["Ubuntu"],"content":"iCloud 前几天买了iCloud的存储空间,好奇在linux上是否支持,因为之前还折腾了一下onedrive,但是失败了,所以就没抱太大希望,试着装了一个软件,发现使用体验满分!而且同步很快,支持拖拽上传文件,linux这回也有网盘了,感动到哭… 这个软件是snap格式的,所以支持命令行安装,snap是ubuntu开发的一种运行在沙盒环境的软件格式,运行速度和安全性较好 ","date":"2020-05-04","objectID":"/posts/ubuntu-19/:3:0","tags":["Linux-Ubuntu"],"title":"Linux上的Apple生态圈","uri":"/posts/ubuntu-19/"},{"categories":["Ubuntu"],"content":"安装iCloud Notes Snap sudo snap install icloud-notes-linux-client 安装应用程序后，打开应用程序菜单并搜索“icloud-notes-linux-client”，打开后，系统会立即提示你使用Apple ID登录Apple的iCloud系统。 ","date":"2020-05-04","objectID":"/posts/ubuntu-19/:3:1","tags":["Linux-Ubuntu"],"title":"Linux上的Apple生态圈","uri":"/posts/ubuntu-19/"},{"categories":["Ubuntu"],"content":"换图标 因为软件自身的图标很是一语难尽…所以琢磨着换个图标 但是由于snap软件的文件无法进行修改,沙盒环境所限制 本来想放弃,但是尝试了最后一个方法,发现竟然好使了 修改本路径下的desktop文件 /var/lib/snapd/desktop/applications ","date":"2020-05-04","objectID":"/posts/ubuntu-19/:3:2","tags":["Linux-Ubuntu"],"title":"Linux上的Apple生态圈","uri":"/posts/ubuntu-19/"},{"categories":["物联网"],"content":"定位技术,物联网通信体系 定位技术 ","date":"2020-05-03","objectID":"/posts/IOT-6/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"卫星定位与基站定位 基于卫星导航的定位： 基于卫星导航的定位方式主要是利用设备或终端上的GPS定位模块将自己的位置信号发送到定位后台来实现定位; 基于参考点的基站定位： 基站定位则是利用基站与通信设备之间无线通信和量测技术,计算两者间的距离,并最终确定通信设备位置信息。基站定位不需要设备或终端具有GPS定位功能,但是其定位精度很大程度依赖于基站的分布及覆盖范围的大小,误差较大。目前,蜂窝定位中的大部分方法都是采用基站定位实现的。 卫星定位技术 卫星定位导航系统是利用卫星来测量物体位置的系统。由于对科技水平要求较高且耗资巨大,所以世界上只有少数的几个国家能够自主研制卫星定位导航系统。目前已投入运行的主要包括: 美国的全球定位系统(GPS),目前唯一覆盖全球的卫星定位导航系统。 俄罗斯的格洛纳斯系统(GLONASS),目前只覆盖俄罗斯境内。 中国的北斗导航系统(COMPASS),目前只覆盖我国境内。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"GPS 发展历史 20世纪70年代(1973),由于人们对连续实时三维导航的需求日渐增强,美国国防部开始研究和建立新一代空间卫星导航定位系统。主要目的是为陆、海、空三大领域提供实时、全天候和全球性的导航服务。 经过20余年的研究实验,耗资近300亿美元,到1994年3月,一个由24颗卫星组成,全球覆盖率达98%的卫星导航系统终于布设完成,该系统被称为GPS,是继阿波罗登月、航天飞机之后的第三大空间工程。 GPS(Global Position System , 全球定位系统),全 称是“Navigation Satellite Timing And Ranging / Global PositionSystem,NAVSTAR/GPS”,其意为“导航卫星测时与测距/全球定位系统”。该系统以卫星的无线电导航技术为基础,可实现授时和测距的空间交会定点的定位导航,为全球用户提供连续、实时、高精度的三维位置、三维速度和时间等相关信息。 系统组成 GPS系统主要由空间部分、地面控制部分和用户接收设备三部分构成 宇宙空间部分 24颗工作卫星 地面监控部分 (全部在美国境内) 1个主控中心(另有1个备用) 4个专用地面天线 6个专用监视站 用户设备部分 GPS接收机 GPS定位原理 用户设备主要是指各种型号的GPS信号接收机,由GPS接收机天线、GPS接收机主机和天线组成。其主要任务是捕获按一定卫星截止角所选择的待测卫星,并跟踪这些卫星的运行。 GPS导航系统的基本原理是测量出已知位置的卫星到用户接收机之间的距离,然后综合多颗卫星的数据就可知道接收机的具体位置。要达到这一目的,卫星的位置可以根据星载时钟所记录的时间在卫星星历中查出。 而用户到卫星的距离则通过纪录卫星信号传播到用户所经历的时间,再将其乘以光速得到。 为什么定位同时需要四颗卫星 GPS导航系统卫星部分的作用就是不断地发射导航电文。 然而,由于用户接受机使用的时钟与卫星星载时钟不可能总是同步,所以除了用户的三维坐标x、y、z外,还要引进一个Δt即卫星与接收机之间的时间差作为未知数,然后用4个方程将这4个未知数解出来。所以如果想知道接收机所处的位置,至少要能接收到4个卫星的信号。 基站定位 ","date":"2020-05-03","objectID":"/posts/IOT-6/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"产生背景 GPS功能强大,但是需要专门的客户端设备才能使用,这不利于其在广泛人群中的普及。 但是,在应急服务等领域,用户往往迫切需要了解自己的地理位置。因此,一些国家开始考虑使用手机这一普及率很高的终端设备提供定位信息。产生背景: 美国通信委员会在1996年通过了增强911法案(在1999年再次修订),这个法案要求手机运营商必须知道每一部手机的地理位置(误差在50至100米误差之内)。任何一部手机拨打美国紧急服务电话911,政府就要知道其位置,即使用户自身不知道身在哪里。这一法案,迫使电信运营商开始发展手机定位系统, 基站定位技术应运而生。 使用蜂窝网络 移动通信蜂窝网络是目前覆盖范围最大的无线网络,基站定位一般应用于手机用户,手机基站定位服务又叫做移动位置服务(LBS——Location Based Service),它是通过电信移动运营商的网络(如GSM网)获取移动终端用户的位置信息(经纬度坐标),在电子地图平台的支持下,为用户提供相应服务的一种增值业务。 在基站定位中,被定位移动终端通常是普通终端(手机等),这在客观上要求多个基站设备通过附加装置测量从移动终端发出的电波信号参数,如传播时间、时间差、相位或入射角等,再通过合适的定位算法推算出移动终端的大致位置。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"定位原理 基站定位一般采用基于参考点的无线定位技术。利用移动运营商的移动通信网络,通过手机与多个固定位置收发信机之间的传播信号的特征参数来计算出目标手机的几何位置,同时,结合地理信息系统(Geographic Information System,GIS),为移动用户提供位置查询等服务。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"COO定位 COO(Cell Of Origin)定位是一种单基站定位,即根据设备当前连接的蜂窝基站的位置来确定设备的位置。那么很显然,定位的精度就取决于蜂窝小区的半径。(Google地图移动版)从原理上我们可以看出,COO定位其精度是不太确定的。但是这却是GSM网络中的移动设备最快捷、最方便的定位方法,因为GSM网络端以及设备端都不需要任何的额外硬件投入。只要运营商支持,GSM网络中的设备都可以以编程方式获取到当前基站的一个唯一代码。 根据手机所处的小区ID号来确定用户的位置,手机所处的小区ID号是网络中已有的信息,手机在当前小区注册后,系统的数据库中就会将该手机与该小区ID号对应起来,根据小区基站的覆盖范围,确定手机的大致位置。所以,该方法的定位精度与小区基站的分布密度密切相关。在基站密度较高的区域,这种定位方式精度可以达到100-150米左右,在基站密度较低的区域(如农村、山区),精度降到1-2公里左右。该方法的优点是定位时间短、对现有网络或手机不需要特殊要求就能够实现定位,缺点是定位精度取决于小区半径。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"7号信令定位 概念 又称为公共信道信令。即以时分方式在一条高速数据链路上传送一群话路信令的通信方式,通常用于局间。在我国使用的7号信令系统称为中国7号信令系统。为了实现电信业务的互联互通,不同通信运营商之间,特别是不同国家的运营商之间都会采用7号信令系统控制运营商之间业务交换的过程。许多的通信运营商也在自己的通信网络里面使用7号信令系统实现计费、漫游或者其他电信业务 定位实现方法 该技术以信令监测为基础,能够对移动通信网中特定的信令过程,如漫游、切换以及与电路相关的信令过程进行过滤和分析,并将监测结果提供给业务中心,以实现对特定用户的个性化服务。该项技术通过对信令进行实时监测,可定位到一个小区,也可定位到地区。故适用对定位精确度要求不高的业务,如漫游用户问候服务,远程设计服务、平安报信和货物跟踪等。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:6:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"TDOA定位 基于电波到达时差TDOA ( TimeDifference of Arrival)定位与TOA定位类似,也是一种三基站定位方法。该方法是利用手机收到不同基站的信号时差来计算手机的位置信息的。如图所示,如果手机收到相邻基站BS1和BS2的信号的时间差为∆t,此时手机的位置在一条双曲线上: 三个不同的基站可以测得两个TDOA(到达时差),手机位于两个TDOA决定的双线的交点上。与TOA法相似,TDOA定位方法可以采用手机到双曲线距离均方误差最小的算法,前提是有两个以上的TDOA值可以用来计算。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:7:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"AOA定位 AOA(Angle of Arrival,到达角度)定位是一种两基站定位方法,基于信号的入射角度进行定位。如图所示,知道了基站1到设备之间连线与基准方向的夹角α1,就可以画出一条射线L1;同样知道了知道了基站2到设备之间连线与基准方向的夹角α2,就可以画出一条射线L2。那么L1月L2的交点就是设备的位置。这就是AOA定位的基本数学原理。用函数调用表达如下。 AOA定位通过两直线相交确定位置,不可能有多个交点,避免了定位的模糊性。但是为了测量电磁波的入射角度,接收机必须配备方向性强的天线阵列。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:8:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"AGPS定位 研发背景 GPS虽然定位十分精确，但是其缺点也很明显： • 硬件初始化(首次搜索卫星)时间较长,需要几分钟至十几分钟; • GPS卫星信号穿透力若,容易受到建筑物、树木等的阻挡而影响定位精度。 AGPS定位技术通过网络的辅助,成功的解决或缓解了这两个问题。 概念 A-GPS(AssistedGPS)网络辅助GPS定位是一种结合网络基站信息和GPS信息对手机进行定位的技术,该技术需要在手机内增加GPS接收机模块,并改造手机天线,同时要在移动网络上加建位置服务器、差分GPS基准站等设备。这种定位方法一方面通过GPS信号的获取,提高了定位的精度,误差可到10m左右;另一方面,通过基站网络可以获取到室内定位信号。不足之处就是手机需要增加相应的模块,成本较高。 定位原理 A-GPS基本思想是通过在卫星信号接收效果较好的位置上设置若干参考GPS接收机,并利用AGPS服务器通过与终端的交互获得终端的粗位置,然后通过移动网络将该终端需要的星历和时钟等辅助数据发送给终端,由终端进行GPS定位测量。测量结束后,终端可自行计算位置结果或者将测量结果发回到AGPS服务器,服务器进行计算并将结果发回给终端。同时后台可获取位置信息为其它服务应用。 收灵敏度等。 无线室内定位 ","date":"2020-05-03","objectID":"/posts/IOT-6/:9:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"技术概述 室内定位系统(IPS) 利用网络设备,对室内设施或用户的位置信息进行确定 位置信息的类型 绝对位置信息 利用物理环境地图,对目标位置进行测量和显示 相对位置信息 依赖于目标与标定参考点之间的物理距离 邻近位置信息 对目标所属物理区域进行指定 ","date":"2020-05-03","objectID":"/posts/IOT-6/:10:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"技术特点 室内定位在以下方面有着自身的特点: 定位精度: 更高精度的定位信息会带来更大的便利 稳健性: 室内环境复杂多变,要求定位技术具有很好的自适应能力 安全性: 很大一部分应用需求都是针对个人用户 方向判断: 判断目标方位和未来运动趋势 标志识别: 利用室内一些“标志性”目标提高定位精度 复杂度: 复杂度应该较低 ","date":"2020-05-03","objectID":"/posts/IOT-6/:11:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"常见室内定位技术 ","date":"2020-05-03","objectID":"/posts/IOT-6/:12:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"红外线室内定位技术 红外线室内定位技术定位的原理是,红外线IR标识发射调制的红外射线,通过安装在室内的光学传感器接收进行定位。 虽然红外线具有相对较高的室内定位精度,但是由于光线不能穿过障碍物,使得红外射线仅能视距传播。 直线视距和传输距离较短这两大主要缺点使其室内定位的效果很差。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:12:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"超声波定位技术 超声波测距主要采用反射式测距法,通过三角定位等算法确定物体的位置,即发射超声波并接收由被测物产生的回波,根据回波与发射波的时间差计算出待测距离,有的则采用单向测距法。 超声波定位整体定位精度较高,结构简单,但超声波受多径效应和非视距传播影响很大,同时需要大量的底层硬件设施投资,成本太高。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:12:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"蓝牙技术 蓝牙技术通过测量信号强度进行定位。在室内安装适当的蓝牙局域网接入点,并保证蓝牙局域网接入点始终是这个微微网(piconet)的主设备,就可以获得用户的位置信息。 蓝牙技术主要应用于小范围定位,设备易于集成在 PDA、PC以及手机中。 持有移动终端设备的用户,只要设备的蓝牙功能开启,蓝牙室内定位系统就能够对其进行位置判断 ","date":"2020-05-03","objectID":"/posts/IOT-6/:12:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"射频识别技术 射频识别技术利用射频方式进行非接触式双向通信交换数据以达到识别和定位的目的。 这种技术作用距离短,一般最长为几十米。但它可以在几毫秒内得到厘米级定位精度的信息。同时由于其非接触和非视距等优点,可望成为优选的室内定位技术。 优点是标识的体积比较小,造价比较低,但是作用距离近,不具有通信能力,而且不便于整合到其他系统之中。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:12:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"Wi-Fi技术 概念：是无线局域网络系列标准之IEEE802.11的一种定位解决方案。该系统采用经验测试和信号传播模型相结合的方式,需要很少基站,系统总精度高。 起源：Wi-Fi 定位技术源于 90 年代末在美国兴起的热点地图,热点地图最初的目的是为了大家上网方便,国外许多公司都推出了允许用户在地图上查看(或标记)无线热点位置的应用程序。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:12:5","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"室内定位算法 ","date":"2020-05-03","objectID":"/posts/IOT-6/:13:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"质心定位算法 质心定位计算法进行定位的过程是通过在定位区域内位置定位准确的且一定数量的参考点,定位目标设备通过收集参考点发出的信号并传输至服务器进行计算以确定定位目标设备是否处于该定位区域,如果定位目标设备处于定位区域,则根据参考点组成的多边形质心位置确定定位目标的具体位置。 质心定位算法作为一种非测距的定位算法主要是依靠参考节点的位置信息发送给未知节点,未知节点通过邻居节点组成的多边形的质心来确定自身的估计位置。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:13:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"信号指纹定位算法 位置指纹识别计算法首先需要确定定位区域内的特征点位置,使特征点位置具有一定的规则性,并收集特征点发出的AP信号强度也就是RSSI值,并建立AP位置信号RSSI值数据库。在实际定位过程中,通过对定位目标设备收集到的APP信号强度进行分析,并与数据库中现有的AP信号进行对比,选择与目标设备AP信号特征相似度最高的信号位置作为目标设备的最终定位位置。在基于 RSSI 测距技术的定位系统中,已知发射节点的发射信号强度,接收节点根据接收到信号的强度,计算出信号的传播损耗,利用理论模型将传输损耗转化为距离,再利用已有的算法计算出节点的位置。 式中,A表示距发射节点1m处的信号强度指示值的绝对值;d表示发射节点与接收节点之间的距离;n为与环境相关的路径损耗系数。 物联网通信体系 ","date":"2020-05-03","objectID":"/posts/IOT-6/:13:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"分类 无线通信技术 短距离通信:蓝牙、NFC 中距离无线:WIFI、Zigbee 远距离无线:3G、4G、5G 长距离无线:微波、卫星 有线通信技术 双绞线、光纤组网 ","date":"2020-05-03","objectID":"/posts/IOT-6/:14:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"有线通信 有线通信是指利用金属导线、光纤等有形媒质传送信息的技术。 有线网络示意图 ","date":"2020-05-03","objectID":"/posts/IOT-6/:14:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"无线通信方式 无线通信是利用电磁波信号在空间中直接传播而进行信息交换的通信技术,无需有形的媒介连接。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:14:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"短距离通信与长距离通信 把通信距离在100m以内的称之为短距离通信 把通信距离超过1000m的称之为长距离通信 短距离通信场景:在家里,办公室,宾馆等 常用技术:蓝牙、NFC、WIFI、ZigBee(无线) 蓝牙、NFC 传输距离 \u003c WIFI、ZigBee 传输距离 双绞线以太网(有线) 中远距离通信场景:一个城市的不同地区、不同城市之间等 常用技术:3G、4G、5G、微波、卫星等(无线) 光纤网(有线) WIFI ","date":"2020-05-03","objectID":"/posts/IOT-6/:14:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"技术标准 ","date":"2020-05-03","objectID":"/posts/IOT-6/:15:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"基本概念 WiFi局域网的本质特点 不使用通信电缆将计算机与网络进行连接,而是用无线的方式,从而使网络的构建和终端的移动更加灵活。 WiFi局域网两个重要的基本概念 站点(Station,STA):每一个连接到无线网络中的终端(如笔记本电脑、手机等可联网的设备)都称之为一个站点。 无线接入点(Access Point,AP):无线网络的创建者,也是网络的中心节点。一般家庭或办公室使用的无线路由器就一个AP。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:16:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"网络拓扑结构 WiFi无线网络包括两种类型的拓扑形式: 基础网(Infrastructure) 自组网(Ad-hoc) 两者的差别: 基础网基于AP组建 自组网中仅含有STA,不存在AP ","date":"2020-05-03","objectID":"/posts/IOT-6/:17:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"WiFi组网:基础网 基于AP组建的基础无线网络 由AP创建,众多STA加入所组成 AP是整个网络的中心 各STA间不能直接通信,需经AP转发 现在,AP 和ADSL Modem（俗称的“猫”）往往合二为一 ","date":"2020-05-03","objectID":"/posts/IOT-6/:17:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"WiFi组网:自组网 Ad-hoc模式也称对等模式,允许一组具有无线功能的计算机或移动 设备之间为数据共享而迅速建立起无线连接。 仅由两个及以上STA组成,网络中不存在AP 各设备自发组网,设备之间是对等的 网络中所有的STA之间都可以直接通信,不需要转发 ","date":"2020-05-03","objectID":"/posts/IOT-6/:17:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"WiFi网络的安全机制 与有线网络不同,理论上无线电波范围内的任何一个站点都可以监听并登录无线网络,所有发送或接收的数据、都有可能被截取。为了使授权站点可以访问网络而非法用户无法截取网络通信,无线网络安全就显得至关重要。 安全性主要包括访问控制和加密两大部分 访问控制：保证只有授权用户才能访问敏感数据 加密： 保证只有正确的接收方才能理解数据 ","date":"2020-05-03","objectID":"/posts/IOT-6/:18:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"用户接入过程中的认证 认证是STA向AP证明其身份的过程 只有通过身份认证的站点才能进行无线接入访问 认证可以通过MAC地址进行,也可以通过用户名/口令进行 认证有开放系统认证和共享密钥认证两种 STA和AP均可通过解除认证来终结认证关系 ","date":"2020-05-03","objectID":"/posts/IOT-6/:18:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"认证系统 开放系统认证:不需要认证,没有任何安全防护能力 共享密钥认证 STA向AP发送认证请求 AP随机产生一个challenge包(即一个字符串)发送给STA STA将收到的字符串拷贝到新消息中,用密钥加密后再发送给AP AP接收到该消息后,用密钥将该消息解密,然后对解密后的字符串和最初给STA的字符串进行比较。相同则通过认证,不相同则认证失败。 蓝牙技术 ","date":"2020-05-03","objectID":"/posts/IOT-6/:18:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"概念 蓝牙技术是一种支持设备短距离通信(一般几十米内)的技术。 蓝牙技术采用分散式网络结构,支持点对点及点对多点通信 。 工作在2.4~2.485GHz频段,其数据速率为1Mbps。采用时分双工传输方案实现全双工传输。 能在包括移动电话、无线耳机、笔记本电脑等等众多设备之间进行无线信息交换。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:19:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"蓝牙技术组网 蓝牙系统采用一种灵活的、无基站的组网方式,使得 一个蓝牙设备可同时与 7 个其他的蓝牙设备相连接。 蓝牙系统的网络结构的有两种形式: 微微网(Piconet) 散射网(Scatternet) ","date":"2020-05-03","objectID":"/posts/IOT-6/:20:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"微微网结构 微微网是通过蓝牙技术以特定方式连接起来的微型网络,一个微微网可以只是2台相连的设备,也可以是8台相连的设备。 在一个微微网中,所有设备的级别都是相同的,有相同权限。 蓝牙采用自组式组网方式(Ad hoc),微微网由主设备单元(发起链接的设备)和从设备单元构成,有1个主设备单元和最多7个从设备单元。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:20:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"散射网结构 散射网由多个独立的、非同步的微微网组成,以特定的方式连接在一起。 一个微微网中的主设备单元同时也可以作为另一个微微网中的从设备单元,作为 2 个或 2 个以上微微网成员的蓝牙单元就成了网桥(bridge)节点 。 网桥最多只能作为一个微微网的主设备,但可以作为多个微微网的从设备。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:20:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"主设备和从设备 主设备一般具有输入端。在进行蓝牙匹配操作时,用户通过输入端可输入随机的匹配密码来将两个设备匹配。蓝牙手机、安装有蓝牙模块的PC等都是主设备 从设备一般不具备输入端。因此从设备在出厂时,在其蓝牙芯片中,固化有一个4位或6位数字的匹配密码。蓝牙耳机、UD数码笔等都是从设备。 例如:蓝牙PC与蓝牙耳机匹配时,用户将蓝牙耳机上的蓝牙匹配密码正确的输入到蓝牙PC上,完成两者之间的匹配。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:21:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"蓝牙协议栈 物理层 负责提供数据传输的物理通道(通常称为信道)。一个通信系统中往往存在几种不同类型的信道,如控制信道、数据信道、语音信道等等。 数据链路层 在物理层的基础上,提供两个或多个设备之间、和物理无关的逻辑传输通道(也称作逻辑链路)。 中间件层 提供针对某种通信方式、服务模式的协议。比如针对语音通信的协议、针对串口通信的协议、查询服务的协议等。 应用层 为实现各种各样的应用功能制定的协议。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:22:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"蓝牙技术安全模式 非安全模式 业务层安全模式 链路层安全模式 业务层安全模式 该模式的安全机制对系统的各个应用和服务需要进行分别的安全保护,包括授权访问、身份鉴别和加密传输。 链路层安全模式 链路层安全机制对所有的应用和服务的访问都需要访问授权、身份鉴别和加密传输。 业务层安全模式与链路层安全模式的本质区别在于: • 业务层安全模式下的蓝牙设备在信道建立以后启动安全性过程, 即其安全性过程在较高层协议进行; • 链路层安全模式下的蓝牙设备在信道建立以前启动安全性过程, 即其安全性过程在低层协议进行。 ZigBee技术 ","date":"2020-05-03","objectID":"/posts/IOT-6/:23:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"概念 ZigBee 是 基 于 IEEE802.15.4 标 准 的 低 功 耗 局 域 网 协 议 ,ZigBee技术是一种近距离、低复杂度、低功耗、低速率、低成本的双向无线通讯技术。 主要适合用于自动控制和远程控制领域,可以嵌入各种设备。非常适合用于有周期性数据、间歇性数据和低反应时间数据传输的应用。 ZigBee又称紫蜂协议,来源于蜜蜂的八字舞(蜜蜂通过之字形“舞蹈”与同伴传递信息)。也就是说ZigBee协议可以建立类似于蜂群的通信网络。 ZigBee是一个由可多到65000个模块组成的无线网络平台,任何结点之间可以相互通信,通信距离一般在几十米左右。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:24:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"技术特点 低功耗:在低耗电待机模式下,2节5号干电池可支持1个节点工作6~24个月,甚至更长。相比较,蓝牙能工作数周、WiFi可工作数小时。 低成本:通过大幅简化协议,降低了对通信控制器的要求,每块芯片的价格远低于蓝牙或WiFi。 低速率:ZigBee 分别提供 250kbps(2.4GHz)、40kbps (915 MHz)和 20kbps(868 MHz)的原始数据吞吐率,满足低速率传输数据的应用需求。 短时延:ZigBee的响应速度较快,一般从睡眠转入工作状态只需15ms,节点连接进入网络只需30ms,进一步节省了电能。相比较,蓝牙需要3~10s、WiFi 需要3s。 高安全:ZigBee提供了三级安全模式,包括无安全设定、使用访问控制清单(ACL) 防止非法获取数据以及在数据转移中采用高级加密标准(AES)的对称密码加密。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:25:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"ZigBee网络组成 协调器 在ZigBee 网络中,有且只能有一个协调器,它在网络中起了网络搭建和网络维护的功能。是整个网络的中心枢纽。是等级最高的父节点。 路由器 路由器在ZigBee 网络中既可以充当父节点,也可以充当子节点,有信息转发和辅助协调器维护网络的功能。 终端 终端的功能最为简单,只能加入网络,为最末端的子节点设备。只能与其父节点进行通信,如果两个终端之间需要通信,必须经过父节点进行多跳或者单跳通信。是网络中数量最多的节点,也是低功耗的网络设备。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:26:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"网络拓扑结构 ","date":"2020-05-03","objectID":"/posts/IOT-6/:27:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"星状网络 星状网络包含一个协调器(中心节点)和若干个路由器和终端(附属节点)组成。该结构如下图所示: 该结构网络中,每个附属节点只能与中心节点通信,如果需要两个附属节点之间通信,必须经过中心节点进行数据转发。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:27:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"树状网络 树状网络包含一个协调器,若干个路由器和终端组成。 结点之间的信息只能沿着树的路径向上传递到共同的父节点,再由共同的父节点向下转发给目的节点。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:27:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"网状网络 网络中具有路由功能的设备之间都可以直接相互通信,在通信范围内不需要其他节点转发。 网络中每个结点具有重新选择路由的功能,所以当某个路由器出现故障时,网络可以自动重新组网,因此该组网方式良好的可靠性。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:27:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"ZigBee协议栈 ","date":"2020-05-03","objectID":"/posts/IOT-6/:28:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"ZigBee网络协议各层功能 物理层(PHY) 物理层定义了物理无线信道和MAC子层之间的接口。物理层数据服务从无线物理信道上收发数据。 MAC层 MAC 层负责处理所有的物理无线信道访问,并产生网络信号、同步信号;提供两个对等MAC实体之间可靠的链路 。 网络层 网络层主要实现结点加入或离开网络、接收或抛弃其他结点、路由查找及传送数据等功能,支持多种路由算法。 应用层 应用层包含三部分:应用框架AF、ZigBee设备对象ZDO和应用支持APS子层。它们实现了将不同的应用对象映射到ZigBee网络层 。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:28:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"ZigBee应用领域 家庭和建筑物的自动化控制:照明、空调、窗帘等家具设备的远程控制; 消费性电子设备:电视、DVD、CD机等电器的遥控。 工业控制:使数据的自动采集、分析和处理变得更加容易; 医疗设备控制:医疗传感器、病人的紧急呼叫按钮等; ","date":"2020-05-03","objectID":"/posts/IOT-6/:29:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"Zigbee、蓝牙、WIFI对比图 移动通信技术 ","date":"2020-05-03","objectID":"/posts/IOT-6/:30:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"概念 移动通信是指通信的双方,或至少有一方处于移动状态下进行信息交换的通信就叫做移动通信。移动体可以是人,也可以是汽车、火车、轮船等在移动状态中的物体。 移动通信系统包括无绳电话,无线寻呼,陆地蜂窝移动通信,卫星移动通信等。一般情况下,移动通信系统是指陆地蜂窝移动通信系统。 移动通信除了依靠无线通信技术之外,还依赖有线通信网络的支持,如公众电话网PSTN,公众数据网PDN, 综合业务数字网ISDN。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:31:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"蜂窝通信网络 ","date":"2020-05-03","objectID":"/posts/IOT-6/:32:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"概念 20世纪70年代中期,贝尔实验室发明了蜂窝式组网技术。 这种技术放弃了点对点传输和广播覆盖模式,把整个服务区域划分成若干个较小的区域(蜂窝技术因此而得名)。 各小区均用小功率的发射机(即基站发射机)进行覆盖,许多小区像蜂窝一样能布满 (即覆盖)任意形状的服务地区。手机均采用这项技术,因此常常被称作蜂窝电话。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:32:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"蜂窝移动通信系统组成 移动台(MS)是用户使用的移动终端设备,最常见的是手机。 基站(BS)的作用是实现覆盖范围内的移动终端与移动通信系统之间的无线通信。 移动业务交换中心(MSC)的主要任务是实现服务区内各个小区之间的信息交换、服务区内外的信息交换和对服务区内各个小区进行集中控制管理。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:33:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"蜂窝移动通信特点 ","date":"2020-05-03","objectID":"/posts/IOT-6/:34:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"频率复用 每一组连接(对于无线电话而言就是一组会话)都需要专门的频率,而可以使用的频率一共只有大约1000个。 为了使更多的会话能同时进行,蜂窝系统把给每一个“蜂窝”(即每一个小的区域) 分配了一定数额的频率。不同的蜂窝可以使用相同的频率。这样有限的无线资源就可以充分利用了。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:34:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"越区切换 越区切换通常发生在移动台从一个基站覆盖的小区进入另一基站覆盖小区的情况下,为保持通信的连续性,将移动台与当前基站之间的链路转移到移动台与新基站之间的链路。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:34:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"位置登记 移动系统中,用户在系统覆盖范围内任意移动。为能把一个呼叫传送给移动的用户,必须有一个高效的位置管理系统来跟踪用户的位置变化。 现有的移动系统中,位置管理采用数据库技术实现。 蜂窝网络的发展 ","date":"2020-05-03","objectID":"/posts/IOT-6/:34:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"第一代:模拟语音 第一代移动通信技术主要有三种窄带模拟系统标准: 北美蜂窝系统AMPS 北欧移动电话系统NMT 英国的全接入通信系统TACS 我国采用的主要是TACS制式,即频段为890 ~ 915MHz与935 ~ 960MHz 第一代移动通信的各种蜂窝网系统有很多相似之处,但是也有很大差异,它们只能提供基本的语音会话业务,不能提供非语音业务,并且保密性差。 不同系统之间还互不兼容,移动用户无法在各种系统之间 实现漫游。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:35:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"第二代:数字语音 第二代移动通信技术使用数字制式,支持传统语音通信、文字和多媒体短信,并支持一些无线应用协议。主要有如下二种工作模式: GSM移动通信(900/1800MHz) GSM是应用最为广泛的移动电话标准。GSM有以下重要特点:防盗拷能力佳、网络容量大、手机号码资源丰富、通话清晰、稳定性强不易受干扰、信息灵敏、通话死角少、手机耗电量低、机卡分离 。 GSM 被设计具有中等安全水平。系统设计使用共享密钥用户认证。用户与基站之间的通讯可以被加密。 CDMA移动通信(800MHz) 工作在800MHz频段,核心网移动性管理协议采用IS-41协议,无线接口采用窄带码分多址(CDMA)技术。 CDMA在蜂窝移动通信网络中的可用容量在理论上可以达到AMPS容量的20倍。CDMA可以同时区分并分离多个同时传输的信号。 CDMA有以下特点:抗干扰性好、抗多径衰落、保密安全性高、容量质量之间可以权衡取舍、同频率可在多个小区内重复使用。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:36:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"第三代:语音与数据 第三代移动通信技术(3G),是指支持高速数据传输的蜂窝移动通讯技术。 3G通信可以提供所有2G的信息业务,同时保证更快的速度,以及更全面的业务内容,如移动办公,视频流服务等。 3G的主要特征是可提供移动宽带多媒体业务,包括高速移动环境下支持144Kbps速率,步行和慢速移动环境下支持384Kbps速率,室内环境则应达到2Mbps的数据传输速率,同时保证高可靠服务质量。 三种主流的3G标准分别是CDMA2000,TD-SCDMA,W-CDMA。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:37:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"CDMA2000 CDMA2000由美国高通北美公司为主导提出。这套系统是从窄频CDMAOne数字标准衍生出来的,可以从原有的CDMAOne结构直接升级到3G,建设成本低廉。使用的地区只有日、韩和北美。CDMA2000与另两个主要的3G标准WCDMA以及TD-SCDMA不兼容。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:37:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"W-CDMA WCDMA是基于GSM网发展出来的3G技术规范,是欧洲提出的宽带CDMA技术。 WCDMA采用最新的异步传输模式(ATM)微信元传输协议,能够允许在一条线路上传送更多的语音呼叫,呼叫数由30个提高到300个,在人口密集的地区线路将不再容易堵塞。 另外,WCDMA还采用了自适应天线和微小区技术,大大地提高了系统的容量。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:37:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"TD─SCDMA TD-SCDMA是由我国信息产业部电信科学技术研究院提出,与德国西门子公司联合开发。 主要技术特点:同步码分多址技术,智能天线技术和软件无线技术。采用TDD双工模式,载波带宽为1.6MHz。TDD是一种优越的双工模式,能使用各种频率资源,能节省未来紧张的频率资源,而且设备成本相对比较低。 另外,TD─SCDMA独特的智能天线技术,能大大提高系统的容量,而且降低了基站的发射功率,减少了干扰。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:37:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"第四代移动通信技术(4G) ","date":"2020-05-03","objectID":"/posts/IOT-6/:38:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"概念 4G是集3G与WLAN于一体能够传输高质量图像、视频的技术产品。 4G系统能够以100Mbps的速度下载,上传的速度也能达到20Mbps。 价格方面,4G与固定宽带网络在价格方面不相上下。 国际电联认可的4G标准包括: WiMax、WirelessMAN-Advanced、HSPA+、LTE、LTE-Advanced。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:38:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"WiMax-全球微波接入(802.16无线城域网) 优势: WiMax所能提供的最高接入速度是70Mbps,是3G所能提供的宽带速度的30倍。 实现更远的传输距离。 劣势: WiMax技术标准不能支持用户在移动过程中无缝切换。 WiMAX严格意义讲不是一个移动通信系统的标准,而是一个无线城域网的技术。 涉及技术: 正交频分多址(OFDMA)、多I/O(MIMO)智能天线技术 ","date":"2020-05-03","objectID":"/posts/IOT-6/:38:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"WirelessMAN-Advanced 即 IEEE 802.16m 标准(WiMax的升级版) 优势: 支持用户在移动过程中无缝切换。 有5种网络数据规格,功耗节省。 可在“漫游”模式或高效率/强信号模式下提供1Gbps的下行速率。 涉及技术 : 正交频分多址(OFDMA)、多I/O(MIMO)智能天线技术 ","date":"2020-05-03","objectID":"/posts/IOT-6/:38:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"HSPA+ 技术 优势: 是一种经济而高效的4G网络,成本上的优势很明显。 是商用条件最成熟的4G标准。 劣势: 速度一般,比不上其他4G标准。 涉及技术: 新的传输信道E-DCH、新的物理信道E-DPDCH ","date":"2020-05-03","objectID":"/posts/IOT-6/:38:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"LTE(长期演进)技术 优势: 下行峰值速率为100Mbps、上行为50Mbps。 强调向下兼容,支持已有的3G系统和非3GPP规范系统的协同运作。 劣势: LTE终端设备有耗电较大。 涉及技术: 基于TDD的双工技术、OFDM(正交频分复用技术)、基于MIMO/SA的多天线技术 ","date":"2020-05-03","objectID":"/posts/IOT-6/:38:5","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"LTE-Advanced 技术 优势: 峰值速率:下行1Gbps,上行500Mbps 。 后向兼容的技术,完全兼容LTE,是演进而不是革命。 劣势: 密集部署、重叠覆盖会造成很复杂的干扰。 涉及技术: 基于TDD的双工技术、OFDM(正交频分复用技术)、基于MIMO/SA的多天线技术 ","date":"2020-05-03","objectID":"/posts/IOT-6/:38:6","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["物联网"],"content":"4G技术的特点 4G系统主要是以正交频分复用为技术核心。其主要思想是:将信道分成若干正交子信道,将高速数据信号转换成并行的低速子数据流,调制到在每个子信道上进行传输。 智能天线应用数字信号处理技术,产生空间定向波束,使天线主波束对准用户信号到达方向,旁瓣或零陷对准干扰信号到达方向,达到充分利用移动用户信号并消除或抑制干扰信号的目的。这种技术既能改善信号质量又能增加传输容量。 **mimo(多输入多输出)**技术是指利用多发射、多接收天线进行空间分集的技术,它采用的是分立式多天线,能够有效的将通信链路分解成为许多并行的子信道,从而大大提高容量。 ","date":"2020-05-03","objectID":"/posts/IOT-6/:39:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-6","uri":"/posts/IOT-6/"},{"categories":["操作系统"],"content":"绪论,进程 绪论 ","date":"2020-05-02","objectID":"/posts/OS-2/:0:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"发展历史 操作系统发展的四个阶段 计算机硬件的重大进展 Unix的特点 ","date":"2020-05-02","objectID":"/posts/OS-2/:1:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"操作系统的结构 ","date":"2020-05-02","objectID":"/posts/OS-2/:2:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"整体式结构 特点: ","date":"2020-05-02","objectID":"/posts/OS-2/:2:1","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"层次式结构 计算机网络中的典型分层结构 操作系统分层结构 特点: ","date":"2020-05-02","objectID":"/posts/OS-2/:2:2","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"微内核结构 态的转换 存储体系 中断 ","date":"2020-05-02","objectID":"/posts/OS-2/:2:3","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"定义 ","date":"2020-05-02","objectID":"/posts/OS-2/:3:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"中断类型 ","date":"2020-05-02","objectID":"/posts/OS-2/:4:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"中断相应过程 进程 ","date":"2020-05-02","objectID":"/posts/OS-2/:5:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"进程特征 ","date":"2020-05-02","objectID":"/posts/OS-2/:6:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"进程状态 ","date":"2020-05-02","objectID":"/posts/OS-2/:7:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"Linux进程状态及标识 ","date":"2020-05-02","objectID":"/posts/OS-2/:8:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"进程PCB ","date":"2020-05-02","objectID":"/posts/OS-2/:9:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"进程撤销 ","date":"2020-05-02","objectID":"/posts/OS-2/:10:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"Windows进程创建 ","date":"2020-05-02","objectID":"/posts/OS-2/:11:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"Linux进程创建 ","date":"2020-05-02","objectID":"/posts/OS-2/:12:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"创建线程 同步互斥 ","date":"2020-05-02","objectID":"/posts/OS-2/:13:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"临界资源 ","date":"2020-05-02","objectID":"/posts/OS-2/:14:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"同步 ","date":"2020-05-02","objectID":"/posts/OS-2/:15:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"信号灯机制 ","date":"2020-05-02","objectID":"/posts/OS-2/:16:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"Windows同步机制 ","date":"2020-05-02","objectID":"/posts/OS-2/:17:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"互斥量 ","date":"2020-05-02","objectID":"/posts/OS-2/:18:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"Linux进程实现同步 ","date":"2020-05-02","objectID":"/posts/OS-2/:19:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"进程通信-管道通信 ","date":"2020-05-02","objectID":"/posts/OS-2/:20:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"Linux终端上的信号机制 ","date":"2020-05-02","objectID":"/posts/OS-2/:21:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"编程实现进程之间的信号通信 ","date":"2020-05-02","objectID":"/posts/OS-2/:22:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"哲学家进餐-同步 ","date":"2020-05-02","objectID":"/posts/OS-2/:23:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"Linux进程 ","date":"2020-05-02","objectID":"/posts/OS-2/:24:0","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"进程类型 ","date":"2020-05-02","objectID":"/posts/OS-2/:24:1","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["操作系统"],"content":"进程优先级及调度策略 当linux中的进程创建子进程时，子进程时间继承自父进程的一半，且当前父进程时间减半 ","date":"2020-05-02","objectID":"/posts/OS-2/:24:2","tags":["操作系统-课程"],"title":"OS总结 Part-2","uri":"/posts/OS-2/"},{"categories":["物联网"],"content":"RFID信号干扰 RFID信号干扰 与其他无线传输系统一样,RFID系统也存在信号干扰问题。 RFID系统中,主要存在以下两种类型的信号干扰: 阅读器之间的冲突干扰(多个阅读器同时发送信号) 标签之间的冲突干扰(多个阅读器同时响应阅读器) 因此,需要降低阅读器之间以及标签之间的冲突来提高对标签的识别效率。 ","date":"2020-05-02","objectID":"/posts/IOT-5/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["物联网"],"content":"阅读器之间的冲突 三种解决方法 基于时分多址(TDMA) 基于频分多址(FDMA) 基于载波侦听多路访问(CSMA) 以下方法是基于TDMA的标签之间的防冲突算法 ","date":"2020-05-02","objectID":"/posts/IOT-5/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["物联网"],"content":"基于ALOHA的防冲突算法 基于ALOHA的防冲突算法采用了回退的机制,标签以概率的方法参与识别过程。 ALOHA的协议的特点: 简单且公平 三种基于ALOHA的防冲突算法: 纯ALOHA算法 时隙ALOHA算法 基于帧的时隙ALOHA算法 ","date":"2020-05-02","objectID":"/posts/IOT-5/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["物联网"],"content":"纯ALOHA算法 定义：若标签收到成功识别确认信息,则不再继续发送标识符。否则其等待一段时间后将重新发送直至发送成功为止。 特点：算法简单 ,易于实现,但信道利用率仅为18.4%,性能差。 ","date":"2020-05-02","objectID":"/posts/IOT-5/:2:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["物联网"],"content":"时隙ALOHA算法 定义：S-ALOHA算法将纯ALOHA算法的时间分为若干 时隙 ,每个时隙大于或等于标签标识符发送的时间长度,并且每个标签只能在时隙开始时刻发送标识符。由于系统进行了时间同步,S‐ALOHA协议的信道利用率达到36.8%,是纯ALOHA的两倍。 ","date":"2020-05-02","objectID":"/posts/IOT-5/:2:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["物联网"],"content":"基于帧的时隙ALOHA算法 定义：在S-ALOHA基础上,将若干个时隙组织为一帧 ,阅读器按照帧为单元进行识别。若标识符发送成功,则标签休眠,否则等待在下一帧中重新选择时隙发送标识符。 FSA算法优点： FSA算法的优点在于逻辑简单,电路设计简单,所需内存少,且在帧内只随机发送一次能够更进一步降低了冲突的概率。FSA成为RFID系统中最 常用 的一种基于ALOHA的防冲突算法 FSA算法局限性:帧的长度固定 当标签数远大于帧长度标签冲突概率增大,识别标签的时间会极大地增加 当标签数远小于帧长度时隙会巨大浪费,识别时间也会增加 当帧的长度等于阅读器场内标签的数目时,FSA才能获得最佳的识别性能,信道利用率最大为36.8%。 帧动态调整 实际应用中,标签数量往往是动态变化的。 动态自适应设置帧长度的算法可以解决FSA的局限性。 常见的帧长调整方法: 根据前一帧通信获取的空的时隙数目,发生碰撞的时隙数目和成功识别标签的时隙数目的数量估计当前的标签数并设置下一帧的最优的长度 ; 根据前一时隙的反馈动态调整帧长为 2 的 整数倍 ,这种方法最具代表性的是EPCglobalGen2标准中设计的Q算法 Q算法：当一帧出现过多的冲突时隙时,阅读器会提前结束该帧并重新发送一个更大的帧;当一个帧出现过多的空闲时隙时,阅读器也会提前结束该帧,重新启动一个更小的帧，Q算法能够自适应地调整帧长,识别效率高,在超高频识别系统中得到了广泛的应用。 基于ALOHA的防冲突算法简单,并且兼顾了公平性。但是,标签存在“饿死”的问题。当一个标签选择的时隙总是冲突时隙,则该标签可能永远无法被识别。 ","date":"2020-05-02","objectID":"/posts/IOT-5/:2:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["物联网"],"content":"基于二进制树的防冲突算法 ","date":"2020-05-02","objectID":"/posts/IOT-5/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["物联网"],"content":"分类 基于二进制树的防冲突算法的基本思想:按照递归的方式将冲突的标签集合划分为两个子集,直到集合中只剩下一个标签为止。 划分子集的算法: 随机二进制树算法:让标签随机选择所属的集合 查询二进制树算法:按照标签的标示符划分子集 ","date":"2020-05-02","objectID":"/posts/IOT-5/:3:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["物联网"],"content":"随机二进制树算法 定义： 随机二进制树算法需要每个标签维持一个计数器(初始值为0)。在每一个间隙开始时,如果标签的计数器为0则立即发送自己的标识符号,否则该时隙不响应。一般,标签被成功识别后将进入沉默状态,对以后时隙的阅读器命令均不响应。每次识别成功，其他标签的计数器数值减一 场内标签调整计数器规则:若该时隙为冲突时隙,参与相应的标签会从0或1中随机选择一个,将其加到自己的计数器上。 整个识别过程就像对二叉树进行中序遍历。 不存在标签饿死的问题,但需要维护计数器。 ","date":"2020-05-02","objectID":"/posts/IOT-5/:3:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["物联网"],"content":"查询二进制树算法 定义： 是一个无状态协议,标签只需要根据阅读器广播的标示符前缀作比较。 阅读器维持一个二进制前缀(初始值为0)。每个间隙开始时,阅读器广播该二进制前缀,标签将自己的标签标识符前几位与此二进制前缀进行比较,若相同则该标签发送标识符号。 整个识别过程就像根据标签的表示符号建立一棵查询二叉树。 可用于无可写存储区的标签,不存在标签饿死。受ID长度以及分布的影响。 ","date":"2020-05-02","objectID":"/posts/IOT-5/:3:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["物联网"],"content":"三种算法的比较 ","date":"2020-05-02","objectID":"/posts/IOT-5/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-5","uri":"/posts/IOT-5/"},{"categories":["Ubuntu"],"content":"Synaptic Package Manager ","date":"2020-05-02","objectID":"/posts/ubuntu-18/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu管理已安装的包","uri":"/posts/ubuntu-18/"},{"categories":["Ubuntu"],"content":"包管理软件 在Ubuntu中安装了很多包之后，很难管理，而且对于我这种强迫症…实在忍不了 搜了一会发现一个好用的可视化管理工具 Synaptic Package Manager 安装很简单，打开终端，输入以下命令： sudo apt-get install synaptic 中文系统安装之后显示“新立得软件包管理器” ","date":"2020-05-02","objectID":"/posts/ubuntu-18/:1:0","tags":["Linux-Ubuntu"],"title":"Ubuntu管理已安装的包","uri":"/posts/ubuntu-18/"},{"categories":["Ubuntu"],"content":"搜狗输入法配置文件 另外今天想设置搜狗输入法，但是之前把状态栏隐藏了，又因为安装的是优麒麟社区特供版，所以导致现在调不出搜狗的设置，一番重装之后发现还是不行，感觉应该是有配置文件，果然在 /home/username/.config/SogouShell/usr/PCPYDict 找到了 env.ini 配置文件 StatusAppearance=1 #设置为1即可 ","date":"2020-05-02","objectID":"/posts/ubuntu-18/:2:0","tags":["Linux-Ubuntu"],"title":"Ubuntu管理已安装的包","uri":"/posts/ubuntu-18/"},{"categories":["Ubuntu"],"content":"本来今天要去净月潭,不过外面阴天,只好窝在家里了… 打开电脑改没写完的blog,感觉再继续用 ibus 我的眼睛就真的要废掉了 所以下定决心 再重新装fcitx!!!(我就不信了) 根据之前的失败经历，我想这次就装个fcitx-google-pinyin就好 经过n次重启之后，终于装上了，更让我意外的是，sogou竟然也好使了！ ubuntu下的ibus和fcitx有很大的坑，两个输入法共同存在，会引起冲突 而且ibus还不能完全卸载，只能通过开机配置文件去限制他的启动 填坑上方法 ","date":"2020-04-30","objectID":"/posts/ubuntu-17/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu输入法配置","uri":"/posts/ubuntu-17/"},{"categories":["Ubuntu"],"content":"1.安装fcitx $ sudo apt install fcitx 输入命令 $ im-config im-config是Input Method Configuration的缩写 运行如下命令之后，就会开启 Input Method Configuration 窗口。 在依次出现的窗口中，依次选择OK –\u003e Yes –\u003e fcitx –\u003e OK 然后重启电脑 ","date":"2020-04-30","objectID":"/posts/ubuntu-17/:1:0","tags":["Linux-Ubuntu"],"title":"Ubuntu输入法配置","uri":"/posts/ubuntu-17/"},{"categories":["Ubuntu"],"content":"2.安装Google拼音 先安装googlepinyin $ sudo apt install fcitx-googlepinyin 然后，运行如下命令 $ fcitx-config-gtk3 依次进行如下操作 打开Input Method Confuguration窗口； 点击 + 号； 取消勾选「 Only Show Current Language 」这个选框； 在搜索栏中输入 google，就会找到我们刚才安装的Google Pinyin这个输入法，选中它，点击「 OK 」，就把谷歌拼音输入法添加到当前输入法列表中了； ","date":"2020-04-30","objectID":"/posts/ubuntu-17/:2:0","tags":["Linux-Ubuntu"],"title":"Ubuntu输入法配置","uri":"/posts/ubuntu-17/"},{"categories":["Ubuntu"],"content":"3.屏蔽ibus 此时如果发现fcitx中语言选择为空,就需要一些神奇的操作了 根据来自 fcitx 的这篇文档，我们了解到需要进行一些环境的改动。 首先修改一下 gnome-settings-daemon 的设置： $ gsettings set org.gnome.settings-daemon.plugins.xsettings overrides \"{'Gtk/IMModule':\u003c'fcitx'\u003e}\" $ gsettings set org.gnome.settings-daemon.plugins.keyboard active false 第一行是修改输入法模块，第二行是禁用键盘动作。 编辑家目录下的.xprofile文件，如没有则创建,添加以下内容： export XMODIFIERS=@im=fcitx export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx 3.编辑家目录下的.xinitrc文件，如没有则创建,添加以下内容： #!/bin/sh # # ~/.xinitrc # # Executed by startx (run your window manager from here) if [ -d /etc/X11/xinit/xinitrc.d ]; then for f in /etc/X11/xinit/xinitrc.d/*; do [ -x \"$f\" ] \u0026\u0026 . \"$f\" done unset f fi eval `dbus-launch --sh-syntax --exit-with-session` export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=\"@im=fcitx\" exec startxfce4 最后重启电脑,就可以使用fcifx了 ","date":"2020-04-30","objectID":"/posts/ubuntu-17/:3:0","tags":["Linux-Ubuntu"],"title":"Ubuntu输入法配置","uri":"/posts/ubuntu-17/"},{"categories":["Ubuntu"],"content":"Ubuntu20.04下的搜狗拼音  由于一些迷惑原因,优麒麟20.04版本的商店上架了搜狗linux版,但是目前搜狗官网没有上架20.04的安装包,所以个人猜测应该是有一些内部交易,希望国内用户转向优麒麟社区,不过…我还是算了吧,国内社区也就那样,UI设计还是没法看,感觉都不知道抄的Win10还是OSX,还是原生Ubuntu舒服 所以这里安装优麒麟Ubuntu社区特供版的搜狗 下载地址 sudo dpkg -i sogouimebs.deb 解决依赖 sudo apt --fix-broken install 重新安装 sudo dpkg -i sogouimebs.deb 然后就可以使用了 ","date":"2020-04-30","objectID":"/posts/ubuntu-17/:4:0","tags":["Linux-Ubuntu"],"title":"Ubuntu输入法配置","uri":"/posts/ubuntu-17/"},{"categories":["物联网"],"content":"物联网标识技术 物联网标识技术 条形码 1920, Kermode发明了最早的条码 他的想法是在信封上做条形码标记,条形码中的信息是收信人的地址,就象今天的邮政编码。为此Kermode发明了最早的条形码标识,设计方案非常的简单,即一个“条”表示数字“1”,二个“条”表示数字“2”,以次类推。 公牛眼 20世纪40年代,称作“公牛眼”条码。伍德兰德和西尔沃提出 1959年申请专利 伍德兰德和费伊赛尔申请专利,0~9用7段平行条构成 一维码 ","date":"2020-04-29","objectID":"/posts/IOT-4/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"概念 条码(Bar Code) 将宽度不等的多个黑条和空白,按照一定的编码规则排列,用以表达一组信息的图形标识符。 码制 条形码的编码要求,数字系统的主要功能是处理信息。 因此必须将信息表示成能够识别的电路,便于运算存储的形式。 条码字符集 某种码制所表示的全部字符的集合 非连续性 非连续性是指每个条码字符之间存在间隔 定长条码与非定长条码 定长条码是指仅能表示固定字符个数的条码。如:EAN-13条码 非定长条码是指能表示可变字符个数的条码。如:EAN-128条码。 双向可读性 自校验性 ","date":"2020-04-29","objectID":"/posts/IOT-4/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"结构 一个完整的条码的组成次序依次为:静区(前)、起始符、数据符、(中间分隔符,主要用于EAN码)、校验符、终止符、静区(后) ","date":"2020-04-29","objectID":"/posts/IOT-4/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"一维条码的识读原理 电信号输出到条码扫描器的放大电路增强信号之后,再送到整形电路将模拟信号转换成数字信号。白条、黑条的宽度不同,相应的电信号持续时间长短也不同。然后译码器通过测量脉冲数字电信号0,1的数目来判别条和空的数目。通过测量0,1信号持续的时间来判别条和空的宽度。最后,由计算机系统进行数据处理与管理,物品的详细信息便被识别了。 二维码 ","date":"2020-04-29","objectID":"/posts/IOT-4/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"二维码的组成 二维条码是用某种特定的几何图形按一定规律相应元素位置上用“点”表示二进制“1”, 用“空”表示二进制“0”,由“点”和“空”的排列组成的代码。 ","date":"2020-04-29","objectID":"/posts/IOT-4/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"二维码与一维码比较 ","date":"2020-04-29","objectID":"/posts/IOT-4/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"二维码的优点 可靠性强 二维码的读取准确率远远超过人工记录,平均每15000个字符才会出现一个错误。 效率高 二维码的读取速度很快,每秒可读取40个字符。 成本低 与其它自动化识别技术相比较,二维码技术仅仅需要一小张贴纸和相对构造简单的光学扫描仪,成本相当低廉。 易于制作 条形码制作:条形码的编写很简单,制作也仅仅需要印刷 灵活实用 条形码符号可以手工键盘输入,也可以和有关设备组成识别系统实现自动化识别,还可和其他控制设备联系起来实现整个系统的自动化管理。 高密度 二维条码通过利用垂直方向的堆积来提高条码的信息密度,而且采用高密度图形表示,因此不需事先建立数据库,真正实现了用条码对信息的直接描述。 纠错功能 二维条形码不仅能防止错误,而且能纠正错误,即使条形码部分损坏,也能将正确的信息还原出来。 ","date":"2020-04-29","objectID":"/posts/IOT-4/:6:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"二维码的分类 线性堆叠式二维码 是在一维条码编码原理的基础上,将多个一维码在纵向堆叠而产生的。典型的码制如: Code 16K、Code 49、PDF417等。 矩阵式二维码 是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码。典型的码制如: Aztec、Maxi Code、QR Code、 Data Matrix等。 QR-CODE ","date":"2020-04-29","objectID":"/posts/IOT-4/:7:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"定义 QR码是由日本电装(Denso)公司于1994年9月研制的一种矩阵二维码符号,QR码除具有一维条码及其它二维条码所具有的信息容量大、可靠性高、可表示汉字及图象多种文字信息、保密防伪性强等优点。普通的一维条码只能在横向位置表示大约20位的字母或数字信息,无纠错功能,使用时候需要后台数据库的支持,而QR码二维条码是横向纵向都存有信息,可以放入字母、数字、汉字、照片、指纹等大量信息,相当一个可移动的数据库。 ","date":"2020-04-29","objectID":"/posts/IOT-4/:8:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"优点 QR码比其他二维码相比,具有识读速度快、数据密度大、占用空间小的优势。QR码的三个角上有三个寻象图形,使用CCD识读设备来探测码的位置、大小、倾斜角度、并加以解码,实现360度高速识读。 每秒可以识读30个含有100个字符QR码。QR码容量密度大,可以放入2108个汉字、7089个数字、4296个英文字母。QR码用数据压缩方式表示汉字,仅用13bit即可表示一个汉字,比其他二维条码表示汉字的效率提高了20%。 QR具有4个等级的纠错功能,即使破损或破损也能够正确识读。QR码抗弯曲的性能强,即使将QR码贴在弯曲的物品上也能够快速识读。 ","date":"2020-04-29","objectID":"/posts/IOT-4/:9:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"QR-CODE编码原理 每个QR码符号由名义上的正方形模块构成,组成一个正方形阵列,它由编码区域和包括寻象图形、分隔符、定位图形和校正图形在内的功能图形组成。功能图形不能用于数据编码。符号的四周由空白区包围。 ","date":"2020-04-29","objectID":"/posts/IOT-4/:10:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"区域组成 寻象图形 寻象图形包括三个相同的位置探测图形,分别位于符号的左上角、右上角和左下角,如图2所示。每个位置探测图形可以看作是由3个重叠的同心的正方形组成,它们分别为7x7个深色色模块、5x5个浅模块和3x3个深色模块。如下图所示,位置探测图形的模块宽度比为1:1:3:1:1。符号中其他地方遇到类似图形的可能性极小,因此可以在视场中迅速地识别可能的QR码符号。识别组成的寻象图形的三个位置探测图形,可以明确地确定视场中符号的位置和方向。 分隔符 在每个位置探测图形和编码区域之间有宽度为1个模块的分隔符,它全部由浅色模块组成。 定位图形 水平和垂直定位图形分别为一个模块宽的一行和一列,由深色浅色模块交替组成,其开始和结尾都是深色模块。水平定位图形位于上部的两个位置探测图形之间,符号的第7行。垂直定位图形位于左侧的两个位置探测图形之间,符号的第7列。它们的作用是确定符号的密度和版本,提供决定模块坐标的基准位置。 校正图形 每个校正图形可看作是3个重叠的同心正方形,由5×5个的深色模块,3×3个的浅色模块以及位于中心的一个深色模块组成。校正图形的数量视符号的版本号而定,在模式2的符号中,版本2以上(含版本2)的符号均有校正图形。 编码区域 编码区域包括表示数据码字、纠错码字、版本信息和格式信息的符号字符。 空白区 空白区为环绕在符号四周的4个模块宽的区域,其反射率应与浅色模块相同。 ","date":"2020-04-29","objectID":"/posts/IOT-4/:11:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"QR-CODE编码过程 射频技术 ","date":"2020-04-29","objectID":"/posts/IOT-4/:12:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"定义 RFID是射频识别技术(Radio Frequency Identification)的英文缩写,利用 射频信号 通过 空间耦合 (交变磁场或电磁场)实现 无接触信息传递 并通过所传递的信息达到 识别 目的。它是上世纪90年代兴起的自动识别技术,首先在欧洲市场上得以使用,随后在世界范围内普及。RFID较其它技术明显的 优点 是电子标签和阅读器 无需接触 便可完成识别。射频识别技术改变了条形码依靠\"有形\"的一维或二维几何图案来提供信息的方式, 通过芯片 来 提供存储 在其中的数量巨大的\"无形\"信息。 ","date":"2020-04-29","objectID":"/posts/IOT-4/:13:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"历史发展 ","date":"2020-04-29","objectID":"/posts/IOT-4/:14:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"工作原理 基本组成: 工业界经常将RFID系统分为标签,阅读器和天线三大组件。 工作原理: 阅读器通过天线发送电子信号,标签接收到信号后发射内部存储的标识信息,阅读器再通过天线接收并识别标签发回的信息,最后阅读器再将识别结果发送给主机。 阅读器 供能 阅读器为射频标签工作提供能量 安全保护 阅读器的通信安全性保证功能,如使用加密、解密技术 通信 阅读器和射频标签之间的通信阅读器和应用层(中间件)之间的通信 ","date":"2020-04-29","objectID":"/posts/IOT-4/:15:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"分类 按工作频率 RFID系统的工作原理与其所使用的射频信号频率有关。工作频率越高,识别距离越远,数据传输速率越高,信号衰减越厉害,对障碍物越敏感。 低频和高频阅读器 工作频率一般小于1m,典型工作频率125kHz、135kHz、6.78MHz、13.56MHz和27.125MHz 超高频和特高频阅读器 工作频率一般大于1m,典型工作频率有433MHz、860MHz~960MHz、2.45GHz和5.8GHz ","date":"2020-04-29","objectID":"/posts/IOT-4/:16:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"信号处理与控制模块 ","date":"2020-04-29","objectID":"/posts/IOT-4/:17:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"射频模块 标签 ","date":"2020-04-29","objectID":"/posts/IOT-4/:18:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"标签功能 存储数据 标签内存储和物品相关的信息,如标识符、生产日期、生产厂家等。 能量获取 标签可以从阅读器发射的电磁场中吸收能量,为标签自生供电。 非触碰式读写 标签可以在距离阅读器一定距离的范围内被识别。 ","date":"2020-04-29","objectID":"/posts/IOT-4/:19:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"标签分类 ","date":"2020-04-29","objectID":"/posts/IOT-4/:20:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"能量来源 有源标签: 主动标签,依靠自身电池。 无源标签: 依靠反射阅读器发射的载波信号来获取能量 半无源标签: 电路板上集成电池,但作为辅助备用 ","date":"2020-04-29","objectID":"/posts/IOT-4/:20:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"工作频率 低频标签: 30kHz~300kHz 一般为无源 电感耦合 穿透力强 高频标签 300kHz~30MHz 一般为无源 电感耦合 传输快、存储大 超高频标签 0.3GHz~3GHz 无源或有源 电磁反向散射耦合 距离远、速率高、移动场景、多标签读写性能好 ","date":"2020-04-29","objectID":"/posts/IOT-4/:20:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"标签组成 ","date":"2020-04-29","objectID":"/posts/IOT-4/:21:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"天线 决定了标签的尺寸接受阅读器发射的射频信号将芯片数据发送给阅读器对于无源标签,天线还用来供能 ","date":"2020-04-29","objectID":"/posts/IOT-4/:21:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["物联网"],"content":"芯片 ","date":"2020-04-29","objectID":"/posts/IOT-4/:21:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-4","uri":"/posts/IOT-4/"},{"categories":["Ubuntu"],"content":"今天学到了一个超级超级好用的小技巧!!! linux每次截图之后,都是按照时间辍来命名截图文件的 但是我们在使用截图的时候就要挨个改名,很麻烦 bash 终端中提供了极好的命令控制 首先在很多系统生成的文件中有空格,这些空格在之后的 mv 命令中会误导系统认为命令结束,所以要先去去掉空格 rename 's/ /_/g' * ##表示把当前目录下所有的文件中有空格的都用_表示 批量重命名(代码不用解释,沸腾就完事啦) i=1; for x in *; do mv $x $i.png; let i=i+1; done bash是无比强大的!!! 我爱Linux!!! 2021-01-13更新 发现Windows的cmd也可以做到(新的沙雕发现) 口号精简了一下: “bash是无敌的!” ","date":"2020-04-29","objectID":"/posts/ubuntu-16/:0:0","tags":["Linux-Ubuntu"],"title":"Linux-bash对文件批量操作","uri":"/posts/ubuntu-16/"},{"categories":["Ubuntu"],"content":"今天在玩Besiege的时候,好多零件的英文都不认识…在steam更新公告里,游戏是支持中文的,可是设置里中的没有中文选项,只有空白 然后我就开始强迫症折腾了… 首先去网上找汉化教程,安装了MOD模块,以及中文mod包,不过没有用,因为linux的特殊性,就去MOD的github官方库去看看咋回事,发现…早就不支持当前版本了 随后发现创意工坊里有繁体中文包,犹豫了好久装不装,突然想到按照它的安装思路,不如去看看他的包是装在哪里,跟着目录找到了steam语言包的位置,发现有chinese文件啊… 这就有意思了…有文件为什么游戏不显示呢? 莫非是…字体不支持! 网上搜了搜发现果然是这样的!linux下的很多游戏中文都是乱码,因为steam游戏要求的字体没有下载 机智如我 安装以下字体即可 sudo apt-get install ttf-wqy-microhei #文泉驿-微米黑 sudo apt-get install ttf-wqy-zenhei #文泉驿-正黑 sudo apt-get install xfonts-wqy #文泉驿-点阵宋体 ","date":"2020-04-29","objectID":"/posts/ubuntu-15/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu下的Steam中文支持","uri":"/posts/ubuntu-15/"},{"categories":["物联网"],"content":"无线传感网络 这两天忙着改论文,所以昨天断更了 今天把老师的派的任务都弄完了,可以继续更blog了吼吼,昨天装了新的Ubuntu20.04,感觉新东西还蛮多的,就是这输入法快把我折磨疯了,中文输入法一直是Ubuntu的一大痛点,之前好不容易装的搜狗输入法,这个版本就用不了了,fcitx和ibus各种来回装,最后fcitx实在装不上了,只能屈服于辣鸡ibus,这跟米粒大的界面,快把我整瞎了,先将就用吧 无线传感器网络(WSN) ","date":"2020-04-28","objectID":"/posts/IOT-3/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"定义 无线传感器网络(WSN)是大量的静止或移动的传感器以自组织和多跳的方式构成的无线网络,目的是协作地采集、处理和传输网络覆盖地域内感知对象的监测信息,并报告给用户。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"结构 传感器节点 功能:采集、处理、控制和通信等 网络功能:兼顾节点和路由器 资源受限:存储、计算、通信、能量 Sink节点 功能:连接传感器网络与Internet等外部网络,实现两种协议栈之间的通信协议转换,发布管理节点的监测任务,转发收集到的数据。 特点:连续供电、功能强、数量少等 ","date":"2020-04-28","objectID":"/posts/IOT-3/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"特点 大规模网络:地理区域大;部署密集 自组织网络:不确定性;拓扑结构变化 资源受限:计算、存储、通讯、能量 动态拓扑:节点故障;通讯故障;移动性;节点加入 可靠性:环境偏远,不利于人工维护 以数据为中心:用户感兴趣的是数据而不是网络和传感器硬件 集成化:集成多种类型的传感器 ","date":"2020-04-28","objectID":"/posts/IOT-3/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"网络的自组织和自我管理 WSN 采用无线自组织方式进行组网, 节点放入检测区域后, 搜集被检测信息, 并把这些信息发于邻接节点, 并将其周围的链路连接信息发回给 sink 节点, sink 节点把从所有信息进行汇总分析后, 可得到网络的拓扑结构和传输路由等信息。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:3:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"拓扑结构 WSN 的拓扑形式一般有三种:平面结构、簇方式、栈结构。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:3:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"合理的能源控制 在 WSN 中, 为了节省能量, 不管是节点自身还是通信协议都需要更为合理的设计, 以适应节点在工作和休眠之间的转换的需要。可以通过在应用层、网络层、接入层协议的控制, 引入能源控制的理念,以延长网络的生存时间。此外, 还可以通过将链路层应答和网络层应答跨层结合起来进行设计,既可以满足性能的要求, 也可降低功耗 ","date":"2020-04-28","objectID":"/posts/IOT-3/:3:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"局限性 首先是节点能量受限。WSN 中的节点通常由电池供电, 电池的容量一般不能维持节点正常工作时间过长;其次,节点处理能力受限。无线传感网络中的节点受体积和成本的影响,内存和处理器均不能和普通计算机相比, 其处理程序和运算数据的能力也有限;最后,它是以数据为中心的,在无线传感网络中, 只需将用户关心的信息数据进行搜集传输, 即 WSN 是一种以数据为中心的网络。 无线传感网络的路由协议 ","date":"2020-04-28","objectID":"/posts/IOT-3/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"路由的定义 路由是指数据从源地址端到目的地址端时,决定端到端路径的网络协议。路由工作的两个基本动作: 确定源节点到目的节点的最佳路径 通过有线或无线网络来传输信息 在无线传感网络(Wireless sensor network, WSN)中,路由协议的核心任务是确保数据由源节点准确高效的传输到目的节点,即寻找数据的最优路径以及沿最优路径发送数据。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"路由协议面临的问题 降低节点能耗:节点的大部分能量消耗在数据通信阶段,建立有效的路由机制,可以减少网络中数据的传输量,减少能耗。 节点间能耗的均衡性:网络中的某个或某些节点能量过早耗尽,将造成网络拓扑结构的改变,影响网络的连通性。 可扩展性:节点的移动、节点寿命的结束、节点的物理损伤以及环境的干扰等因素都可能会造成网络拓扑结构的变化。 典型的WSN路由协议 ","date":"2020-04-28","objectID":"/posts/IOT-3/:6:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"洪泛路由(Flooding)协议 ","date":"2020-04-28","objectID":"/posts/IOT-3/:7:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"定义 洪泛法是一种传统的网络路由协议,不需要知道网络拓扑结构和使用任何路由算法 ","date":"2020-04-28","objectID":"/posts/IOT-3/:7:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"协议内容 点S希望发送一块数据给节点D,节点S首先通过网络将数据副本传送给它的每一个邻居节点,每一个邻居节点又将其传输给各自的每一个邻居节点,除了刚刚给它们发送数据副本的节点S外。如此继续下去,直到将数据传输到目标节点D为止或者为该数据所设定的生命期限(在传感器网络里面通常定义为最大跳数)变为零为止或者所有节点拥有此数据副本为止。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:7:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"洪泛路由(Flooding)的优点 协议实现简单 不需要为保持网络拓扑信息和实现复杂的路由发现算法而消耗计算资源 适用于健壮性要求高的场合 ","date":"2020-04-28","objectID":"/posts/IOT-3/:7:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"洪泛路由(Flooding)的缺点 存在信息爆炸问题 出现部分重叠(Overlap)现象 盲目使用资源 ","date":"2020-04-28","objectID":"/posts/IOT-3/:7:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"洪泛路由(Flooding)的应用 可以作为衡量标准评价其它路由算法 有极好的健壮性,可用于军事应用 ","date":"2020-04-28","objectID":"/posts/IOT-3/:7:5","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"SPIN 协商机制路由协议 ","date":"2020-04-28","objectID":"/posts/IOT-3/:8:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"定义 SPIN (Sensor protocol for informationvia negotiation) SPIN是最早的以数据为中心的自适应路由协议,通过协商机制来解决洪泛算法中的“内爆”和“重叠”问题,节省了能量的消耗。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:8:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"协议内容 节点A在发送一个DATA数据包之前,会首先对向邻居节点B广播ADV数据包; 如果邻居节点B在收到ADV后有意愿接收该DATA数据包,那么它向该节点A发送一个REQ数据包,接着节点A将向该邻居节点B发送DATA数据包; 类似地进行下去,DATA数据包可被传输到远方汇节点或基站。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:8:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"SPIN协议遵守的几个原则 为了避免出现扩散法的信息爆炸问题和部分重叠现象,传感器节点在传送数据之前彼此进行协商,协商制度可确保传输有用数据。 节点间通过发送元数据(即描述传感器节点采集的数据属性的数据,meta-data),而不是采集的整个数据进行协商。 在传输或接收数据之前,每个节点都必须检查各自可用的能量状况,如果处于低能量水平,必须中断一些操作。 SPIN有3种数据包类型,即ADV、REQ和DATA.节点用ADV宣布有数据发送,用REQ请求希望接收数据,用DATA封装数据。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:8:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"SPIN协议的优点 ADV消息模式减轻了内爆问题 通过数据命名解决了交叠问题 节点根据自身资源和应用信息决定是否进行ADV通告,避免了资源利用盲目问题 ","date":"2020-04-28","objectID":"/posts/IOT-3/:8:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"SPIN协议的缺点 在传输新数据的过程中,直接向邻居节点广播ADV数据包,而没有考虑其所有邻居节点由于自身能量的原因,不愿承担起转发新数据的功能,则新数据无法传输,将会出现“数据盲点”,进而影响整个网络信息的收集。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:8:5","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"DD 定向扩散路由协议 ","date":"2020-04-28","objectID":"/posts/IOT-3/:9:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"定义 DD(Directed Diffusion)是一种以数据为中心的路由协议,与已有的路由协议有着截然不同的实现机制,其突出特点是引入了梯度来描述网络中间节点对该方向继续搜索获得匹配数据的可能性。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:9:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"协议内容 建立路由时,sink节点首先会广播包含属性列表、 上报间隔、持续时间、地理区域等信息的查询请 求Interest。 每个传感器节点在收到嗜好(Interest) 后保存在各自的Cache中。每个嗜好项 (interest entry)包含一个时间标签域和若干个梯度域。 当一个嗜好传遍整个网络后,从源节点(即嗜好所在区域的传感器节点)到 sink 节 点 或 基 站 之 间的梯度就建立起来了。 一旦源节点采集到嗜好所需的数据,那么源节点沿着该嗜好的梯度路径传输数据到sink节点或基站。其中,源节点采集的数据首先在本地采用数据融合技术进行整合,然后在网上传输。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:9:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"DD路由协议的优点 采用多路径,健壮性好 节点只需要和邻居节点通信,因而不需要全局的地址机制 ","date":"2020-04-28","objectID":"/posts/IOT-3/:9:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"DD路由协议的缺点 基于查询驱动模型的,不适用于环境监测的WSN 梯度场的建立开销很大,不适合多sink点网络 ","date":"2020-04-28","objectID":"/posts/IOT-3/:9:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"GPSR 路由协议 ","date":"2020-04-28","objectID":"/posts/IOT-3/:10:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"定义 GPSR协议是一个典型的基于位置的路由协议。使用GPSR协议,网络节点都知道自身地理位置并被统一编址,各节点利用贪心算法尽量沿直线转发数据。产生或收到数据的节点向以欧氏距离计算最靠近目的节点的邻节点转发数据,但由于数据会到达没有比该节点更接近目的点的区域(称为空洞),导致数据无法传输,当出现这种情况时,空洞周围的节点能够探测到,并利用右手法则沿空洞周围传输来解决此问题。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:10:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"GPSR路由协议的优点 用接近于最短欧氏距离的路由,数据传输时延小 ","date":"2020-04-28","objectID":"/posts/IOT-3/:10:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"GPSR路由协议的缺点 需要GPS定位系统或其他定位方法协助计算节点位置信息 这个路由方式的处理方式有些复杂,这里有一篇blog提供参考 ","date":"2020-04-28","objectID":"/posts/IOT-3/:10:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"LEACH路由协议 ","date":"2020-04-28","objectID":"/posts/IOT-3/:11:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"定义 LEACH(Low-Energy Adaptive Clustering Hierarchy)是一种基于聚类(Clustering)路由协议,在WSN路由协议占有重要地位。LEACH协议分为两个阶段操作,即类准备阶段和就绪阶段。在类准备阶段,LEACH协议随机选择一个传感器节点作为类头节点。在就绪阶段,类头节点开始接收类内各节点采集的数据,然后采用数据融合和数据压缩等技术进行汇聚,将整合后的数据传输给Sink节点。 ","date":"2020-04-28","objectID":"/posts/IOT-3/:11:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-3","uri":"/posts/IOT-3/"},{"categories":["物联网"],"content":"传感器 这几天在学操作系统和物联网概论的网课,操作系统因为之前学过,所以一些新学到的知识点,攒一攒再发一篇blog,日常更新物联网概论,加油 ","date":"2020-04-26","objectID":"/posts/IOT-2/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"传感器 ","date":"2020-04-26","objectID":"/posts/IOT-2/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"定义 能够感受规定的被测量的信息,并按照一定规律转换成可用信号的器件或装置,它通常由敏感元件和转换元件组成。 敏感元件:直接感受被测量,并输出与被测量成确定关系的某一物理量的元件。 转换元件:敏感元件的输出就是它的输入,它把输入转换成电路参量。 转换电路:上述电路参数接入基本转换电路(简称转换电路),便可转换成电量输出。主要技术:电子技术——运算放大器 传感器输出电量有很多种形式,如电压、电流、电容、电阻等,输出信号的形式由传感器的原理确定。通常,传感器由敏感元件和转换元件组成或测量的电信号的部分。 由于传感器输出信号一般都很微弱,需要有信号调理与转换电路进行放大、运算调制等。 随着IC发展,传感器的信号调理转换电路与敏感元件通常会集成在同一芯片上,安装在传感器的壳体里。 传统的传感器包括两种类型的处理技术,即模拟信号处理技术和数字信号处理技术。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:1:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"静态特性 衡量静态特性的重要指标是线性度、灵敏度、迟滞和重复性等 。 输出量与输入量之间的实际关系曲线偏离直线的程度称为线性度。一般用非线性误差表示可用下式表示: 传感器的灵敏度是其在稳态下输出增量 ΔY 与输入增量 ΔX的比值。常用 Sn 对于线性传感器,其灵敏度就是它的静态特性的斜率 传感器在正(输入量增大)反(输入量减小)行程中输出输入曲线不重合称为迟滞 迟滞差值:正反行程的差值。 迟滞误差:传感器在全量程范围内最大迟滞差值⊿Hmax与满量程输出值之比 重复性是指传感器在输入按同一方向做全量程连续多次变动时所得特性曲线不一致的程度。重复性误差可用正反行程的最大偏差表示 ΔRmax1正行程的最大重复性偏差 ΔRmax2反行程的最大重复性偏差 ","date":"2020-04-26","objectID":"/posts/IOT-2/:1:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"动态特性 传感器对随时间变化的输入量的响应特性。 被测量可能以各种形式随时间变化,只要输入量是时间的函数,则其输出量也将是时间的函数。其间的关系用动态特性方程描述。 它依赖于传感器本身的测量原理、结构,取决于系统内部机械的、电气的、磁性、光学的等各种参数,而且这个特性本身不因输入量、时间和环境条件的不同而变化。 研究方法 时域:瞬态响应法 频域:频率响应法 ","date":"2020-04-26","objectID":"/posts/IOT-2/:1:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"传感器的分类 ","date":"2020-04-26","objectID":"/posts/IOT-2/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"传感器的工作原理分类 物性型传感器 是利用某些功能材料本身所具有的内在特性及效应把被测量直接转换为电量的传感器。如:各种压电晶体传感器。 结构型传感器 是以结构(如形状、尺寸)为基础,利用某些物理规律实现把被测量转换为电量。如:电容式传感器。 化学型传感器 是利用化学反应的原理,把无机和有机化学物质的成分、浓度等转换为电信号的传感器。如:气体传感器。 生物传感器 是一种对生物物质敏感并将其浓度转换为电信号进行检测的仪器。如:各种酶传感器 ","date":"2020-04-26","objectID":"/posts/IOT-2/:2:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"传感器的信号变换特征分类 能量转换型传感器 直接由被测对象输入能量使其工作,又称无源传感器,它不起能量转换作用,只是将被测非电量转换为电参数的量,如光电式、电磁感应式传感器等 能量控制型传感器 传感器从被测对象中获取能量,用于控制激励源,故又称有源型传感器。如:电阻式、电感式、电容式、霍尔式 ","date":"2020-04-26","objectID":"/posts/IOT-2/:2:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"电阻应变式传感器 ","date":"2020-04-26","objectID":"/posts/IOT-2/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"定义 电阻应变传感器是目前应用最广泛的传感器之一。它的原理是将电阻应变片粘贴到各种弹性敏感元件上,通过电阻应变片将应变转换为电阻变化。所谓的电阻应变就是当由金属丝、箔、薄膜制成的电阻应变片在外界应力作用下其电阻值会发生变化。 当被测物理量作用在弹性元件上,弹性元件的变形会引起敏感元件的电阻值变化,通过转换电路转变成电量输出,电量值的大小反映了被测物理量的大小。 应变电阻器可用来测量位移、加速度、力、力矩、等物理量。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:3:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"原理 ","date":"2020-04-26","objectID":"/posts/IOT-2/:3:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"应变式力传感器 被测物理量为荷重或力的应变传感器,统称为应变式力传感器,主要用于做各种电子秤与材料试验机的测力元件,以及发动机的推力测试、水坝承载测试等。它要求具有较高的灵敏度和稳定性。常见的应变式力传感器有柱式力传感器、梁式力传感器等 ","date":"2020-04-26","objectID":"/posts/IOT-2/:3:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"应变式压力传感器 应变式压力传感器主要用来测量流动介质的动态或静态压力。如动力管道设备的进出口气体或液体压力、发动机内部的压力变化,枪管及炮管内的压力,内燃机的管道压力等。应变式压力传感器大多采用膜片式或筒式弹性元件。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:3:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"应变式容器内液体重量传感器 应变式容器内液体重量传感器的原理是利用感压膜感受上面液体的压力。当容器中溶液增多时,感压膜感受的压力就增大,通过将其上两个传感器Rt的电桥接成正向串接的双电桥电路,此时电桥输出电压与柱式容器内感压膜上面溶液的重量成线性关系,因此可以测量容器内储存的溶液重量 ","date":"2020-04-26","objectID":"/posts/IOT-2/:3:5","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"应变式加速度传感器 应变式加速度传感器用于物体加速度的测量,如图所示,其测量原理是将传感器壳体与被测对象刚性连接,当被测物体以加速度a运动时,质量块受到一个与加速度方向相反的惯性力作用,使悬臂梁变形,该变形被粘贴在悬臂梁上的应变片感受到并随之产生应变,从而使应变片的电阻发生变化。电阻的变化引起应变片组成的桥路出现不平衡,从而输出电压, 即可得出加速度a值的大小。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:3:6","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"电容式传感器 ","date":"2020-04-26","objectID":"/posts/IOT-2/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"定义 电容式传感器以各种类型的电容器作为敏感元件,将被测物理量的变化转换为电容量的变化,再由转换电路(测量电路)转换为电压、电流或频率,以达到检测的目的 电容式传感器不仅能测量荷重、位移、振动、角度、加速度等机械量,还能测量压力、液面、料面、成分含量等热工量。这种传感器具有结构简单、灵敏度高、动态特性好等一系列优点,在机电控制系统中占有十分重要的地位。 由物理学可知,当忽略电容器边缘效应时,由绝缘介质分开的两个平行金属板组成的平板电容器,其电容量为: ","date":"2020-04-26","objectID":"/posts/IOT-2/:4:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"电容式传感器的不同种类 变极板间距离(d)型 变面积电容传感器 常用的有角位移型和线位移型两种,与变间隙型相比,适用于较大角位移及直线位移的测量 变面积电容传感器 常用的有角位移型和线位移型两种,与变间隙型相比,适用于较大角位移及直线位移的测量 变介质型电容式传感器 常用于对容器中液面的高度、溶液的浓度以及某些材料的厚度、湿度、温度等的检测。如用来测量纸张、绝缘薄膜等的厚度;测量粮食、纺织品、木材或煤等非导电固体介质的湿度等。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:4:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"电感式传感器 ","date":"2020-04-26","objectID":"/posts/IOT-2/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"定义 电感式传感器是利用线圈自感或互感系数的变化来实现非电量电测的一种装置。利用电感式传感器,能对位移、压力、振动、应变、流量等参数进行测量。 它具有结构简单、灵敏度高、输出功率大、输出阻抗小、抗干扰能力强及测量 精度高等一系列优点,因此在机电控制系统中得到广泛的应用。它的主要缺点是响应较慢,不宜于快速动态测量。 电感式传感器种类很多,根据感知原理可分为自感式、互感式和电涡流式等 ","date":"2020-04-26","objectID":"/posts/IOT-2/:5:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"自感原理 ","date":"2020-04-26","objectID":"/posts/IOT-2/:5:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"互感原理 ","date":"2020-04-26","objectID":"/posts/IOT-2/:5:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"电涡流原理 根据法拉第电磁感应原理, 块状金属导体置于变化的磁场中或在磁场中作切割磁力线运动时, 导体内将产生呈涡旋状的感应电流, 此电流叫电涡流, 以上现象称为电涡流效应。 电涡流效应与被测金属间的距离及电导率、磁导率、线圈的几何形状、几何尺寸、电流频率等参数有关。通过电路可将被测金属参数转换成电压或电流变化。电涡流传感器根据这一原理实现对金属物体的位移、振动等参数的测量。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:5:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"传感器在智能手机中的应用 ","date":"2020-04-26","objectID":"/posts/IOT-2/:6:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"距离传感器 原理:通过红外线LED灯发射红外线,被物体反射后由红外线探测器接受,藉此通过计算接收到红外线的强度来判断距离 应用:感知手机是否被贴在耳朵上讲电话,若是则会关闭屏幕来省电;距离传感器也可以运用在部分手机支持的手套模式中,用来解锁或锁定手机。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:6:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"重力传感器 原理:通过压电效应来实现。重力传感器内部有一块重物与压电片整合在一起,透过正交两个方向产生的电压大小,来计算出水平的方向。 应用:运用在手机中时,可用来切换横屏与直屏方向,也运用在赛车游戏中。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:6:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"指纹传感器 原理:透过人体带有的微电场与电容传感器之间产生的微电流,指纹的波峰波谷与传感器之间的距离形成电容高低差,来描绘出指纹的图形。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:6:3","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"霍尔传感器 原理:依靠霍尔磁电效应,当电流通过一个位于磁场中的导体时,磁场会对导体中的电子产生一个垂直于电子运动方向上的的作用力,从而在导体的两端产生电势差 应用:运用在翻盖解锁、合盖锁定屏幕等功能当中 ","date":"2020-04-26","objectID":"/posts/IOT-2/:6:4","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"气压传感器 原理:气压传感器是将薄膜与变组器或电容连接在一起,当气压产生变化时,会导致电阻或电容数值发生变化,藉此量测气压的数据 GPS也可用来量测海拔高度但会有10米左右的误差,若是搭载气压传感器,则可以将误差校正到1米左右;也可用来辅助GPS定位,来确认所在楼层位置等信息。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:6:5","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"心率传感器 原理:通过高亮度的LED灯照射手指,因心脏将血液压送到毛细血管时,亮度红光的深度)会呈现周期性的变化。再透过摄影机捕捉这一些规律性的变化,并将数据传送到手机中进行运算,进而判断心脏的收缩频率,得出每分钟的心跳数。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:6:6","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"血氧传感器 原理:血液当中血红蛋白与氧合血红蛋白对于红光的吸收比率不同,用红外光与红光LED同时照射手指,并测量反射光的吸收光谱。 ","date":"2020-04-26","objectID":"/posts/IOT-2/:6:7","tags":["物联网概论-课程"],"title":"物联网概论 PART-2","uri":"/posts/IOT-2/"},{"categories":["物联网"],"content":"物联网概述 ","date":"2020-04-25","objectID":"/posts/IOT-1/:0:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"概念定义 第一次系统学习物联网相关的课程,没想到物联网概念是BILL GATES在1995年提出来的,前几天刚看完他的纪录片,95年出版的\"THE ROAD AHEAD\"预测了几大技术,而25年后的今天,几乎都应验了…大佬的眼界,唉 1995 Bill Gates在《未来之路》中提及物联网概念 1998 MIT的 Kevin Ashton:把RFID技术与传感器技术应用于日常物品中形成一个“物联网” 1999 EPC global 的Auto-ID中心:物联网是成千上万的物品采用无线方式接入了Internet的网络。这是物联网概念真正的提出。 2005 ITU报告:物联网是通过传感器、RFID和智能计算等技术实现全世界设备互连的网络。 2008 IBM: “互联网+物联网=智慧地球\"把传感器设备安装到电网、铁路、桥梁、隧道、供水系统、大坝、油气管道等各种物体中,并且普遍连接形成网络,即“物联网” 一个普遍被大家接受的定义为:物联网是通过使用射频识别(RFID)、传感器、红外感应器、全球定位系统、激光扫描器等信息采集设备,按约定的协议,把任何物品与互联网连接起来,进行信息交换和通讯,以实现智能化识别、定位、跟踪、监控和管理的一种网络。 从我现阶段的理解来看,物联网是多学科领域的复杂交集,软硬件的结合,行业门槛很高,但当今技术落地趋势迅速,而且对生产生活的帮助相对明显,市场需求还是比较可观的. ","date":"2020-04-25","objectID":"/posts/IOT-1/:1:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"物联网的结构 ","date":"2020-04-25","objectID":"/posts/IOT-1/:2:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"简单三层结构 全面感知 “感知”是物联网的核心。 可靠传递 数据传递的稳定性和可靠性是保证物-物相连的关键。为了实现物与物之间信息交互,就必须约定统一的通信协议。由于物联网是一个异构网络,不同的实体间协议规范可能存在差异,需要通过相应的软、硬件进行转换,保证物品之间信息的实时、准确传递。 智能处理 物联网的目的是实现对各种物品(包括人)进行智能化识别、定位、跟踪、监控和管理等功能。需要通过云计算、人工智能等智能计算技术,对海量数据进行存储、分析和处理,针对不同的应用需求,对物品实施智能化的控制。 ","date":"2020-04-25","objectID":"/posts/IOT-1/:2:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"五大系统(C3SD)结构 控制系统(control) 计算系统(computation) 通信系统(communication) 感知系统(sensor) 数据海(data ocean) ","date":"2020-04-25","objectID":"/posts/IOT-1/:2:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"物联网与泛在网和传感网的关系 ","date":"2020-04-25","objectID":"/posts/IOT-1/:3:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"泛在网和传感网的概念 泛在网 在现有电子通信范畴内通信网络的基础上,提出无处不在网络,即,任何人无论何时、何地都可以何种方式实现通信和服务的接入; 泛在网络支持人与人、人与物、物与物之间的通信; 无线传感器网络 Wireless Sensor Networks 包含传感器节点,按计算能力可分为普通节点和汇聚节点等; 传感器节点包含了具有采集环境数据功能的感应器和具有联网功能的电子元件; 节点间能够通过特有无线通信方式互联(如:ZigBee)。 目前米家智能家居支持的协议中就有ZigBee ","date":"2020-04-25","objectID":"/posts/IOT-1/:3:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"区别与联系 泛在网、物联网和传感网是依次包容的关系。 传感器网络专注于物与物之间的末端联系,它专注于物理世界信息的感知和采集,专注于网络的分发和汇聚效率;专注于低速高效,低功低耗。 物联网是面向物与物和人与物的网络,它包含多种感知单元(传感器、RFID等等),同时支持一种或几种网络通信方式,为现实世界提供服务和应用。 泛在网涵盖并高于物联网,讲求多网络和多技术融合,探索通信和服务的无缝连接,探索人与人之间新的通信和服务方式。 其实从一些方面来说,传感网等同于物联网 ","date":"2020-04-25","objectID":"/posts/IOT-1/:3:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"物联网与M2M、CPS的区别 ","date":"2020-04-25","objectID":"/posts/IOT-1/:4:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"定义 机对机通信Machine-to-Machine 机器与机器之间的通信;研究机器的智能交互和机器的网络化应用;主要驱动力来自工业和自动化行业,M2M连接的机器多是非IT设备,通过无线或有线通信网络实现通信。 信息物理融合系统Cyber Physical Systems CPS是一个综合物理环境、信息环境和智能计算的系统集合;从工业角度提出大型系统的实时感知和动态控制;美国CPS指导小组将CPS应用主要放在交通、国防、能源、医疗、农业和大型建筑设施上面。 ","date":"2020-04-25","objectID":"/posts/IOT-1/:4:1","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"区别与联系 M2M和CPS可以被认为是工业界对物联网的理解、表达和展望; M2M偏重实际应用,强调机器之间的通信并因此实现智能动作和智能联动,是典型的车间派; CPS偏重系统化,注重理论抽象,由上至下解决问题并有理论支撑,是典型的理论派; 从工业角度来讲,CPS、M2M就是物联网。 ","date":"2020-04-25","objectID":"/posts/IOT-1/:4:2","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["物联网"],"content":"物联网技术特点 感知识别普适化 无所不在的感知和识别将传统上分离的物理世界和信息世界高度融合。 异构设备互联化 各种异构设备利用无线通信模块和协议自组成网,异构网络通过“网关”互通互联。 联网终端规模化 物联网时代每一件物品均具通信功能成为网络终端,5-10年内联网终端规模有望突破百亿。 管理调控智能化 物联网高效可靠组织大规模数据,与此同时,运筹学,机器学习,数据挖掘,专家系统等决策手段将广泛应用于各行各业。 应用服务链条化 以工业生产为例,物联网技术覆盖从原材料引进,生产调度,节能减排,仓储物流到产品销售,售后服务等各个环节。 经济发展跨越化 物联网技术有望成为从劳动密集型向知识密集型,从资源浪费型向环境友好型国民经济发展过程中的重要动力。 ","date":"2020-04-25","objectID":"/posts/IOT-1/:5:0","tags":["物联网概论-课程"],"title":"物联网概论 PART-1","uri":"/posts/IOT-1/"},{"categories":["数据库"],"content":"依赖关系,范式定义 依赖关系 假设存在关系: R(学号，姓名，性别，班级，班主任，课程号，课程名，学时数，成绩) 主键：学号+课程号 主属性：{学号，课程号} 非主属性有：{姓名，性别，班级，班主任，课程名，学时数，成绩} ","date":"2020-04-24","objectID":"/posts/DB-6/:0:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"完全函数依赖分析 成绩依赖于学号和课程号两个字段的组合；但只知道学号无法确定成绩，同理只知道课程号也无法确定成绩；只有学号和课程号组合在一起才能标识哪个学生哪门课程的成绩； 因此（学号，课程号）-\u003e 成绩 是“完全函数依赖”。 ","date":"2020-04-24","objectID":"/posts/DB-6/:1:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"部分函数依赖分析 姓名、性别和班级三个属性只依赖于主键中的学号，与“课程号”无关。 因此（学号，课程号）-\u003e 姓名是“部分函数依赖” （学号，课程号）-\u003e 性别是“部分函数依赖” （学号，课程号）-\u003e 班级是“部分函数依赖” 课程名和学时数只依赖于课程号， 因此（学号，课程号）-\u003e 课程名是“部分函数依赖” ","date":"2020-04-24","objectID":"/posts/DB-6/:2:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"传递函数依赖分析 班主任依赖于班级，与学号无关，与课程号也无关 又因班级依赖于学号所以班主任间接依赖于学号 因此，（学号，课程号）-\u003e 班主任是“传递函数依赖” 范式定义 目前关系数据库有六种范式： 第一范式（1NF） 第二范式（2NF） 第三范式（3NF） 巴斯-科德范式（BCNF） 第四范式(4NF） 第五范式（5NF，又称完美范式） 规范化： 一个低一级的关系模式通过模式分解可以转化为若干个高一级范式的关系模式的集合，这个过程叫做规范化。 ","date":"2020-04-24","objectID":"/posts/DB-6/:3:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"第一范式 如果某个域中元素被认为是不可分的,则这个域称为是原子的 如果关系模式R的所有属性的域都是原子的,则R称为属于第一范式(1NF) ","date":"2020-04-24","objectID":"/posts/DB-6/:4:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"第二范式 定义: 若某关系R属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则关系R属于第二范式。 主属性: 所有候选码的属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。 理解： 第二范式是指每个表必须有一个（有且仅有一个）数据项作为关键字或主键（primary key），其他数据项与关键字或者主键一一对应，即其他数据项完全依赖于关键字或主键。由此可知单主属性的关系均属于第二范式。 判断一个关系是否属于第二范式： 找出数据表中的所有码； 找出所有主属性和非主属性； 判断所有的非主属性对码的部分函数依赖。 ","date":"2020-04-24","objectID":"/posts/DB-6/:5:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"BC范式 BCNF ","date":"2020-04-24","objectID":"/posts/DB-6/:6:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"定义 定义： 关系模式R\u003cU,F\u003e中，若每一个决定因素都包含码，则R\u003cU,F\u003e属于BCFN。 理解： 根据定义我们可以得到结论，一个满足BC范式的关系模式有： 所有非主属性对每一个码都是完全函数依赖； 所有主属性对每一个不包含它的码也是完全函数依赖； 没有任何属性完全函数依赖于非码的任何一组属性。 ","date":"2020-04-24","objectID":"/posts/DB-6/:6:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"检查是否为BC范式 ","date":"2020-04-24","objectID":"/posts/DB-6/:6:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"BCNF分解算法 ","date":"2020-04-24","objectID":"/posts/DB-6/:6:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"BDNF与保持依赖 ","date":"2020-04-24","objectID":"/posts/DB-6/:6:4","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"第三范式 3NF ","date":"2020-04-24","objectID":"/posts/DB-6/:7:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"3NF来源 ","date":"2020-04-24","objectID":"/posts/DB-6/:7:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"3NF定义 定义： 非主属性既不传递依赖于码，也不部分依赖于码。 理解： 第三范式要求在满足第二范式的基础上，任何非主属性不依赖于其他非主属性，即在第二范式的基础上，消除了传递依赖. ","date":"2020-04-24","objectID":"/posts/DB-6/:7:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"3NF分解算法 ","date":"2020-04-24","objectID":"/posts/DB-6/:7:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"例题 ","date":"2020-04-24","objectID":"/posts/DB-6/:8:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"例题1 ","date":"2020-04-24","objectID":"/posts/DB-6/:8:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"例题2 ","date":"2020-04-24","objectID":"/posts/DB-6/:8:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"例题3 ","date":"2020-04-24","objectID":"/posts/DB-6/:8:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"关系数据库的设计目标 ","date":"2020-04-24","objectID":"/posts/DB-6/:9:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"多值依赖 ","date":"2020-04-24","objectID":"/posts/DB-6/:10:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"第四范式 4NF 定义： 限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。 理解： 显然一个关系模式是4NF，则必为BCNF。也就是说，当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值，若有多值就违反了4NF。 ","date":"2020-04-24","objectID":"/posts/DB-6/:11:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["数据库"],"content":"第五范式 5NF 第五范式有以下要求： 必须满足第四范式； 表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。 第五范式是在第四范式的基础上做的进一步规范化。第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。 这章过于理论,需要反复揣摩其中的函数关系 数据库撒花啦! ","date":"2020-04-24","objectID":"/posts/DB-6/:12:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-6","uri":"/posts/DB-6/"},{"categories":["Ubuntu"],"content":"一个月前我被N卡折磨的重装系统,一个月后的今天,本小辣鸡又来了! 跟上次雪崩不同的是,这次是成功的!记录一下过程 早上看到知乎热搜,竟然有我之前玩的那个沙盒游戏 因为之前之前那个游戏实在win环境下玩的,不由得想起来,似乎现在steam上支持Linux的游戏越来越多了,好奇心让我去steam官网看了一下,没想到竟然真的支持Linux!!! 随后一波操作下载steam,安装,启动 可是!为什么游戏只有…30fps…虽然画面流畅度还算凑活,但是…这也太难受了吧,想到之前win环境下运行很流畅,心中不禁有很多问号,难道是游戏优化问题?不能啊,是不是显卡用的核显? emmmmm….好像是 到网上查了一下,发现确实,在系统详情里会显示当前使用的显卡,我点开一看,果然是intel核显…吼! 看了很多教程,和blog,小心翼翼的一步步操作(真的害怕系统雪崩) 最后在这里记录一下过程,想必以后也会再装的,给未来的自己填个坑(我也太好了) ","date":"2020-04-24","objectID":"/posts/ubuntu-14/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu安装NVIDIA驱动","uri":"/posts/ubuntu-14/"},{"categories":["Ubuntu"],"content":"1. 检查电脑有哪些显卡 执行Terminal命令 lshw -c video ","date":"2020-04-24","objectID":"/posts/ubuntu-14/:1:0","tags":["Linux-Ubuntu"],"title":"Ubuntu安装NVIDIA驱动","uri":"/posts/ubuntu-14/"},{"categories":["Ubuntu"],"content":"2. 查看可安装驱动 Ubuntu自带了为Nvidia显卡开发的开源Nouveau驱动,这个Nouveau驱动是包含在Linux内核中的。但是它不支持3D加速。为了获得最佳图形性能，这里用 software-properties-gtk 这个程序来安装专有的Nvidia显卡驱动。在 terminal 里输入下面的命令 software-properties-gtk 该命令将打开软件与更新窗口。点击\"额外驱动\"标签。可以看见Ubuntu默认为Nvidia显卡启用了Nouveau开源驱动，并且列出了可以安装的专有显卡驱动。 ","date":"2020-04-24","objectID":"/posts/ubuntu-14/:2:0","tags":["Linux-Ubuntu"],"title":"Ubuntu安装NVIDIA驱动","uri":"/posts/ubuntu-14/"},{"categories":["Ubuntu"],"content":"3. 查看推荐驱动并安装 在终端里输入下面的命令来查看哪一个专有驱动是推荐安装的。 sudo ubuntu-drivers devices 可以看到nvidia-driver-435是推荐安装的驱动.在终端里输入下面的命令安装这个驱动。 sudo apt-get install nvidia-driver-435 ","date":"2020-04-24","objectID":"/posts/ubuntu-14/:3:0","tags":["Linux-Ubuntu"],"title":"Ubuntu安装NVIDIA驱动","uri":"/posts/ubuntu-14/"},{"categories":["Ubuntu"],"content":"4. 安装过程中的设置密码 下载完成后,会显示需要输入一个密码,以确认驱动安装,并且重启开机时会让重新输入一次,值得注意的是,开机时会有四个选项,选择第二个enroll MOK 然后输入密码进入系统,这时打开设置,就会看到!安装完成啦 ","date":"2020-04-24","objectID":"/posts/ubuntu-14/:4:0","tags":["Linux-Ubuntu"],"title":"Ubuntu安装NVIDIA驱动","uri":"/posts/ubuntu-14/"},{"categories":["Ubuntu"],"content":"5. 快乐切换显卡 打开程序列表,会发现N卡的软件,在软件中,可以切换当前显卡 然后打开游戏,就会有发现…真的有这么丝滑吗 最高140fps的体验,这就是Linux下的游戏吗 i 了 ","date":"2020-04-24","objectID":"/posts/ubuntu-14/:5:0","tags":["Linux-Ubuntu"],"title":"Ubuntu安装NVIDIA驱动","uri":"/posts/ubuntu-14/"},{"categories":["数据库"],"content":"数据库范式定义,模式分解,函数依赖,正则覆盖,模式分解 昨天数据库还剩10节课,以为能看完,再来写总结,可没想到…最后两章这么难 到现在还是有些迷糊,这两章可以说全是理论,集合之间的操作 今天可算学完了,数据库原理撒花 数据库范式定义  设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范 越高的范式数据库冗余越小。 模式分解 ","date":"2020-04-23","objectID":"/posts/DB-5/:0:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"定义 例如可以将关系模式( A,B,C,D) 分解为:( A,B )和( B,C,D ),或( A,C,D )和 ( A,B,D ),或( A,B,C )和( C,D ),或( A,B )、( B,C )和( C,D ),或 ( A,D )和( B,C,D ) 原模式( R )的所有属性都必须出现在分解后的( R1 , R2 )中: R = R1 并R 2 无损连接分解 对关系模式 R 上的所有可能的关系 r ","date":"2020-04-23","objectID":"/posts/DB-5/:1:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"目标 目标:设计一个理论 以判断关系模式 R 是否为“好的”形式(不冗余) 当 R 不是“好的”形式时,将它分解成模式集合{ R 1 , R 2 , …, R n }使得 每个关系模式都是“好的”形式 分解是无损连接分解 理论基于: 函数依赖( functional dependencies ) 多值依赖( multivalued dependencies ) 函数依赖 ","date":"2020-04-23","objectID":"/posts/DB-5/:2:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"定义 设 R 是一个关系模式,且有属性集 α ⊆ R, β⊆ R β函数依赖于α, α函数决定β (α -\u003e β) 函数依赖是码概念的推广 被所有关系实例都满足的函数依赖称为平凡的 ","date":"2020-04-23","objectID":"/posts/DB-5/:3:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"函数依赖集的闭包 给定函数依赖集 F, 存在其他函数依赖被 F 逻辑蕴含 例如如果 A -\u003e B 且 B -\u003e C ,则可推出 A -\u003e C 被 F 逻辑蕴含的全体函数依赖的集合称为 F 的闭包,用 F+表示 F 的闭包 例: F = { A -\u003e B, B -\u003e C } ,F + = { A -\u003e B, B -\u003e C, A -\u003e C,A -\u003e A, AB -\u003e B, AC -\u003e C, A -\u003e BC, … } ","date":"2020-04-23","objectID":"/posts/DB-5/:4:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"计算闭包 例: R = ( A, B, C, G, H, I ) F = { A -\u003e B, A-\u003e C, CG -\u003e H, CG -\u003e I, B -\u003e H } 计算F+ : 可用Armstrong公理计算 ","date":"2020-04-23","objectID":"/posts/DB-5/:4:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"Armstrong公理 自反律 若 β ⊆ α ,则 α -\u003e β 增补律 若 α -\u003e β ,则 γα -\u003e γβ 传递律 若 α -\u003e β 且 β -\u003e γ ,则 α -\u003e γ 合并律 若 α -\u003e β 与 α -\u003e γ 成立,则 α -\u003e βγ 分解律 若 α -\u003e βγ 成立,则 α -\u003e β 与 α -\u003e γ 伪传递律 若 α -\u003e β 与 βγ -\u003e g 成立,则 αγ -\u003e g Armstrong公理 正确有效的(不会产生错误的函数依赖) 完备的(产生所有成立的函数依赖即 F + ) ","date":"2020-04-23","objectID":"/posts/DB-5/:4:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"公式计算过程 ","date":"2020-04-23","objectID":"/posts/DB-5/:4:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"属性集的闭包 ","date":"2020-04-23","objectID":"/posts/DB-5/:5:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"定义 给定一个属性集 α, 在函数依赖集 F 下由 α 函数确定的所有属性的集合为 F 下 α 的闭包(记做 α + ) - 检查函数依赖 α -\u003e β 是否属于 F + \u003c-\u003e β ⊆ α+ - 判断 α 是否为超码: α -\u003e R 属于 F + -\u003e R ⊆ α ","date":"2020-04-23","objectID":"/posts/DB-5/:5:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"公式计算过程 ","date":"2020-04-23","objectID":"/posts/DB-5/:5:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"例题 ","date":"2020-04-23","objectID":"/posts/DB-5/:5:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"属性闭包算法的用途: 测试超码( α -\u003e R ) 为检测 α 是否超码,可计算 α+ 并检查 α+ 是否包含 R 的所有属性 测试函数依赖( α -\u003e β ) 为检测函数依赖 α -\u003e β 是否成立(即是否属于 F+ ),只需检查是否β⊆ α 即,可计算 α+,并检查它是否包含β 计算 F 的闭包( F+ = ? ) 对每个 γ ⊆ R ,计算 γ+,再对每个 S ⊆ γ+,输出函数依赖 γ -\u003e S 正则覆盖 ","date":"2020-04-23","objectID":"/posts/DB-5/:5:4","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"定义 F 的正则覆盖(记做 Fc )是指与 F 等价的\"极小的\"函数依赖集合 Fc 中任何函数依赖都不包含无关属性 Fc 中函数依赖的左半部都是唯一的 ","date":"2020-04-23","objectID":"/posts/DB-5/:6:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"计算过程 ","date":"2020-04-23","objectID":"/posts/DB-5/:7:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"无关属性 ","date":"2020-04-23","objectID":"/posts/DB-5/:8:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"公式计算过程 ","date":"2020-04-23","objectID":"/posts/DB-5/:9:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"例题 模式分解 ","date":"2020-04-23","objectID":"/posts/DB-5/:10:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"定义 规范化的目标 以判断关系模式 R 是否为“好的”形式(不冗余,无插入、删除、更新异常) 当 R 不是“好的”形式时,将它分解成模式集合{ R 1 , R 2 , …, R n }使得 每个关系模式都是“好的”形式 分解是无损连接分解 分解是保持依赖 ","date":"2020-04-23","objectID":"/posts/DB-5/:11:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"分解要求 ","date":"2020-04-23","objectID":"/posts/DB-5/:12:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"例题 ","date":"2020-04-23","objectID":"/posts/DB-5/:13:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["数据库"],"content":"公式判定是否保持依赖 由于最后两章东西太多了,所以第十章再开一个blog写,不得不说,数据库最后这两章真的让我有些头疼,感觉今天学了一天才差不多明白个大概 ","date":"2020-04-23","objectID":"/posts/DB-5/:14:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-5","uri":"/posts/DB-5/"},{"categories":["Ubuntu"],"content":"昨天在微博上碰巧看到一个分享，讲的是一个电脑与移动设备的文件互传的工具 因为Linux上的im软件一直是wine套娃，所以体验不是很好，这也是我在使用过程中心中一直不舒服的一个点，现在生产环境都已经迁移到了ubuntu，不得不说ubuntu一直让我很是满意，没有win10臃肿的系统，高度的可定制化，便捷的库安装过程，庞大的开放社区，今天上午想着试一下这个工具，安装之后使用起来真的让我感到很惊艳，在这里记录一下安装过程 ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:0:0","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"项目地址 github ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:1:0","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"安装GO环境 这个工具是go语言编写的,所以要安装一下go的环境 ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:2:0","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"1.官网下载go语言安装包 地址：https://studygolang.com/dl ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:2:1","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"2.解压安装包 将下载下来的安装包解压到/usr/local下 tar xf go1.12.1.linux-amd64.tar.gz -C /usr/local ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:2:2","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"3.配置全局变量 vim ~/.bashrc 最后一行加上下面配置 export GOPATH=/usr/local/go export PATH=$GOPATH/bin:$PATH ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:2:3","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"4.验证配置是否成功 go version #warning: GOPATH set to GOROOT (/usr/local/go) has no effect #go version go1.12.1 linux/amd64 ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:2:4","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"5.出现warning，配置PATH export GOROOT=/usr/local/go export GOPATH=$PATH:$GOROOT/bin ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:2:5","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"6.测试安装 go version #go version go1.12.1 linux/amd64 ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:2:6","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"安装工具 ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:3:0","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"Install it with Go go get github.com/claudiodangelis/qrcp ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:3:1","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"手动下载Go包的通用方法 如果出现 https fetch: Get xxxxxxx: dial tcp: i/o timeout 那么就说明当前网络状态下载不了(被墙的太严重了) 使用手动下载就好,首先看当前下载的包的地址 github.com/${PATH1} golang.org/x/${PATH2} 若是github,则在你 src/ 目录里terminal git clone https://github.com/${PATH1} ${GOPATH}/src/github.com/${PATH1} 若是golang,则在你 src/golang.org/x/ 目录里使用 (在不在没关系 ) git clone https://github.com/golang/${PATH2} ${GOPATH}/src/golang.org/x/${PATH2} ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:3:2","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"Install the binary 下载Release,将其移动到路径 /usr/local/bin 随后terminal 将其改为可执行程序 chmod +x /usr/local/bin/qrcp ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:3:3","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"工具使用 这里只举最简单的两个例子,更多用法请参照官方说明 ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:4:0","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"Send a file qrcp MyDocument.pdf ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:4:1","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"Receive files qrcp receive ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:4:2","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["Ubuntu"],"content":"特别提示 特别提示:我在使用过程中,发现iPhone自带的扫描二维码功能,在扫描生成的二维码后,并不会跳转,似乎是iPhone的bug,这里推荐使用其他浏览器或微信进行扫描 ","date":"2020-04-23","objectID":"/posts/ubuntu-13/:4:3","tags":["Linux-Ubuntu"],"title":"Linux与移动设备的文件互传","uri":"/posts/ubuntu-13/"},{"categories":["数据库"],"content":"ER图 ER图 ","date":"2020-04-21","objectID":"/posts/DB-4/:0:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"定义 E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 ","date":"2020-04-21","objectID":"/posts/DB-4/:1:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"常用表示符号 矩形代表实体集 菱形代表联系集 线段将实体集连接到联系集 构成主码的属性用下划线标明 虚线将联系集属性连接到联系集 双线显示实体在联系集中的参与度 双菱形代表连接到弱实体集的标志性联系集 ER图中的关系表示 ","date":"2020-04-21","objectID":"/posts/DB-4/:2:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"角色 实体在联系集中的作用 下图给出了 course 实体集和 preq 联系集之间的角色标识 course_id 和prereq_id (角色标记是可选的,用于明确联系的语义) ","date":"2020-04-21","objectID":"/posts/DB-4/:3:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"基数约束 在联系集与实体集之间用有向直线(-\u003e)表示’一’,无向直线(—)表示’多' ","date":"2020-04-21","objectID":"/posts/DB-4/:4:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"一对一联系 实体集instructor和student之间的联系集可以是一对一,表示一名教师可以指导至多一名学生,并且一名学生可以有至多一位导师 ","date":"2020-04-21","objectID":"/posts/DB-4/:4:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"一对多联系 实体集instructor和student之间的联系集可以是一对多,表示一名教师可以指导多名学生,但一名学生可以有至多一位导师 ","date":"2020-04-21","objectID":"/posts/DB-4/:4:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"多对多联系 实体集instructor和student之间的联系集可以是多对多,表示一名教师可以指导多名学生,并且一名学生可以有多位导师 ","date":"2020-04-21","objectID":"/posts/DB-4/:4:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"参与约束 ","date":"2020-04-21","objectID":"/posts/DB-4/:5:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"全参与和部分参与约束 反映了一个实体参与关联的数目下限:0次,还是至少1次 全参与(用双线表示):实体集中的每个实体都至少参加联系集中的一个联系 部分参与:某些实体可能未参加联系集中的任何联系 ","date":"2020-04-21","objectID":"/posts/DB-4/:5:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"映射基数约束 限定了一个实体与发生关联的另一端实体可能关联的数目上限 例每个学生有且仅有一个导师,教师可以有零个或多个学生 ","date":"2020-04-21","objectID":"/posts/DB-4/:5:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"具有三元联系的E-R图 例如一个教师可以指导多个学生,并可以参与到多个项目 但是三元关系显得很复杂,这就需要转为二元关系 ","date":"2020-04-21","objectID":"/posts/DB-4/:6:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"弱实体集 不具有主键的实体集称为弱实体集 例如考虑一个 section 实体,它由课程编号、学期、学年以及开课编号唯 一标识。显然,开课实体和课程实体相关联。假定我们在实体集 section 和 course 之间创建了一个联系集 sec_course。 若,实体集section为: section ( sec_id,semester,year ),则其为弱实体集(父子关系) 弱实体集的存在依赖于它的标识实体集(或属主实体集)的存在 标识性联系:将弱实体集与其标识实体集相联的联系 标识性联系是从弱实体集到标识实体集多对一的,并且弱实体集在联系中的 参与是全部的 弱实体集的分辨符(或称部分码)是指在一个弱实体集内区分所有实体 的属性集合 例,弱实体集 section 的分辨符由属性 sec_id,year 以及 semester 组成 弱实体集的主码由它所依赖的强实体集的主码加上它的分辨符组成 section的主码: 注意:强实体集的主码并不显式地存于弱实体集中,而是隐含地通过标识性联系起作用 如果 course_id 显式存在, section 就成了强实体,则 section与course 之间的联系变得冗余。因为 section 与 course 共有的属性course_id 已定义了一个隐含的联系 ","date":"2020-04-21","objectID":"/posts/DB-4/:7:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"特化 自顶向下设计过程中,确定实体集中的一个具有特殊性质的子集 这些子集称为低层实体集,它们具有特殊的属性或者参加特殊的联系 属性继承 :低层实体集继承它连接的高层实体集的所有属性及参加的联系 ","date":"2020-04-21","objectID":"/posts/DB-4/:8:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"概化 自底向上设计过程中,将若干共享相同特性的实体集组合成一个高层实体集 特化与泛化简单互逆:它们在E-R图中以相同方式表示 关于实体在单个概化中是否可以属于多于一个低层实体集的约束 不相交 一个实体只能属于一个低层实体集 在E-R图中ISA三角形旁边加注disjoint 重叠 一个实体可以属于多个低层实体集 完备性约束 说明高层实体集中的实体是否必须至少属于一个低层实体集 全部概化或特化:每个高层实体必须属于一个低层实体集(双线) 部分概化或特化:允许一些高层实体不属于任何低层实体集(默认的) ","date":"2020-04-21","objectID":"/posts/DB-4/:9:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"聚集 通过聚集消除冗余 将联系视为一个抽象实体 从而允许联系之间的联系 联系抽象为新实体 构建ER图 ","date":"2020-04-21","objectID":"/posts/DB-4/:10:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"例题1  学生学习某门课程。每个学生都有学号,姓名,年龄和性别属性。每门课程都有课程编号,课程名,学分和上课教室编号属性。每个学生可以是本科生或研究生。对于每一个本科生,我们想记录他/她的学习年份,平均绩点,以及(可能是多个)电子邮箱。对于每一个研究生,我们要记录他/她的导师的名字,以及(可能是多个)电子邮箱。此外,每门课程有一名研究生作为课程助教,我们要记录助教的开始和结束时间(例如,开始于2015年3月10日,结束于2015年6月30日)。绘制E-R图。 ","date":"2020-04-21","objectID":"/posts/DB-4/:11:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"例题2  一个公司的数据库需要存储有关雇员(由empid唯一标识,有姓名、工资和手机号码作为属性),部门(由dno唯一标识,有部门名称与预算作为属性)和雇员的孩子信息(有姓名和年龄属性)。员工在部门工作,每个部门由一个管理员管理,孩子必须被唯一名称标识,其父母(假定只有父母中的一位在公司工作)是已知的。一旦父母离开公司,我们将不再关注孩子的信息。绘制ER图,然后将其转换为关系模式。 数据库就剩最后一章了! ","date":"2020-04-21","objectID":"/posts/DB-4/:12:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-4","uri":"/posts/DB-4/"},{"categories":["数据库"],"content":"Trigger,数据库安全性 ","date":"2020-04-20","objectID":"/posts/DB-3/:0:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"Trigger ","date":"2020-04-20","objectID":"/posts/DB-3/:1:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"定义 触发器(trigger)是由数据库更新操作引起的被系统自动执行的语句 设计触发器必须: 指明触发器被执行的条件 指明触发器执行时所做的具体操作 即可以将触发器看作是函数,在触发条件下被调用 createtriggertimeslot_check1afterinsertonsectionreferencingnewrowasnrowforeachrowwhen(nrow.time_slot_idnotin(selecttime_slot_idfromtime_slot))/* time_slot 中不存在该time_slot_id */beginrollbackend; ","date":"2020-04-20","objectID":"/posts/DB-3/:1:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"触发事件 包括insert, delete和update 针对update的触发器可以指定具体修改的属性 create trigger takes_trigger after update of takes on grade 更新前后的属性值可通过下列方法被引用 referencing old row as orow:对删除和修改有效 referencing new row as nrow:对插入和修改有效 ","date":"2020-04-20","objectID":"/posts/DB-3/:1:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"for each statement 针对受到一个事务影响的所有行只执行一次操作 for each statement || for each row 也可以用referencing old table 或 referencing new table 来引用包含受影响的行的临时表 ","date":"2020-04-20","objectID":"/posts/DB-3/:1:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"外部动作 触发器不能直接实现外部动作, 但是触发器可以在某个表中记录将采取的行动, 而让另一个外部进程不断扫描该表并执行相应的外部动作 createtriggerreorder_triggerafterupdateofleveloninventoryreferencingoldrowasorow,newrowasnrowforeachrowwhennrow.level\u003c=(selectlevelfromminlevelwhereminlevel.item=nrow.item)andorow.level\u003e(selectlevelfromminlevelwhereminlevel.item=orow.item)begininsertintoorders(selectitem,amountfromreorderwherereorder.item=orow.item)end 判断数值条件超过临界值 oldrow小于等于临界值 newrow大于临界值 ","date":"2020-04-20","objectID":"/posts/DB-3/:1:4","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"数据库安全性 ","date":"2020-04-20","objectID":"/posts/DB-3/:2:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"授权 读权限 – 允许读,但不允许更新数据 插入权限 – 允许插入新数据, 但不允许更新现有数据 修改权限 – 允许修改, 但不允许删除数据 删除权限 – 允许删除数据 对修改数据库模式的授权包括: 索引权限 – 允许创建和删除索引 资源权限 – 允许创建新关系 修改权限 – 允许增加或删除关系的属性 删除权限 – 允许删除关系 ","date":"2020-04-20","objectID":"/posts/DB-3/:2:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"视图的巧妙使用-权限管理 用户可被授予关于视图的权限, 而不被授予关于该视图定义中涉及的关系的权限 视图隐藏数据的能力既能简化系统的使用又能增强安全性(只允许用户存取他们工作中需要的数据) 关系级安全性与视图级安全性的结合使用可精确地将用户存取限制在他所需要的数据上 例如一个工作人员只需要知道一个给定系(比如Geology系)里所有员工的工资,但无权看到其他系中员工的相关信息 方法:不允许对 instructor 关系的直接访问,但授予对视图 geo_instructor 的访问权限,该视图仅由属于Geology系的那些instructor元组构成 视图 geo_instructor 用SQL定义如下: createviewgeo_instructoras(select*frominstructorwheredept_name='Geology'); ","date":"2020-04-20","objectID":"/posts/DB-3/:2:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"角色 通过创建角色可以一次性对一类用户指定其共同的权限 像对用户一样, 可以对角色授予或收回权限 角色可被赋予给用户, 甚至给其他角色 授权 grant createroleinstructor;grantselectontakestoinstructor; 收回权限 revoke REVOKE\u003cprivilegelist\u003eON\u003crelationnameorviewname\u003eFROM\u003cuserlist\u003e[restrict|cascade]/*例如*/revokeselectoninstructorfromU1,U2,U3cascade 级联回收: cascade 阻止级联收回: restrict ","date":"2020-04-20","objectID":"/posts/DB-3/:2:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"ODBC ","date":"2020-04-20","objectID":"/posts/DB-3/:3:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"定义 简单来说ODBC就是高级语言用户连接数据库的一个中间件,快捷方便调用数据的程序 ODBC程序会先分配一个SQL的环境变量,然后是一个数据库连接句柄 ODBC程序随后会利用SQLConnect打开和数据库的连接,这个调用有几个参数包括: 数据库的连接句柄 要连接的服务器 用户的身份 密码 因为之前一直搞web开发,接触了很多次ODBC,这里就不过多记录了 ","date":"2020-04-20","objectID":"/posts/DB-3/:3:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"数据库设计 ","date":"2020-04-20","objectID":"/posts/DB-3/:4:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"定义 数据库可被建模为: 实体集合(实体集) 实体间联系(联系集) 这部分也很常识…只写干货啦 ","date":"2020-04-20","objectID":"/posts/DB-3/:4:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"联系集的度 参加联系的实体集的个数 涉及两个实体集的联系集称为二元的(二元联系) 联系集可以涉及多于两个的实体集 例如假设一个student在每个项目上最多只能有一位导师,包含三个实体集 instructor 、 student 和 project (三元联系:项目导师学生,丁字形关系) 多于两个实体集之间的联系较少见,数据库系统中的联系集一般多为二元的 ","date":"2020-04-20","objectID":"/posts/DB-3/:4:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"映射基数 表达可与一个实体通过联系集进行关联的其他实体的个数 二元联系集的映射基数有以下几种情况: 一对一,如:就任总统(总统,国家) 一对多,如:分班情况(班级,学生) 多对一,如:就医(病人,医生) 多对多,如:选课(学生,课程) ","date":"2020-04-20","objectID":"/posts/DB-3/:4:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["数据库"],"content":"实体集中的键和码 实体集的超码是能够唯一标识每个实体的一个或多个属性 候选码是实体集的最小超码 候选码可能存在多个,我们只会选择一个候选码作为主码或主键 例, instructor ( ID , name , dept_name , salary ) 候选码: ID 超码:{ ID },{ ID , name },{ ID ,…} 明天更ER图,数据库马上就学完啦! ","date":"2020-04-20","objectID":"/posts/DB-3/:4:4","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-3","uri":"/posts/DB-3/"},{"categories":["操作系统"],"content":"今天听操作系统课的时候听到老师简单讲了几句计算机开机的过程,提到了GRUB,我一听,这不是我当初装双系统折腾过的嘛,就好奇去搜了一下开机过程OS的过程,在这里记录一下 总体过程 进入POST -\u003e CMOS设置 -\u003e 读取MBR -\u003e 控制权交给MBR -\u003e MBR读取分区表找到其中的活动分区(Active Partition) -\u003e MBR读取分区中的首扇区(分区引导记录PBR) -\u003e 加载到内存中 -\u003e PBR继续控制后续的引导过程 常见的引导程序: GRUB, BOOTMGR (GRUB!!! 我的linux开机就是这个!) 核心初始化: 初始化os内核, 初始化系统核心数据, 各种寄存器, 存储系统的页表, 核心进程的构建 系统初始化: 初始化文件系统, 网络系统, 控制台, 图形界面 OS的四个过程 ","date":"2020-04-19","objectID":"/posts/OS-1/:0:0","tags":["操作系统-课程"],"title":"开机过程中的操作系统","uri":"/posts/OS-1/"},{"categories":["操作系统"],"content":"第一阶段：BIOS 上个世纪70年代初，“只读内存”（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。 这块芯片里的程序叫做\"基本输入输出系统\"（Basic Input/Output System），简称为BIOS。BIOS是(Fireware 固件) 固件: 以硬件方式存在,其中储存软件 ","date":"2020-04-19","objectID":"/posts/OS-1/:1:0","tags":["操作系统-课程"],"title":"开机过程中的操作系统","uri":"/posts/OS-1/"},{"categories":["操作系统"],"content":"硬件自检 BIOS程序首先检查，计算机硬件能否满足运行的基本条件，“加电自检”(Power-On Self-Test),缩写为POST。 初始化基本硬件:CPU, 内存, 显卡 如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。 当按下Power on或Reset键后执行的第一条指令 FFFF0指令即JUMP POST跳转到POST,随后POST查找显卡BIOS,调用显卡BIOS,依次查找其他设备BIOS ","date":"2020-04-19","objectID":"/posts/OS-1/:1:1","tags":["操作系统-课程"],"title":"开机过程中的操作系统","uri":"/posts/OS-1/"},{"categories":["操作系统"],"content":"启动顺序 硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。 BIOS需要知道，“下一阶段的启动程序\"具体存放在哪一个设备(硬盘/软盘/光驱)。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做\"启动顺序”（Boot Sequence）。 BIOS的操作界面，其中有一项设置就是\"设定启动顺序\"。 ","date":"2020-04-19","objectID":"/posts/OS-1/:1:2","tags":["操作系统-课程"],"title":"开机过程中的操作系统","uri":"/posts/OS-1/"},{"categories":["操作系统"],"content":"第二阶段：主引导记录MBR BIOS按照\"启动顺序\"，将控制权转交给排在首位的储存设备。 这时，计算机读取该设备的第一个扇区(首扇区)，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给\"启动顺序\"中的下一个设备。 最前面的512个字节，叫做\"主引导记录\"（Master boot record，缩写为MBR。其作用为: 让用户选择不同的启动项,实现多种启动 加载核心文件直接指向启动区加载操作系统 跳转:将启动管理功能转交给其他loader ","date":"2020-04-19","objectID":"/posts/OS-1/:2:0","tags":["操作系统-课程"],"title":"开机过程中的操作系统","uri":"/posts/OS-1/"},{"categories":["操作系统"],"content":"主引导记录的结构 “主引导记录\"只有512个字节,它的主要作用是，指定计算机到硬盘的哪一个位置去找操作系统。即完成OS加载或启动管理 主引导记录由三个部分组成： 第1-446字节：调用操作系统的机器码。 第447-510字节：分区表（Partition table）。 第511-512字节：主引导记录签名（0x55和0xAA）。 其中第二部分\"分区表\"的作用，是将硬盘分成若干个区。 ","date":"2020-04-19","objectID":"/posts/OS-1/:2:1","tags":["操作系统-课程"],"title":"开机过程中的操作系统","uri":"/posts/OS-1/"},{"categories":["操作系统"],"content":"分区表 硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，“主引导记录\"因此必须知道将控制权转交给哪个区。 分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做\"主分区”。 每个主分区的16个字节，由6个部分组成： 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的 第2-4个字节：主分区第一个扇区的物理位置(柱面、磁头、扇区号等等) 第5个字节：主分区类型 第6-8个字节：主分区最后一个扇区的物理位置 第9-12字节：该主分区第一个扇区的逻辑地址 第13-16字节：主分区的扇区总数。 ","date":"2020-04-19","objectID":"/posts/OS-1/:2:2","tags":["操作系统-课程"],"title":"开机过程中的操作系统","uri":"/posts/OS-1/"},{"categories":["操作系统"],"content":"第三阶段：硬盘启动 这个时期，计算机的控制权就要转交给硬盘的某个分区了 ","date":"2020-04-19","objectID":"/posts/OS-1/:3:0","tags":["操作系统-课程"],"title":"开机过程中的操作系统","uri":"/posts/OS-1/"},{"categories":["操作系统"],"content":"卷引导记录 在分区中，只有一个是激活的(Active Partition)。计算机会读取激活分区的第一个扇区(首扇区)即\"卷引导记录”（Volume boot record，缩写为VBR）。 “卷引导记录\"的主要作用: 指明操作系统在这个分区里的位置。然后计算机就可加载操作系统。 ","date":"2020-04-19","objectID":"/posts/OS-1/:3:1","tags":["操作系统-课程"],"title":"开机过程中的操作系统","uri":"/posts/OS-1/"},{"categories":["操作系统"],"content":"第四阶段：操作系统 控制权转交给操作系统后，操作系统的内核首先被载入内存。 Linux启动过程 这里举例Linux的启动过程: POST -\u003e MBR -\u003e KERNEL映像 -\u003e KERNEL自解压并执行 -\u003e 内核初始化 -\u003e 内核启动 KERNEL映像是zlib压缩过的内核映像 KERNEL映像前端是可执行例程(实现核心硬件初始化,并解压)然后调用内核并开始启动内核引导 载入程序 /sbin/init （Debian系统是/etc/initab） 根据配置文件产生init进程,这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。 ","date":"2020-04-19","objectID":"/posts/OS-1/:4:0","tags":["操作系统-课程"],"title":"开机过程中的操作系统","uri":"/posts/OS-1/"},{"categories":["数据库"],"content":"事务,完整性约束 ","date":"2020-04-19","objectID":"/posts/DB-2/:0:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-2","uri":"/posts/DB-2/"},{"categories":["数据库"],"content":"事务 ","date":"2020-04-19","objectID":"/posts/DB-2/:1:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-2","uri":"/posts/DB-2/"},{"categories":["数据库"],"content":"定义 一条SQL语句被执行,就隐式地开始了一个事务 Commit work:提交当前事务,也就是将该事务所做的更新在数据库中持 久保存。在事务被提交后,一个新的事务自动开始 Rollback work:回滚当前事务,即撤销该事务中所有SQL语句对数据库 的更新。这样,数据库就恢复到执行该事务第一条语句之前的状态 updateaccountsetbalance=balance–100whereaccount_number='A-101';updateaccountsetbalance=balance+100whereaccount_number='A-201';COMMITWORK; 这两个更新要么全部成功,要么全部失败 ","date":"2020-04-19","objectID":"/posts/DB-2/:1:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-2","uri":"/posts/DB-2/"},{"categories":["数据库"],"content":"事务的四个性质: 原子性(atomic) 一致性(consistency) 隔离性(isolation) 持久性(durability ) ","date":"2020-04-19","objectID":"/posts/DB-2/:1:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-2","uri":"/posts/DB-2/"},{"categories":["数据库"],"content":"完整性约束 ","date":"2020-04-19","objectID":"/posts/DB-2/:2:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-2","uri":"/posts/DB-2/"},{"categories":["数据库"],"content":"定义 完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性 域完整性、实体完整性(主键的约束)、参照完整性(外键的约束) 和用户定义的完整性约束 ","date":"2020-04-19","objectID":"/posts/DB-2/:2:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-2","uri":"/posts/DB-2/"},{"categories":["数据库"],"content":"单个关系上的约束 not null unique check(\u003c谓词\u003e) ","date":"2020-04-19","objectID":"/posts/DB-2/:2:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-2","uri":"/posts/DB-2/"},{"categories":["数据库"],"content":"域约束 域约束是完整性约束的最基本形式,可用于检测插入到数据库中的数 据的合法性 从现有数据类型可以创建新的域 createdomainDollarsasnumeric(12,2)notnullcreatedomainPoundsasnumeric(12,2);createtableinstructor(IDchar(5)primarykey,namevarchar(20),dept_namevarchar(20),salaryDollars,commPounds);/*其中numeric(12,2)代表精确度小数点12位整数,小数点后两位整数*/ check子句可以应用到域上 /*check子句保证教师工资域中只允许出现大于给定值的值*/createdomainYearlySalarynumeric(8,2)constraintsalary_value_testcheck(value\u003e=29000.00);/*YearlySalary 域有一个约束来保证年薪大于或等于29 000.00美元 constraint salary_value_test 子句是可选的,它用来将该约束命名为 salary_value_test 。系统用这个名字来指出一个更新违反了哪个约束*/ 使用in子句可以限定一个域只包含指定的一组值 createdomaindegree_levelvarchar(10)constraintdegree_level_testcheck(valuein('Bachelors','Masters','Doctorate')); ","date":"2020-04-19","objectID":"/posts/DB-2/:2:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-2","uri":"/posts/DB-2/"},{"categories":["数据库"],"content":"数据库的修改 数据库的修改会导致参照完整性的破坏,这是要考虑使用级联修改或级联删除选项 SQL中的级联动作 级联删除: 由于有了与外码声明相关联的on delete cascade子句,如果删除department 中的元组导致了此参照完整性约束被违反,则删除并不被系统拒绝,而是对course关系作“级联”删除,即删除了被删除系的元组 createtablecourse(...foreignkey(dept_name)referencesdepartment[ondeletecascade][onupdatecascade]...); 级联更新也类似 如果存在涉及多个关系的外码依赖链,则在链一端所做的删除或更 新可能传至整个链 但是,如果一个级联更新或删除导致的对约束的违反不能通过进一 步的级联操作解决,则系统终止该事务,即,该事务所做的所有改变及级联动作将被撤销 ","date":"2020-04-19","objectID":"/posts/DB-2/:2:4","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-2","uri":"/posts/DB-2/"},{"categories":["数据库"],"content":"SQL中的参照完整性 主码、候选码和外码可在SQL的create table语句中指明 primary key子句包含一组构成主码的属性 unique子句包含一组构成候选码的属性 foreign key子句包含一组构成外码的属性以及被修改外码所参照的关系 名 默认地,外码参照被参照关系中的主码 foreign key ( dept_name ) references department 可以使用如下的简写形式定义单个列为外码 dept_name varchar (20) references department 被参照关系中的属性可以被明确指定(即属性名字可以不同),但是必须被声明为主码或候选 码 foreign key ( dept_name ) references department ( dept_name2 ) ","date":"2020-04-19","objectID":"/posts/DB-2/:2:5","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-2","uri":"/posts/DB-2/"},{"categories":["数据库"],"content":"绪论,关系模型,SQL语言 ","date":"2020-04-18","objectID":"/posts/DB-1/:0:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"绪论 ","date":"2020-04-18","objectID":"/posts/DB-1/:1:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"数据库解决的问题 在文件处理系统中存储组织信息的主要弊端: 完整性问题 完整性约束(如账户余额\u003e0)成为程序代码的一部分 增加新的约束或更改现有的约束很困难 原子性问题 在进行部分数据更新时,一旦发生故障,可能导致数据库处于不一致的状态,例如,从一个账户转移资金到另一个账户,此操作要么完成,要么根本不会发生 并发访问异常 为了提高系统的总体性能,许多系统允许并发访问 不受控制的并发访问可能导致数据不一致,例如,两个用户读取同一账号余额,并在同一时间更新它 安全性问题 并非所有用户都可以访问所有数据 ","date":"2020-04-18","objectID":"/posts/DB-1/:1:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"数据库结构 物理层:描述数据实际上是怎样存储的 逻辑层:描述数据库中存储什么数据及这些数据间存在什么关系 如type instructor = record ID : char(5); name : char(20); dept_name : char(20); salary : numeric(8,2); end; 视图层:应用程序能够隐藏数据类型的详细信息。视图也可以出于安全目的隐藏数据信息(例如,员工的薪水) 数据库设计结构 数据库实体结构 ","date":"2020-04-18","objectID":"/posts/DB-1/:1:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"实例和模式 类似编程语言中的类型(types)和变量(variables) 类型\u003c-\u003e模式 变量\u003c-\u003e实例 模式(Schema):数据库的总体设计 类似于程序中变量的类型信息 物理模式:在物理层描述数据库的设计 逻辑模式:在逻辑层描述数据库的设计 实例(Instance):特定时刻存储在数据库中的信息的集合 类似于程序中变量的值 ","date":"2020-04-18","objectID":"/posts/DB-1/:1:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"物理独立性和逻辑独立性 修改一层的结构定义不影响更高层的结构定义 物理数据独立性 :修改物理结构而不需要改变逻辑结构的能力 应用程序依赖于逻辑结构 应用程序独立于数据的结构和存储 这是使用DBMS最重要的好处 逻辑数据独立性:数据逻辑结构的改变不影响应用程序 逻辑数据独立性一般难以实现,因为应用程序严重依赖于数据的逻辑结构 ","date":"2020-04-18","objectID":"/posts/DB-1/:1:4","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"数据库语言 数据库语言: Data Definition Language(DDL,数据定义语言) Data Manipulation Language(DML,数据操纵语言) Data Control Language(DCL,数据控制语言) 数据定义语言(DDL) 指定一个数据库模式作为一组关系模式的定义 指定存储结构,访问方法和一致性约束 DDL语句经过编译,得到一组存储在一个特殊文件中的表,特殊文件即数据字典(data dictionary),其中包含元数据(metadata) 例如该SQL语句创建了表account CREATE TABLE account (account_number char(10),balance integer); 数据字典(data dictionary)包含元数据(metadata),包括: 数据库模式 数据存储结构 访问方法和约束 统计信息 授权 数据操纵语言(DML) 从数据库中检索数据 插入/删除/更新数据 DML也称为查询语言 两类基本的数据操作语言: 过程化DML: 要求用户指定需要什么数据,以及如何获得这些数据(C,Pascal,Java,…) 声明式DML: 也称为非过程化DML,只要求用户指定需要什么数据,而不指明如何获得这些数据(SQL,Prolog) 数据控制语言(DCL) DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。 在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL SQL SQL = DDL + DML + DCL ","date":"2020-04-18","objectID":"/posts/DB-1/:1:5","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"关系模型 ","date":"2020-04-18","objectID":"/posts/DB-1/:2:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"定义 关系数据库基于关系模型,是一个或多个关系组成的集合 关系通俗来讲就是表(由行和列构成) 关系模型的主要优点是其简单的数据表示,易于表示复杂的查询 SQL语言是最广泛使用的语言,用于创建,操纵和查询关系数据库,而关系模型是其基础。 属性类型 关系的每个属性都有一个名称 域:每个属性的取值集合称为属性的域 属性值必须是原子的,即不可分割(1NF,第一范式) 多值属性值不是原子的 复合属性值不是原子的 特殊值null是每一个域的成员 空值给数据库访问和更新带来很多困难,因此应尽量避免使用空值 关系概念 关系涉及两个概念:关系模式和关系实例 关系模式描述关系的结构: Instructor-schema = ( ID : string, name : string, dept_name : string, salary: int) Instructor-schema = ( ID , name, dept_name, salary ) 关系实例表示一个关系的特定实例,也就是所包含的一组特定的行 关系、关系模式、关系实例区别: 变量\u003c-\u003e关系 变量类型\u003c-\u003e关系模式 变量值\u003c-\u003e关系实例 码-键 使K 属于 R 如果K值能够在一个关系中唯一地标志一个元组,则K是R的超码 { instructor-ID, instructor-name } { instructor-ID } 都是instructor 的超键 如果K是最小超码,则K是候选码 { instructor-ID }是 instructor 的候选码 因为它是一个超码,并且它的任意真子集都不能成为一个超码 如果k是一个候选码,并由用户明确定义,则K是一个主键。主键通常用下划线标记 外键 假设存在关系r和s:r(A, B, C), s(B, D),则在关系r上的属性B称作参照s的外码,r也称为外码依赖的参照关系,s叫做外码被参照关系 instructor ( ID , name , dept _ name , salary ) - 参照关系 department ( dept_name , building , budget ) - 被参照关系 ","date":"2020-04-18","objectID":"/posts/DB-1/:2:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"关系代数 在某种程度上是过程化语言 六个基本运算 Select 选择 Project 投影 Union 并 set difference 差(集合差) Cartesian product 笛卡儿积 Rename 更名(重命名) 用户输入一个或两个关系,并得到新的关系 附加运算 Set intersection 交 Natural join 自然连接 Division 除 Assignment 赋值 关系运算的优先级: 投影\u003e选择\u003e笛卡尔积\u003e连接、除\u003e交\u003e并、差 扩展关系代数运算 广义投影 聚集函数 聚集运算的结果是没有名称的 可以使用更名运算为其命名 可以把重命名作为聚集运算的一部分,如: branch-name g sum(balance) as sum-balance ( account ) 聚集函数 **1. avg: 平均值:** 例: g \u003csub\u003eavg(balance) \u003c/sub\u003e(account) **2. min: 最小值** **3. max: 最大值 (求平均存款余额)** **4. sum: 值的总和** **5. count:值的数量** 外连接 - 外连接运算是连接运算的扩展,可以处理缺失信息 - 保留一侧关系中所有与另一侧关系的任意元组都不匹配的元组,再把产生的元组加到自然连接的结构上 - 使用空值:空值表示值不知道或不存在 ","date":"2020-04-18","objectID":"/posts/DB-1/:2:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"数据库的修改 数据库的内容可以使用下面的操作来修改: 删除 插入 更新 所有这些操作都使用赋值操作表示(使用关系代数) 删除可表达为: r \u003c- r – E 其中 r是关系,E是关系代数查询 插入 r \u003c- r 并 E 更新 ","date":"2020-04-18","objectID":"/posts/DB-1/:2:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"SQL语言 ","date":"2020-04-18","objectID":"/posts/DB-1/:3:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"组成 SQL语言有以下几个部分: DDL (Data-definition Language) 数据定义语言 create table,alter table,drop table create index,drop index create view,drop view create trigger,drop trigger … DML (Data-manipulation Language) 数据操纵语言 select … from insert, delete, update DCL (Data-control Language) 数据控制语言 grant, revoke ","date":"2020-04-18","objectID":"/posts/DB-1/:3:1","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"基本数据类型 char(n):固定长度字符串,用户指定长度n varchar(n):可变长度的字符串,用户指定最大长度n int:整数类型(和机器相关的整数类型的子集),等价于全程integer smallint:小整数类型(和机器相关的整数类型的子集) numeric(p, d):定点数,精度由用户指定。这个数有p位数字,其中d 位数字在小数点右边 real, double precision:浮点数与双精度浮点数,精度与机器相关 float(n):精度至少为n位的浮点数 null:每种类型都可以包含一个特殊值,即空值。可以申明属性值不为 空,禁止加入空值 date:日期,含年、月、日,如 ‘2015-3-20’ time:时间,含小时、分钟、秒,如‘ 08:15:30’或‘ 08:15:30.75’ timestamp:日期 + 时间,如‘2015-3-20 08:15:30.75’ ","date":"2020-04-18","objectID":"/posts/DB-1/:3:2","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"视图 定义 向用户隐藏特定的数据 SQL允许通过查询来定义“虚关系”,它在概念上包含查询的结果,但并不预先计算并存储。像这种作为虚关系对用户可见的关系称为视图(view) 在SQL中,我们用create view命令定义视图,命令的格式为: create view v as \u003c query expression \u003e - \u003c query expression \u003e可以是任何合法的查询表达式 - v 表示视图名 - 使用视图的目的:安全及易于使用 - 对应地,删除视图,使用命令: drop view v /* 举例代码:*/createviewphysics_fall_2009asselectcourse.course_id,sec_id,building,room_numberfromcourse,sectionwherecourse.course_id=section.course_idandcourse.dept_name='Physics'andsection.semester='Fall'andsection.year='2009'; SQL查询中使用视图 一旦定义了一个视图,就可以用视图名指代该视图生成的虚关系。由于数据库只存储视图定义本身,那么当视图关系出现在查询中时,它就会被已存储的查询表达式代替 /*使用视图physics_fall_2009,找到所有于2009年秋季学期在Watson 大楼开设的Physics课程*/selectcourse_id,room_numberfromphysics_fall_2009wherebuilding='Watson'; SQL视图更新 假设我们向视图 faculty 插入一条新元组,可写为: insert into faculty values (‘30765’,‘Green’,‘Music’); 但这个插入必须表示为对instructor关系的插入,即必须给出salary的值。存在 两种合理的解决方法: 拒绝插入,并向用户返回一个错误信息 向instructor关系插入元组(‘30765’,‘Green’,‘Music’, null) 对于视图的更新,处理方式较为严谨,所以需要判断此时定义的视图是否符合更新要求,一般地,如果定义视图的查询对下列条件都能满足,我们称SQL视图是可更新的(updatable),即视图上可以执行插入、更新或删除 1. from子句中只有一个数据库关系 2. select子句中只包含关系的属性名,不包含任何表达式、聚集或distinct声明 3. 任何没有出现在select子句中的属性可以取空值;即这些属性上没有notnull约束,也不构成主码的一部分 4. 查询中不含有group by或having子句 ","date":"2020-04-18","objectID":"/posts/DB-1/:3:3","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["数据库"],"content":"感悟  在开始学这本书之前,结合之前自学的数据库那点皮毛,想的有些简单 学了半本书发现有用的新知识太多了,学一门技术还是要实打实的从书看起,不然只是学了很多杂乱的知识点,只是皮毛 之前数据库可能只是简单的软件操作,以及sql语句的增删查改,但其实数据库很严谨,很全面立体 例如之前写程序都是直接直接操作表,但其实有一个明智的方法就是操作视图,对于稍大一点的mis系统,视图是一个完美的解决方案 并且数据库的底层是通过数学的集合运算(关系代数)来操作数据 对于数据的操作过程中,原子性操作的事务,以及数据库函数trigger,都是让我很惊喜的功能(感觉自己之前像个傻子…之前学了个锤子) 这几天加油把数据库学完!还有太多东西等着我去学 ","date":"2020-04-18","objectID":"/posts/DB-1/:4:0","tags":["数据库原理及应用-课程"],"title":"数据库原理及应用 PART-1","uri":"/posts/DB-1/"},{"categories":["Ubuntu"],"content":"挂载windows分区挂载到ubuntu的文件管理器中  由于Ubuntu在开机时,将Windows的磁盘分区当做外部media设备,所以开机的时候并不自动挂载,这样在使用中就有很多不便,例如Ubuntu中的vscode在打开后每次无法自动加载Windows磁盘中的项目 以下为开机自动挂载的设置步骤: 查看分区信息 sudo fdisk -l 查看磁盘类型 sudo blkid 例： 得到以下内容 Device Boot Start End Sectors Size Id Type /dev/1 2048 1187839 1185792 579M 7 HPFS/NTFS/exFAT /dev/2 1187840 210903039 209715200 100G 7 HPFS/NTFS/exFAT /dev/3 210903040 420618239 209715200 100G 7 HPFS/NTFS/exFAT /dev/4 420620286 500117503 79497218 37.9G 5 Extended /dev/5 420620288 421595135 974848 476M 83 Linux /dev/6 421597184 450891775 29294592 14G 83 Linux /dev/7 450893824 500117503 49223680 23.5G 83 Linux 修改配置文件 sudo vim /etc/fstab 根据2中得到的内容，添加以下内容到/etc/fstab # for Windows 10 C:/ /dev/2 /home/usrname/File ntfs defaults 0 0 注意：其中的/home/usrname/ 路径系统直接创建File文件夹,即C盘 挂载新添加的分区 sudo mount -a ","date":"2020-04-17","objectID":"/posts/ubuntu-11/:0:0","tags":["双系统"],"title":"Ubuntu开机挂载Windows磁盘","uri":"/posts/ubuntu-11/"},{"categories":["数据结构与算法"],"content":"单源多源最短路径 ","date":"2020-04-17","objectID":"/posts/DS-11/:0:0","tags":["Leetcode-C++"],"title":"图的最短路径","uri":"/posts/DS-11/"},{"categories":["数据结构与算法"],"content":"总体思想 需要两个辅助数组 dist数组: 记录当前路径长度 path数组: 记录当前的路径上的结点 单源和多源的算法不同点: 单源path为二维数组(只需要记录目标节点),多源为三维数组(需要记录两个结点) 单源遍历过程中,得到目标节点后,更新其余结点的dist,path,并赋值当前结点dist=0,而多源遍历中,只需要三层for循环,不断更新dist和path即可 单源最外层是while循环,需要flag判断是否还有结点没有进行最短路径计算 每次循环进行新增中间结点判断 ","date":"2020-04-17","objectID":"/posts/DS-11/:1:0","tags":["Leetcode-C++"],"title":"图的最短路径","uri":"/posts/DS-11/"},{"categories":["数据结构与算法"],"content":"算法 ","date":"2020-04-17","objectID":"/posts/DS-11/:2:0","tags":["Leetcode-C++"],"title":"图的最短路径","uri":"/posts/DS-11/"},{"categories":["数据结构与算法"],"content":"单源最短路径-迪杰斯特拉算法 void dijkstra(MGraph g, int v){ int dist[MAX]; int path[MAX][MAX]; int i, j, k, min, n, flag; for(i=0; i\u003cg.vexNum; i++){ //初始化path,都为-1 for(j=0; j\u003cg.vexNum; j++){ path[i][j] = -1; } } for(i=0; i\u003cg.vexNum; i++){ //对初始化dist,path第一个结点为v(起始结点) dist[i] = g.arcs[v][i]; if(dist[i] != 0 \u0026\u0026 dist[i] != 10000){ path[i][0] = v; } } flag = 1; //判断循环继续的标志 while(flag){ k = 0; min = 10000; for(j=0; j\u003cg.vexNum; j++){ //获得最小dist的结点 if(dist[j] !=0 \u0026\u0026 dist[j] \u003c min){ k = j; min = dist[j]; } } for(j = 0; j\u003c g.vexNum; j++){ //以最小dist结点为中间结点更新其他结点的dist和path if(j != k \u0026\u0026 dist[j] != 0 \u0026\u0026 dist[j] != 10000){ if(dist[j] \u003e dist[k] + g.arcs[k][j]){ dist[j] = dist[k] + g.arcs[k][j]; for(m=0; m\u003cg.arcNum; m++){ path[j][m] = path[k][m]; //j结点路径与j结点路径相同,进行赋值 } for(m=0; m\u003cg.arcNum \u0026\u0026 path[j][m]!=-1;){ m++; //将j结点路径最后一个位置赋值其自身 } path[j][m] = j; //找到 } } } dist[k] = 0; //此时dist最小结点完成最短路径搜索,dist=0 flag = 0; for(j=0 ;j\u003cg.vexnum; j++){ //判断图中是否还有结点可进行最小路径搜索 if(dist[j] != 0 \u0026\u0026 dist[j]\u003c10000){ flag = 1; } } } } ","date":"2020-04-17","objectID":"/posts/DS-11/:2:1","tags":["Leetcode-C++"],"title":"图的最短路径","uri":"/posts/DS-11/"},{"categories":["数据结构与算法"],"content":"多源最短路径-弗洛伊德算法 typedef PATH[MAX]; //定义路径数组 void floyd(MGraph){ int i, j, m, m, p; int d[MAX][MAX]; PATH path[MAX][MAX]; for(i=0; i\u003cg.vexNum; i++){ //初始化dist和path for(j=0; j\u003cg.vexNum; j++){ d[i][j] = g.arc[i][j]; for(k=0; k\u003cg,vexNum; k++){ path[i][j][k] = -1; // i, j 结点之间路径的第k个结点 } } } for(i=0; i\u003cg.vexNum; i++){ for(j=0; j\u003cg.vexNum; j++){ if(d[i][j] != 10000 \u0026\u0026 d[i][j] != 0){ path[i][j][0] = i; path[i][j][1] = j; //初始化path路径为i, j的直接路径,此时无中间结点 } } } for(k=0; k\u003cg.vexNum; k++){ //中间节点遍历,更新path和dist for(i=0; i\u003cg.vexNum; i++){ for(j=0; j\u003cg.vexNum; j++){ if(d[i][k] + d[k][j] \u003c d[i][j]){ d[i][j] = d[i][k] + d[k][j]; for(m=0; m\u003cg.vexNum \u0026\u0026 path[i][j][m]!= -1; m++){ path[i][j][m] = path[i][k][m]; //将i,k路径赋值给i,j路径(前半段) } for(n=1; n\u003cg.vexNum; m++, n++){ path[i][j][m] = path[k][j][n]; //将k,j路径赋值给i,j路径(后半段,从m位置开始) } } } } } } 现在图就剩拓扑排序啦!明天算法笔记就到了,基础打好,准备快乐刷算法题! ","date":"2020-04-17","objectID":"/posts/DS-11/:2:2","tags":["Leetcode-C++"],"title":"图的最短路径","uri":"/posts/DS-11/"},{"categories":["Ubuntu"],"content":"搜狗云输入法惹的祸! 今天电脑风扇突然起飞了…打开性能监视器发现一直单核cpu 100%负荷 很是纳闷,发现 fcitx 占用很高 搜了很久才发现问题,是搜狗云输入出现了bug 在应用目录里找到Fictx配置 找到附加组件 选择高级选项 找到搜狗云拼音,取消勾选 参考: 博客地址 ","date":"2020-04-17","objectID":"/posts/ubuntu-10/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu-CPU异常负荷","uri":"/posts/ubuntu-10/"},{"categories":["数据结构与算法"],"content":"简单路径,最短路径,最小生成树 ","date":"2020-04-16","objectID":"/posts/DS-10/:0:0","tags":["Leetcode-C++"],"title":"图的算法应用\u0026\u0026最小生成树","uri":"/posts/DS-10/"},{"categories":["数据结构与算法"],"content":"1.求包含图中所有顶点的简单路径问题 思路: 哈密尔顿问题-基于深度优先遍历 创建变量 int n ,访问结点后, n++ 创建 path 数组记录顶点(路径) 判断条件: n == g.vexnum 则输出当前path void Hamilton(MGraph g){ int i; int visited[100]; int path[100]; for(i = 0; i\u003cvexNum; i++){ //初始化数组 visited[i] = 0; path[i] = 0; } int n = 0; for(i = 0; i\u003cg.vexNum; i++){ //将所有结点都进行遍历操作 if(!visited[i]){ DFS_h(g, i, path, \u0026n); } } } void DFS_h(MGraph g, int i, int path[], int visited[], int *n){ visited[i] = 1; path[*n] = i; (*n)++; if((*n) == g.vexNum){ //满足条件输出路径 printf(path); } fot(j = 0; j\u003cg.vexNum; j++){ if(g.arcs[i][j] \u0026\u0026 visited[j]){ //递归执行dfs DFS_h(g, j, path, n); } } visited[i] = 0; //此时所有子结点都访问完成,向上一级继续访问 (*n)--; //路径结点数-1 } ","date":"2020-04-16","objectID":"/posts/DS-10/:1:0","tags":["Leetcode-C++"],"title":"图的算法应用\u0026\u0026最小生成树","uri":"/posts/DS-10/"},{"categories":["数据结构与算法"],"content":"2.判断图中是否存在环 思路:基于深度优先遍历 判断条件: 如果深度遍历过程中结点的子结点都已经被访问,则代表存在环 void DFSloop(MGraph g, int i, int visited[]){ visited[i] = 1; //当前结点访问 for(int di=0, vi=0, j=0; j\u003cg.vexNum; j++){ //判断边是否都被访问 if(g.arcs[i][j]){ di++; if(visited[j]){ vi++; } } } if(di == vi \u0026\u0026 di!= 1){ //判断是否存在环 printf(\"有回路\"); return; } for(j=0; j\u003cg.arcNum; j++){ //dfs遍历,递归判断 if(g.arcs[i][j] \u0026\u0026 visited[j] == 0){ DFSloop(g, j, visited); } } } ","date":"2020-04-16","objectID":"/posts/DS-10/:2:0","tags":["Leetcode-C++"],"title":"图的算法应用\u0026\u0026最小生成树","uri":"/posts/DS-10/"},{"categories":["数据结构与算法"],"content":"3.求无向图中顶点 a 到 i 之间的简单路径 思路:基于深度优先遍历 path记录路径上的结点,如果访问到目标节点,输出path,如果当前结点的子节点深度遍历都没有访问到目标节点,则path删除当前结点,回溯上一层节点,进行上次一层节点的下一次循环(下一个子结点)进行递归查找 void DFSSearchPath(MGraph g, int v, int s, char path[], int visited[], int *found){ visited[v-1] = 1; //访问该结点 append(path, g.vertex[v-1]); //结点进数组path for(j = 0; j\u003cg.vexNum \u0026\u0026 !(*found); j++){ if(g.arcs[v-1][j] == 1){ //边存在 if(s == j+1){ //当前结点为为目标节点,则找到路径 *found = 1; append(path, g.vertex[j]); } else if(visited[j] == 0){ //dfs递归遍历 DFSSearchPath(g, j+1, s, path, visited, *found); } } } if(!(*found)){ //递归子结点都访问完,删除当前结点,回溯进入下一次循环 delete(path); } } ","date":"2020-04-16","objectID":"/posts/DS-10/:3:0","tags":["Leetcode-C++"],"title":"图的算法应用\u0026\u0026最小生成树","uri":"/posts/DS-10/"},{"categories":["数据结构与算法"],"content":"4.求无向图中 vi 到 vj 之间的最短路径 思路:这个算法很是巧妙,一开始很懵,直到手动模拟过程,才明白其中的道理,巧妙的点就在于 prior 指针指向的是 front ,这样在输出的时候就是最短路径 算法基于广度优先遍历,这个很好理解,因为最短路径就是最少层去发现的过程 构建了新的队列,带有前驱和后继指针,重写了进栈的函数,prior 指向 front //求无向图中vi和vj之间的最短路径 int BFSsearchPath(MGraph g, int vi, int vj, SqQueue *q){ for(int i=0; i\u003cg.vexNum, i++){ //初始化 visted[] visited[i] = 0; } initQueue(q); EnQueue_bfs(q, vi); //第一个节点访问 visited[vi] = 1; while(!QueueEmpty(q)){ //广度优先遍历 DeQueue_bfs(q, \u0026v); for(w = 0; w\u003cg.vexNum; w++){ if(g.arcs[v][w] \u0026\u0026 visited[w]){ visited[w] = 1; EnQueue_bfs(q, w); if(w == vj){ break; } } } if(w \u003e= g.vexNum){ continue; } } } typedef struct bfsnode{ //队列实现 struct bfsnode *prior; struct bfsnode *next; Elemdata data; }bfsnode, *bfslink; typedef struct { bfslink front; bfslink rear; }bfsqueue; void EnQueue_bfs(bfsqueue *q, Elemdata data){ //prior指向队头front p = (bfsqueue)malloc(sizeof(bfsnode)); p-\u003edata = data; p-\u003enext = NULL; p-\u003eprior = q-\u003efront; q-\u003erear-\u003enext = p; q-\u003erear = p; } void Dequeue_bfs(bfsqueue *q, Elemdata *data){ *data = q-\u003efront; q-\u003efront = q-\u003efront-\u003enext; } ","date":"2020-04-16","objectID":"/posts/DS-10/:4:0","tags":["Leetcode-C++"],"title":"图的算法应用\u0026\u0026最小生成树","uri":"/posts/DS-10/"},{"categories":["数据结构与算法"],"content":"5.最小生成树 ","date":"2020-04-16","objectID":"/posts/DS-10/:5:0","tags":["Leetcode-C++"],"title":"图的算法应用\u0026\u0026最小生成树","uri":"/posts/DS-10/"},{"categories":["数据结构与算法"],"content":"Prim算法 思路: 使用 lowcost 辅助数组记录结点到生成树的距离 从未包含在生成树的结点(weight == 0)的边中选取权值最小 赋值新进入结点的lowcost.weigh = 0 从新进入生成树的 i 结点开始更新lowcost数组(比较g.arc[i][j]和lowcost[j]) 外部循环g.vexnum次,即对每个节点都进行该操作 #define maxcost 10000 typedef struct{ int vi; int weight; }Lowcost; void prim(MGraph g){ int mincost, i, j, k; Lowcost *lowcost = (Lowcost*)malloc(sizeof(Lowcost) * g.vexNum); //申请 lowcost 数组空间 for(i=0; i\u003cg.vexNum; i++){ //初始化 lowcost 数组 lowcost[i].vi = 0; lowcost[i].weight = g.arcs[0][i]; } lowcost[0].weight = 0; //第一个节点进入生成树中,weight=0 for(i=0; i\u003cg.vexNum; i++){ //找到当前离树权值最小的结点 mincost = maxcost; for(j=0; j\u003cg.vexNum; j++){ if(lowcost[j].weight \u003c mincost \u0026\u0026 lowcost[j].weight != 0){ mincost = lowcost[j].weight; k = j; } } lowcost[k].weight = 0; //权值最小结点进生成树,weight=0 for(j=0; j\u003cg.vexNum; g++){ //更新其余未进入生成树结点的权值 if(g.ars[k][j] \u003c lowcost[j].weight){ lowcost[j] = g.ars[k][j]; lowcost[j].vi = k; } } } } ","date":"2020-04-16","objectID":"/posts/DS-10/:5:1","tags":["Leetcode-C++"],"title":"图的算法应用\u0026\u0026最小生成树","uri":"/posts/DS-10/"},{"categories":["数据结构与算法"],"content":"Kruskal算法 思路:这个算法也很有意思,一开始看到五个循环我人都傻… 其实蛮简单的,应该是作者希望读者理解的更快一点,才这么写的 算法中有两个小知识点 int转char 因为字符是ASCII值表示的,‘0’是一个字符,由48表示 所以c[i][0] = i+48; stract函数 例如 char d[20]=“Golden”; char s[20]=“View”; strcat(d,s); printf(\"%s\",d); 输出 d 为 ‘GoldenView’ 返回指向d的指针。 第一个for循环: 将结点的下标转换为字符串 i+48,加入c数组中 第二个for循环: 将所有边进行初始化,加入x数组 第三个for循环: 将边的权值从小到大排序 第四个for循环: 依次找到最小边,判断是否边的两个节点都在生成树中,如果不在生成树中,则将两个结点合并到第一个节点,并删除第二个结点 第五个for循环: 输出生成树的边 typedef char afc[MAX]; void kruskal(MGraph g){ int i, j, k, t., p, q, x[MAX][4]; zfc c[MAX]; for(i=0; i\u003cg.vexNum; i++){ c[i][0] = i+48; //初始化,下标转字符串 c[i][1] = 0; //字符串结束标志 } for(i=0; i\u003cg,vexNum; i++){ //初始化所有边,放进 x[max][4] 数组 for(j=i; j\u003cg.vexNum; j++){ if(g.arcs[i][j] != 0 \u0026\u0026 g.arcs[i][j] != maxcost){ x[k][0] = i; x[k][1] = j; x[k][2] = g.arcs[i][j]; x[k][3] = 0 k++; } } } for(i=0; i\u003cg.arcNum; i++){ //对所有边进行排列,权值从小到大 for(j=0; j\u003cg.arcNum-1-i; j++){ if(x[j][2] \u003e x[j+1][2]){ for(p=0; p\u003c4; p++){ t = x[j][p]; x[j][p] = x[j+1][p]; x[j+1][p] = t; } } } } for(i=0, k=0; i\u003cg.arcNum; i++){ //对所有边进行从小到大判断 p = find(c, g.vexNum, x[i][0]+48); q = find(c, g.vexNum, x[i][1]+48); //判断边的两个结点是否成环 if(p != q){ stract(c[p], c[q]); c[q][0] = 0; k++; x[i][3] = 1; } if(k == g.vexNum-1){ //当有 vexnum-1 条边时,最小生成树构造完成 break; } } printf(\"%7c%7c%6s\", \"顶点\", \"顶点\", \"权值\"); for(i=0; i\u003cg.arcNum; i++){ //输出边 if(x[i][3] == 1){ printf(\"%7c%7c%6d\", g.vertex[x[i][0]], g.vertex[x[i][1]], x[i][2]) } } } int find(afc *s, int n, char c){ for(int i=0; i\u003cn; i++){ for(int j=0; j\u003cstrlen(s[i]); j++){ if(s[i][j] == c){ return i; } } } return -1; } ","date":"2020-04-16","objectID":"/posts/DS-10/:5:2","tags":["Leetcode-C++"],"title":"图的算法应用\u0026\u0026最小生成树","uri":"/posts/DS-10/"},{"categories":["数据结构与算法"],"content":"图的重点! ","date":"2020-04-15","objectID":"/posts/DS-9/:0:0","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"图的存储结构-这里只写两种常用的 ","date":"2020-04-15","objectID":"/posts/DS-9/:1:0","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"邻接矩阵存储 #define VNUM 20 typedef struct{ VertexType vexs[VNUM]; //存储顶点信息 int arcs[VNUM][VUM]; //存储顶点关系 int vexNum, arcNum; //存储顶点数,弧数 }MGraph; ","date":"2020-04-15","objectID":"/posts/DS-9/:1:1","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"邻接表 //图的邻接表-边结点的定义 typedef struct ArcNode{ int adjvex; struct adjvex *nextArc; [WeightType info;] //视情况而定 }ArcNode; //图的邻接表-表头结点的定义 typedef struct VertexNode{ Elemdata vertex; ArcNode *firstArc; }VertexNode; //图的邻接表-总体类型 typedef struct ALGraph{ VertexNode adjlist[MAX]; int vexNum, arcNum; }ALGraph; ","date":"2020-04-15","objectID":"/posts/DS-9/:1:2","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"图的遍历 ","date":"2020-04-15","objectID":"/posts/DS-9/:2:0","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"深度优先遍历 思路: 非递归使用栈 首先初始化栈和visited数组 之后进栈当前元素,访问当前元素 while(!emptystack)外层循环 访问当前结点的所有边指向的结点 如果是邻接矩阵 i = stackget_top(s); for(int i=0; i\u003cg.vexnum; i++){ if(visited[j] \u0026\u0026 g.arcs[i][j]){ 进栈;访问; break,跳出当前for循环 } } 判断是否是因为子结点都无法访问,如果是,pop当前结点,否则下一次while外层循环 如果是邻接表 i = stackget_top(s); p = g.adjlist[i]-\u003efirstArc while(p){ if(p \u0026\u0026 visited[p-\u003eadjvex] == 0){ 进栈,访问,break;跳出当前循环 } p = p-\u003enextArc; //寻找下一条能访问的边 } //子结点访问完成 判断是否所有子结点都无法访问,如果是,pop此结点,否则下一次while外层循环 ","date":"2020-04-15","objectID":"/posts/DS-9/:2:1","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"广度优先搜索 思路: 非递归使用队列 首先初始化队列和visited数组 当前结点访问进队列 while(!emptyqueue)外层循环 如果是邻接矩阵 i = dequeue(q); for(int i=0; i\u003cg.vexnum; i++){ if(visited[j] \u0026\u0026 g.arcs[i][j]){ 进队列;访问; } } 如果是邻接表 i = dequeue(q); p = g.adjlist[i]-\u003efirstArc; while(p){ if该节点未被访问 访问p-\u003eadjvex; 进队列; p = p-\u003enextArc; } ","date":"2020-04-15","objectID":"/posts/DS-9/:2:2","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2020-04-15","objectID":"/posts/DS-9/:3:0","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"邻接矩阵连通图-深度优先遍历递归 void DFSR_MGraph(MGraph g, int v, visited[]){ printf(g.vertex[v]); visited[v] = 1; for(j = 0; j\u003cg.vexNum; j++){ if(g.arcs[v][j] == 1 \u0026\u0026 visited[j] == 0){ DFSR_MGraph(g, j, visited); } } } ","date":"2020-04-15","objectID":"/posts/DS-9/:3:1","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"邻接表连通图-深度优先非递归遍历-使用栈 void DFS_ALGraph(ALGraph g, int v){ int i; SqStack s; initStack(s); int visited[100]; for(i = 0; i\u003cg.vexNum; i++){ //初始化visited数组 visited[i] = 0; } printf(G.adjlist[v].vertex); //访问第一个节点 visited[v] = 1; SqStackPush(s, v); while(!SqStackEmpty(s)){ k = SqStackGetTop(s); p = g.adjlist[k].firstArc; //获得栈顶结点的第一条边 while(p){ if(p \u0026\u0026 visited[p-\u003eadjvex] == 0){ printf(g.adjlist[p-\u003eadjvex].vertex); visited[p-\u003eadjvex] = 1; SqStackPush(s, p-\u003eadjvex); break; } p = p-\u003enextArc; //下一条边 } if(!p){ SqStackPop(s); //没有相连结点可以访问,出栈此时结点 } } } ","date":"2020-04-15","objectID":"/posts/DS-9/:3:2","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"邻接表连通图的广度优先遍历-使用队列 void BFSRecursion(ALGraph g, int v){ initQueue(q); printf(g.adjlist[v].vertex); visited[v] = 1; EnQueue(q, v); while(!QueueEmpty){ //对队列元素执行广度优先 v = DeQueue(q); p = g.adjlist[v].firstArc; //得到队头的第一条边 while(p){ if(visited[w] == 0){ //此时尚未访问,访问该节点 printf(g.adjlist[p-\u003eadjvex].vertex); visited[w] == 1; EnQueue(q, w); //进栈该节点 } p = p-\u003enextArc; //结点的下一条边 } } } ","date":"2020-04-15","objectID":"/posts/DS-9/:3:3","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"参考 一篇很好的博客 ","date":"2020-04-15","objectID":"/posts/DS-9/:4:0","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["数据结构与算法"],"content":"感悟  这一遍下来比之前学的透彻多了,之前只是背代码,现在真正敲出来,才是自己的,图的应用算法本来学完了,但由于篇幅原因,放在明天更了 今天感觉在iPad上看电子版的\"算法笔记\"很麻烦,还特意去淘宝买了一本,嘿嘿 今年把CCF认证过一下,好好学算法! 冲! ","date":"2020-04-15","objectID":"/posts/DS-9/:5:0","tags":["Leetcode-C++"],"title":"图的DFS/BFS遍历","uri":"/posts/DS-9/"},{"categories":["操作系统"],"content":"二进制运算 ","date":"2020-04-13","objectID":"/posts/CMU213-2/:0:0","tags":["CMU213"],"title":"CMU213_Part-2","uri":"/posts/CMU213-2/"},{"categories":["操作系统"],"content":"1.位宽不等的二进制运算 符号位扩展，补齐后运算即可。 例如：-1的4位补码为 1111；+1的8位补码为000000001。显然，两个数相加的结果为零 计算过程如下： ","date":"2020-04-13","objectID":"/posts/CMU213-2/:0:1","tags":["CMU213"],"title":"CMU213_Part-2","uri":"/posts/CMU213-2/"},{"categories":["操作系统"],"content":"2.二进制运算溢出 溢出的概念  对一个N位二进制补码，其可以表达的范围是 - 2N ~ 2N-1之间。如果超出这个范围就称为溢出了。  拿上面的-3-6来说，我们刚刚在计算时，转换为二进制补码是4位的。它的取值范围是-8 ~ +7之间。而我们想要的结果是-9,比范围的最小值还要小，这个叫做负溢出。同理如果想要的结果比最大值还要大，那么就叫做正溢出，如取值范围是-8 ~ +7之间，想要的结果是+8，那么就是正溢出。 溢出后该如何正确计算结果 　解决方式: 将位宽扩大一位，按前面的判定方法进行判定。 　举例: -3-6 = -9 前面这是一个负溢出，我们在转换为二进制时进行位宽扩大，以提升取值范围。 　此处 -3 二进制写成 10011(5位比开始多一位), -6二进制写成10110(5位比开始多一位)。再进行补码运算，10011–\u003e 11100+1–\u003e11101, 10110–\u003e11001+1–\u003e11010. 11101 + 11010 = 110111 最高位舍去,得到 10111,取反 01000, +1 = 01001= -9 参考博客地址 CSAPP这门课知识点很多,看书之后再来添加知识点 ","date":"2020-04-13","objectID":"/posts/CMU213-2/:0:2","tags":["CMU213"],"title":"CMU213_Part-2","uri":"/posts/CMU213-2/"},{"categories":["ShortCut"],"content":"暴力猴脚本 ","date":"2020-04-12","objectID":"/posts/shortcut-1/:0:0","tags":["网易云"],"title":"网易云导入Apple Music","uri":"/posts/shortcut-1/"},{"categories":["ShortCut"],"content":"利用暴力猴脚本迁移 ","date":"2020-04-12","objectID":"/posts/shortcut-1/:0:1","tags":["网易云"],"title":"网易云导入Apple Music","uri":"/posts/shortcut-1/"},{"categories":["ShortCut"],"content":"步骤： 安装脚本 网易云歌单导出 安装成功后网易云歌单界面会有\"导出\"选项 进入网易云网页版，点击导出歌单为TXT格式 打开歌单迁移网站 tunemymusic.com 导入来源选择从文本，复制粘贴刚刚下载的TXT内容到输入框 目的地选择 Apple music ","date":"2020-04-12","objectID":"/posts/shortcut-1/:0:2","tags":["网易云"],"title":"网易云导入Apple Music","uri":"/posts/shortcut-1/"},{"categories":["数据结构与算法"],"content":"今天应该进入图的,但是感觉还是整理一下树和哈夫曼树吧,知识点挺多的 ","date":"2020-04-12","objectID":"/posts/DS-8/:0:0","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"1.树的表示法 ","date":"2020-04-12","objectID":"/posts/DS-8/:1:0","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"双亲表示法(顺序存储) typedef struct tnode{ Elemdata data; int parent; //父节点的位置 }PNode; typedef struct PNode{ PNode tree[MAX]; //存放结点的数组 int n; //存放树结点的数量 int r; //存放根结点的位置 }PTree; 理解:只有前驱父节点位置,而没有保存子节点 ","date":"2020-04-12","objectID":"/posts/DS-8/:1:1","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"孩子链表表示法(链式存储) typedef struct CTNode{ //孩子链表上的结点类型 struct CTNode *next; //下一个孩子的位置 int child; //第一个孩子结点所在的位置 }CTNode, *ChildPtr; typedef struct{ //头结点的类型 Elemdata data; ChildPtr link; //孩子链表的头指针 }CTbox; typedef struct{ //孩子链表的数据类型 CTbox nodes[MAX]; int n,r; //结点数目和根结点的位置 }ChildList; 理解: 虽然前驱后继结点都有保存,但是数据冗余,浪费空间 孩子兄弟链表(链式存储) typedef struct CSNode{ Elemdata data; struct CSNode *fch, *nsib; }CSNode, *CStree; 理解: 标准的树存储结构,Perfect 哈夫曼树 typedef struct{ char data; int weight; //权重 int parent, lch, rch; }NodeType; typedef NodeType HufTree[M+1]; typedef char **HufCode; 理解: 值得注意的点是HufCode是动态分配指针数组 ","date":"2020-04-12","objectID":"/posts/DS-8/:1:2","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"2.创建树 ","date":"2020-04-12","objectID":"/posts/DS-8/:2:0","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"创建孩子链表的方法 void createPTree(ChildList *t){ int i, j, k; ChildPtr p, s; char father, child; printf(\"请输入节点数:\"); scanf(\"%d\", \u0026t-\u003en); getchar(); printf(\"请依次输入%d个结点的值\",t-\u003en); for(i = 0; i\u003ct-\u003en; i++){ //初始化结点序列 nodes scanf(\u0026t-\u003enodes[i]-\u003edata); t-\u003enodes[i].link = NULL; } getchar(); t-\u003er = 0; printf(\"格式{双亲,孩子}输入%d个分支{从左至右,从上至下}\",t-\u003en-1); for(i = 1; i \u003c t-\u003en-1; i++){ scanf(\u0026father, \u0026child); getchar(); for(j=0; j\u003ct-\u003en; j++){ if(father == t-\u003enodes[j].data) break; //找到父结点的位置 } if(j \u003e t-\u003en) return; for(k=0; k\u003ct-\u003en; k++){ if(child == t-\u003enodes[k].data) break; //找到孩子结点的位置 } if(k \u003e t-\u003en) return; p = t-\u003enodes[j].link; //建立链接 if(p == null){ //当前头结点还没有孩子结点,申请结点,链接 s = (ChildPtr)malloc(sizeof(CTNode)); s-\u003echild = k; s-\u003enext = NULL; t-\u003enodes[j].link = s; } else{ //有孩子节点,找到最后一个位置建立兄弟链接 while(p-\u003enext) p = p-\u003enext; s = (ChildPtr)malloc(sizeof(CTNode)); s-\u003enext = NULL; s-\u003echild = k; p-\u003enext = s; } } } ","date":"2020-04-12","objectID":"/posts/DS-8/:2:1","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"创建孩子兄弟树 void createCSTree(CStree *t){ initQueue(q); CStree r; *t = NULL; scanf(fa, ch); while(ch != '#'){ p = (CStree)malloc(sizeof(CSNode)); //初始化结点 p-\u003edata = ch; p-\u003efch = p-\u003ensib = NULL; EnQueue(Q, p); if(fa == '#') *t = p; //此时为根节点 else{ s = LinkStackGetTop(Q); while(s-\u003edata != fa){ //找到父节点位置 DeQueue(Q); s = LinkStackGetTop(Q); if(s-\u003efch == NULL){ //如果没有孩子结点,直接链接为第一个孩子 s-\u003efch = p; r = p; //r存储当前孩子结点位置 } else{ //有孩子结点,找到链接孩子节点,并赋值r为当前兄弟结点 r-\u003ensib = p; r = p; } } } scanf(fa, ch); } } ","date":"2020-04-12","objectID":"/posts/DS-8/:2:2","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"创建哈夫曼树 //已知n个字符,生成一棵哈夫曼树 void huff_tree(int w[], int n, HufTree ht){ int i, s1, s2; fot(i = 1; i\u003c2*n; i++){ //首先初始化,一共2n-1个结点 if(i\u003e=1; \u0026\u0026 i\u003c=n){ ht[i].weight = w[i-1]; //将所给字符,赋值到初始结点中 } else{ ht[i].weight = 0; } ht[i].parent = 0; //初始化结点 ht[i].lch = 0; ht[i],rch = 0; } for(i = n+1; i\u003c2*n, i++){ select(ht, n, \u0026s1, \u0026s2); //从结点中挑选两个最小权值结点 ht[i].weight = ht[s1].weight + ht[s2].weight; //结点合并 ht[i].lch = s1; //合并结点建立父子链接 ht[i].rch = s2; ht[s1].parent = i; ht[s2].parent = i; } } void select(HufTree ht, int n, int *s1, int *s2){ //从结点中挑选最小的两个结点 int i, min; for(min = 100, i = 1; i\u003c2*n; i++){ //最小结点1 if(ht[i].parent == 0 \u0026\u0026 ht[i].weight != 0 \u0026\u0026 ht[i].weight \u003c= min){ min = ht[i].weight; *s1 = i; } } for(min = 100, i = 1; i\u003c2*n; i++){ //最小结点2 if(ht[i],parent == 0 \u0026\u0026 ht[i].weight != 0 \u0026\u0026 i != s1 \u0026\u0026 ht[i].weight \u003c=min){ min = ht[i].weight; *s2 = i } } } ","date":"2020-04-12","objectID":"/posts/DS-8/:2:3","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"3.树的一般操作 ","date":"2020-04-12","objectID":"/posts/DS-8/:3:0","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"树的结点插入 int insertTree(CStree *t, char father, char child){ //父结点的值为 father,需要插入的孩子结点值为 child CStree p = NULL, q, s; findTree(t, father, \u0026p); //找父节点,其值为father if(p){ s = (CStree)malloc(sizeof(CSNode)); //初始化结点 strcpy(s-\u003edata, child); s-\u003efch = s-\u003ensib = NULL; if(!p-\u003efch){ //如果没有孩子结点 p-\u003efch = s; } else{ //有孩子节点 q = p-\u003efch; while(q-\u003ensib){ //找到最后一个兄弟节点 q = q-\u003ensib; } q-\u003ensib = s; } return 1; } else{ return 0; } } ","date":"2020-04-12","objectID":"/posts/DS-8/:3:1","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"树的结点删除 int deleteTree(CStree *t, char fa, char ch){ CStree pfa = NULL, pch = NULL; if(strcmp(fa, \"#\") == 0){ //如果此时删除的结点为根结点 postdelete(*t); //递归删除树(根结点为 t ) *t = NULL; return; } else{ findTree(*t, fa, \u0026pfa); //得到父结点,赋值指针 pfa findTree(*t, ch, \u0026pch); //得到孩子结点,赋值指针 pch if(pfa == NULL || pch == NULL){ return; //指针不存在,数据有误 } else{ if(pfa-\u003efch != pch){ //不是直接孩子,需要查找 father's child's sibling pfa = pfa-\u003e fch; while(pfa){ if(pfa-\u003ensib == pch) break; pfa = pfa-\u003ensib; //这里得到 pfa 为 pch 的前驱结点 } } delete(pch, pfa); //在删除 pch 的子树时需要 pch 的前驱,用来重新链接其他子树 } } } void delete(CStree p, CStree f){ //删除单个结点,重新连接后序子树 if(f-\u003efch == p){ f-\u003efch = p-\u003ensib; p-\u003ensib = NULL; postdelete(p); } if(f-\u003ensib == p){ f-\u003ensib = f-\u003ensib; p-\u003enisb = NULL; postdelete(p); } } void postdelete(CStree t){ //递归删除整个树 if(t){ postdelete(t-\u003efch); postdelete(t-\u003ensib); free(p); } } ","date":"2020-04-12","objectID":"/posts/DS-8/:3:2","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"树的深度 int depthTree(BiThrTree t){ if(t == NULL){ return 0; } else{ d1 = depthTree(t-\u003efch); //递归求深度 d2 = depthTree(t-\u003ensib); return d1+1 \u003e d2 ? d1+1:d2; } } ","date":"2020-04-12","objectID":"/posts/DS-8/:3:3","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"树的叶子结点路径 void AllTreePath(CStree t, SqStack *s){ while(t){ SqStackPush(s, t-\u003edata); if(!t-\u003efch){ //没有子结点,输出栈 SqStackTraverse(s); } else{ //一直递归直到遇到叶子结点输出栈 AllTreePath(t-\u003efch, *s); } SqStackPop(s); //叶子结点出栈 t = t-\u003ensib; //上一层开始寻找兄弟结点 } } ","date":"2020-04-12","objectID":"/posts/DS-8/:3:4","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"4.哈夫曼树的操作 ","date":"2020-04-12","objectID":"/posts/DS-8/:4:0","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"求叶子结点的哈夫曼编码 void hufcode(HufCode *hcd, HufTree ht, int n){ char *cd; int i, start, c, f; *hcd = (HufCode)malloc((n+1)*sizeof(*char)); cd = (char *)malloc(n*sizeof(char)); //申请存放编码的数组 for(i = 1; i\u003c=n; i++){ cd[n-1] = '\\0'; start = n-1; c = i; f = ht[c].parent; //从下向上获得编码 while(f){ if(ht[f].lch == c){ cd[--start] = '0'; } else{ //根据左右子树状态确定编码0或1 cd[--start] = '1'; } c = f; f = ht[f].parent; } (*hcd)[i] = (char *)malloc((n-start)*sizeof(char)); strcpy((*hcd)[i], \u0026cd[start]); //使用char数组指针,一直到'\\0'结束 } } ","date":"2020-04-12","objectID":"/posts/DS-8/:4:1","tags":["Leetcode-C++"],"title":"树和哈夫曼树的算法整理","uri":"/posts/DS-8/"},{"categories":["数据结构与算法"],"content":"二叉树的线索化 首先在线索二叉树中有一个头结点(为了不浪费树中的空指针) 初始化时左指针指向根结点,右指针指向自己 线索化完成后,右指针指向最后一个结点 某序遍历下的第一个结点和最后一个结点指向头结点 rtag,ltag = 1时表示指向后继结点 ","date":"2020-04-09","objectID":"/posts/DS-7/:0:0","tags":["Leetcode-C++"],"title":"线索二叉树","uri":"/posts/DS-7/"},{"categories":["数据结构与算法"],"content":"1. 二叉树的线索化 ","date":"2020-04-09","objectID":"/posts/DS-7/:1:0","tags":["Leetcode-C++"],"title":"线索二叉树","uri":"/posts/DS-7/"},{"categories":["数据结构与算法"],"content":"不带头结点的中序线索化 void InThreading(BiThrTree t, BiThrTree *pre){ //基于递归中序遍历 if(p){ InThreading(t-\u003elchild, pre); if(!p -\u003e lchild){ p-\u003eltag = 1; p-\u003elchild = *pre; } else{ p -\u003e ltag = 0; } if(!(*pre) -\u003e rchild){ (*pre) -\u003e rtag = 1; (*pre) -\u003e rchild = p; } else{ (*pre) -\u003e rtag = 0; } InThreading(t-\u003erchild, pre); } } ","date":"2020-04-09","objectID":"/posts/DS-7/:1:1","tags":["Leetcode-C++"],"title":"线索二叉树","uri":"/posts/DS-7/"},{"categories":["数据结构与算法"],"content":"带头结点的中序线索化 首先申请一个头结点 初始化头结点,随后调用 InThreading 函数 int InorderThr(BiThrTree *head, BiThrTree t){ if(!(*head = (BiThrTree)malloc(sizeof(BiThrNodeType))){ return 0; } (*head) -\u003e rchild = *head; (*head) -\u003e ltag = 0; (*head) -\u003e rtag = 1; BiThrTree pre; if(!t) (*head) -\u003e lchild = *head; //如果树 t 为空,则左指针也回指*head else{ (*head) -\u003e lchild = t; InThreading(t, \u0026pre); pre -\u003e rchild = *head; //最后一个结点指回*head pre -\u003e rtag = 1; //改变最后一个结点的tag (*head) -\u003e rchild = pre; //头指针的 rchild 指向最后一个结点 } } ","date":"2020-04-09","objectID":"/posts/DS-7/:1:2","tags":["Leetcode-C++"],"title":"线索二叉树","uri":"/posts/DS-7/"},{"categories":["数据结构与算法"],"content":"2. 在中序线索二叉树中寻找*序的前驱或后继 ","date":"2020-04-09","objectID":"/posts/DS-7/:2:0","tags":["Leetcode-C++"],"title":"线索二叉树","uri":"/posts/DS-7/"},{"categories":["数据结构与算法"],"content":"中序线索树查找任意结点的中序前驱结点 BiThrTree InPreNode(BiThrTree p){ BiThrTree pre; pre = p-\u003elchild; if(p-\u003eltag != 1){ while(pre-\u003ertag == 0){ //如果结点有左子树,则前驱结点应该是左子树的最右端结点 pre = pre-\u003erchild; } } return pre; } ","date":"2020-04-09","objectID":"/posts/DS-7/:2:1","tags":["Leetcode-C++"],"title":"线索二叉树","uri":"/posts/DS-7/"},{"categories":["数据结构与算法"],"content":"中序线索二叉树查找任意结点的中序后继结点 BiThrTree InPostNode(BiThrTree p){ BiThrTree post = p-\u003erchild; if(p-\u003ertag != 1){ while(post-\u003eltag == 0){ //如果结点有右子树,则后驱结点应该是右子树的最左端结点 post = post-\u003elchild; } } return post; } ","date":"2020-04-09","objectID":"/posts/DS-7/:2:2","tags":["Leetcode-C++"],"title":"线索二叉树","uri":"/posts/DS-7/"},{"categories":["数据结构与算法"],"content":"中序线索树查找任意结点先序前驱结点 p为非叶子结点: 如果结点p-\u003ertag = 0,则先序遍历的后继结点即p-\u003erchild 如果p-\u003ertag = 1,先序后继结点为p-\u003elchild p为叶子节点: 如果p-\u003elchild = *head,则p-\u003elchild为后继结点,因为先序遍历和中序遍历最后一个结点相同,后继也相同 如果p-\u003elchild != *head,若p-\u003elchild有右子树,直接p = p-\u003elchild-\u003elchild,若p-\u003elchild有右线索,进入循环 pre = pre-\u003elchild BiThrNode IPostPreNode(BiThrTree p){ BiThrNode pre; if(p-\u003ertag == 0) pre = pre-\u003erchild; else{ pre = p; while(pre-\u003eltag == 1 \u0026\u0026 pre-\u003elchild != head) pre = pre-\u003elchild; pre = pre-\u003elchild } return pre; } ","date":"2020-04-09","objectID":"/posts/DS-7/:2:3","tags":["Leetcode-C++"],"title":"线索二叉树","uri":"/posts/DS-7/"},{"categories":["数据结构与算法"],"content":"中序线索树查找任意结点先序后继结点 p为非叶子结点: 如果结点p-\u003eltag = 0,则先序遍历的后继结点即p-\u003elchild 如果p-\u003eltag = 1,先序后继结点为p-\u003erchild p为叶子节点: 如果p-\u003erchild = *head,则p-\u003erchild为后继结点,因为先序遍历和中序遍历最后一个结点相同,后继也相同 如果p-\u003erchild != *head,若p-\u003erchild有右子树,直接p = p-\u003erchild-\u003erchild,若p-\u003erchild有右线索,进入循环 pre = pre-\u003erchild BiThrNode IPrePostNode(BiThrTree p){ BiThrNode post; if(p-\u003eltag == 0;) post = p-\u003elchild; else{ post = p; while(post-\u003ertag == 1 \u0026\u0026 post-\u003erchild != head) post = post-\u003erchild; post = post-\u003erchild; } return post; } ","date":"2020-04-09","objectID":"/posts/DS-7/:2:4","tags":["Leetcode-C++"],"title":"线索二叉树","uri":"/posts/DS-7/"},{"categories":["数据结构与算法"],"content":"今天线索二叉树还是没弄完,快给我脑壳绕晕了,开题报告和论文翻译昨晚肝到今天中午,最后可算完成了。 上一篇总结了非递归遍历,这篇总结各种应用算法…本来7号就应该写完的,结果拖了这么久…(惭愧) ","date":"2020-04-09","objectID":"/posts/DS-6/:0:0","tags":["Leetcode-C++"],"title":"二叉树应用算法整理","uri":"/posts/DS-6/"},{"categories":["数据结构与算法"],"content":"1. 读边创建二叉树: 读取参数为（fa, ch, lrtag）分别为father, child, 左右子树标志 根据读取的参数,创建一个结点 BiTree p = (BiTree)malloc(sizeof(BiTNode)); //申请空间 p -\u003e data = ch; //后来的结点通过data寻找father p -\u003elchild = p-\u003erchild = null; Enqueue(p,s); //进栈 判断此时节点是否是根节点 if(p - \u003efa == '') *t = p; 在栈中寻找父节点,并链接 else{ s = gethead(s); while(s-\u003edata != fa){ Dequeue(s); s = gethead(s); } } 递归传入新的节点 ","date":"2020-04-09","objectID":"/posts/DS-6/:1:0","tags":["Leetcode-C++"],"title":"二叉树应用算法整理","uri":"/posts/DS-6/"},{"categories":["数据结构与算法"],"content":"2. 先序和中序确定一棵二叉树 思想:根据先序遍历序列中第一个字符在中序中的位置,分两种情况递归函数 参数:先序遍历的序列,中序遍历的序列,两种遍历的首字符位置,默认为0 判断是否为空树 if(n == 0) *t = null; 判断先序遍历序列第一个字符是否在中序遍历序列中存在,否则为空树 k = search(ino, pre[ps]); if(k == -1) *t = null; 分两种情况递归 if(!(*t = (BiTree)malloc(sizeof(BiTNode)))) exit 0; if(k == is){ //没有左子树 (*t) -\u003e lchild = null; } else{ CrtBT(\u0026(*t)-\u003elchild, pre, ino, ps+1, is, k-is); } if(k == is+n-1){ //没有右子树 (*t) -\u003erchild = null; } else{ CrtBT(\u0026(*t)-\u003erchild, ps, ino, ps+1+(k-is), k+1, n-(k-is)-1); } ","date":"2020-04-09","objectID":"/posts/DS-6/:2:0","tags":["Leetcode-C++"],"title":"二叉树应用算法整理","uri":"/posts/DS-6/"},{"categories":["数据结构与算法"],"content":"3. 求二叉树深度 思想:后序递归遍历,在父节点进行判断左右子树的深度 代码实现 int depth (BiTree t){ if(t == null) return 0; else{ depth_left = depth(t-\u003elchild); depth_right = depth(t-\u003erchild); if(depth_left \u003e depth_right) return depth_left; else return depth_right; } } ","date":"2020-04-09","objectID":"/posts/DS-6/:3:0","tags":["Leetcode-C++"],"title":"二叉树应用算法整理","uri":"/posts/DS-6/"},{"categories":["数据结构与算法"],"content":"4. 求二叉树节点数量 void count(BiTree t, int *x){ if(t == null) return; //空树直接返回 else{ count(t-\u003erchild, x); //递归左子树,传入x参数 if(t-\u003elchild == null \u0026\u0026 t-\u003erchild == null) x++; //当前为叶子节点 count(t-\u003crchild, x); //递归右子树 } } ","date":"2020-04-09","objectID":"/posts/DS-6/:4:0","tags":["Leetcode-C++"],"title":"二叉树应用算法整理","uri":"/posts/DS-6/"},{"categories":["数据结构与算法"],"content":"5. 二叉树任意结点的父节点 思想:二叉树基于路径分析的非递归遍历–后序遍历 使用栈,直接goleft,到最左结点,进栈 第一次访问结点,标记数组初始化:c[p] = ‘L’ 第二次遇到时c[p] = ‘R’ 第三次遇到代表该结点的子结点都访问完成 如果此时p为需要求父节点的结点,那么此时栈中的元素就是它的所有父结点 void search_priorder(BiTree t, Elemdata x){ //基于路径分析法实现-后序遍历 SqStack s; initStack(\u0026s); char lrtag[MAX] = \"\"; BiTree t; t = priGoleft(t, \u0026s, lrtag); while(t \u0026\u0026 t-\u003edata != x){ lrtag[s.top] = 'R'; if(t-\u003erchild) t = priGoleft(t-\u003erchild, \u0026s, lrtag); else{ while(!SqStackEmpty(s) \u0026\u0026 lrtag[s.top] == 'R'){ gettop(s, \u0026t); if(t-\u003edata == x){ printstack(s); return; } } if(!SqStackEmpty(s)) gettop(s, \u0026t); else t = NULL; } } } BiTree priGoleft(BiTree t, SqStack *s, char c[]){ if(!t){ return NULL; } else{ while(t){ push(s, t); c[s-\u003etop] = 'L'; if(t == NULL){ break; } t = t-\u003elchild; } } return t; } ","date":"2020-04-09","objectID":"/posts/DS-6/:5:0","tags":["Leetcode-C++"],"title":"二叉树应用算法整理","uri":"/posts/DS-6/"},{"categories":["数据结构与算法"],"content":"6. 二叉树叶子节点的路径 void AllBitreePath(BiTree t, stack *s){ while(t){ SqStackPush(s, t-\u003edata); if(!t-\u003e lchild \u0026\u0026 !t-\u003erchild){ //叶子节点此时输出栈 SqStackTraverse(*s); } else{ AllBitreePath(t-\u003elchild, *s); //非叶子结点进栈 AllBitreePath(t-\u003erchild, *s); } SqStackPop(s); //此时已经输出栈,出栈当前叶子结点 } } 目前书本上的应用是这几种,如果以后遇到新的,还会加上! 这两天看了\u003cInside Bill’s Brain: Decoding Bill Gates\u003e,本以为是在讲bill的成功历程,但主题是bill现在搞的慈善,帮助非洲贫穷国家改善卫生,消除一些很低级的疾病,相比其他传记,感觉可能讲这个更加人文一点(虽然也并不是很明白人文这个词的含义),讲到bill的成功秘诀就是天生的聪慧和不断的思考(恰巧我这两点都没有),果然伟大的人,总是如此谦虚而又有些高傲… ","date":"2020-04-09","objectID":"/posts/DS-6/:6:0","tags":["Leetcode-C++"],"title":"二叉树应用算法整理","uri":"/posts/DS-6/"},{"categories":["操作系统"],"content":"原码,反码,补码,有符号数,无符号数 ","date":"2020-04-05","objectID":"/posts/CMU213-1/:0:0","tags":["CMU213"],"title":"CMU213_Part-1","uri":"/posts/CMU213-1/"},{"categories":["操作系统"],"content":"1. 原码,反码,补码 一开始讲到机器原码反码和补码,有点懵,野路子学计算机导致知识点不细致,看了很多视频和博客算是明白了 这篇算是讲的最好的了 原码作为人能识别的数字,给机器运算的话,会因为符号位的识别,浪费很多资源,所以想到将符号位也加入到二进制的运算中.最后只使用加法器 一开始使用反码运算,取反运算正是电路擅长的但是由于+0和-0,造成两个0的情况,又想出了补码运算 运算完成之后,将进位去除,还原为原码.即最后的结果 所以目前机器内存中存储的数据都是补码存储,在单片机中输出数据很多也是补码 一篇讲补码很好的文章 ","date":"2020-04-05","objectID":"/posts/CMU213-1/:0:1","tags":["CMU213"],"title":"CMU213_Part-1","uri":"/posts/CMU213-1/"},{"categories":["操作系统"],"content":"2.signed和unsigned类型的运算 第一节课的后部分讲到signed和unsigned进行算数比较以及两者的范围,这里着重记录比较 这里有两个重点需要记住 有符号数和无符号数混合运算时（包括逻辑运算和算术运算）默认会将有符号数看成无符号数进行运算，返回无符号数结果 32位机器中，比int小的整型（包括short 、unsigned short 、 unsigned char和char）在运算中都要转换成int然后进行运算 这两篇博客解释的很好 第一篇 第二篇 ","date":"2020-04-05","objectID":"/posts/CMU213-1/:0:2","tags":["CMU213"],"title":"CMU213_Part-1","uri":"/posts/CMU213-1/"},{"categories":["数据结构与算法"],"content":"今天本菜鸡开始学离散数学和CMU的213深入操作系统，虽然刚开始学，但收获很大，这几天还看了很多大佬的演讲，他们看世界的角度真的很不一样，高度更高，想得更深，思维更广，羡慕大佬 今天敲基本数据结构的时候，发现一个之前没注意的知识点 例如链队列的操作 //定义一个链队列 typedef struct{ Elemdata data; struct qnode *next; }QNode; *QueueLink; typedef struct{ QueueLink rear; QueueLink front; }QLink; 由此得到初始化链队列的函数 int initQLink(QLink *q){ q-\u003erear = q-\u003efront = (QueueLink)malloc(sizeof(Qnode)); if(q-\u003efront == NULL) return 0; q-\u003efront-\u003enext = NULL; return 1; } 可以看到在函数初始化时参数是 *q 指针变量 所以对于函数的使用是这样 QLink q; initQLink(\u0026q); 可以看到使用函数的时候传入的是q的地址 (本菜鸡一直以为函数中的参数是\u0026q) *\u0026q = q 还有一点需要注意,链队列中,头指针front-\u003enext指向头结点(出队的第一个节点) rear指向入队的结点 q-\u003efront-\u003enext //访问头结点 今日菜的抠脚 ","date":"2020-04-04","objectID":"/posts/DS-5/:0:0","tags":["C++基础语法"],"title":"链式存储中传入参数的类型","uri":"/posts/DS-5/"},{"categories":["数据结构与算法"],"content":"今天算是更加深刻地学习了一下二叉树的非递归遍历,学习期间们摸鱼去看了两集\u003c伟大的卫国战争\u003e不禁感叹纳粹德国的勇猛和苏联人的顽强,最开始闪电战的顺利进行以为可以四个月攻占苏联,就像德国将军所说,这样的战争局势放在任何一个别的国家都是注定的结局,敌人只会溃不成军,但是苏联军队却是如此的顽强。这么一看二战中苏联和中国的情况很是相似，不过中国似乎表现的更有些…说不上来的迟钝吧 又扯了这么多，好想写一篇最近感受的专题哈哈哈，回到主题 之前学习树的非递归总是有些迷糊，先序和中序还好，后序压根在脑袋中像一锅粥一样。 非递归的方法，我自己总结了算是四种方法 常规压栈 标记上一个结点 任务点分析方法 路径规划法 ","date":"2020-04-03","objectID":"/posts/DS-4/:0:0","tags":["Leetcode-C++"],"title":"二叉树的非递归遍历","uri":"/posts/DS-4/"},{"categories":["数据结构与算法"],"content":"1. 常规压栈 这种方法适合于前序和中序，结构很简单。 先序遍历举例 void tree_preorder(BiTree t){ BiTNode p = t; initStack(S); while(!SqStackEmpty(S) || p){ if(p){ push(S,p); visit(p); //前进到最左侧节点，先序中途一直访问 p = p-\u003elchild; } else{ pop(S,p); //当左侧无节点时，转向右节点 p = p-\u003erchild; } } } 但是此方法对于后序遍历不适用，因为没办法去做合理的回溯操作 ","date":"2020-04-03","objectID":"/posts/DS-4/:1:0","tags":["Leetcode-C++"],"title":"二叉树的非递归遍历","uri":"/posts/DS-4/"},{"categories":["数据结构与算法"],"content":"2. 标记上一个节点 这个方法适用于后序遍历,也算是一个简单方法,不需要数组额外空间或者改变结点的构造,只需要创建一个结点元素 后序遍历中最大的问题就是解决回溯,这个结点的存在就可以知道上级结点是否应该执行回溯操作 void tree_postorder(BiTree t){ BiTNode p = t; BiTNode lastnode = NULL; initStack(S); while(!SqStackEmpty(S) || p){ while(p){ //直接到达最左侧结点 push(S,p); p = p-\u003elchild; } pop(S,p); //先出栈然后判断是否需要回溯 if(p-\u003erchild == NULL || p-\u003erchild == lastnode){ //右子树完成访问,不需要回溯 visit(p); lastnode = p; } else{ //右子树需要访问,此时结点重新进栈,等待回溯 p = p-\u003erchild; while(p){ push(S,p); p = p-\u003elchild; } } } } ","date":"2020-04-03","objectID":"/posts/DS-4/:2:0","tags":["Leetcode-C++"],"title":"二叉树的非递归遍历","uri":"/posts/DS-4/"},{"categories":["数据结构与算法"],"content":"3. 任务点分析 这个方法是在教材上看到的，感觉领会方法之后似乎对二叉树有了一点新的认识，很巧妙 对于在遍历过程中的每个结点来说，都有两个任务点，第一个就是遍历子节点，第二个是访问（自己），那么就可以将结点新增一个变量task typedef struct{ BiTree ptr; int task; //task = 1表示遍历，task = 0表示访问 }Elemdata; 适当的，在栈的定义中Elemtype也要改为Elemdata 这样在遍历过程中，只需要改变task的值，来确定结点的状态 //以后序遍历来举例 void task_postorder(BiTree t){ initStack(S); //创建栈 Elemdata e; //初始化结点 e.ptr = t; e.task = 1; BiTree p; //初始化操作指针 if(t) push(S,e); //进栈 while(!SqStackEmpty(S)){ push(S,e); if(e.task == 0){ //task = 0访问 visit(e.ptr); } else{ p = e.ptr; //后序遍历先进入右结点 e.ptr = p-\u003erchild; e.task = 1; //初始化右结点进栈元素 if(e.ptr){ push(S,e); } e.ptr = p-\u003elchild; e.task = 1; //初始化左结点进栈严肃 if(e.ptr){ push(S,e); } e.ptr = p; e.task = 0; //最后改变当前元素的task,下次循环访问操作 push(S,e); } } } ","date":"2020-04-03","objectID":"/posts/DS-4/:3:0","tags":["Leetcode-C++"],"title":"二叉树的非递归遍历","uri":"/posts/DS-4/"},{"categories":["数据结构与算法"],"content":"4.路径分析方法 这种方法需要额外构造一个数组,来存放结点的访问状态,此时的状态不再是上一种方法的任务点,结点有null,L,R三种路径,null代表结点没有访问,R代表右子树访问完成,L代表左子树访问完成 BiTree Goleft(BiTree t, SqStack *s, char c[]){ //左子树一直进栈 if(!t) return NULL; while(t){ push(s,t); c[s-\u003etop] = 'L'; //第一次访问改变为\"L\" if(t-\u003elchild == NULL) break; t = t-\u003elchild; } return t; //返回最左侧结点 } void NR_postorder(BiTree t){ initStack(S); char lrtag[MAX]; //创建标记数组 BiTree p; t = Goleft(t,S,lrtag); //左子树进栈,p为最左侧结点 while(t){ lrtag[S.top] = 'R'; //第二次访问,改变为\"R\",紧接着访问\"rchild\" if(t-\u003erchild){ t = Goleft(t-\u003erchild,S,lrtag); } else{ while(!SqStackEmpty(S) \u0026\u0026 lrtag[S.top] == 'R'){ pop(S,p); visit(p); } } if(!SqStackEmpty(S)) gettop(S,t); else{ t = NULL; } } } 以上为总结的四种方法,下一期总结线索二叉树,嘿嘿,快乐数据结构 ","date":"2020-04-03","objectID":"/posts/DS-4/:4:0","tags":["Leetcode-C++"],"title":"二叉树的非递归遍历","uri":"/posts/DS-4/"},{"categories":["Ubuntu"],"content":"套娃Windows 我是话唠   想把linux当做生产力，就少不了一些必要的IM软件，但是...国内的IM软件却都没有linux，之前有的web.qq和web.weixin还都被官方关闭了，虽然国外的IM全都有linux版，比如telegram，但国外有的都被墙了...唉...爱我中华，我觉得墙倒不是一个问题，就是国内的这些大厂都不争气，全民盗版windows，金钱利益催使，而国外对于正版的概念很普及，而且微软也严厉打击，所以linux的用户很多，不过现在国内正版意识逐渐建立起来，去年腾讯也拿出了新的linux2.0版QQ（那是给2020年的人用的吗？，用08年版改的）而且外加西方国家对中国的技术封锁，之前政府甚至提出让公务员都装linux，开源的linux在以后只会发展的越来越好，大势所趋吧   说了这么多，还是回到主题哈哈   在网上搜了很久，最后也只能用迫不得已且唯一的方法了，套娃一个windows的环境在linux里（真是难为我linux了）想了想，很多软件还是独占win环境的，看到网上各行各业的大佬们都在装这个环境，整就完事儿啦   网上各种方法的都有，各种大佬制作的wine环境，但我挨个尝试了之后，都以兼容性告别了，最后用winetricks装更是让人恼火，安装之后第一次使用没问题，关闭了之后再启动就GG了，提示少dll文件，我想我这双系统正好啊，就去windows下拷贝dll文件过来，发现没卵用，吼！！！，后来又去winetricks里那里按照网上搜到的解决方法，去禁用什么tencentplatform.exe文件，然后第二次启动QQ，原来报错三个，现在报错两个了...最后实在熬不住了，换deepin-wine试试，一直没考虑用deepin，因为感觉...不靠谱（之前装过deepin的linux，发现体验很糟糕，对deepin失去了好感）装好之后，发现...能用了....（我真的...国产系统还不错，真香...）   然后开始说方法吧，之前用过的那些错误方法就不提了，只说最后好使的，作为国产linux的领头羊deepin，这个wine环境官方会一直维护下去的，所以还挺靠谱的 ","date":"2020-03-30","objectID":"/posts/ubuntu-9/:0:0","tags":["wine"],"title":"Ubuntu安装Deepin-Wine","uri":"/posts/ubuntu-9/"},{"categories":["Ubuntu"],"content":"1. 安装wine-deepin环境 terminal执行命令clone远程库 git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git 这个库很棒，作者把所有依赖库都放在了里面，然后在文件目录下执行 sudo ./install.sh wine环境就装好了 ","date":"2020-03-30","objectID":"/posts/ubuntu-9/:1:0","tags":["wine"],"title":"Ubuntu安装Deepin-Wine","uri":"/posts/ubuntu-9/"},{"categories":["Ubuntu"],"content":"2. 安装wine-QQ deepin-win软件池 可以看到wine-deepin下支持的所有软件，然后下载QQ对应的文件，格式为deb，之后dpkg-i命令安装文件包，就可以安装成功啦，但是安装后别着急打开，我的系统是Ubuntu18.04，所以还要多下载一个Gnome的插件TopIcons Plus ","date":"2020-03-30","objectID":"/posts/ubuntu-9/:2:0","tags":["wine"],"title":"Ubuntu安装Deepin-Wine","uri":"/posts/ubuntu-9/"},{"categories":["Ubuntu"],"content":"2020年5月15日更新: 推荐使用TIM,QQ过于臃肿,优化不是很好 deepin.com.qq.office ","date":"2020-03-30","objectID":"/posts/ubuntu-9/:2:1","tags":["wine"],"title":"Ubuntu安装Deepin-Wine","uri":"/posts/ubuntu-9/"},{"categories":["Ubuntu"],"content":"2020年5月26号更新: deepin-wine版本更新 git仓库 下载仓库文件到本地,然后执行新版本的安装脚本 sudo sh ./install_new_version.sh 修复软件安装的依赖问题 apt-get -f install = apt-get install -f 假如系统上有某个package不满足依赖条件,这个命令就会自动修复,安装那个package依赖的package。 ","date":"2020-03-30","objectID":"/posts/ubuntu-9/:2:2","tags":["wine"],"title":"Ubuntu安装Deepin-Wine","uri":"/posts/ubuntu-9/"},{"categories":["Ubuntu"],"content":"3.安装TopIcons Plus terminal执行命令 sudo apt install chrome-gnome-shell 然后打开插件网站  应用该插件，随后提示下载安装，安装之后启动QQ就会顺利运行啦！撒花（虽然看起来很简单，但是真的踩了好多坑，试了很多方法…委屈哭了） ","date":"2020-03-30","objectID":"/posts/ubuntu-9/:3:0","tags":["wine"],"title":"Ubuntu安装Deepin-Wine","uri":"/posts/ubuntu-9/"},{"categories":["Ubuntu"],"content":"使用工具: Gparted 最近几天迷上了ubuntu，希望以后研究物联网，这就绕不开Linux这个宝贝各种折腾，原以为会很枯燥，但发现超有意思啊，昨天还去b站饶有兴趣的看了linux教程，不得不说Linus Torvalds这人真是天才，发明了伟大的Linux和git，推动了开源，甚至可以说推进了人类的发展进程，这种人才称得上历史人物吧，当然最开始创建的unix的人也很厉害，不过一开始要作为商用，没有linus这种代表新世界的思想。（好想变成一个厉害的coder）继续刷Linux教程了嘿嘿 说了这么多没用的话，还是继续说主题吧 在开始装双系统的时候，本着试一试的态度，就没给ubuntu分配过多的磁盘空间，照着网上帖子的思路，一共才分配了60G，/home分配了20G，用了几天发现ubuntu太爽了，但发现/home空间已经用掉了80%，因为还没有系统的学linux命令，只能铺天盖地的搜教程，最后总结出了自己的方法 1.查看磁盘空间 直接terminal df -h 就可以查看当前磁盘的使用情况，根据使用情况计划扩容 2. 安装Gparted软件 sudo apt-get install gparted 安装之后就可以重启切换到Windows了 3.Windows分配空闲空间 因为是双系统，所以先去windows环境下压缩卷，将多的空间分配出来，空间显示为灰色未分配 4.Ubuntu扩充 使用之前制作的Ubuntu系统U盘启动器（还好我没删掉）进入系统，选择try ubunutu选项，进入u盘状态下的ubuntu系统，然后打开之前安装的Gparted软件，可以看到已经分配的磁盘分区，还可以看到未分配的黑色分区 由于磁盘系统的逻辑关系，只能将未分配分区经过到/home分区中间的全部分区，也就是一层一层的向上或向下调整 例如/home在未分配空间的上方，中间隔了A1,A2,A3分区，空闲分区只能先并入A3分区，再从A3分区remove出来，随后并入A2部分，再从A2出来并入A1 最后空闲分区移动到了/home分区下，并入/home，至此完成空间的扩充 5.应用更改 在菜单中的edit，选择apply all changes 应用磁盘更该操作，然后慢慢等待吧，完成之后关机拔下u盘，重启进入ubuntu，就会发现扩充啦！可以继续快乐啦！ ","date":"2020-03-29","objectID":"/posts/ubuntu-8/:0:0","tags":["双系统"],"title":"双系统的Ubuntu18.04扩充分区","uri":"/posts/ubuntu-8/"},{"categories":["Ubuntu"],"content":"发现Firefox竟然看不了b站视频 我人又傻了，之前找了好久的方法才装上flashplayer，这次记录一下，免得下次又要铺天盖地的找方法 - 1.启用Canonical Partners Repository存储库 最新的Flash插件位于Canonical Partners的存储库中，默认情况下它是处于禁用状态，必须在尝试安装Flash插件之前启用此存储库。 sudo add-apt-repository \"deb http://archive.canonical.com/ $(lsb_release -sc) partner\" - 2.安装Adobe Flash插件 sudo apt update sudo apt install adobe-flashplugin browser-plugin-freshplayer-pepperflash - 3.重启Firefox ","date":"2020-03-28","objectID":"/posts/ubuntu-7/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu安装Flashplayer插件","uri":"/posts/ubuntu-7/"},{"categories":["Git"],"content":"昨天clone别人的库的时候，发现下载速度才8k/s…后来搜到了一个很奇妙的方法:将https网址改为ssh! clone时将https网址改为ssh方式 使用 git@github.com 开头的clone链接 速度从8k/s变为了100k/s,虽然还是不太快，但是速度…提升了10倍！ 虽然也想过用梯子的方法，但是发现还要设置什么全局代理…懒得折腾了 ","date":"2020-03-28","objectID":"/posts/github-1/:0:0","tags":["Github"],"title":"Github clone提速的方法","uri":"/posts/github-1/"},{"categories":["Ubuntu"],"content":"神奇鹦鹉螺(nautilus) 今天需要在boot目录下移动很多文件（之前命令行的时候出了点问题，导致文件位置有错误）但是这么多文件…我总不能挨个sudo mv吧…还去网上学了一会通配符，发现并不能用上 后来百度发现了一个好东西 sudo nautilus 这个命令可以调出一个带有root权限的文件管理器(简直无敌) 还是要系统的学一学linux，前几天下载了鸟哥私房菜，但是600多页给我看傻了，但不看永远都深入不了（列入日程(¬‿¬)） ","date":"2020-03-28","objectID":"/posts/ubuntu-6/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu带权限的文件管理器","uri":"/posts/ubuntu-6/"},{"categories":["Ubuntu"],"content":"日常踩坑 事情的经过是这样的…  昨天下午由于好奇宝宝行为，觉得电脑开关机很慢，就根据上一个贴的方法，修改了一下系统的conf文件，把Timeout时间调的很小1s（但感觉系统应该没事啊）…虽然关机是很快了，但是开机却无法进入系统，一直卡在加载界面，最后多次强制关机再开机，我就进入了恢复模式（recovery mode）总算进入了系统，以为几下修复工作之后系统就没问题了，也没改什么文件，和备份文件（对ubuntu过于自信，没想到这次是我最后一次进入系统…）然后开机继续卡顿，最后F2看到开机的启动记录，发现…kernel挂了…fail to start kernel…我人傻了，然后恢复模式也进不去了 最后重装了两次系统，花了一个上午的时间，终于把新装系统的环境恢复到了之前的样子 这里主要记录一下对于以后ubuntu的注意事项 如果是双系统用户，在使用ubuntu时，自己的工作文件应该放在你的Windows盘中，在ubuntu中的路径为/media，这样做的优点是 文件可以在ubuntu和windows中共享使用 如果ubuntu系统发生错误，在重装系统是，这些文件可以保留下来，这点很重要 缺点就是，每次如果从文件浏览器打开的话，寻找文件会多点几下鼠标，文件路径稍微有点长 我在用npm下载hexo时发现，如果使用taobao.com的镜像，速度会极为慢，最后改为官方默认npm下载源后，下载速度恢复了正常，在百度之后发现，有些库在下载时使用taobao.com源也会很慢，所以可以得出，国内的npm源并不是下载所有库都会很快，有些库反而适得其反，会很慢。 ubuntu对于双显卡的电脑支持并不是很好，我在第一次安装时系统时，考虑到了这个问题，去软件更新那里下载安装了nvida的闭源的适配软件，但在使用中发现电脑GPU部分发热严重，今天百度发现可能由于开始没有禁用linux自带的Nouveau驱动，导致N卡没有正常工作，引起后来的各种错误，所以在双显卡上安装ubuntu要尤其注意N卡的驱动修改，先禁用自带驱动，再去安装nvidia的驱动文件,建议如果不是在ubuntu下搞GPU并行计算的小伙伴，暂时不要碰N卡… 如果有N卡GPU需求，按照这个blog的教程操作 ","date":"2020-03-27","objectID":"/posts/ubuntu-5/:0:0","tags":["Linux-Ubuntu"],"title":"记一次Ubuntu雪崩","uri":"/posts/ubuntu-5/"},{"categories":["Ubuntu"],"content":"今天使用Ubuntu遇到了两个问题 重启关机速度过慢 开机后显示WiFi模块工作不正常 最后通过修改系统配置文件和terminal命令解决 1.重启关机过慢 关机过程中一直显示加载界面，风扇也一直在转，并没有死机，在这种情况下按F2，可以看到正在处理的系统进程，可以看到系统卡在了“A stop job is running for .. ”的等待进程上，由于Ubuntu默认终止进程的等待时间为90s，所以当需要关闭的进程过多时，就会造成一直等待终止进程的假死情况 此时应该强制关机，并且开机后修改配置文件 Terminal执行 sudo vim /etc/systemd/system.conf 之后修改 DefaultTimeoutStartSec=10s DefaultTimeoutStopSec=10s 去掉这两项开头的注释字符，然后修改后面的时间 随后Esc退出编辑模式 ：wq保存更改 Terminal执行 systemctl daemon-reload 重新加载配置文件 2.开机后WiFi模块工作不正常 执行Terminal命令 sudo /etc/init.d/networking restart ","date":"2020-03-26","objectID":"/posts/ubuntu-4/:0:0","tags":["Linux-Ubuntu"],"title":"Ubuntu关机重启过慢","uri":"/posts/ubuntu-4/"},{"categories":["数据结构与算法"],"content":"今天在学习算法题的基础数据结构操作的时候,发现教材里在构造单向链表时有头结点，而在构造链栈时采用不带头结点的单向链表 在此记录一下两种的差别 首先对于数据结构的构造 单链表-带头结点 typedef struct snode{ Elemtype data; struct snode *next; }LNode, *LinkList; 初始化操作 int initLinkList(LinkList *l){ *l = (LinkList)malloc(sizeof(LNode)); if(*l == NULL){ printf(\"申请空间失败\"); return 0； } (*l) -\u003enext = NULL; //头结点初始化next指针为空 return 1; } 链栈-不带头结点 typedef struct snode{ Elemtype data; struct node *next; }SNode, *LinkStack; 初始化操作 int initLinkStack(LinkStack *s){ *s = (LinkStack)malloc(sizeof(SNode)); if(*s == NULL){ printf(\"申请空间失败\"); return 0; } *s = NULL; //不带头结点时直接初始化链栈指针为空 return 1; } ","date":"2020-03-26","objectID":"/posts/DS-3/:0:0","tags":["C++基础语法"],"title":"算法题 - 小知识点2","uri":"/posts/DS-3/"},{"categories":["数据结构与算法"],"content":"strcmp函数,getchar() strcmp函数是string compare(字符串比较)的缩写，用于比较两个字符串并根据比较结果返回整数。基本形式为 strcmp(str1,str2) 若str1=str2，则返回零 若str1\u003cstr2，则返回负数；若str1\u003estr2，则返回正数 对于单链表的操作中增加和删除操作由于涉及到第一个元素，操作时要得到被操作元素的前一个元素 LinkList p = l; 而更新定位操作则不需要获得前一个元素 LinkList p = l-\u003enext; getchar()函数定义为 int getchar(void) 当程序调用getchar时，程序就等着用户按键。用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止（回车字符也放在缓冲区中）。即回车是用户输入结束的标志，同时也会将回车字符也放在缓冲区中，此时getchar才开始从键盘缓冲区中读取数据，包括回车符。 所以直接调用时，为回车结束此次输入，执行getchar()之后的代码。 单链表头插法和尾插法区别在于：尾插法需要一个指针指向尾部 ，而头插法不需要，头插法可以直接用(*L)确定头指针 ","date":"2020-03-25","objectID":"/posts/DS-2/:0:0","tags":["C++基础语法"],"title":"算法题 - 小知识点1","uri":"/posts/DS-2/"},{"categories":["数据结构与算法"],"content":"最近刷leedcode以及看数据结构的代码，发现一直弄不太清typedef的使用情况，百度之后才明白这其中的原理 typedef的最简单使用 typedef long byte_4; 给已知数据类型long起个新名字，叫byte_4。 2. typedef与结构结合使用 typedef struct tagMyStruct{ int iNum; long lLength; } MyStruct; 这语句实际上完成两个操作： 定义一个新的结构类型 struct tagMyStruct{ int iNum; long lLength; }; 分析：tagMyStruct称为“tag”，即“标签”，实际上是一个临时名字，struct 关键字和tagMyStruct一起，构成了这个结构类型，不论是否有typedef，这个结构都存在。 我们可以用struct tagMyStruct varName来定义变量，但要注意，使用tagMyStruct varName来定义变量是不对的，因为struct 和tagMyStruct合在一起才能表示一个结构类型。 typedef为这个新的结构起了一个名字，叫MyStruct。 typedef struct tagMyStruct MyStruct; 因此，MyStruct实际上相当于struct tagMyStruct，我们可以使用MyStruct varName来定义变量。 规范做法： struct tagNode{ char *pItem; struct tagNode *pNext; }; typedef struct tagNode *pNode; ","date":"2020-03-24","objectID":"/posts/DS-1/:0:0","tags":["C++基础语法"],"title":"算法题 - typedef与struct","uri":"/posts/DS-1/"},{"categories":["Ubuntu"],"content":"electron-ssr 所需工具 1. electron-ssr 2. rss订阅地址（购买梯子的网站会提供） electron-ssr的作者已经把github的项目删掉了，由于不可描述的原因…所以只能去网上胡乱搜 还好搜到一个码云上还有留存下来的 下载deb格式的安装包，在安装包所在目录terminal执行 sudo dpkg -i \u003cpackage.deb\u003e package.deb就是下载的那个包 如果报错…就对了，因为需要很多依赖库还没有安装 此时执行 sudo apt-get -f install 安装依赖库后重新执行第一条安装命令就安装成功了 随后打开软件输入ssr地址，重启电脑之后就可以在工具栏看到软件图标，选择合适的节点，之后选择模式，这时会有两种模式选择，pac模式和全局模式 PAC模式 也就是智能分流模式，根据规则去匹配你访问的网站，国外网站走代理，国内网站不走代理，非常智能； 优点：节省流量，国内网站依旧走本地网络，速度快，绝大部分国外网站都走代理，速度也快。 缺点：少部分国外网站会不经过代理，不能起到加速效果，甚至无法访问（解决方案：自己编辑PAC规则列表，将不走代理的国外网址加入进去，或者直接选择全局模式）。 全局模式 国内、国外所有网站都走代理。 优点：可访问全球所有网站。 缺点：所有网站都走代理，访问国内网站速度变慢，且耗流量。 按需求选择自己的模式，之后梯子就搭建完成了，在运行期间会有一个终端一直在开启，那个就是梯子的程序，不要关闭。 ","date":"2020-03-23","objectID":"/posts/ubuntu-3/:0:0","tags":["SSR"],"title":"Ubuntu搭建梯子","uri":"/posts/ubuntu-3/"},{"categories":["Ubuntu","Hexo"],"content":"准备以后编程开发环境都转移到ubuntu上，这就涉及到以后blog的更新，想了想不如把hexo迁移到这里，原以为只是clone远程库就完事了，但没想到还是好多坑！吼！ 需要安装的工具 git npm nodejs 安装命令： sudo apt-get update sudo apt-get install nodejs sudo apt-get install npm sudo apt-get install git npm install -g hexo 安装完成后查看版本号： nodejs -v npm -v windows上可复制过来的文件 sourse文件，_config文件，theme文件 \u003c1\u003e创建空文件夹，执行init hexo ，然后将sourse文件进行替换，之后hexo g生成文件 ，hexo s启动本地服务器命令就可以在默认landscape主题下启动hexo \u003c2\u003ewin与ubuntu两种环境下最大的区别就是，ubuntu需要手动去安装很多依赖库文件，例如在hexo d上传时需要执行npm install –save hexo-deployer-git \u003c3\u003e最后安装admin模块方便增加删除文章 npm install hexo-admin 使用hexo过程中的坑 hexo init后要安装依赖库 npm install hexo-generator-index --save npm install hexo-generator-archive --save npm install hexo-generator-category --save npm install hexo-generator-tag --save npm install hexo-server --save npm install hexo-deployer-git --save npm install hexo-deployer-heroku --save npm install hexo-deployer-rsync --save npm install hexo-deployer-openshift --save npm install hexo-renderer-marked --save npm install hexo-renderer-stylus --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save 在使用定制theme时也要注意，是否需要额外的依赖库 ","date":"2020-03-22","objectID":"/posts/ubuntu-2/:0:0","tags":["Hexo"],"title":"Hexo迁移到ubuntu的坑","uri":"/posts/ubuntu-2/"},{"categories":["Ubuntu"],"content":"厌倦了在windows里的虚拟机ubuntu来体验套娃linux，索性去重新下载了一个ubuntu18.04版本，从双系统到后来的linux命令，再到最后迁移hexo，走了很多的坑 Win10/Ubuntu双系统的安装 需要的工具： easyuefi（easybcd） 系统u盘制作软件 ubuntu镜像 第一步： 在阿里镜像网站下载稳定版ubuntu镜像，制作启动器 在固态硬盘中创建200m的可用空间，机械硬盘中创建60-80G的可用空间（双硬盘配置的笔记本）随后u盘启动 install ubuntu，在磁盘分配界面选择自定义设置，具体参照此bolg 注意分清swap，/boot，/ 三个分区的设定，随后安装完成，安装过程不要连接网络，否则会进行软件自动更新 第二步： 重启电脑选择windows boot manager进入win10系统，打开easyuefi软件，创建新的linux启动项，选择grabx文件类型，重启电脑，即可进入双系统选择界面 此界面可以在ubuntu中美化，修改grub 之后在ubuntu中更改镜像源 此时ubuntu可以正常下载软件使用 ","date":"2020-03-22","objectID":"/posts/ubuntu-1/:0:0","tags":["双系统"],"title":"双系统安装Ubuntu18.04","uri":"/posts/ubuntu-1/"},{"categories":null,"content":"炒鸡喜欢Coding! 想成为一个有趣的程序员! 希望为电力行业的发展贡献出一份微薄的力量 ","date":"2020-03-02","objectID":"/about/:0:0","tags":null,"title":"关于小辣鸡","uri":"/about/"},{"categories":null,"content":"喜欢的事情!!! 😄 💻 | 📸 | 🚲 | 🐶 ","date":"2020-03-02","objectID":"/about/:1:0","tags":null,"title":"关于小辣鸡","uri":"/about/"},{"categories":null,"content":"本科期间科技竞赛: 大学生创新创业训练项目 国家级立项 三项 三次国奖 2017年中国机器人及人工智能大赛 二等奖 2018年中国机器人及人工智能大赛 二等奖 2019年节能减排科技竞赛 三等奖 四次省奖 全国高校计算机大赛 东北赛区一等奖 全国数学建模大赛 吉林省赛区二等奖 挑战杯科技竞赛 吉林省赛区三等奖 吉林省数学建模大赛 二等奖 三次校级一等奖 MIS系统开发大赛 一等奖 节能减排科技竞赛 一等奖 航模竞赛 一等奖 ","date":"2020-03-02","objectID":"/about/:2:0","tags":null,"title":"关于小辣鸡","uri":"/about/"},{"categories":null,"content":"工作经历 中国水利电力物资集团有限公司 北京-石景山区-银河大街-银河财智中心 2021年8月 - 至今 ","date":"2020-03-02","objectID":"/about/:3:0","tags":null,"title":"关于小辣鸡","uri":"/about/"},{"categories":null,"content":"联系方式 weixusheng@cweme.com ","date":"2020-03-02","objectID":"/about/:4:0","tags":null,"title":"关于小辣鸡","uri":"/about/"},{"categories":null,"content":"title: “归档” description: 专注于电力行业的代码屎山搭建工作 type: archives ","date":"0001-01-01","objectID":"/archives/:0:0","tags":null,"title":"","uri":"/archives/"},{"categories":null,"content":"title: “分类” description: 专注于电力行业的代码屎山搭建工作 type: categorie ","date":"0001-01-01","objectID":"/categorie/:0:0","tags":null,"title":"","uri":"/categorie/"},{"categories":null,"content":"title: “搜索” description: “搜索页面” type: “search” ","date":"0001-01-01","objectID":"/search/:1:0","tags":null,"title":"","uri":"/search/"},{"categories":null,"content":"title: “标签” description: 专注于电力行业的代码屎山搭建工作 type: tag ","date":"0001-01-01","objectID":"/tag/:0:0","tags":null,"title":"","uri":"/tag/"}]